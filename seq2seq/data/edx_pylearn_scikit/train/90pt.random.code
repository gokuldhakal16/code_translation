response_content = {'test_response': 'test_content'} self.server.config['This is only a test.'] = response_content
remap_dict[fullname_with_subpath] = asset_key
if self.has_answerpool(): return
with self.settings(DATA_DIR='/not/the/data/dir'): try_tar(self._edx_platform_tar())
pred = mb_k_means.predict(mb_k_means.cluster_centers_) assert_array_equal(pred, np.arange(n_clusters))
pass
if sp_version >= (0, 12): solvers.append('lbfgs')
return super(NullBackend, self).set_config_by_domain(domain)
data = fetch_20newsgroups_vectorized().data[:500]
self.user = {}
container.add_missing_groups() self.verify_groups(container, ['alpha', 'gamma'], ['beta'])
self.odd_course = CourseFactory.create( org='test.org_1-2', number='test-2.3_course', display_name='dotted.course.name-2', )
OverrideFieldData.provider_classes = None
'MODE_CREATION_FOR_TESTING': False,
d1 = datetime.datetime(2003, 1, 1) d2 = datetime.datetime(2008, 1, 1)
return realpath(abspath(rpath))
self.assertIs( descriptor._field_data._authored_data._source.fallback, descriptor._unwrapped_field_data )
CourseModeFactory.create(course_id=self.COURSE_KEY, mode_slug='honor') CourseModeFactory.create(course_id=self.COURSE_KEY, mode_slug='verified')
self.course_nav.go_to_vertical('Test Vertical-1')
with self.assertRaises(CourseUserGroup.DoesNotExist): get_cohort_by_name(self.course.id, "AutoGroup")
display_name = String(help="Display name for this module", scope=Scope.settings)
generate_subs_from_source( result_subs_dict, os.path.splitext(user_filename)[1][1:], srt_transcripts.data.decode('utf-8-sig'), item, lang )
self.assertFalse(SignatureValidator(self.lti_consumer).check_client_key(key))
CREDIT_PROVIDER_SECRET_KEYS = {}
xgrid = np.arange(xmin, xmax, batch.grid_size) ygrid = np.arange(ymin, ymax, batch.grid_size)
return self.q(css=".proctored_exam_status .exam-timer").is_present()
dict(safe_zip(range(9), numpy.arange(9) * 5 + 30)),
input_formula = "2*x - x + y + y" self.assert_grade(problem, input_formula, "correct")
from openedx.core.djangoapps.credit.api import set_credit_requirement_status
return self.q(css='a.action-{}'.format(widget_name))
self.mock_tracker.reset_mock() try: views.server_track(request, str(sentinel.event_type), '{}')
click_css(self, 'a.duplicate-button', source_index)
self.assert_grade(problem, "Second", "correct")
from __future__ import unicode_literals
from lms.envs.common import ( COURSE_KEY_PATTERN, COURSE_ID_PATTERN, USAGE_KEY_PATTERN, ASSET_KEY_PATTERN )
return user_id in self.context["staff_user_ids"] or user_id in self.context["ta_user_ids"]
cls.course_with_visibility = CourseFactory.create( display_name='visible_course', org='TestMicrositeX', course="foo", catalog_visibility=CATALOG_VISIBILITY_CATALOG_AND_ABOUT, emit_signals=True, )
for user in [UserFactory(), UserFactory(), UserFactory()]: render.get_module_for_descriptor( user, request, descriptor, field_data_cache, course.id, course=course )
return { 'id': self.id, 'name': self.name, 'query': self.query, 'viewers': self.viewers, }
from __future__ import unicode_literals
XBLOCK_SELECT_FUNCTION = prefer_xmodules
for mode in [CourseMode.DEFAULT_MODE_SLUG, CourseMode.VERIFIED]: CourseModeFactory.create( course_id=self.course.id, mode_slug=mode, mode_display_name=mode, )
return self.q(css=self._bounded_selector('a.delete-button'))
course_enrollment = CourseEnrollment.get_enrollment(user, course_key) enrollment_date = course_enrollment.created if course_enrollment else ""
sparse_results = sparse_classifier.predict(X_test_sparse) dense_results = dense_classifier.predict(X_test) assert_array_equal(sparse_results, dense_results)
user.profile.name = u'Jan ĄĘ'
#html_static_path.append('source/_static')
self._create_block_hierarchy() self.store.publish(self.course.location, self.user_id)
admin.site.register(User, UserAdmin)
while self.dispatch_one_batch(iterator): self._iterating = True else: self._iterating = False
child_classes = set(child.get_icon_class() for child in self.get_children()) new_class = 'other' for higher_class in CLASS_PRIORITY: if higher_class in child_classes: new_class = higher_class return new_class
if 'download_video' not in field_data and sources: field_data['source'] = field_data['html5_sources'][0]
self.assertTrue(expected_published_prefix in unit.last_published_text) self.assertTrue(expected_saved_prefix in unit.last_saved_text)
self.q(css='input.check').first.click() self.wait_for_ajax()
pass
assert_array_equal(mb_k_means.predict(X), mb_k_means.labels_)
visitor = AllNodeVisitor(python_code, results) visitor.visit(root_node)
self.assert_redirect_to_login_looks_correct(actions.do_complete(request.backend, social_views._do_login))
class_name = getattr(block, 'unmixed_class', block.__class__).__name__
white_label_org = microsite.get_value('course_org_filter') if white_label_org: zendesk_tags = zendesk_tags + ["whitelabel_{org}".format(org=white_label_org)]
assert not any([key in rval for key in contrib]) assert all([key in params for key in contrib])
unfiltered_response = self.verify_response(params={'username': self.staff_user.username}) for org in [self.course.org, alternate_course.org]: self.assertTrue(
self._bind_module(lc_block) self.assertEqual(len(lc_block.children), num_to_create) self.assertEqual(len(lc_block.get_child_descriptors()), num_expected)
user = data['user'] profile = UserProfile.objects.get(user=user) return profile.name
return cls.objects.filter(requirement__in=requirements, username=username)
self.course_key = self.store.make_course_key('Org_1', 'Course_1', 'Run_1') self._create_course_with_given_location(self.course_key)
existing_program_ids = get_awarded_certificate_programs(student)
if source_item.has_children and not children_handled: dest_module.children = dest_module.children or [] for child in source_item.children: dupe = _duplicate_item(dest_module.location, child, user=user)
html_response.debug = {'url': url, 'section': section, 'block_urlname': block_urlname} return html_response
add_component(self.lib_page, "html", "Text") self.assertEqual(len(self.lib_page.xblocks), 1) first_block_id = self.lib_page.xblocks[0].locator
self.assert_grade( two_choice_two_input, self._make_answer_dict([(True, ["1"]), (True, ["Platypus"])]), "correct" )
layer_to_chains[self.dbm.visible_layer] = inputs
self.original_usage = edit_info.get('original_usage', None) self.original_usage_version = edit_info.get('original_usage_version', None)
item = self.store.get_item(usage_key) if verify_is_draft: self.assertTrue(getattr(item, 'is_draft', False)) return item
resp = self.client.ajax_post( self.url, data={'tabs': [{'tab_id': tab_id} for tab_id in tab_ids]}, ) self.assertEqual(resp.status_code, 204)
return models.Client.objects.create( name=name, user=user, client_id=client_id, redirect_uri=redirect_uri, client_type=constants.CONFIDENTIAL, )
return self.topo_space.np_format_as(topo_batch, self.storage_space)
rng = np.random.RandomState(0) X = np.c_[X, rng.randn(n_samples, 200 * n_features)]
kwargs = {'script': script, 'cfn': 'check_func'} xml_str = CustomResponseXMLFactory().build_xml(**kwargs)
rng = np.random.RandomState(0) rand_data = RandomData(rng) n_samples = 500 n_features = rand_data.n_features n_components = rand_data.n_components
add_button_html = '<div class="add-xblock-component new-component-item adding"></div>' if can_add: self.assertIn(add_button_html, html) else: self.assertNotIn(add_button_html, html)
html_theme = 'scikit-learn'
from __future__ import unicode_literals
pass
def two_pass_var(X): mean = X.mean(axis=0) Y = X.copy() return np.mean((Y - mean)**2, axis=0)
for element in collection: if element.location.block_id == _id: return element
if not success: raise IOError("Could not acquire valid {driver} browser session.".format(driver=browser_driver))
for section in course.get_children(): curr_section = {} curr_section['display_name'] = own_metadata(section).get('display_name', '') data = [] c_subsection = 0
estimator.means_init = np.array([X_train[y_train == i].mean(axis=0) for i in range(n_classes)])
if self.contentstore: self.contentstore.copy_all_course_assets(source_course_id, dest_course_id) return dest_course_id
course = self._create_course("verified") response = self._get_page(payment_flow, course.id) self._assert_contribution_amount(response, "")
self._mock_paver_needs = patch.object(pavelib.quality.run_jshint, 'needs').start() self._mock_paver_needs.return_value = 0
self.assertEqual(sysex.exception.args, (1,))
password_history_entry = PasswordHistory() password_history_entry.create(user)
wait_for_problem('Problem 2')
restricted_course, __ = RestrictedCourse.objects.get_or_create(course_key=course_key) restricted_course.enroll_msg_key = 'default' restricted_course.access_msg_key = 'default' restricted_course.disable_access_check = disable_access_check restricted_course.save()
field_data_cache = FieldDataCache([], course.id, user)
data_content = None
def setUp(self): super(SignalDisconnectTestMixin, self).setUp() SignalHandler.course_published.disconnect(listen_for_course_publish)
migrate_cohort_settings(course)
pred2 = svm.libsvm.cross_validation(iris.data, iris.target.astype(np.float64), 5, kernel='linear', random_seed=0) assert_array_equal(pred, pred2)
if self.is_active != is_active and is_active is not None: self.is_active = is_active activation_changed = True
return self.client.post(self.url, self._post_body(user, client, token_type))
for phase in self.run_data.keys(): if phase in ('fake_assets',): continue per_phase = self.run_data[phase] html.add_header(1, phase)
AUTHENTICATION_BACKENDS = ( 'ratelimitbackend.backends.RateLimitModelBackend', )
y = np.ravel(y)
rng = np.random.RandomState(random_state)
assert_array_almost_equal(K.flat[::6], np.ones(5))
pass
self.assertEqual(len(self.video.q(css='video')), 1)
EmptyPromise( lambda: self.q(css=self.certficate_css + " .new-button").present, 'Create first certificate button is displayed' ).fulfill()
UID_FIELD = "id"
return TAG_PATTERN.sub(_sanitize_tag, source)
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
self.expected_settings_change_initiated_event( 'email', email, 'you@there.com', username=username, user_id=user_id),
URLCONF_MODULES = None
try: user = User.objects.get(id=user_id) except ObjectDoesNotExist: return None
num_pad_bytes = ord(input_str[-1]) if num_pad_bytes < 1 or num_pad_bytes > AES.block_size or num_pad_bytes >= len(input_str): raise UsernameDecryptionException("padding") return input_str[:-num_pad_bytes]
ForestClassifier = FOREST_CLASSIFIERS[name]
from openedx.core.djangoapps.credit.api.eligibility import ( is_credit_course, set_credit_requirement_status as api_set_credit_requirement_status )
if name is 'SpectralClustering': return set_random_state(alg) with warnings.catch_warnings(record=True): pred2 = alg.fit_predict(X) assert_array_equal(pred, pred2)
raise NotImplementedError
transformer_weights={ 'subject': 0.8, 'body_bow': 0.5, 'body_stats': 1.0, },
X_sparse_pruned = sparse.csr_matrix(X_dense)
import signals import exceptions
n_samples, h, w = lfw_people.images.shape
with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_key): assertProblemNameEquals(problem_new_name) assertNumProblems(problem_original_name, 0)
self.store.publish(locations['child_sibling'], self.user_id)
return u'{0}@test.com'.format(username)
def landing(request, org, course, coursename): return render_to_response('temp-course-landing.html', {})
self.verified_course_mode = CourseMode( course_id=self.verified_course_key, mode_slug=CourseMode.HONOR, mode_display_name="honor cert", min_price=self.cost ) self.verified_course_mode.save()
email_image = email_payload_first[1]
raise NotImplementedError()
pass
import codecs from fractions import Fraction import unittest
return ( MAX_COMMENT_DEPTH is not None and ( MAX_COMMENT_DEPTH < 0 or (parent and parent["depth"] >= MAX_COMMENT_DEPTH) ) )
xblock = self.store.create_item( self.user_id, test_course.id, 'vertical', block_id='test_vertical' )
return (hasattr(x, '__len__') or hasattr(x, 'shape') or hasattr(x, '__array__'))
regression = IsotonicRegression() n_samples = 50 x = np.linspace(-3, 3, n_samples) y = x + rng.uniform(size=n_samples)
e._element.send_keys(Keys.ENTER)
print "checking initialization..." eobjs = before_ideal.create_user(self.course_key) before = EmailEnrollmentState(self.course_key, eobjs.email) self.assertEqual(before, before_ideal)
item = order.orderitem_set.all().select_subclasses()[0] coupon_redemption = CouponRedemption.objects.select_related('coupon').filter(order=order)
return False
store = modulestore() with store.default_store('split'): destination_course_key = store.make_course_key(org, number, run)
return CourseEmailTemplate.get_template(name=self.template_name)
(it is done to allow user to enter both /static/filename.srt and filename.srt)
SERVICE_VARIANT = os.environ.get('SERVICE_VARIANT', None)
serialized_course_team['content'] = { 'text': self.content_text() }
course_programs = _get_course_programs(user, [enrollment.course_id for enrollment in course_enrollments])
csv_file.seek(0) csv_data = csv_file.read() csv_file.seek(0) csv_file.truncate() return csv_data
score = module.max_score() block_structure.set_transformer_block_field(module.location, cls, 'max_score', score)
safe_update(ups, p_up)
return self.list_display
for student in students[0:MAX_SCREEN_LIST_LENGTH + 1]: results.append({ 'name': student['student__profile__name'], 'username': student['student__username'], })
sync_cohort_with_mode.apply_async(kwargs=args, countdown=300)
lines[grid_dimension[0]] = '==> ' + lines[grid_dimension[0]]
component = self.draft_store.get_item(location) self.assertEqual(component.published_on, published_date) self.assertEqual(component.published_by, published_by)
with patch('capa.capa_problem.LoncapaProblem.rescore_existing_answers') as mock_rescore: mock_rescore.side_effect = exception_class(u'test error \u03a9') result = module.rescore_problem()
response = self.client.get(activation_link) self.assertEqual(response.status_code, 200)
mock_ip.return_value = 'IR'
block_wrappers = []
if self.min_weight_fraction_leaf != 0. and sample_weight is not None: min_weight_leaf = (self.min_weight_fraction_leaf * np.sum(sample_weight)) else: min_weight_leaf = 0.
n_samples, n_features = 5, 4 y = rng.randn(n_samples) X = rng.randn(n_samples, n_features)
if Y is not None: state_above = dbm.hidden_layers[-1].downward_state(Y) layer_above = dbm.hidden_layers[-1] assert len(dbm.hidden_layers) > 1
est = DummyRegressor(strategy="constant", constant=constants) est.fit(X_learn, y_learn) y_pred_learn = est.predict(X_learn) y_pred_test = est.predict(X_test)
self.notes_page.search("note") self.assertFalse(self.notes_page.is_error_visible) self.assertIn(u"Search Results", self.notes_page.tabs)
course_tag_api.set_course_tag(user, course_key, partition_key, group.id)
new_groups = [Group(10, 'New Group 10'), Group(20, 'New Group 20'), Group(30, 'New Group 30')] new_user_partition = UserPartition(
return render_to_response('discussion/index.html', context)
deadline = self.date return deadline is not None and deadline <= datetime.now(pytz.UTC)
mongo_course2_id = mongo_course1_id
world.click_course_content() outline_css = 'li.nav-course-courseware-outline a' world.css_click(outline_css)
program_config = self.create_programs_config(enabled=False) actual = get_edx_api_data(program_config, self.user, 'programs') self.assertTrue(mock_warning.called) self.assertEqual(actual, [])
pass
parent_location = parent_location.map_into_course(target_id)
test_stats = {'n_test': 0, 'n_test_pos': 0}
self.page.create_experiment_group_configuration()
ModeCreationPage( self.browser, self.course_id, mode_slug=u'verified', mode_display_name=u'Verified Certificate', min_price=10, suggested_prices='10,20' ).visit()
ancestors = urlpath.cached_ancestors
pass
if not settings.FEATURES.get('MILESTONES_APP', False): return [] from milestones import api as milestones_api return milestones_api.get_course_content_milestones(course_id, content_id, relationship)
with super(CreateThreadUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
@skip("Not supported by DjangoXBlockUserStateClient") def test_iter_blocks_deleted_block(self): pass
reset_time = datetime.now(UTC) + timedelta(seconds=300) with freeze_time(reset_time): response = self.client.get(url) self.assertEquals(response.status_code, 404)
store = self._get_modulestore_for_courselike(course_key) if not hasattr(store, 'fill_in_run'): return course_key return store.fill_in_run(course_key)
email_opt_in = request.data['email_opt_in'].lower() == 'true' update_email_opt_in(request.user, org, email_opt_in) return HttpResponse(status=status.HTTP_200_OK)
from __future__ import unicode_literals
assert_method = getattr(self, expected_result) assert_method(block_list)
set_runtime_service('instructor', InstructorService())
course = CourseFactory.create() create_account(self.USERNAME, self.PASSWORD, self.EMAIL)
def _set_cookie_wrapper(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=False):
resp = self.client.get(self.urls['course_modes_choose'], follow=True) self.assertRedirects(resp, self.urls['verify_student_start_flow'])
response = self.client.post(self.send_mail_url, test_email) self.assertEquals(json.loads(response.content), self.success_content)
ensemble = BaggingRegressor(base_estimator=DecisionTreeRegressor(), max_samples=1.0, bootstrap=False, random_state=rng).fit(X_train, y_train)
self.assertFalse(CourseEnrollment.is_enrolled(self.user, non_existent_course_key))
PIPELINE_ENABLED = False STATICFILES_STORAGE = 'openedx.core.storage.DevelopmentStorage'
store = self._verify_modulestore_support(course_key, 'import_xblock') return store.import_xblock(user_id, course_key, block_type, block_id, fields, runtime, **kwargs)
return self.q(css='.active .bookmark-icon').visible
assert_false("the" in vocabulary)
oauth2_adapter = adapters.DOPAdapter()
STUDENT_VIEW = 'student_view'
merged_parent_group_ids = None
ps_new_cache = self._create_service(username, {}) self.assertEqual( second_group.id, ps_new_cache.get_user_group_id_for_partition(user_partition_id) )
if remaining_iterations == 0: if verbose: print('Maximum number of iterations reached') results = location, covariance, det, support, dist
response = self.client.get(self.url, params)
self._verify_editable(self._get_course_details_response(True))
module = CapaFactory.create(attempts=attempts, max_attempts=attempts, done=True) self.assertFalse(module.should_show_save_button())
return None
CELERY_RESULT_BACKEND = 'djcelery.backends.cache:CacheBackend'
self.client.login(username=self.global_staff.username, password="test")
counts = self.get_counters(request) return sum(counts.values()) >= self.requests
dict(safe_zip(range(-5, 6), range(-5, 6))),
y_true = (y_true == pos_label)
log.exception("Unable to generate html from LoncapaProblem") raise
verification_status, verification_msg = SoftwareSecurePhotoVerification.user_status(user)
original_image_shape = (96, 96)
super(TestVertSplitTestVert, self).setUp()
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
sut = PCA(self.num_components) sut.apply(self.dataset, True)
return _get_array_element('category', label, ('animal', 'human', 'airplane', 'truck', 'car', 'blank'))
to_string(monitor)
registration = Registration() registration.register(user)
if key not in self: root = self.__root last = root[0] last[1] = root[0] = self.__map[key] = [last, root, key] dict_setitem(self, key, value)
queue = deque([block]) while queue: item = queue.popleft() yield item queue.extend(item.get_children())
dist_X, ind_X = getattr(nbrs_X, method)(None) dist_D, ind_D = getattr(nbrs_D, method)(None) assert_array_almost_equal(dist_X, dist_D) assert_array_almost_equal(ind_X, ind_D)
X = lfw_people.data n_features = X.shape[1]
return next((tab for tab in tab_list if tab.type == tab_type), None)
precs_full = np.array([np.diag(1. / np.sqrt(x)) for x in covars_diag])
urlpatterns = ( '',
self.last_time = time.time()
seed = random_state.randint(0, np.iinfo(np.int32).max)
self.reset_tracker()
tag = course_tag_api.get_course_tag(self.user, self.course_id, self.test_key) self.assertIsNone(tag)
self.enter_search_term(text) self.search()
certificate["version"] = CERTIFICATE_SCHEMA_VERSION if certificate.get("signatories") is None: certificate["signatories"] = [] certificate["editing"] = False return certificate
assert_equal(_dynamic_max_trials(1, 100, 10, 0), 0) assert_equal(_dynamic_max_trials(1, 100, 10, 1), float('inf'))
super(MongoModuleStore, self).create_course( org, course, run, user_id, runtime=xblock.runtime, **kwargs )
self.assertTrue(self._is_valid_key(key), msg="Failed for unicode character {0}".format(unicode_char))
testing.assert_array_equal( FunctionTransformer(np.log1p).transform(X), np.log1p(X), )
scorer = get_scorer('mean_squared_error') ridge_gcv4 = RidgeCV(fit_intercept=False, scoring=scorer) ridge_gcv4.fit(filter_(X_diabetes), y_diabetes) assert_equal(ridge_gcv4.alpha_, alpha_)
thread_local_branch_setting = getattr(self.thread_cache, 'branch_setting', None) if thread_local_branch_setting: return thread_local_branch_setting else: return self.default_branch_setting_func()
n_leaves = n_samples
clf = OneVsRestClassifier(base_clf).fit(X, Y) y_pred = clf.predict([[3, 0, 0]])[0] assert_equal(y_pred, 1)
self.assertSetEqual( {block['id'] for block in response.data}, self.non_orphaned_block_usage_keys, )
shutil.rmtree(root_dir)
random_state = check_random_state(0) y1 = random_state.randint(0, 2, size=(20, )) y2 = random_state.randint(0, 2, size=(20, ))
n_init_range = np.array([1, 5, 10, 15, 20])
response.data["current_page"] = self.page.number
self._studio_publish_content(1)
_, sap, _ = randomized_svd(X, k, n_iter=5, power_iteration_normalizer=normalizer)
accepts_logins = False
self.good_dir = self.create_course_xml(self.content_dir, self.base_course_key)
self.set_team_configuration({u"max_team_size": 10, u"topics": []}) self.verify_teams_present(False)
{},
self.total_violations = 0 self.totals_by_rule = dict.fromkeys( [rule.rule_id for rule in Rules.__members__.values()], 0 )
self.assertEqual(str(user.username.encode('utf-8')), UsernameCipher().decrypt(str(pref.value)))
Application.objects.filter(user=self.request.user).delete() return super(ApiRequestStatusView, self).form_valid(form)
about_descriptor = XBlock.load_class('about') overview_template = about_descriptor.get_template('overview.yaml') self.expected_data['overview'] = overview_template.get('data')
cohort_tuple = namedtuple("Cohort", "name id user_count assignment_type user_partition_id group_id") return cohort_tuple( name=cohort.name, id=cohort.id, user_count=user_count, assignment_type=assignment_type, user_partition_id=user_partition_id, group_id=group_id )
cost = SumOfCosts([SumOfParams(), (0., DummyCost())]) model = DummyModel(shapes, lr_scalers=scales) dataset = ArangeDataset(1) momentum = 0.5
if not encoded_videos: video_url = self.html5_sources[0] if self.html5_sources else self.source if video_url: encoded_videos["fallback"] = { "url": video_url,
cur_block = unordered_structure[block]
parent = self.modulestore.get_parent_location( as_published(location), ModuleStoreEnum.RevisionOption.published_only if location.revision is None else ModuleStoreEnum.RevisionOption.draft_preferred )
JoblibException.__init__(self, message, etype) self.message = message self.etype = etype
other = UserFactory.create() self.client.login(username=other.username, password='test') self.enroll() self.logout()
self.video.wait_for_state('pause')
self.assert_grade(problem, "Other String", "incorrect")
response = problem.responders.values()[0] self.assertFalse(response.has_mask()) self.assertFalse(response.has_answerpool())
with warnings.catch_warnings(): warnings.simplefilter("ignore") check_cv_coverage(skf_3, X2, y, labels=None, expected_n_iter=3)
fields = dict(self.CREDENTIALS_DEFAULTS, **kwargs) CredentialsApiConfig(**fields).save() return CredentialsApiConfig.current()
return timedelta(microseconds=self.refund_window_microseconds)
for sub_grid in self.param_grid: if not sub_grid: if ind == 0: return {} else: ind -= 1 continue
setattr(self._modulestore, name, value)
result = SoftwareSecurePhotoVerification.get_initial_verification(user=user) self.assertIs(result, None)
elements = self.q(css="ol.course-tabs .new-post-btn") return elements.first if elements.visible and len(elements) == 1 else None
self.browser.refresh() self.cohort_management_page.wait_for_page() self.instructor_dashboard_page.select_cohort_management() self.cohort_management_page.wait_for_page() self.cohort_discussion_topics_are_visible()
self.setup_groups_partitions(num_user_partitions=3)
response.set('id', response_id_str) response_id += 1
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 5)
mode_slug = models.CharField(max_length=100)
value = None
import ddt from mock import call, patch from nose.plugins.attrib import attr import before_after
return Response(status=503, headers={'Retry-After': '120'})
self._perform_test_using_store(store_type, self._test_delete_course_from_search_index_after_course_deletion)
(['honor', 'verified', 'audit'], 'honor'),
if obj <= best_obj: best_obj = obj best_alpha = alpha best_alpha_ind = ind
self.def_ms = modulestore() self.msg = u'' self.datatable = [] super(SysadminDashboardView, self).__init__(**kwargs)
gsn._corrupt_switch = False
safe_exec("a = 1/2", g) self.assertEqual(g['a'], 0.5)
self.save()
return self.q(css='div.batch-enrollment').present
grad_shared = sharedX(zv) z_shared = sharedX(zv)
api.set_credit_requirements(self.course_key, requirements[1:])
template_loc = self.location.replace(category='custom_tag_template', name=template_name)
modules = get_accessible_discussion_modules(course, self.non_staff_user) self.assertTrue( all(module.display_name == 'released' for module in modules) )
top_level_logger.setLevel(logging.DEBUG if debug else logging.INFO)
url( r'^courses/{}/progress/(?P<student_id>[^/]*)/$'.format( settings.COURSE_ID_PATTERN, ), 'courseware.views.views.progress', name='student_progress', ),
skiprows = 1 if headers else 0 x = np.loadtxt(test_path, delimiter=delimiter, skiprows=skiprows)
msg = _("answer-pool value should be an integer") raise LoncapaProblemError(msg)
world.wait_for_js_to_load()
django_user_service = DjangoXBlockUserService(self.user, user_is_staff=True) anonymous_user_id = django_user_service.get_anonymous_user_id(username="No User", course_id='edx/toy/2012_Fall') self.assertIsNone(anonymous_user_id)
P = noise + X_dense P = theano.tensor.switch(P > 0, 1, 0) P = tensor.cast(P, theano.config.floatX)
old_tab = CourseTabList.get_tab_by_type(self.course.tabs, tab_type)
est = TreeEstimator(max_features=10) assert_raises(ValueError, est.fit, X, y)
cert_items = CertificateItem.objects.filter(order=order)
self.update_masquerade(role='staff') self.verify_staff_debug_present(True)
self.login_staff() response = self.get_course_info_page() self.assertEqual(response.status_code, 200) content = response.content self.assertIn("OOGIE BLOOGIE", content)
for algorithm in ALGORITHMS:
values = []
return numpy.arcsin(1. / val)
return False
EDXMKTG_LOGGED_IN_COOKIE_NAME = ENV_TOKENS.get('EDXMKTG_LOGGED_IN_COOKIE_NAME', EDXMKTG_LOGGED_IN_COOKIE_NAME) EDXMKTG_USER_INFO_COOKIE_NAME = ENV_TOKENS.get('EDXMKTG_USER_INFO_COOKIE_NAME', EDXMKTG_USER_INFO_COOKIE_NAME)
if usage_info.has_staff_access: return
xml = self.render_to_xml(self.context) xpath = "//div[@class='indicator-container']/span[@class='status correct']" self.assert_has_xpath(xml, xpath, self.context)
CourseOverview.get_from_id(params["course_key"])
self._assert_course_verification_status(VERIFY_STATUS_SUBMITTED)
if graceperiodjson is not None: if 'grace_period' in graceperiodjson: graceperiodjson = graceperiodjson['grace_period']
return "is-editing" in self.q(css=self.NAME_FIELD_WRAPPER_SELECTOR).first.attrs("class")[0]
module.system.render_template = Mock(return_value="<div>Test Template HTML</div>")
valid_file.seek(0) test_file.seek(0)
self.browser.refresh() self.wait_for_page()
'course_action_state',
request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO['username'])
return getattr(self.steps[0][1], '_pairwise', False)
return iter(sorted(self._stacks.keys(), key=lambda stack: (self.stack_calls(stack), stack), reverse=True))
raise VersionConflictError(course_key, version_guid)
child_to_delete_location = self.problem_y1a_1 old_parent_location = self.vertical_y1a self.store.delete_item(child_to_delete_location, self.user_id)
user.is_staff = True
self.find_css('.action-primary').first.click() self.wait_for_ajax()
published_branch = course.id.for_branch( ModuleStoreEnum.BranchName.published )
self.assertNotEqual(httpretty.last_request().headers, {})
#latex_use_parts = False
return cls.objects.filter( user=user, status="approved", created_at__gte=(earliest_allowed_date or cls._earliest_allowed_date()) ).exists()
script = 'raise Exception("Test")' problem = self.build_problem(answer=script)
return super(MongoBulkOpsMixin, self)._is_in_bulk_operation( course_id.for_branch(None), ignore_case )
roc_auc_scorer = make_scorer(roc_auc_score, greater_is_better=True, needs_threshold=True) average_precision_scorer = make_scorer(average_precision_score, needs_threshold=True) precision_scorer = make_scorer(precision_score) recall_scorer = make_scorer(recall_score)
optima = [(self._constrained_optimization(obj_func, self.kernel_.theta, self.kernel_.bounds))]
self._update_cutoff()
pass
from __future__ import division
'statici18n',
options.ignore = tuple(DEFAULT_IGNORE.split(','))
CourseModeFactory.create( course_id=self.course.id, mode_slug='professional', mode_display_name='Professional Education', )
return CourseAssetsFromStorage(course_key, doc_id, course_assets['assets'])
file = getattr(instance, field.attname) data[field.attname] = file.name
BROKER_HEARTBEAT = 10.0 BROKER_HEARTBEAT_CHECKRATE = 2
return UserPartition( partition_id, name, description, groups, MockUserPartitionScheme(scheme) ).to_json()
for i in range(current_page, total_pages): _check_page() if current_page < total_pages: page.click_on_page(current_page + 1) current_page += 1
self._check_results( test_user, expected_user_accessible_blocks, blocks_with_differing_access, transformers, )
return course_key.to_deprecated_string()
original_modified = tag.modified tag.value = "barfoo" tag.save() self.assertEquals(tag.value, "barfoo") self.assertNotEqual(original_modified, tag.modified)
sign_active[idx] = -sign_active[idx]
lti_params = response[LTI_PARAMS_KEY] return lti_params['oauth_consumer_key'] + ":" + lti_params['user_id']
reg = 1E-3 * evals.sum(1)
currency = models.CharField(default="usd", max_length=8)
for attribute in ABOUT_ATTRIBUTES: if attribute in jsondict: cls.update_about_item(descriptor, attribute, jsondict[attribute], user.id)
return NoneToEmptyQuerySet(self.model, using=self._db)
names_t_actual = sel.transform([feature_names]) assert_array_equal(feature_names_t, names_t_actual.ravel())
scope_map = defaultdict(set) for descriptor in descriptors: for field in descriptor.fields.values(): scope_map[field.scope].add(field) return scope_map
result = {} metadata = cls.fetch_all(descriptor) for key, value in metadata.iteritems(): if key in cls.filtered_list(): continue result[key] = value return result
private_vertical = self.store.create_item(self.user.id, course_id, 'vertical', self.PRIVATE_VERTICAL) self.assertFalse(self.store.has_published_version(private_vertical))
if self.cleaned_data.get("_expiration_datetime"): return self.cleaned_data.get("_expiration_datetime").replace(tzinfo=UTC)
self.assertIsNone(auth.authenticate(password=password, username=username))
nn = NearestNeighbors(metric='chebyshev', n_neighbors=n_neighbors)
if not modulestore().has_course(course_key): return Response(status=status.HTTP_404_NOT_FOUND)
return HttpResponse("Mode '{mode_slug}' created for '{course}'.".format( mode_slug=PARAMETERS['mode_slug'], course=course_id ))
__SKLEARN_SETUP__
valid_repr = transform_valid(valid_set) test_repr = transform_test(test_set)
for svd_sparse, svd_dense in svds_sparse_v_dense: assert_array_almost_equal(svd_sparse.explained_variance_ratio_, svd_dense.explained_variance_ratio_)
module = CapaFactory.create(due=self.yesterday_str, force_save_button="true", done=True) self.assertFalse(module.should_show_save_button())
with remove_ccx(xblock) as (xblock, restore): return restore(self._modulestore.has_changes(xblock))
n_jobs = min(_get_n_jobs(n_jobs), n_estimators)
return os.sep.join(__file__.split(os.sep)[:-4]) + '/data/uploads/' + filename
notes = self.q(css=self._bounded_selector(".annotator-hl")) return [EdxNoteHighlight(self.browser, note, self.item_id) for note in notes]
return cls.objects.get_or_create( course_id=course_id, group_type=group_type, name=name )
error_msg = _(u"You must agree to the {platform_name} {terms_of_service}.").format( platform_name=get_themed_value("PLATFORM_NAME", settings.PLATFORM_NAME), terms_of_service=terms_link )
assert_greater(1, 0) _assert_greater(1, 0) assert_raises(AssertionError, assert_greater, 0, 1) assert_raises(AssertionError, _assert_greater, 0, 1)
for child in self.get_display_items(): rendered_child = child.render(STUDENT_VIEW, child_context) fragment.add_frag_resources(rendered_child)
chaos_user = UserFactory() locked_toc = self._return_table_of_contents() for toc_section in self.expected_locked_toc: self.assertIn(toc_section, locked_toc)
self.times_called += 1 if self.times_called % 2 == 0: return True, 'Task Completed' return False, 'Task Errored In Some Way'
return _get_fake_course_info(course_id)
self.dashboard_page.visit()
self.base_estimator = base_estimator self.n_estimators = n_estimators self.estimator_params = estimator_params
return block_structure.get_transformer_block_field( block_key, cls, cls.BLOCK_DEPTH, )
assert_almost_equal(np.abs(np.dot(d2[:2], [0, 1])), 1.0)
from pylearn2.datasets import preprocessing
pending_change = PendingEmailChange.objects.filter(user=self.user) self.assertEqual(0, len(pending_change))
if not settings.FEATURES.get('MILESTONES_APP', False): return None from milestones import api as milestones_api return milestones_api.add_course_milestone(course_id, relationship, milestone)
sign, ld = np.linalg.slogdet(A) if not sign > 0: return -np.inf return ld
from __future__ import unicode_literals
child = self.store.get_item(child.location) child.display_name = 'Changed Display Name' self.store.update_item(child, user_id=editing_user)
api.update_credit_request_status(request["parameters"]["request_uuid"], self.PROVIDER_ID, status) self._assert_credit_status(status)
query_features = task_input.get('features') student_data = enrolled_students_features(course_id, query_features) header, rows = format_dictlist(student_data, query_features)
self.assertProfessionalModeBypassed()
from sklearn.ensemble import RandomForestClassifier from sklearn.svm import SVC
self._enroll(course.id, "verified")
params = { param_name: request.POST[param_name] for param_name in [ "face_image", "photo_id_image", "course_key", "checkpoint", "full_name" ] if param_name in request.POST }
course_enrollments = list(get_course_enrollments(user, course_org_filter, org_filter_out_set))
if not request.user.is_superuser and not ApiKeyHeaderPermission().has_permission(request, self): return Response(status=status.HTTP_403_FORBIDDEN)
query = self.q(css=CREATE_TEAM_LINK_CSS) if query.present: query.first.click() self.wait_for_ajax()
VERIFY_STATUS_NEED_TO_VERIFY = "verify_need_to_verify" VERIFY_STATUS_SUBMITTED = "verify_submitted" VERIFY_STATUS_APPROVED = "verify_approved" VERIFY_STATUS_MISSED_DEADLINE = "verify_missed_deadline" VERIFY_STATUS_NEED_TO_REVERIFY = "verify_need_to_reverify"
self.assertEqual(len(response.redirect_chain), 1) self.assertIn(302, response.redirect_chain[0]) self.assertEqual(len(outbox), outbox_count)
self.assertTrue(subsection.release_date) self.assertFalse(subsection.due_date) self.assertFalse(subsection.policy)
self.assertIsNone(self.service.get_credit_state(0, self.course.id))
xx, yy = np.meshgrid(np.linspace(-4, 5, 500), np.linspace(-4, 5, 500))
second_result = SoftwareSecurePhotoVerification.get_initial_verification(user=user) self.assertIsNotNone(second_result) self.assertEqual(second_result, first_result)
X = np.zeros((n_samples, n_features)) y = np.zeros(n_samples, dtype=np.int)
return self.input_space
cache[cache.keys()[0]] = (None, {'a': 17})
CourseEnrollment.unenroll_by_email("jack@fake.edx.org", course_id) self.assertFalse(CourseEnrollment.is_enrolled(user, course_id)) self.assert_no_events_were_emitted()
self._validate_vocabulary() max_df = self.max_df min_df = self.min_df max_features = self.max_features
return _absolute_url(is_secure=is_secure, url_path="")
label = "P{0}.{1}.{2}".format(c_subsection, c_unit, c_problem)
with super(UpdateCommentUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
self._install_masquerade(self.course_staff) self.assertEqual( 'student', access.get_user_role(self.course_staff, self.course_key) )
self.assertIn('<header class="xblock-header xblock-header-vertical">', html) self.assertIn('<article class="xblock-render">', html)
objects = UserProfile.objects course_key = CourseKey.from_string(course_id) students = objects.filter(user__courseenrollment__course_id=course_key, user__courseenrollment__is_active=True) return students
rng = np.random.RandomState(0) X = np.c_[X, rng.randn(n_samples, 200 * n_features)]
urlpatterns += ( url(r'^certificates/', include('certificates.urls', app_name="certificates", namespace="certificates")),
try: import dogstats_wrapper as dog_stats_api except ImportError: dog_stats_api = None
return self.q(css=".button.button-reindex")[0]
user = User.objects.get(email=staff_email) token = default_token_generator.make_token(user) uidb36 = int_to_base36(user.id)
from __future__ import unicode_literals
default_z += T.alloc(*([0.]+[shape[elem] for elem in self.h_space.axes])).astype(default_z.dtype) assert default_z.ndim == 4
EDX_XML_PARSER = XMLParser(dtd_validation=False, load_dtd=False, remove_comments=True, remove_blank_text=True, encoding='utf-8')
source_courselike.static_asset_path = source_courselike.data_dir source_courselike.save() log.debug('course static_asset_path=%s', source_courselike.static_asset_path)
LogoutPage(self.browser).visit() AutoAuthPage(self.browser, username=username, email=email, course_id=self.course_id, staff=staff).visit()
clf = svm.LinearSVC(random_state=0).fit(X, Y)
clf = self.factory(alpha=0.01, eta0=0.01, n_iter=5, shuffle=False, learning_rate=lr) clf.fit(X, Y)
raise NotImplementedError()
verification_good_until = self._verification_valid_until(request.user)
clf = QuadraticDiscriminantAnalysis() y_pred = clf.fit(X6, y6).predict(X6) assert_array_equal(y_pred, y6)
return V[:n_components, :].T, s[:n_components], U[:, :n_components].T
fragment = Fragment(content) fragment.add_css('body {background-color:red;}') fragment.add_javascript('alert("Hi!");') return fragment
coloring_matrix = np.random.normal(size=(n_features, n_features)) X_train = np.dot(base_X_train, coloring_matrix) X_test = np.dot(base_X_test, coloring_matrix)
return location.replace(revision=MongoRevisionKey.published)
return "{}/library/{}".format(BASE_URL, unicode(self.locator))
context['certificate_date_issued_title'] = _("Issued On:")
if urlparse.urlparse(url_path).netloc: return url_path
return X.take(indices, axis=0)
return self.q(css='body.view-teams').present
return self.metric in ["rbf"]
assert_raises(ValueError, scale, X_csr, with_mean=False, axis=1)
_set_verification_partitions(course_key, icrv_blocks)
with patch('capa.capa_problem.LoncapaProblem.get_html') as mock_html: mock_html.return_value = "<div>Test Problem HTML</div>"
rng = check_random_state(0) X_train, X_test, y_train, y_test = train_test_split(boston.data[:50], boston.target[:50], random_state=rng)
url(r'^api/course_structure/', include('course_structure_api.urls', namespace='course_structure_api')),
expected_energy_p = model.energy( layer_to_chains[model.visible_layer], [layer_to_chains[layer] for layer in model.hidden_layers] ).mean()
self._test_visible_to_students(True, 'public_no_start', None, publish=True)
self.assertEqual(tab.tab_id, expected_tab_id)
self.attempt_login(200) user.is_active = False
_update_certificate_context(context, user_certificate, platform_name)
X = check_array(X, dtype=np.float64, order='F', copy=self.copy_X and self.fit_intercept) y = check_array(y, dtype=np.float64, ensure_2d=False)
from datetime import datetime from mock import patch, Mock
coef_grads[layer] = safe_sparse_dot(activations[layer].T, deltas[layer]) coef_grads[layer] += (self.alpha * self.coefs_[layer]) coef_grads[layer] /= n_samples intercept_grads[layer] = np.mean(deltas[layer], 0) return coef_grads, intercept_grads
if not has_html_certificates_enabled(course_id): log.info( "Invalid cert: HTML certificates disabled for %s. User id: %d", course_id, user_id, ) return render_to_response(invalid_template_path, context)
modulestore = XMLModuleStore( data_dir, default_class=None, source_dirs=source_dirs )
self.assertGreater(len(items[0].question), 0)
top_level_export_dir = 'exported_source_course_with_asides' export_course_to_xml( self.store, contentstore, dest_course_key, self.export_dir, top_level_export_dir, )
self.xml_data = "static 463139" self.xml_url = "8e4cce2b4aaf4ba28b1220804619e41f"
self.page_num = page_num self.num_pages = num_pages
self.url = reverse_course_url('tabs_handler', self.course.id)
assert_raises(ValueError, ForestEstimator(min_samples_leaf=-1).fit, X, y) assert_raises(ValueError, ForestEstimator(min_samples_leaf=0).fit, X, y)
if isinstance(obj, OpaqueKey): return unicode(obj) return JSONEncoder.default(self, obj)
return module.seed
if not course.certificates or not course.certificates.get('certificates'): return [] return [cert['id'] for cert in course.certificates['certificates']]
with store.branch_setting(ModuleStoreEnum.Branch.published_only, course.id): store.get_item(course.location)
self.assertInUnsucceededCourseActions(destination_course_key)
x_p_nrm, y_p_nrm = norm(x_p), norm(y_p) x_n_nrm, y_n_nrm = norm(x_n), norm(y_n)
self.xblock.save()
if sample_weight is None: base_estimator.fit(X_subset, y_subset) else: base_estimator.fit(X_subset, y_subset, sample_weight=sample_weight[subset_idxs])
self.client.logout() staff_user = StaffFactory(course_key=self.course.id) staff_user.is_staff = True self.client.login(username=staff_user.username, password='test')
self.setup()
return super(EligibleCertificateManager, self).get_queryset().exclude( status__in=(CertificateStatuses.audit_passing, CertificateStatuses.audit_notpassing) )
days_good_for = settings.VERIFY_STUDENT["DAYS_GOOD_FOR"] return datetime.now(pytz.UTC) - timedelta(days=days_good_for)
def utcoffset(self, _dt): return timedelta(hours=4)
rng = check_random_state(0) X_train, X_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state=rng)
rng = np.random.RandomState(2)
prod = np.dot(W1, W2) pv = make_viewer(prod.T) return pv
space, source = data_specs if isinstance(space, CompositeSpace): sub_spaces = space.components sub_sources = source else: sub_spaces = (space,) sub_sources = (source,)
PROFILE_IMAGE_MAX_BYTES = 1000 PROFILE_IMAGE_MIN_BYTES = 1000
self.store.convert_to_draft(item_location, self.user_id) item = self.store.get_item(item_location) self.assertTrue(self.store.has_published_version(item))
return reverse_url(handler_name, 'course_key_string', course_key, kwargs)
return redirect(reverse('about_course', args=[unicode(course_key)]))
return self.encode(inputs)
import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm from sklearn.neighbors import KernelDensity
field_errors = self._validate_patch(request.data) if field_errors: return Response({'field_errors': field_errors}, status=status.HTTP_400_BAD_REQUEST) return self.partial_update(request, *args, **kwargs)
if hasattr(self, 'has_targeted'): return
asset_md = store.find_asset_metadata(new_asset_loc) self.assertIsNone(asset_md)
course_overview_after = CourseOverview.get_from_id(course.id)
return self.q(css=".submission-error li").text
learning_rate = 1.
train_obj.main_loop() state.results = jobman.tools.resolve(state.extract_results)(train_obj) return channel.COMPLETE
course_location = locator.CourseLocator('Org1', 'Course1', 'Run1') self.course, self.enrollment = self._create_course_and_enrollment(course_location)
self.courseware_page.visit() self.courseware_page.wait_for_page() self.assertTrue(element_has_text( page=self.courseware_page, css_selector=entrance_exam_link_selector, text='Entrance Exam' ))
w = rng.randn(num_features)
start_index = end_triple_quote_match.start()
used_all_attempts = CapaFactory.create(showanswer='closed', max_attempts="1", attempts="1", due=self.tomorrow_str) self.assertTrue(used_all_attempts.answer_available())
return self.REMOVE_SPAN_TAG_RE.search(element.get_attribute('innerHTML')).groups()[0].strip()
inactive_children = [child for child in children if child not in active_children]
return course_metadata_utils.has_course_ended(self.end)
return middleware.RequestCache.get_current_request()
if rolename not in [FORUM_ROLE_ADMINISTRATOR, FORUM_ROLE_MODERATOR, FORUM_ROLE_COMMUNITY_TA]: return HttpResponseBadRequest(strip_tags( "Unrecognized rolename '{}'.".format(rolename) ))
self.assertTrue(context['reg_code_info_list'][0]['is_redeemed']) self.assertFalse(context['reg_code_info_list'][1]['is_redeemed'])
super(SupportViewCertificatesTests, self).setUp() SupportStaffRole().add_users(self.user)
y = np.reshape(y, (-1, 1))
pass
covars_tied = np.array([x for x in covars_diag]).mean(axis=0) precs_tied = np.diag(np.sqrt(1. / covars_tied))
self._verify_masquerade_for_group(self.user_partition.groups[0]) self._verify_masquerade_for_group(self.user_partition.groups[1]) self._verify_masquerade_for_group(None)
from course_wiki.plugins.markdownedx.wiki_plugin import ExtendMarkdownPlugin
XBLOCK_MIXINS = (LmsBlockMixin, InheritanceMixin, XModuleMixin, EditInfoMixin)
history = HistoricalRecords()
self.category = category self.display_name = display_name self.data = data self.metadata = metadata self.grader_type = grader_type self.publish = publish self.children = [] self.locator = None self.fields = kwargs
s_2 = -0.5 * (np.diag(K) - np.einsum('ij, ij -> j', C, C)) \
all_answer_ids = problem.get_answer_ids() all_answers = dict((answer_id, real_answers.get(answer_id, "")) for answer_id in all_answer_ids)
email_placeholder = _(u"username@domain.com")
self.assertEqual(module.attempts, 1)
stripped, ccx = strip_ccx(to_strip) yield stripped, partial(restore_ccx_collection, ccx_id=ccx)
from django.core.urlresolvers import reverse from django.test import TestCase import mock from edx_oauth2_provider.tests.factories import AccessTokenFactory, ClientFactory
css_class = 'start-date' title = ugettext_lazy('Course Starts') @property def date(self): return self.course.start
try: return self.store.get_item(location) except ItemNotFoundError: return None
self.is_released = is_released self.publish_state = publish_state self.is_locked = is_locked
self.disable_cohorting(self.course_fixture) self.refresh_thread_page(self.thread_id) self.assertEquals(self.thread_page.get_group_visibility_label(), "This post is visible to everyone.")
os.environ['NO_PREREQ_INSTALL'] = 'true'
if order_items.count() == 1: receipt_template = order_items[0].single_item_receipt_template context.update(order_items[0].single_item_receipt_context)
cs, sn, rho = _sym_ortho(rhobar1, beta)
with outer_atomic(): if section_module.hide_from_toc or unicode(section_module.location) in gated_content: continue
response = self.client.get(self.url) self.assertRedirects(response, reverse('api_admin:api-request'))
self.course = self.store.get_course(self.course.id)
return from_addr_format.format( course_title=course_title_no_quotes, course_name=course_name, from_email=theming_helpers.get_value( 'bulk_email_default_from_email', settings.BULK_EMAIL_DEFAULT_FROM_EMAIL ) )
block_info.setdefault('paths', []) block_info['paths'].append(current_path) for child_block_info in block_info['children']: add_path_info(child_block_info, current_path + [block_info])
self._add_draft_modules_to_course(new_course.location, source_course_key, user_id, **kwargs)
self.client.login(username=self.coach.username, password="test")
bokchoy_utils.clear_mongo() self.cache.flush_all()
'verified_track_content',
url(r'^generate_example_certificates$', 'instructor.views.api.generate_example_certificates', name='generate_example_certificates'),
msg_format = _("Progress: {action} {succeeded} of {attempted} so far")
pass
clf = MultinomialNB() assert_raises(ValueError, clf.fit, -X, y2) y_pred = clf.fit(X, y2).predict(X)
assert_is_none(get_current_request())
self.edit_component(1) self.open_advanced_tab() self.video.set_field_value('YouTube ID', 'sampleid123') self.save_unit_settings()
urls = microsite.get_value("urls", default={}) return urls.get(name) or EMPTY_URL
@ignore_warnings(category=DeprecationWarning) def test_eval(self): if not self.do_test_eval:
unvisited_children.reverse() stack.extend(unvisited_children)
self.assertEqual(self.cudnn2d.get_params(), [self.filters])
problem = self.build_problem(answer='(1, ]') input_dict = {'1_2_1': '3'} with self.assertRaises(StudentInputError): problem.grade_answers(input_dict)
try: matches = CONTENT_RE.search(request.META["HTTP_CONTENT_RANGE"]) content_range = matches.groupdict()
return (self.q(css=self._bounded_selector('.cohort-management-nav')).visible and self.q(css=self._bounded_selector('.wrapper-cohort-supplemental')).visible)
multi_db = True
super(NoseTestSuite, self).__exit__(exc_type, exc_value, traceback) test_utils.clean_mongo()
op = optparse.OptionParser() op.add_option("--n-times", dest="n_times", default=5, type=int, help="Benchmark results are average over n_times experiments")
return self.q(css=self.search_bar_selector).present
if time_since_last_activity > timedelta(seconds=timeout_in_seconds): del request.session[LAST_TOUCH_KEYNAME] auth.logout(request) return
for i in range(X.shape[0]): x = X[i] out[i, i] = metric(x, x, **kwds)
xblocks = self._get_nested_xblocks(self) if category: xblocks = [x for x in xblocks if x.category == category] return xblocks
'openedx.core.djangoapps.common_views',
self.assertEqual(_get_release_date(response), 'Unscheduled') _assert_settings_link_present(response)
'ENABLE_CREDIT_ELIGIBILITY': ENABLE_CREDIT_ELIGIBILITY,
with self._mock_geoip('US'): result = embargo_api.check_course_access(self.course.id, user=self.user, ip_address='0.0.0.0')
original_item = self.get_item_from_modulestore(source_usage_key) duplicated_item = self.get_item_from_modulestore(duplicate_usage_key)
self.xblock.location = Location("org", "import", "run", "category", "stubxblock")
best = sorted(grid_scores, key=lambda x: x.mean_validation_score, reverse=True)[0] self.best_params_ = best.parameters self.best_score_ = best.mean_validation_score
PAIRWISE_DISTANCE_FUNCTIONS = { 'cityblock': manhattan_distances, 'cosine': cosine_distances, 'euclidean': euclidean_distances, 'l2': euclidean_distances, 'l1': manhattan_distances, 'manhattan': manhattan_distances,
source_store = self.store._get_modulestore_by_type(source_modulestore) dest_store = self.store._get_modulestore_by_type(destination_modulestore) self.assertCoursesEqual(source_store, source_course_key, dest_store, dest_course_id)
raise NotImplementedError()
self.assertEqual(response.status_code, 200) res_json = json.loads(response.content)
rng = np.random.RandomState(0) n_samples, n_features, n_components = 500, 2, 2
assert_in(InheritanceMixin, root.xblock_mixins)
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
Z = Z.reshape(xx.shape) ax.contourf(xx, yy, Z, cmap=cm, alpha=.8)
container.visit() container.delete(0)
with self.assertRaises(SearchIndexingError): reindex_course_and_check_access(self.course.id, self.user)
return get_id_token(user, CLIENT_NAME)
try: return view(request, course_id=course_id) except DashboardError, error: return error.response()
while block.parent: block = block.get_parent() return block
self._auto_auth(self.USERNAME, self.EMAIL, False) self.courseware_search_page.visit()
if link_map[name] is not None: return reverse(link_map[name])
super(Donation, cls).add_to_order(order, currency=currency)
handlers = logger.handlers level = logger.getEffectiveLevel()
if raw: self.set_raw_content(content) else: self.set_content(content) self.cancel()
def __init__( self, parseElementList ): self.parseElementTrace = parseElementList def __str__( self ): return "RecursiveGrammarException: %s" % self.parseElementTrace
if Y.ndim == 1: Y = Y[:, np.newaxis] if Y.shape[1] == 1: Y = np.append(1 - Y, Y, axis=1)
preprocessor = CentralWindow(self._window_shape) for data in self._center: preprocessor.apply(data)
if Bookmark.objects.filter(user=user, course_key=course_key).count() >= settings.MAX_BOOKMARKS_PER_COURSE: return False
children = [] for child in tree: children.append(_merge_children(child, tags))
for random_matrix in all_random_matrix: yield check_input_size_random_matrix, random_matrix yield check_size_generated, random_matrix yield check_zero_mean_and_unit_norm, random_matrix
try: course_code_number = int(request.POST['total_registration_codes']) except ValueError: course_code_number = int(float(request.POST['total_registration_codes']))
'openedx.core.djangoapps.credit',
return cls.objects.filter( course__course_key=course_key, course__enabled=True, username=username, deadline__gt=datetime.datetime.now(pytz.UTC), ).exists()
tstart = time() clf = factory(alpha=alpha).fit(X, Y) delta = (time() - tstart)
self.assertIn('Search for a course', response.content)
suggested_prices = models.CommaSeparatedIntegerField(max_length=255, blank=True, default='')
if state.transposed: results = results[:, ::-1]
reset_time = datetime.now(UTC) + timedelta(seconds=300) with freeze_time(reset_time): response = self.client.post(url) self.assertEquals(response.status_code, 404)
y_true, y_pred, _ = make_prediction(binary=False)
raise NotImplementedError(str(self.__class__) + " does not implement " "_get_required_mlp_output_space")
html = module.get_problem_html(encapsulate=False)
return self.q(css=CLASS_SELECTORS['video_controls']).visible
homework_1_score = 1.0 / 2 homework_2_score = 0.0 self.check_grade_percent(round((homework_1_score + homework_2_score) / 2, 2))
for status in ["created", "ready", "denied"]: attempt.status = status attempt.save() assert_false(SoftwareSecurePhotoVerification.user_has_valid_or_pending(user), status)
TASK_LOG.info(u'%s, Task type: %s, Finishing task: %s', task_info_string, action_name, task_progress) return task_progress
if 'user_partition_id' not in old_content or old_content['user_partition_id'] != self.user_partition_id: selected_partition = self.get_selected_partition() if selected_partition is not None:
for url in user_info["header_urls"].values(): self.assertIn("http://testserver/", url)
assert last_row % stride[0] == 0 num_row_steps = last_row / stride[0] + 1
assert isinstance(model.hidden_layers[-1], dbm.Softmax)
if 'pinned' not in thread: thread['pinned'] = False
nnbrs = NearestNeighbors(algorithm='brute', metric='cosine').fit(X)
tab_id_locator = request.json['tab_id_locator']
tolerance_xml = xml.xpath( '//*[@id=$id]//responseparam[@type="tolerance"]/@default', id=xml.get('id') )
enetcv_unconstrained = ElasticNetCV(n_alphas=3, eps=1e-1, max_iter=max_iter, cv=2, n_jobs=1) enetcv_unconstrained.fit(X, y) assert_true(min(enetcv_unconstrained.coef_) < 0)
from __future__ import unicode_literals
self.mock_programs_api() self.mock_credentials_api(self.user, reset_url=False) actual = get_programs_credentials(self.user, category='xseries') expected = self.expected_credentials_display_data()
self._add_prerequisite_course() self.init_course_access() self._verify_unfulfilled_milestone_response()
from __future__ import print_function
time.sleep(0.2)
self.enroll(self.course, True) self.enroll(self.test_course, True)
self.assertEqual(result.get(), "succeeded") rerun_state = CourseRerunState.objects.find_first(course_key=split_rerun_id) self.assertEqual(rerun_state.state, CourseRerunUIStateManager.State.SUCCEEDED)
class Meta(object): list_serializer_class = BulkTeamCountTopicListSerializer
assert (np.diag(cm)[:-1] > np.diag(cm)[1:]).all()
new_children.append(new_block_key)
self._assert_steps_displayed( response, PayAndVerifyView.PAYMENT_STEPS + PayAndVerifyView.VERIFICATION_STEPS, PayAndVerifyView.FACE_PHOTO_STEP )
from __future__ import unicode_literals
num_new_fields_set = num_fields_after - num_fields_before self._ddog_histogram(evt_time, 'set_many.fields_set', num_new_fields_set)
return []
tag = gettag(xml)
num_dimensions += 1
y_pred, sigma = gp.predict(x, return_std=True)
super(AdaBoostRegressor, self)._validate_estimator( default=DecisionTreeRegressor(max_depth=3))
return convolution_indices.evaluate(inshp, kshp, offset, nkern, mode=mode, ws=False)
self.password = 'abc' self.student = UserFactory.create(username='student', email='student@test.com', password=self.password)
totals_data.append( ['', '{tax_label}: {tax_id}'.format(tax_label=self.tax_label, tax_id=self.tax_id)] )
expected_answers = {CapaFactory.answer_key(): '3.14'} self.assertEqual(module.lcp.student_answers, expected_answers)
with patch_edxnotes_api_settings("http://example.com/"): self.assertEqual("http://example.com/", get_endpoint_function())
children_headers = self._set_library_content_settings(count=2, capa_type="Custom Evaluated Script") self.assertEqual(children_headers, set())
assert_array_almost_equal(clf_lda_svd.explained_variance_ratio_, clf_lda_eigen.explained_variance_ratio_[:tested_length])
self.assert_logged_in_cookie_redirect(actions.do_complete(
with self._secondary_action_menu_open(".response_{} .discussion-response".format(response_id)): return self._is_element_visible(".response_{} .discussion-response .action-edit".format(response_id))
email = staff.email password = 'test' self.login(email, password) self.enroll(self.course, verify=True)
batch_unsubscribe = mailchimp.listBatchUnsubscribe result = batch_unsubscribe(id=list_id, emails=emails, send_goodbye=False, delete_member=False) log.debug(result)
email_instructions = _("The email address you used to register with {platform_name}").format( platform_name=settings.PLATFORM_NAME )
oa = OAS() loglik_oa = oa.fit(X_train).score(X_test)
params["honor_code"] = "tRUe" self.assert_success(params)
user = User.objects.get(id=user_id) return anonymous_id_for_user(user, None)
return (self.large_width, self.large_height)
if wildcard: return '*' else: return unicode(badge_class.course_id)
if offset.isdigit(): offset = int(offset) else: offset = 0
if viewname == "django_comment_client.forum.views.forum_form_discussion" and args == [unicode(course.id)]: return "default_discussion_link"
self.client.logout()
return _get_fake_enrollment(student_id, course_id)
item.sub = filename
import datetime import pytz
self.assertTrue('success' in result and not result['success'])
return cls(task_id, **options)
self._assert_course_verification_status(VERIFY_STATUS_APPROVED)
self.exceptions = [TransportableException]
my_pca_preprocessor.apply(training_set, can_fit = True) my_pca_preprocessor.apply(test_set, can_fit = False)
else: status = VERIFY_STATUS_MISSED_DEADLINE
self.client.logout()
idx = mapping if isinstance(flat, (tuple, list)): assert 0 <= idx < len(flat) return flat[idx] else: assert idx == 0 return flat
self.instructor = InstructorFactory(course_key=self.course.id) self.staff = [ StaffFactory(course_key=self.course.id) for __ in xrange(STAFF_COUNT) ]
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
self._set_gender(None) self.assertIsNone(self.profile.gender_display)
old_tab_list = course_item.tabs
mb_k_means = MiniBatchKMeans(init="random", n_clusters=n_clusters, random_state=42, n_init=10).fit(X) _check_fitted_model(mb_k_means)
provider = CreditProvider.objects.get() provider.active = False provider.save()
if not expected_url.startswith("/"): expected_url = "/" + expected_url self.assertEquals(expected_url, actual_url)
self._restrict_course(self.course.id) embargo_api.message_url_path(self.course.id, 'courseware')
result = embargo_api.check_course_access(self.course.id, user=self.user, ip_address='0.0.0.0') self.assertTrue(result)
self.assertAssetsEqual(self.LOCKED_ASSET_KEY, self.LOCKED_ASSET_KEY.course_key, course_id)
mean = X.mean(axis=0) std = X.std(axis=0) X = (X - mean) / std
return self.default_modulestore.make_course_key(org, course, run)
self.assertEqual(self.team_management_page.header_page_name, title) self.assertEqual(self.team_management_page.header_page_description, description) self.assertEqual(self.team_management_page.header_page_breadcrumbs, breadcrumbs)
component = self.store.get_item(component.location) component.display_name = 'Changed Display Name' self.store.update_item(component, self.user_id)
est = DeprecatedAttributeEstimator(a=1)
keep_lambda = np.ones(n_features, dtype=bool)
store = self._verify_modulestore_support(course_id, 'branch_setting') with store.branch_setting(branch_setting, course_id): yield
super(TrackSelectionPage, self).__init__(browser) self._course_id = course_id
monitoring_dataset = DenseDesignMatrix(X=X)
if not os.path.exists(dataset_conf_path): os.makedirs(dataset_conf_path)
self._assert_queue_task(mock_send, cert)
if key.scope not in self.VALID_SCOPES: raise InvalidScopeError(key, self.VALID_SCOPES) if key.scope == Scope.content: self._load_definition()
if self.escQuote: ret = ret.replace(self.escQuote, self.endQuoteChar)
has_partial_fit = hasattr(self, 'partial_fit_')
self.mappings[course_key] = store
self.processes = 0
response = self.client.get(self.url) if is_visible: self.assertContains(response, "Student-Generated Certificates") else: self.assertNotContains(response, "Student-Generated Certificates")
assert_almost_equal(np.dot(U[:, :k], V[:k, :]), np.dot(Ua, Va))
self.client = Client() cache.clear()
response_element = etree.Element("formularesponse")
self.user.is_active = False self.user.save()
desc_score_indices = np.argsort(y_score, kind="mergesort")[::-1] y_score = y_score[desc_score_indices] y_true = y_true[desc_score_indices] if sample_weight is not None: weight = sample_weight[desc_score_indices] else: weight = 1.
return has_access(requesting_user, CourseStaffRole.ROLE, course_key)
self.clear_user_answers(user) SurveyAnswer.save_answers(self, user, answers, course_key)
self.assertEqual(1, len(mail.outbox)) self.assertIn(expected_message, mail.outbox[0].subject) self.assertIn(expected_message, mail.outbox[0].body)
for i, species in enumerate([BV_bunch, MM_bunch]): print("_" * 80) print("Modeling distribution of species '%s'" % species.name)
self.assertEqual(self.cmap.get_overall_message(), "")
self._assert_enable_certs_button(True)
for cache in caches.all(): self.assertIsNone(cache.get(key)) cache.set(key, "Not None")
self._enable_cohorting() self._create_verified_cohort() self._enable_verified_track_cohorting() self.assertTrue(VerifiedTrackCohortedCourse.is_verified_track_cohort_enabled(self.course.id)) self._enroll_in_course()
ALL_ASSETS_XML_TAG = 'assets'
rng = np.random.RandomState(1999) n, p = 50, 3
from tempfile import mkdtemp import shutil from functools import partial
suite = BokChoyTestSuite('', num_processes=2, verbosity=3) with self.assertRaises(BuildFailure): BokChoyTestSuite.verbosity_processes_string(suite)
if text[-1] in SUFFIXES: return float(text[:-1]) * SUFFIXES[text[-1]] else: return float(text)
self.assertEqual(params['override_custom_receipt_page'], self.CALLBACK_URL)
with super(UsersEndpointTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
random_state.randint(MAX_INT, size=len(self.estimators_))
(13, True, u"False"),
contentstore().save(content) del_cached_content(content.location)
output_filename = course_key.to_deprecated_string().replace('/', '-') + ".csv"
goals_label = _(u"Tell us why you're interested in {platform_name}").format( platform_name=settings.PLATFORM_NAME )
#epub_guide = ()
self.client.logout()
set_credit_requirements(course.id, requirements)
verify_name(self.html_usage_key, self.seq_usage_key, "Duplicate of 'Text'")
Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape)
path = preprocess(path) data_x, data_y = self.make_data(which_set, path)
return datetime.fromtimestamp(os.path.getctime(self.path(name)))
pass
library_fixture.add_children( XBlockFixtureDesc("problem", "Bad Problem", data='<'), )
for field in ['id', 'name', 'course_id', 'topic_id', 'date_created', 'description']: self.assertIn(field, team)
return get_endpoint(settings.EDXNOTES_INTERNAL_API, path)
return [ v[-1][0] for v in self.__tokdict.values() ]
sh("coverage combine --rcfile={}".format(rcfile))
assert_array_equal(votes, np.round(decisions))
return 1 - (0.5 ** (1 / n_subsamples) * (n_samples - n_subsamples + 1) + n_subsamples - 1) / n_samples
def get_memmap_info(memmap): assert isinstance(memmap, numpy.memmap)
with modulestore().bulk_operations(course_key): course = modulestore().get_course(course_key, depth=depth) if course: return course else: raise Http404("Course not found.")
est = pickle.loads(pickle.dumps(est)) assert_true(sparse.issparse(est.coef_)) pred = est.predict(X) assert_array_equal(pred, pred_orig)
pass
default="images_course_image.jpg"
def test_real_user(useless): useless_user = Mock(email='fake@fake.com', id=useless) return useless_user
expected_grades = [self._format_user_grade(header_row, **user_grade) for user_grade in user_grades] self.verify_rows_in_csv(expected_grades)
self.task_input = "THIS IS INVALID JSON"
result = data.get_course_enrollment(self.user.username, unicode(self.course.id)) self.assertIsNone(result)
self.measures.append((name, size))
result = self.collection.update( {'_id': location.to_deprecated_son()}, {'$set': update}, multi=False, upsert=allow_not_found,
args = [self.system, '--settings=acceptance'] if self.fasttest: args.append('--skip-collect') call_task('pavelib.assets.update_assets', args=args)
labels = (label == 'root' and node_id == 0) or label == 'all'
PACKAGES_TO_UNINSTALL = [
resource = self.generate_edit_resource(self.resource_id) for xblock_name in self.XBLOCK_NAMES: self.check_event_response_by_http_status('edit_resource', resource, 200, xblock_name)
POST_AUTH_PARAMS = ('course_id', 'enrollment_action', 'course_mode', 'email_opt_in')
_FUNCTION_HASHES = weakref.WeakKeyDictionary()
if self.rerandomize in [RANDOMIZATION.ALWAYS, RANDOMIZATION.ONRESET] and self.is_submitted(): return True else: if self.is_correct(): return False else: return self.show_reset_button
assert isinstance(course_id, CourseKey) for course in self.get_courses(**kwargs): if course.id == course_id: return course return None
if entrance_exam_url: problems = get_problems_in_section(entrance_exam_url) usage_keys = [UsageKey.from_string(location) for location in problems.keys()]
return redirect_to
return len(self.q(css='.wrapper-translations-settings .list-settings-item').results)
self.assertEquals(response.status_code, 302) cache.clear()
packed_coef_inter = _pack(self.coefs_, self.intercepts_)
pass
if create_after_overview: self.set_config(enabled=False)
self.stub_api() self.auth() self.listing_page.visit() self.assertTrue(self.listing_page.is_sidebar_present) self.assertTrue(self.listing_page.are_cards_present)
self.store.convert_to_draft(problem.location, self.user.id) problem = self.store.get_item(problem.location)
return cPickle.dumps(obj, get_pickle_protocol())
current = stack[-1]
if drop_first: n_components = n_components + 1
dest_info = dest_structure['blocks'][block_key]
i_best_alpha = np.argmin(mse_path.mean(axis=-1)) best_alpha = all_alphas[i_best_alpha]
wip1 = W_list[i+1] hi_mean += T.dot(samples[i+1], wip1.T) * beta
draft = 'draft-branch' published = 'published-branch' library = 'library'
EmptyPromise( lambda: self.find_css('.signatory-panel-body .signatory-name-value').present, 'On signatory details view' ).fulfill()
pass
grid_indices = [0, ] * 5
grp = Group(name=settings.PAYMENT_REPORT_GENERATOR_GROUP) grp.save() self.user.groups.add(grp) self.assertTrue(_can_download_report(self.user))
add_instructor(new_lib.location.library_key, request.user, request.user)
if course_tabs != course_module.tabs: course_module.tabs = course_tabs
if adjacent: self.leaveWhitespace() self.adjacent = adjacent self.skipWhitespace = True self.joinString = joinString
'recordedYoutubeIsAvailable': self.youtube_is_available,
if not has_studio_write_access(request.user, source_course_key): raise PermissionDenied()
problem = self.build_problem( choice_type='checkbox', choices=[False, False, True, True, False], credit_type='halves' )
Y = None
full_name = self.imported_names[local_name] + remainder yield name, full_name
new_structure = self.version_structure(course_key, structure, user_id)
return self.q(css=self._bounded_selector('.team-card'))
X = np.array([[1], [2], [3]]) Y = np.array([1, 2, 3]) clf = ARDRegression(compute_score=True) clf.fit(X, Y)
with cls.store.bulk_operations(course.id, emit_signals=False):
n_samples = K.shape[0] n_targets = y.shape[1]
'django.contrib.auth.hashers.SHA1PasswordHasher', 'django.contrib.auth.hashers.MD5PasswordHasher',
url(r'^choose/{}/$'.format(settings.COURSE_ID_PATTERN), views.ChooseModeView.as_view(), name='course_modes_choose'),
'ENABLE_PAID_COURSE_REGISTRATION': False,
return self.get_item(item_loc)
StudentViewTransformer('video').transform(usage_info=None, block_structure=self.block_structure)
new_block_info = copy.deepcopy(source_block_info) existing_block_info = dest_structure['blocks'].get(new_block_key, BlockData()) new_block_info.defaults = new_block_info.fields
self._check_sizes(space)
new_block = self.store.get_item(new_block.location)
grid_search = GridSearchCV(clf, param_grid=param_grid) start = time() grid_search.fit(X, y)
youtube_stub_config_url = cls.URL + 'get_config' response = requests.get(youtube_stub_config_url) if response.ok: return json.loads(response.content) else: return {}
metric_str = metric if name in METRICS_WITH_POS_LABEL: metric_str = partial(metric_str, pos_label=pos_label_str)
return block_structure.get_transformer_block_field( block_key, cls, cls.MERGED_START_DATE, False )
_EASY_CHOICE_FEATURES = ('gender', 'level_of_education') _OPEN_CHOICE_FEATURES = ('year_of_birth',)
raise NotImplementedError('override-me')
self.update_masquerade(role='staff') self.assertEqual(self.get_progress_detail(), u'0/2')
for _ in range(100): response = self.client.post(self.url, data=payload) if response.status_code == 403: break
pass
request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO["username"])
regr_1 = DecisionTreeRegressor(max_depth=4)
return self.q(css='.wrapper-create-course').visible
del DEFAULT_FILE_STORAGE MEDIA_ROOT = "/edx/var/edxapp/uploads"
CourseModeFactory.create( course_id=self.course.id, mode_slug=CourseMode.VERIFIED, mode_display_name=CourseMode.VERIFIED, expiration_datetime='1970-01-01 05:00:00' )
tfidf_test = t1.transform(counts_test).toarray() assert_equal(tfidf_test.shape, (len(test_data), len(v1.vocabulary_)))
self.definition_loaded = False self.from_storable(kwargs)
for subsection in section.get_children(): c_subsection += 1 subsection_name = own_metadata(subsection).get('display_name', '')
return []
self.course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
self.check_event_response_by_http_status('remove_resource', resource, test_case['status'])
response = self._get_page(payment_flow, course.id) self._assert_steps_displayed( response, PayAndVerifyView.PAYMENT_STEPS, PayAndVerifyView.MAKE_PAYMENT_STEP ) self._assert_requirements_displayed(response, [])
reg.activate() reg.save()
if relevant_verification is not None: if relevant_verification.status == "approved": status = VERIFY_STATUS_APPROVED elif relevant_verification.status == "submitted": status = VERIFY_STATUS_SUBMITTED
students_require_certificates = enrolled_students.filter( generatedcertificate__course_id=course_id, generatedcertificate__status__in=statuses_to_regenerate ) return list(students_require_certificates)
problem = self.build_problem(rectangle="(10,10)-(20,20)")
for key, value in configs: self.setConfig(key, value)
if self.closed() and not is_survey_question: return False
draft_items_locations = {item.location for item in draft_items} return [ item for item in base_get_items(MongoRevisionKey.published) if item.location not in draft_items_locations ]
X_scaled = MinMaxScaler().fit_transform(X) assert_true(np.isfinite(X_scaled).all())
self._assert_cert_status(self.courses[0].id, self.user, CertificateStatuses.notpassing) self._assert_cert_status(self.courses[1].id, self.user, other_status)
norm_phi = np.dot(exp_doc_topic_d, exp_topic_word_d) + EPS
return self.q(css='ul.listing-courses .course-item .info-date-block').first.text[0]
self.instructor_dashboard_page = InstructorDashboardPage(self.browser, self.course_id) self.instructor_dashboard_page.visit() self.cohort_management_page = self.instructor_dashboard_page.select_cohort_management()
html_with_inline_css = pynliner.fromString('<style>' + css_content + '</style>' + html_without_css) return html_with_inline_css
n_samples = int(X.shape[0]) rs = check_random_state(self.random_state)
DATABASES = AUTH_TOKENS['DATABASES']
tag_links = self.q(css=self._bounded_selector(self.TAG_SELECTOR)) if len(tag_links) == 0: return None return[tag_link.text for tag_link in tag_links]
raise ItemNotFoundError(course_id)
create_exam( course_id=unicode(self.course.id), content_id='foo3', exam_name='A Proctored Exam', time_limit_mins=10, is_proctored=True, is_active=True, is_practice_exam=True )
return structure['blocks'].get(block_key)
theano.config.warn.sum_div_dimshuffle_bug = False
return dict((k, self.errored_courses[k].errors) for k in self.errored_courses)
p_shared = sharedX(zv[:,0:rows:pool_rows,0:cols:pool_cols,:]) h_shared = sharedX(zv) z_shared = sharedX(zv)
n_samples = 100 n_features = 500 rank = 5 k = 10
from __future__ import unicode_literals
old_mixed_setting = self.ALREADY_UPDATED_MIXED_CONFIG new_mixed_setting, new_default_store_setting = self.assertMigrated(old_mixed_setting) self.assertTrue(self.is_split_configured(new_mixed_setting)) self.assertEquals(old_mixed_setting, new_mixed_setting)
log.info('Denying API request from user [%s].', self.user.id) self.status = self.DENIED self.save()
optioninput_element.set('correct', str(correct_option))
all_assets, count = contentstore('trashcan').get_all_content_for_course(self.course.id) self.assertEqual(len(all_assets), 0) self.assertEqual(count, 0)
item = modulestore().get_item(usage_key)
sparse_results = sparse_classifier.staged_predict_proba(X_test_sparse) dense_results = dense_classifier.staged_predict_proba(X_test) for sprase_res, dense_res in zip(sparse_results, dense_results): assert_array_equal(sprase_res, dense_res)
url = reverse('instructor_dashboard', kwargs={'course_id': self.course.id.to_deprecated_string()}) self.assert_request_status_code(200, url)
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
pipeline = Pipeline([('imputer', Imputer(missing_values=0)), ('tree', tree.DecisionTreeRegressor(random_state=0))])
X_, y_ = make_classification(n_samples=200, n_features=100, random_state=0)
if instructor not in list_instructor_ccx: try: enroll_email( course_id=ccx_key, student_email=instructor.email, auto_enroll=True, email_students=send_email, email_params=email_params, )
return self.q(css='.dropdown-menu li a').text
assert_array_equal(X_truth[:, :2], out_X_unstructured[0]) assert_array_equal(X_truth[:, :2], out_X_structured[0])
self.assertEqual(context['currency_symbol'], 'Rs') self.assertEqual(context['currency'], 'PKR')
for db_alias in self.dbs.keys(): sh("cp {db} {db_cache}".format(db_cache=self.db_caches[db_alias], db=self.dbs[db_alias]))
new_message = ', '.join(str(arg) for arg in new_exc.args)
context_processors = _builtin_context_processors context_processors += tuple(settings.DEFAULT_TEMPLATE_ENGINE['OPTIONS']['context_processors']) return tuple(import_string(path) for path in context_processors)
grid_search = GridSearchCV(pipeline, parameters, n_jobs=-1, verbose=1)
return self.get_courses(**kwargs)
title = _("Powered by Open edX") return { "url": settings.FOOTER_OPENEDX_URL, "title": title, "image": settings.FOOTER_OPENEDX_LOGO_IMAGE, }
if used_ids is None: used_ids = [] cid = random.randint(minimum, maximum) while cid in used_ids: cid = random.randint(minimum, maximum) return cid
url(r'^api/user/', include('openedx.core.djangoapps.user_api.urls')),
self.q(css=".contribution-option > input").first.click()
if xblock.category == 'vertical': if parent_xblock is None: parent_xblock = get_parent_xblock(xblock) parent_category = parent_xblock.category if parent_xblock else None return parent_category == 'sequential' return False
if not run_diff_quality( violations_type="jshint", prefix=pythonpath_prefix, reports=jshint_reports, percentage_string=percentage_string, branch_string=compare_branch_string, dquality_dir=dquality_dir ): diff_quality_percentage_pass = False
faces_centered -= faces_centered.mean(axis=1).reshape(n_samples, -1)
with patch('capa.capa_problem.LoncapaProblem.grade_answers') as mock_grade: mock_grade.side_effect = exception_class('test error')
CELERYD_PREFETCH_MULTIPLIER = 1
return render_to_response('api_admin/catalogs/search.html')
init_bound = np.sqrt(2. / (fan_in + fan_out))
return models.AccessToken.objects.get(token=token_string)
return {'Authorization': 'Token {}'.format(settings.BADGR_API_TOKEN)}
problem = self.build_problem(sample_dict=sample_dict, num_samples=10, tolerance=0.01, answer="$calculated_ans", script=script)
for chapter_module in course_module.get_display_items(): if chapter_module.hide_from_toc: continue
estimator.fit(X, y) coef, intercept, dual_gap = (estimator.coef_, estimator.intercept_, estimator.dual_gap_)
tasks = instructor_task.api.get_instructor_task_history(course_id, module_state_key)
if correctness == 'incorrect': second_addend += random.randint(1, 10)
return y, None
return ( usage_key.block_type in self.block_types or usage_key.block_type in BLOCK_TYPES_WITH_CHILDREN )
self._login(staff_email, staff_password, should_succeed=False, err_msg_check="Your password has expired due to password policy on this account")
rng = self.mlp.rng if self.irange is None: raise ValueError("Recurrent layer requires an irange value in " "order to initialize its weight matrices")
precision recall f1-score support a 0.83 0.79 0.81 24 b 0.33 0.10 0.15 31 c 0.42 0.90 0.57 20
for char in pipeline.make_random_password(length=100000): self.assertIn(char, pipeline._PASSWORD_CHARSET)
self.asset_name = 'delete_test' self.asset = self.get_sample_asset(self.asset_name)
self.check_val('true', True)
demand_hints = self.lcp.tree.xpath("//problem/demandhint/hint") demand_hint_possible = len(demand_hints) > 0
p = linear_response * (linear_response > 0.) + self.left_slope *\ linear_response * (linear_response < 0.) return p
if axis == 0: X = X.transpose() mask = mask.transpose()
return self.scope_ids.usage_id.course_key.org
from collections import namedtuple from copy import deepcopy import ddt import itertools from nose.plugins.attrib import attr from unittest import TestCase
_rcost = MeanBinaryCrossEntropy() reconstruction_cost = lambda a, b: _rcost.cost(a, b) / ds.X.shape[1]
_ = lambda text: text
usage_key = request_params['usage_key'] course_key = request_params['course_key']
print "static_asset_path = {0}".format(course.static_asset_path) self.assertEqual(course.static_asset_path, 'test_import_course')
if value is not UNSET: dct[key] = value
error_msg = "XQueue received invalid grade request" self._send_immediate_response(False, message=error_msg)
load_svmlight_file(.42)
_timed_exams = modulestore().get_items( course_key, qualifiers={ 'category': 'sequential', }, settings={ 'is_time_limited': True, } )
assert_equal(len(np.unique(km.labels_)), 3)
params = self._signed_callback_params(self.order.id, self.COST, self.COST) result = process_postpay_callback(params)
if course.discussion_link: return CourseTab.load( 'external_discussion', name=_('External Discussion'), link=course.discussion_link )
self.assertIn( settings.MICROSITE_CONFIGURATION['test_microsite']["urls"]['TOS_AND_HONOR'], data['company_tos_url'] )
email_enabled = models.BooleanField(default=False)
'course', 'org', 'url_name', 'filename', 'xml_attributes')
connection.close()
X_df = MockDataFrame(X) X_train, X_test = cval.train_test_split(X_df) assert_true(isinstance(X_train, MockDataFrame)) assert_true(isinstance(X_test, MockDataFrame))
mean = np.zeros(2)
return self.broadcast_beta(self.beta)
item = self.draft_mongo.get_item(vert_location, 0) self.assertFalse(getattr(item, 'is_draft', False), "Item was published. Draft should not exist")
self.track_selection_page.visit()
inline_script = "messages[0] = {code}".format(code=self._get_random_number_code()) problem = self.build_problem(answer=inline_script)
self.browser.refresh() self.wait_for_video_player_render()
thumbnail_location=asset['thumbnail_location'], import_path=asset['import_path'], locked=asset.get('locked', False)
stores = [{'NAME': name, 'ENGINE': 'This space deliberately left blank'} for name in names]
y = label_binarize(y, classes=[0, 1, 2]) n_classes = y.shape[1]
self.assertEqual(params['signature'], self._signature(params))
y = np.arange(10) % 3
'learner_dashboard',
ScopeIds(None, block_type, definition_id, usage_id), field_data,
for student in students_require_certs: task_progress.attempted += 1 status = generate_user_certificates( student, course_id, course=course )
line_X = np.arange(-5, 5) line_y = model.predict(line_X[:, np.newaxis]) line_y_ransac = model_ransac.predict(line_X[:, np.newaxis])
class_prior = np.array([0.75, 0.25]) assert_array_almost_equal(np.exp(clf.class_log_prior_), class_prior)
X, y = make_regression(n_samples=200, n_features=20, n_informative=5, shuffle=False, random_state=0)
y_train = np.copy(y) y_train[unlabeled_set] = -1
item.transcripts.pop(lang) reraised_message += ' ' + ex.message
if role == 'instructor': world.instructor = InstructorFactory(course_key=world.course_key) world.enroll_user(world.instructor, world.course_key)
us_rule.delete() self._assert_history([('AU', 'blacklist')])
objects = CourseActionStateManager()
return [ desc for desc in [ desc for (_, desc) in XModuleDescriptor.load_classes() ] ]
task_type = 'problem_responses_csv' task_class = calculate_problem_responses_csv task_input = {'problem_location': problem_location} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
print("Fitting ExtraTreesClassifier on faces data with %d cores..." % n_jobs) t0 = time() forest = ExtraTreesClassifier(n_estimators=1000, max_features=128, n_jobs=n_jobs, random_state=0)
iris = datasets.load_iris() X = iris.data y = iris.target
self.now = datetime.datetime.now()
utils.get_programs(self.user)
enrollment = self.enroll() enrollment.is_active = False enrollment.save() self.assertIsNone(self.service.get_credit_state(self.user.id, self.course.id))
get_space = lambda i: (model.aes[i].get_input_space() if i == 0 else model.aes[i - 1].get_output_space())
self.mock_programs_api()
response = self.session.put( "{}/xblock/{}".format(STUDIO_BASE_URL, locator), data=json.dumps(data), headers=self.headers, )
fast_model.fit(X_train, y_train, sample_weight=weights)
xpath = "//span[contains(@class,'selected')]/p/b" self.assert_has_text(xml, xpath, 'HTML 2', exact=False)
return {}
return self.inherited_settings[key.field_name]
return _PSA_BACKENDS[self.backend_name]
$ ./manage.py lms resubmit_error_certificates
trust_root = TrustRoot.parse(openid_request.trust_root) if not trust_root: log.error('invalid trust_root') return False
payload = { "course_id": unicode(course_id or self.course.id) } if marketing_email_opt_in: payload["email_opt_in"] = True return self.client.post(self.url, payload)
return self.enabled and self.cache_ttl > 0
num_vis = rng.randint(1,11) n_classes = rng.randint(1, 11)
vertical.start = self.future modulestore().update_item(vertical, self.dummy_user)
self.exp_dirichlet_component_ = np.exp( _dirichlet_expectation_2d(self.components_))
self.video.show_captions()
user_groups = {} for partition, groups in partition_groups: user_groups[partition.id] = partition.scheme.get_group_for_user( course_key, user, partition, )
self.assertNotIn('index_in_children_list', attributes) self.assertNotIn('parent_sequential_url', attributes) self.assertNotIn('parent_url', attributes)
course = CourseFactory.create(mobile_available=True, default_store=modulestore_type) course_overview_1 = CourseOverview.get_from_id(course.id) self.assertTrue(course_overview_1.mobile_available)
self.label_distributions_ = np.multiply( clamp_weights, self.label_distributions_) + y_static remaining_iter -= 1
scores = cross_val_score(MultinomialNB(alpha=10), X, y, cv=10) assert_greater(scores.mean(), 0.86)
self.W = sharedX(W, name='W') self.v = sharedX(v, name='v') self.mean = sharedX(mean, name='mean')
return unicode(data)
url = '{0}&order_by=display_name&sort_order=desc'.format(self.list_url_master_course) resp = self.client.get(url, {}, HTTP_AUTHORIZATION=self.auth)
self.get_extended_hints(student_answers, new_cmap)
response = self.client.get(self.path) self.assertEqual(response.status_code, 403)
y_pred_grd = grd.predict_proba(X_test)[:, 1] fpr_grd, tpr_grd, _ = roc_curve(y_test, y_pred_grd)
for name, TreeEstimator in CLF_TREES.items(): est = TreeEstimator() assert_raises(NotFittedError, est.predict_proba, X)
FEATURES['ENABLE_DASHBOARD_SEARCH'] = True
def wrap_f_init(*args): data = f_init(*args) length = len(data) / 2 return data[:length], data[length:] return wrap_f_init
self.q(css='div.problem button.hint-button').click() self.wait_for_ajax()
if sp.issparse(X) and X.getformat() not in ["csr", "csc"]: X = X.tocsr()
self.attempt_login(403, ns="http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0")
with self.assertNumQueries(0): RestrictedCourse.is_restricted_course(new_course_id)
unicode_text = "好 各位同学".decode('utf-8') self.assertTrue(self.video.downloaded_transcript_contains_text('srt', unicode_text))
self.check_anonymous_request_rejected('delete') self.assertFalse(mock_log.info.called)
return self.store.get_course(courselike.id.replace(branch=None, version_guid=None))
self.instructor = AdminFactory.create() self.client.login(username=self.instructor.username, password="test")
module = self.descriptor._xmodule self.assertIsInstance(module, ErrorModule)
self.course_nav.go_to_vertical('Test Problem 2')
from __future__ import print_function
self.assertTrue(CourseEnrollment.is_enrolled(self.user, course_id)) self.assertTrue(self.user.roles.filter(name="Student", course_id=course_id))
url_path = embargo_api.message_url_path(self.course.id, access_point) self.assertEqual(url_path, expected_url_path)
try: json.loads(self.configuration) except ValueError: raise ValidationError('Must be valid JSON string.')
Xf = np.asfortranarray(X) est = TreeEstimator() est.fit(Xf, y) assert_almost_equal(est.predict(T), true_result)
self.visbiasY = sharedX( numpy.zeros(nvisy), name='vbY', borrow=True )
raise NotImplementedError('Subclasses must implement course_partition')
self._assert_no_redirect(self.course_without_survey)
template = key.lower() if '.' not in template: template = "%s.%s" % (template, settings.STATIC_TEMPLATE_VIEW_DEFAULT_FILE_EXTENSION)
check_is_fitted(self, "coefs_") y_scores = self.decision_function(X) y_scores = ACTIVATIONS[self.out_activation_](y_scores) return self.label_binarizer_.inverse_transform(y_scores)
return u"{url}?auth_entry={auth_entry}&{param_str}".format( url=reverse("social:begin", kwargs={"backend": backend_name}), auth_entry=auth_entry, param_str=self._finish_auth_url_param(login_params), )
draft_preferred = 'draft-preferred' published_only = 'published-only'
X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=rng)
if which_norb == 'big': self.label_index_to_name = (self.label_index_to_name +
self.assertEquals(xmodule_tabs.CourseTabList.get_tab_by_type(self.course.tabs, tab.type), tab)
self.interpolates_text_or_html = True
return SurveyAnswer.objects.filter(form=form, user=user).exists()
params["terms_of_service"] = "tRUe" self.assert_success(params)
root.set('org', self.courselike_key.org) root.set('library', self.courselike_key.library)
arr = np.random.random(100) assert not contains_nan(arr) arr[0] = np.nan assert contains_nan(arr)
self.assertEqual(len(snapshot['country_rules']), len(country_rules))
'MILESTONES_APP': False,
except NotFoundError: log.exception("Module indicating to user that request doesn't exist") raise Http404
invalid_json = "{u'name': 'Test Name', []}"
assert_almost_equal(metric(y1_sparse_indicator, y2_sparse_indicator), measure, err_msg="%s failed representation invariance " "between dense and sparse indicator " "formats." % name)
expr = stripXML(self.mathml_start + expr + self.mathml_end) expected = stripXML(self.mathml_start + expected + self.mathml_end)
verifications = SoftwareSecurePhotoVerification.objects.filter(user=user)
course.tabs = [tab for tab in course.tabs if not tab.type == 'discussion'] modulestore().update_item(course, user_id)
pts = pts[pts['species'] == species_name] bunch['pts_%s' % label] = pts
for _id in bulk_write_record.structures.viewkeys() - bulk_write_record.structures_in_db: dirty = True
error_msg = ('Invalid parameter %s for estimator %s. ' 'Check the list of available parameters ' 'with `estimator.get_params().keys()`.')
raise Exception(msg), None, sys.exc_info()[2]
REPO_ROOT = path(__file__).abspath().parent.parent.parent
self.assertIsNone(self.profile.level_of_education_display)
enrollment = CourseEnrollment.get_enrollment(student, self.course.id) self.assertEqual(enrollment.is_active, False)
self.client.logout()
assert has_expected
is_hideable = False
is_present = self.q(css=selector).present return is_present, is_present
return self.get_text('.name')
K1 = kernel(X, Y) K2 = pairwise_kernels(X, Y, metric=kernel) assert_array_almost_equal(K1, K2)
header = None rows = [] err_rows = [["id", "username", "error_msg"]] current_step = {'step': 'Calculating Grades'}
from .models import SAMLProviderConfig return SAMLProviderConfig.current(idp_name).get_config()
if mod_loc.name not in name: return False
super(UngenerateCertificatesTest, self).setUp() self.course = self.courses[0]
_write_metric(num_violations, (Env.METRICS_DIR / "jshint"))
payment_data = checkout_with_ecommerce_service( request.user, course_id, current_mode, request.POST.get('processor') )
if answer_id in self.cmap: return self.cmap[answer_id]['correctness'] in ['correct', 'partially-correct'] return None
return self.link_value
return (0, 0, self.rule.rule_id)
'ENABLE_SPECIAL_EXAMS': False,
block_relations, transformer_data, block_data_map = zunpickle(zp_data_from_cache) block_structure = BlockStructureModulestoreData(root_block_usage_key) block_structure._block_relations = block_relations block_structure._transformer_data = transformer_data block_structure._block_data_map = block_data_map
while n_features > 2: sfm.threshold += 0.1 X_transform = sfm.transform(X) n_features = X_transform.shape[1]
return set(JIRA_RE.findall(text))
current_hash = get_hash_tuple(full_header_path, full_cython_path, full_gen_file_path)
bulk_write_record = self._get_bulk_ops_record(course_key) if bulk_write_record.active: bulk_write_record.definitions[definition['_id']] = definition else: self.db_connection.insert_definition(definition, course_key)
self.n_iter_final = it
image = image * 255. image = np.cast['uint8'](image)
response = self._add_edx4edx() self.assertIn(GitImportErrorNoDir(settings.GIT_REPO_DIR).message, response.content.decode('UTF-8'))
from __future__ import unicode_literals
classifier = svm.SVC(gamma=0.001)
if task_progress.attempted % status_interval == 0: task_progress.update_task_state(extra_meta=current_step) task_progress.attempted += 1
rval = -T.mean(log_hx)-T.mean(log_one_minus_hy) rval.name = 'NCE('+X_name+')'
for course_key, record in self._active_bulk_ops.records.iteritems(): if record.active: yield (course_key, record)
import matplotlib.pyplot as plt
is_increasing = y_[0] < y_[-1] assert_true(is_increasing)
try: user.email_user( subject, message, theming_helpers.get_value('default_from_email', settings.DEFAULT_FROM_EMAIL) )
expected_redirect = reverse( 'instructor_dashboard', kwargs={'course_id': unicode(self.course.id)} ) expected_redirect += '#view-certificates' self.assertRedirects(response, expected_redirect)
enrollment = cls.get_or_create_enrollment(user, course_key) enrollment.update_enrollment(is_active=True, mode=mode) if badges_enabled(): from lms.djangoapps.badges.events.course_meta import award_enrollment_badge award_enrollment_badge(user)
self.lc_block.refresh_children() self.assertTrue(self.lc_block.validate())
updates, layer_to_chains = model.get_sampling_updates( layer_to_chains, self.theano_rng, num_steps=self.num_gibbs_steps, return_layer_to_updated=True)
self.assertItemsEqual( data.keys(), ['company_about_url', 'company_privacy_url', 'company_tos_url'] )
n_samples, n_features = X.shape n_targets = y.shape[1]
dict(safe_zip(range(0, 36, 2), numpy.arange(0, 360, 20))),
if (student_username != request.user.username) and (not staff_access): raise PermissionDenied
ave = elemwise_kl(Y, Y_hat)
self._auto_auth(self.USERNAME, self.EMAIL, False) self.courseware_search_page.visit()
from __future__ import unicode_literals
return library_key.replace(version_guid=None, branch=None)
for missing in SUBMISSION_SET_KWARGS: kwargs = SUBMISSION_SET_KWARGS.copy() del kwargs[missing] submissions_score_set_handler(None, **kwargs) self.signal_mock.assert_not_called()
TEST_ROOT = REPO_ROOT / "test_root" LOG_DIR = (TEST_ROOT / "log").abspath()
path = self._last_visited_module_path(request, course) path_ids = [unicode(module.location) for module in path] return Response({ "last_visited_module_id": path_ids[0], "last_visited_module_path": path_ids, })
resp = self.client.get(self.url + '?_accept=application/x-tgz') self._verify_export_succeeded(resp)
train_algo = SGD( learning_rate = 0.1, cost = MeanSquaredReconstructionError(), batch_size = 10, monitoring_batches = 10, monitoring_dataset = trainset, termination_criterion = EpochCounter(max_epochs=MAX_EPOCHS_UNSUPERVISED), update_callbacks = None )
university = microsite.get_value('university')
requirements = get_credit_requirements(self.course.id, namespace="reverification") self.assertEqual(len(requirements), 1)
'ENTRANCE_EXAMS': False,
staff = UserFactory.create(username="staff", email="staff@e.com", password="test") role = CourseStaffRole(self.course_limited.id) role.add_users(staff)
for state in READY_STATES: running_tasks = running_tasks.exclude(task_state=state) return len(running_tasks) > 0
last_touch = request.session.get(LAST_TOUCH_KEYNAME)
def __init__(self, *args): self.args = args
read_data = "".join(textwrap.dedent(c) for c in content) return patch.object(pavelib.i18n, 'open', create=True, new=mock_open(read_data=read_data))
if tasks.environment.dry_run: for cmd in cmd_list: tasks.environment.info(cmd) return
self.import_asset_metadata(data_path, dest_id)
seed_milestone_relationship_types() course_milestones = milestones_api.get_course_milestones(course_key=course_key, relationship="fulfills")
self.contentstore = MongoContentStore(HOST, DB, port=PORT)
self.validation_scores_.append(self.score(X_val, y_val))
for attempt in xrange(self.INVALID_ATTEMPTS): self._change_password(email=self.NEW_EMAIL)
self.log_ais_w = numpy.zeros(n_runs, dtype=config.floatX)
has_changes = None if (is_xblock_unit or course_outline) and not is_library_block: has_changes = modulestore().has_changes(xblock)
partial(replace_static_urls, None, course_id=course_id), _studio_wrap_xblock,
hasher = FeatureHasher() hasher.set_params(n_features=np.inf) assert_raises(TypeError, hasher.fit)
MAILCHIMP_NEW_USER_LIST_ID = ENV_TOKENS.get("MAILCHIMP_NEW_USER_LIST_ID")
self.assertEqual(seed, module.seed)
if i == 0: layer_below = self.dbm.visible_layer else: layer_below = self.dbm.hidden_layers[i-1] state_below = layer_to_state[layer_below] state_below = layer_below.upward_state(state_below)
activation_key = create_account(self.USERNAME, self.PASSWORD, self.EMAIL) user = User.objects.get(username=self.USERNAME)
if setup_option or query_yes_no(self.CONFIRMATION_PROMPT, default="no"): course_keys = [course.id for course in modulestore().get_courses()] else: return
with wrap_ugettext_with_xyz(french_translation): self.assertEqual(i18n_service.ugettext(self.test_language), 'XYZ dummy language')
self.user.is_staff = True self.user.save()
_update_social_context(request, context, course, user, user_certificate, platform_name)
wclf = svm.SVC(kernel='linear', class_weight={1: 10}) wclf.fit(X, y)
rng = np.random.RandomState(1999) n, p = 50, 3
self.assertEqual(self.account_settings_page.value_for_dropdown_field('year_of_birth', ''), '')
self._each_parens(r'\left\{x^y\right\}', 'x^y', '{', tall=True)
self.course_info['number'] = "3355358979513794782079645765720179311111"
([UnregisteredTestTransformer3()], [UnregisteredTestTransformer3.name()]),
self.course_data['org'] = 'University of California, Berkeley' self.assert_course_creation_failed(r"(?s)Unable to create course 'Robot Super Course'.*")
matching_coupons = Coupon.objects.filter(code=code, is_active=True) if matching_coupons: return save_registration_code( user, course_id, mode_slug, invoice=invoice, order=order, invoice_item=invoice_item )
session_user_id = SafeSessionMiddleware.get_user_id_from_session(request)
self.notes_page.wait_for_ajax()
self.find_css('li.group-configuration-usage-unit a').nth(index).click()
from openedx.core.djangoapps.credit.api.eligibility import ( is_credit_course, remove_credit_requirement_status as api_remove_credit_requirement_status )
alternate_course = self.create_course(course='mobile', mobile_available=True)
return Response({"developer_message": developer_message}, status=status_code)
if strategy == "median": cols_to_keep = ~np.isnan(X_true).any(axis=0) else: cols_to_keep = ~np.isnan(X_true).all(axis=0)
if coupon_redemption.exists(): coupon_codes = [redemption.coupon.code for redemption in coupon_redemption] order_item_dict.update({'coupon_code': ", ".join(coupon_codes)})
return sample_weight, 1., 0.
raise NotImplementedError("%s does not implement definition_from_xml" % cls.__name__)
#html_show_sphinx = True
read_only_fields = () explicit_read_only_fields = ("profile_image", "requires_parental_consent")
signal_handler.reset_mock() unit = self.store.create_child(self.user_id, subsection.location, 'vertical') signal_handler.send.assert_not_called()
self.mc_setup_response()
return { 'gender': {'user__profile__gender': value}, 'level_of_education': {'user__profile__level_of_education': value}, }[feature]
ip_address = "192.168.10.20" IPFilter.objects.create( blacklist=ip_address, enabled=True )
raise SkipTest
self.student = UserFactory( username=self.STUDENT_USERNAME, email=self.STUDENT_EMAIL, password=self.STUDENT_PASSWORD, )
from __future__ import unicode_literals
yield dec
SINGLE_EMAIL_FAILURE_ERRORS = (
task_type = 'proctored_exam_results_report' task_class = proctored_exam_results_csv task_input = {'features': features} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
self._transformer_data = defaultdict(dict)
self.type = None self.data = None self.choices_display_names = None
return force_text(urlsafe_base64_encode(force_bytes(base36_to_int(uidb36 or self.uidb36))))
([], 'honor'),
except Exception as err: print("Error running process {}".format(err), file=sys.stderr)
self.set_config(enabled=False)
a = "this is \xe0 test" expected = 'this is a test' assert_equal(strip_accents_unicode(a), expected)
def tile_columns(self, **kwargs): raise NotImplementedError('override me')
raise CommandError( _( 'Skipping user "{}" because the specified and existing email ' 'addresses do not match.' ).format(user.username) )
for key, val in six.iteritems(dict_from): if key in dict_to: raise KeyError(key) dict_to[key] = val return dict_to
lfw_people = fetch_lfw_people(data_home=SCIKIT_LEARN_DATA, resize=None, slice_=None, color=True, download_if_missing=False) assert_equal(lfw_people.images.shape, (17, 250, 250, 3))
X = [[0], [1]] Y = [[-1], [2]]
master_doc = 'index'
mlb = MultiLabelBinarizer(classes=[1, 3, 2]) assert_array_equal(mlb.fit_transform(inp), indicator_mat) assert_array_equal(mlb.classes_, [1, 3, 2])
self.blocks = [XBlockFixtureDesc('html', str(i)) for i in xrange(1, 41)] library_fixture.add_children(*self.blocks)
return request.session.get('partial_pipeline')
self.store.delete_item( orphan.location, self.user.id, skip_auto_publish=True )
default_level = None from_logout = _is_from_logout(request) if from_logout: default_level = logger.getEffectiveLevel() logger.setLevel(ERROR) try: yield finally: if from_logout: logger.setLevel(default_level)
MESSAGE = None def __init__(self, message=None): if message is None: message = self.message super(GitImportError, self).__init__(message)
return [child.version_agnostic() for child in children]
self.store.convert_to_draft(problem.location, self.user.id) problem = self.store.get_item(problem.location)
if not hasattr(self, 'mask_weights'): self.mask_weights = None if not hasattr(self, 'max_col_norm'): self.max_col_norm = None
open_assessment = ItemFactory.create( parent_location=vertical.location, category="openassessment", display_name="untitled", ) draft_open_assessment = self.store.convert_to_draft( open_assessment.location, self.user.id )
logging.debug("Current state of '{}' element is '{}'".format(state_selector, current_state))
with self.settings(PIPELINE_ENABLED=False): js_include = compressed_js('base_application') self.assertIn(u'/static/js/src/logger.js', js_include)
self.assertNotEqual(discussion_item.discussion_id, '$$GUID$$')
reg_item = PaidCourseRegistration.add_to_order(cart, course_key) return reg_item
def __getstate__(self): return {"valid": self.valid, "value": self.value}
raise SkipTest('Sandbox RNNs are disabled.')
([], 'honor'),
if third_party_auth.is_enabled() and pipeline.running(request): running_pipeline = pipeline.get(request) redirect_url = pipeline.get_complete_url(running_pipeline['backend'])
local_name = os.path.join(self.dataset_local_dir, os.path.relpath(remote_name, self.dataset_remote_dir))
theano.config.floatX = self.orig_floatX
X, y = mnist.data / 255., mnist.target X_train, X_test = X[:60000], X[60000:] y_train, y_test = y[:60000], y[60000:]
return _write_js(output_root, _list_descriptors())
raise NotImplementedError("%s doesn't implement make_symbolic_state" % type(self))
return self.child(title)
return self.ROOT + value
if self.normalize_y: self.y_train_mean = np.mean(y, axis=0) y = y - self.y_train_mean else: self.y_train_mean = np.zeros(1)
log.warning("Multiple gating milestones found for prereq UsageKey %s", prereq_content_key)
response = getattr(self.client, method)(self.path) self.assertEqual(response.status_code, 405)
self.assertEquals(cohorts.get_cohort(user, course.id).name, "AutoGroup")
n_neighbors = 5
return sorted(cls._enabled_providers(), key=lambda provider: provider.name)
response = self.client.post(self.send_mail_url, test_email) self.assertEquals(json.loads(response.content), self.success_content)
self.add_license_to_xml(xml_object, default="all-rights-reserved")
raised = False fmt = OneHotFormatter(max_labels=50) try: fmt.theano_expr(theano.tensor.vector(dtype=theano.config.floatX)) except TypeError: raised = True assert raised
for parent, children in enumerate(children_map): for child in children:
if library_key_string: return _display_library(library_key_string, request)
monitoring_dataset = DenseDesignMatrix(X=X)
response = self.post_credit_request(None, 'a/b/c') self.assert_error_response(response, 'A username must be specified.')
raise
if options['course']: try: course = CourseKey.from_string(options['course']) except InvalidKeyError: course = SlashSeparatedCourseKey.from_deprecated_string(options['course'])
self._auto_auth(self.USERNAME, self.EMAIL, False) self.courseware_search_page.visit() self.courseware_search_page.search_for_term(search_term) return search_term in self.courseware_search_page.search_results.html[0]
with self.assertRaises(StudentInputError): problem = self.build_problem(answer='(1 5)')
skip_if_no_sklearn() mapping = {'dataset_iterator': 'DatasetShuffleSplit'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
if 'detached' not in published._class_tags and published.start is not None: return datetime.now(UTC) > published.start
self.assertEqual(tab.link_func(self.course, self.reverse), expected_link)
sh("coverage xml --rcfile={}".format(rcfile)) sh("coverage html --rcfile={}".format(rcfile)) call_task('diff_coverage', options=dict(options))
other_course_key = CourseKey.from_string("edX/other/2015") self._configure_credit(course_key=other_course_key) second_request = api.create_credit_request(other_course_key, self.PROVIDER_ID, self.USER_INFO["username"])
if not hasattr(self, '_datasets'): self._datasets = [self._dataset] del self._dataset
self.courseware_page.go_to_sequential_position(4) self.assert_navigation_state('Test Section 1', 'Test Subsection 1,1', 3, next_enabled=True, prev_enabled=True)
if self.options.verbose: print('checking %s' % filename) fchecker = self.checker_class( filename, lines=lines, options=self.options) return fchecker.check_all(expected=expected, line_offset=line_offset)
response = self.assert_request_status_code(400, url, method="POST", data=data) self.assertIn("This invoice is already active.", response.content)
assert_equal(sample_without_replacement(0, 0).shape, (0, ))
assert_equal(len(data2cats.filenames), len(data2cats.target)) assert_equal(len(data2cats.filenames), len(data2cats.data))
if field.primary_key: continue
sample_dict = {'x': (-10, 10), 'y': (-10, 10)}
return dict(parse_qsl(urlparse(url).query))
self.assertEquals(7, self.response.content.count('grade_Pass'))
BOK_CHOY_MONGO_DATABASE = "test" BOK_CHOY_CACHE = memcache.Client(['0.0.0.0:11211'], debug=0)
nbrs_X = neighbors.NearestNeighbors(n_neighbors=3) nbrs_X.fit(X) dist_X, ind_X = getattr(nbrs_X, method)(Y)
X = np.arange(100).reshape(10, 10) y = np.array([0] * 5 + [1] * 5)
response = self.client.get(reverse('branding.views.courses')) self.assertEqual(response.status_code, 200)
return self.q(css='{} input[name=delete-entrance-exam-state]'.format(self.EE_CONTAINER))
if course_overview and not hasattr(course_overview, 'image_set'): CourseOverviewImageSet.create_for_course(course_overview)
X, y = X[y < 2], y[y < 2]
pass
test_element = rendered_html.find("test") self.assertEqual(test_element.tag, "test") self.assertEqual(test_element.text, "Test include")
return '1234'
try: atomic_replace(temp_filename,local_dst) except Exception as e: raise IOError("[ac] %s %s --> %s" % (str(e),temp_filename,local_dst))
logger.info('computing mean') self.mean_ = numpy.asarray(X.mean(axis=0))[0, :]
err_msg = None
sh('xmodule_assets common/static/xmodule') print("\t\tFinished processing xmodule assets.")
if not view_func.__module__.startswith('wiki.'): return
if hint_list: hintgroup_element = etree.SubElement(response_element, "hintgroup")
return None
return time.strftime('%Y-%m-%dT%H:%M:%SZ', value)
assert abs(exact_logz - logz) < 0.01*exact_logz
return ""
self.assertTrue( CourseEnrollment.objects.filter(course_id=self.course.id, user=student).exists() )
items = self.store.get_items(self.course.id) self.assertEqual(len(items), 0)
super(LoggerBackend, self).__init__(**kwargs) self.event_logger = logging.getLogger(name)
#epub_scheme = ''
course_modes = CourseMode.objects.filter(course_id=course.id) actual = [course_mode.mode_display_name for course_mode in course_modes] self.assertListEqual(actual, ['Verified Certificate', 'Honor Certificate'])
pass
y_noisy = y + 0.05 * np.random.randn(len(y))
def __init__(self, user=None, course_id=None): self.user = user self.course_id = course_id
EDX_PLATFORM_REVISION = dealer.git.Backend(path=REPO_ROOT).revision
step_incr = -1 start_idx = (num_assets - 1) - start_idx end_idx = (num_assets - 1) - end_idx
self.assertTrue(CourseEnrollment.is_enrolled(self.user, course_id)) self.assertTrue(self.user.roles.filter(name="Student", course_id=course_id))
self.contentstore.delete(asset_key)
this_algorithm = deepcopy(algorithm) this_algorithm._set_monitoring_dataset(datasets)
_update_microsite_context(context, configuration)
return self.lcp.done
with self.assert_logged_with_message( "SafeCookieData user at request '{}' does not match user at response: '{}'".format( user_at_request, user_at_response ), log_level=log_level, ): yield
assert_true(id1, id2)
X = [[1]] Y = [0]
expected_message = self.get_dashboard_analytics_message() self.assertTrue(expected_message in response.content)
HOMEPAGE_COURSE_MAX = None
continue
@property def score(self): raise AttributeError
self.expect_error_on_file_content( '', "The file must end with the extension '.csv'.", file_suffix='.notcsv' )
self.assertEqual(exam['hide_after_due'], sequence.hide_after_due)
'float64': 0x1E3D4C53, 'int32': 0x1E3D4C54, 'uint8': 0x1E3D4C55, 'int16': 0x1E3D4C56
for i, j in product([0, 1], repeat=2): metric([i], [j])
with self.assertNumQueries(1): VerificationDeadline.deadlines_for_courses(course_keys)
tab_content = get_static_tab_contents(request, course, tab) self.assertIn(self.course.id.to_deprecated_string(), tab_content) self.assertIn('static_tab', tab_content)
X -= X.min()
details = pipeline_kwargs.get('details')
ESTIMATE_PRECISION_ERROR_MESSAGE = ("The algorithm has diverged because of " "too few samples per components. Try to " "decrease the number of components, " "or increase reg_covar.")
StudentViewTransformer.collect(block_structure) BlockCountsTransformer.collect(block_structure) BlockDepthTransformer.collect(block_structure) BlockNavigationTransformer.collect(block_structure)
predictions = cross_val_predict(clf, X, y) assert_equal(predictions.shape, (150,))
mode = CourseMode.objects.get(course_id=course_key, mode_slug=mode_slug) mode.expiration_datetime = upgrade_deadline mode.save()
self.assert_redirect_to_dashboard_looks_correct(actions.do_disconnect( request.backend, request.user, None, redirect_field_name=auth.REDIRECT_FIELD_NAME))
total_amount = Invoice.get_invoice_total_amount_for_course(self.course_key) self.assertEqual(total_amount, 123.45)
self.children.extend(args) return self
X = T.matrix() Y = T.nnet.sigmoid(X) Z = arg_of_sigmoid(Y) assert X is Z
self._assert_user_name(self.user.profile.name)
(32, False, True, u"True"),
course = get_course(course_id)
result = Fragment() if 'activate_block_id' in context: result.add_content(u"Activate Block ID: {block_id}</p>".format(block_id=context['activate_block_id'])) return result
self.register_page.visit()
full_path = path(__file__).abspath().dirname() / "data" / rel_path with open(full_path) as data_file: return data_file.read()
return functools.partial(self.cache, ignore=ignore, verbose=verbose, mmap_mode=mmap_mode)
return 'latex' not in template['template_id'] or course.use_latex_compiler
'ENABLE_PREREQUISITE_COURSES': False,
url( r'^v1/blocks/', BlocksInCourseView.as_view(), name="blocks_in_course" ),
REQUEST_CONTEXT.request = request
course_modes = CourseMode.modes_for_course( obj.id, include_expired=self.include_expired, only_selectable=False ) return [ ModeSerializer(mode).data for mode in course_modes ]
return None
flo = numpy.floor sub = numpy.subtract mul = numpy.multiply div = numpy.divide mod = numpy.mod
@ensure_csrf_cookie
epoch_num = 15 termination_criterion = EpochCounter(epoch_num)
transfer_students.Command().handle( source_course=original_key, dest_course_list=new_key_one + "," + new_key_two ) self.assertTrue(self.signal_fired)
RestrictedCourse.invalidate_cache_for_course(instance.course_key) CountryAccessRule.invalidate_cache_for_course(instance.course_key)
self.get_data_specs(model)[0].validate(data) X = data return self.cost(X, model.reconstruct(X))
X = [[-2, -1], [-1, -1], [-1, -2], [1, 1], [1, 2], [2, 1]]
return 'unknown'
dashboard = DashboardPage(self.browser) dashboard.wait_for_page() return dashboard
return self.fit(X).labels_
X = check_array(X, dtype=DTYPE, order="C") return self._decision_function(X).ravel()
if bulk_write_record.active: bulk_write_record.set_structure_for_branch(course_key.branch, new_structure)
return self.find_css('a.group-toggle.hide-groups').present
attrs.append(node.id) self.accessed_names.add('.'.join(reversed(attrs)))
self.assertOLXIsDraftOnly(block_list_to_revert) self.publish(block_list_to_revert) self.assertOLXIsPublishedOnly(block_list_to_revert) self.revert_to_published(block_list_to_revert) self.assertOLXIsPublishedOnly(block_list_to_revert)
([TestTransformer1(), UnregisteredTestTransformer3()], [UnregisteredTestTransformer3.name()]),
PARENTAL_CONSENT_AGE_LIMIT = 13
import warnings import numpy as np from scipy import linalg
return self._active_count > 0
course = self.process_xml(xml.CourseFactory.build()) self.assertEquals(course_image_url(course), '/static/xml_test_course/images/course_image.jpg')
self.store.delete_item(self.problem_x1a_1, self.user_id) self.assertTrue(self._has_changes(self.vertical_x1a))
xml_object.tag = self.category node.tag = self.category
return self.make_call( reverse('topics_detail', kwargs={'topic_id': topic_id, 'course_id': str(course_id)}), expected_status, 'get', data, **kwargs )
nested_ipt = mapping.nest(ipt)
results.append(benchmark(LinearSVC(loss='l2', penalty=penalty, dual=False, tol=1e-3)))
image_index[0] = add_mod(image_index[0], step, len(row_indices))
app.add_domain(NumpyPythonDomain) app.add_domain(NumpyCDomain)
for student in students[2:5]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.error, mode='honor', grade=default_grade )
return self.n_iter
if dispatch == 'preview_formcalc': return self.preview_formcalc(get) return {}
SESSION_COOKIE_NAME = str(SESSION_COOKIE_NAME)
means = rand_data.means g.means_init = means g.fit(X) assert_array_equal(means, g.means_init)
request_password_change(self.EMAIL, self.ORIG_HOST, self.IS_SECURE)
maxDiff = None
DEFAULT_DATETIME_STR = datetime.datetime(year=2014, month=12, day=1).isoformat(' ')
updates.update(dict(safe_zip(params, [param - learning_rate * lr_scalers.get(param, 1.) * grads[param] for param in params])))
response = self.http_get(reverse(self.view), HTTP_AUTHORIZATION=auth_header) self.assertEqual(response.status_code, 200)
course = self.set_up_course(due_date_display_format=None) text = self.get_text(course) self.assertIn(self.time_with_tz, text)
return hasattr(self, '_has_answerpool')
post_params = sign(self.CLIENT_POST_PARAMS)
return self.q(css=self.VIEW_MODE_OPTIONS_CSS).filter(lambda el: el.is_selected()).first.text[0]
assert_raises(ValueError, gs.fit, X, y)
block_path = course_export_dir if draft: block_path = os.path.join(block_path, 'drafts') return os.path.join(block_path, block_type)
assert world.css_visible('iframe') check_lti_iframe_content("This is LTI tool. Success.")
loading_css = "#loading-indicator" courses_css = '.courses-listing' return self.q(css=courses_css).visible \ and self.q(css=loading_css).present \ and not self.q(css=loading_css).visible
courses, in_process_course_actions = _accessible_courses_summary_list(request)
md.inlinePatterns.add('mathjax', MathJaxPattern(), '<escape')
if delete_vertical: self.store.delete_item(vertical1.location, self.user.id) else: self.store.delete_item(problem1.location, self.user.id)
self.assertEqual(context['currency'], 'PKR') self.assertEqual(context['currency_symbol'], 'Rs')
np.random.seed(0) X = np.zeros((n_samples, 2)) step = 4. * np.pi / n_samples
def_key = AsideDefinitionKeyV1(definition_id, aside_type) usage_key = AsideUsageKeyV1(usage_id, aside_type) return (def_key, usage_key)
if value is None: return Response(status=status.HTTP_404_NOT_FOUND)
self.url = xml.get('url') or "http://qisx.mit.edu:8889/pyloncapa"
log.info('deleting redemption entry (%s) from the database.', code_redemption.id) code_redemption.delete()
from cms.djangoapps.contentstore.courseware_index import CourseAboutSearchIndexer CourseAboutSearchIndexer.remove_deleted_items(course_key)
source = find_staff_lock_source(xblock) return _xblock_type_and_display_name(source) if source else None
X, y = make_classification(n_samples=200, n_features=20, n_informative=3, n_redundant=2, n_repeated=0, n_classes=8, n_clusters_per_class=1, flip_y=0.0, class_sep=10, shuffle=False, random_state=0)
'ENABLE_MOBILE_REST_API': False,
input_dict = {'1_2_1': 'California'} correct_map = problem.grade_answers(input_dict) self.assertEquals(correct_map.get_hint('1_2_1'), "")
params["username"] = "this_username_has_31_characters" assert_username_error("Username cannot be more than 30 characters long")
visible_reqs = api.get_credit_requirements(self.course_key) self.assertEqual(len(visible_reqs), 1) self.assertEqual(visible_reqs[0]["namespace"], "grade")
exc = drf_exceptions.AuthenticationFailed({u'error_code': -1}) self.assertEqual(exc.detail, u"{u'error_code': -1}")
clf = GradientBoostingClassifier(n_estimators=10, random_state=1) clf.fit(iris.data, iris.target)
return usage_key in self.modules[usage_key.course_key]
msg_p_elements = msg_div_element.findall('p') self.assertEqual(msg_p_elements[0].tag, "p") self.assertEqual(msg_p_elements[0].text, "Test message 1")
assert_equal(len(cv), wrapped_old_skf.get_n_splits())
if user is not None and user.is_active: if 'openid_error' in request.session: del request.session['openid_error']
with self.assert_logged('SafeCookieData BWC parse error'): yield
return SoftwareSecurePhotoVerification.user_status(self.user)[0]
return self.q(css=TEAMS_HEADER_CSS + ' .page-description')[0].text
self.assertTrue('Activate Course Enrollment' in response.content)
cs = CourseStructure.objects.get(course_id=self.course.id) self.assertEqual(cs.structure_json, structure_json)
code = "a = 0\n" + ("a += 1\n" * 12345)
n_samples, n_features = X.shape max_features = ensemble.max_features
self.q(css='.create-user-button').first.click() self.wait_for(lambda: self.new_user_form_visible, "Add user form is visible")
self.testing_course.enrollment_start = self.tomorrow self.testing_course.enrollment_end = self.nextday self.testing_course = self.update_course(self.testing_course, self.user.id)
field_data = LicenseMixin.parse_license_from_xml(field_data, xml)
self.client.login(username=self.user.username, password='test')
cfn = xml.get('cfn') if cfn: log.debug("cfn = %s", cfn)
binary_metric = (lambda y_true, y_score, average="macro": _average_binary_score( precision_score, y_true, y_score, average)) _check_averaging(binary_metric, y_true, y_pred, y_true_binarize, y_pred_binarize, is_multilabel=True)
cache.clear()
if isinstance(student_answer, list): student_answer = student_answer[0]
return mapping[math_string]
_view_name = 'profile_image_upload' _replacement_method = 'openedx.core.djangoapps.profile_images.views.ProfileImageView.post'
config.floatX = self.prev_floatX
self.assertEqual(certificate_exception['user_email'], self.user.email) self.assertEqual(certificate_exception['user_name'], self.user.username)
second_config.edit() second_config.name = "Updated Second Content Group" self.assertEqual(second_config.get_text('.action-primary'), "Save") second_config.save()
if convnet_available.compile_error: _logger.debug('error last time') return False
chapter_to_delete = course.get_children()[0] self.delete_item(store, chapter_to_delete.location)
response.set_cookie_wrapped_func = response.set_cookie response.set_cookie = _set_cookie_wrapper
print("training score : %.3f (%s)" % (clf.score(X, y), multi_class))
expected_y = y.mf_update( state_below = v.upward_state(v_state))
module = CapaFactory.create(attempts=attempts - 3) self.assertEqual(module.check_button_name(), "Check")
time.sleep(5)
partial( wrap_xblock, 'PreviewRuntime', display_name_only=display_name_only, usage_id_serializer=unicode, request_token=request_token(request) ),
video_data = local_cache['course_videos'].get(video_descriptor.edx_video_id, {})
CreditProvider.objects.create(provider_id=other_provider_id, enable_integration=True)
course_items_table.drawOn(self.pdf, table_left_padding, y_pos - rendered_height)
probas = [c.fit(X, y).predict_proba(X) for c in (clf1, clf2, clf3, eclf)]
err_msg = colorize( 'red', "No coverage info found. Run `paver test` before running " "`paver coverage`.\n" ) sys.stderr.write(err_msg) return
EmptyPromise(self.is_upload_finished, 'Upload Finished', timeout=30).fulfill()
assets_deleted = content_store.remove_redundant_content_for_courses() success = True
new_group = RandomUserPartitionScheme.get_group_for_user(self.MOCK_COURSE_ID, self.user, user_partition) self.assertIn(new_group.id, [3, 4])
_refresh_course_tabs(request, course_module)
return self.q(css="div.problems-wrapper").text[0]
self._build_f(X, y) return self
teams_per_topic = 10 topics = self.setup_topics(teams_per_topic=teams_per_topic) self.assert_serializer_output(topics, num_teams_per_topic=teams_per_topic, num_queries=1)
course = modulestore().get_course(self.course.id) self.assertNotIn("notes", course.advanced_modules)
if not self._requested_xblock_fields: return for xblock_usage_key, xblock in self._xblock_map.iteritems(): for field_name in self._requested_xblock_fields: self._set_xblock_field(xblock_usage_key, xblock, field_name)
for namespace, directories in namespace_dirs.items(): for directory in directories: add_lookup(namespace, directory)
input_type = X.format if sp.issparse(X) else type(X) err = "Expected a CSR or CSC sparse matrix, got %s." % input_type raise TypeError(err)
return beta_from_design(dataset.X, **kwargs)
response = requests.post(url, data=data, headers=headers, verify=False)
test_cases = [('unsubmitted', 'unanswered'), ('incomplete', 'incorrect'), ('incorrect', 'incorrect')]
if not settings.FEATURES.get('ENABLE_TEAMS'): filtered_list.append('teams_configuration')
return LoncapaProblem(xml, id='1', seed=seed, capa_system=capa_system or test_capa_system(), capa_module=mock_capa_module())
auth_entry = request.session.get(pipeline.AUTH_ENTRY_KEY)
PUBLIC_RSA_KEY = None PRIVATE_RSA_KEY = None
eligible_certificates = EligibleCertificateManager()
self.put = send
return self.q(css="div.problem div.problem-hint").text[0]
if required_courses: pre_requisite_courses[course_key] = {'courses': required_courses}
self.assertGreater(len(sections), 0, "No sections found")
self.auth_page.visit() self.dashboard_page.visit()
with self.assert_last_activity_updated(should_update): user = getattr(self, user) signal.send(sender=None, user=user, post=self.mock_comment())
assert_array_equal(mb_k_means.predict(X_csr), mb_k_means.labels_)
return social_auth.uid[len(self.lti_consumer_key) + 1:]
self.certificates_section.add_certificate_exception(self.user_name, '')
prior = DiagonalGaussianPrior() vae = DummyVAE() prior.set_vae(vae) prior.initialize_parameters(nhid=5) z = T.tensor3('z') prior.log_p_z(z)
response = view_func(request)
return any(self.correct_map.is_queued(answer_id) for answer_id in self.correct_map)
item = self.store.get_item(item_location) item.group_access[self.content_partition.id] = group_ids self.store.update_item(item, self.user.id)
return value
clf = self.factory(loss="log", alpha=0.01, n_iter=10).fit(X2, Y2)
return ( self.created_at < deadline and self.expiration_datetime > deadline )
return ( _has_catalog_visibility(courselike, CATALOG_VISIBILITY_CATALOG_AND_ABOUT) or _has_catalog_visibility(courselike, CATALOG_VISIBILITY_ABOUT) or _has_staff_access_to_descriptor(user, courselike, courselike.id) )
users_state_after_post = self._post_words( ['word1', 'word2', 'word3'])
expected_text = "This component is out of date. The library has new content." library_block = self._get_library_xblock_wrapper(self.unit_page.xblocks[1])
for idx in range(new_parent_cursor, len(new_parent.children)): if new_parent.children[idx].block_id == old_child_loc.block_id: new_parent_cursor = idx + 1
selector = '{} .acid-block {} .pass'.format(self.context_selector, test_selector) return bool(self.q(css=selector).results)
self.assertEqual(resp.status_code, 200)
return self.q(css=ERROR_ITEM_NAME_SELECTOR).text
except(KeyError, ValueError): raise ValueError( u"Invalid submission: {val} for {key}".format(val=data[key], key=key) )
cdn_response_video_url = settings.CDN_VIDEO_URLS["CN"] + self.original_video_file self.assertEqual( rewrite_video_url(settings.CDN_VIDEO_URLS["CN"], self.original_video_url), cdn_response_video_url )
page.browser.execute_script("jQuery.fx.off = true;")
test_deviance[i] = clf.loss_(y_test, y_pred)
if symtab: varset = symtab else: varset = { 'p': sympy.Symbol('p'), 'g': sympy.Symbol('g'),
for block_hierarchy in course_hierarchy: self.add_parents(block_hierarchy, block_map)
pass
resp_params = PaymentFakeView.response_post_params(post_params)
url = TEST_SERVER_HOST if path: url += path return url
self.login_page.login(email="nobody@nowhere.com", password="password")
if not course_key_string or not action_state_id: return HttpResponseBadRequest()
call_command('manage_user', TEST_USERNAME, TEST_EMAIL, '--remove') self.assertEqual([], list(User.objects.all()))
unique_tab_types = [ CoursewareTab.type, CourseInfoTab.type, 'textbooks', 'pdf_textbooks', 'html_textbooks', ]
component.display_name = 'Changed' self.store.update_item(component, edit_user) updated_component = self.store.get_item(component.location)
buttons = world.css_find('div.new-component-{} button'.format(category))
for param in self.params: value = param.get_value(borrow=True) if not isfinite(value): raise RuntimeError("NaN in " + param.name)
self.different_client.login(username=self.different_user.username, password=self.test_password) self.send_get(self.different_client, expected_status=404)
uploaded_file = request.FILES['file']
clf.sparsify() assert_true(sp.issparse(clf.coef_)) pred = clf.predict(X) assert_array_equal(pred, Y)
num_certs = GeneratedCertificate.eligible_certificates.filter(user=self.student).count() self.assertEqual(num_certs, 1)
self.inputs = {}
delete_index, = np.where(unlabeled_indices == image_index) delete_indices = np.concatenate((delete_indices, delete_index))
get_user_credentials(self.user)
d_int32 = astype(a_int32, dtype=np.int32, copy=True) assert_false(np.may_share_memory(d_int32, a_int32))
try: store = self._verify_modulestore_support(usage_key.course_key, 'get_block_original_usage') return store.get_block_original_usage(usage_key) except NotImplementedError: return None, None
if self.youtube_id_1_0: encoded_videos["youtube"] = { "url": self.create_youtube_url(self.youtube_id_1_0),
continue
self.assertContains(response, 'course-container', 2) self._assert_responses(response, 1)
def dispatcher(self, obj): reduced = reduce_func(obj) self.save_reduce(obj=obj, *reduced) self.dispatch[type] = dispatcher
metadata_to_inherit = {}
results.append(['', label, problem_name, count_grade, student_count_percent, percent])
_, _, relative_path, params, query_string, fragment = urlparse(path)
for label_index, weight in enumerate(n_samples_per_label): lightest_fold = np.argmin(n_samples_per_fold) n_samples_per_fold[lightest_fold] += weight label_to_fold[indices[label_index]] = lightest_fold
course_publish_orphans = self.store.get_orphans(course_locator_publish)
template = lookup_template(namespace, template_name) return template.render_unicode(**context_dictionary)
unpack_tarball(src,dst) run_scripts(dst+package.name, scripts=["getscript","postinst"] )
entry_needs_updating = True entry_needs_saving = False task_output = None
X, y = make_classification(n_samples=200, n_features=20, n_informative=3, n_redundant=2, n_repeated=0, n_classes=8, n_clusters_per_class=1, flip_y=0.0, class_sep=10, shuffle=False, random_state=0)
def test_unicode_values(self): country = Country.objects.create(country='NZ') self.assertEquals(unicode(country), "New Zealand (NZ)")
super(TestLibraryAccess, self).setUp() self.non_staff_user, self.non_staff_user_password = self.create_non_staff_user()
if not formatted: indent = "" nextLevelIndent = "" nl = ""
pass
user_requested_access(request.user) return JsonResponse({"Status": "OK"})
problem = new_loncapa_problem(xml_str) problem.done = True
grid_search_no_score.fit(X, y)
if block_type in self.disabled_xblock_types: return self.default_class return super(DescriptorSystem, self).load_block_type(block_type)
assert_almost_equal(clf.coef_, clf_weighted.coef_, decimal=2) assert_almost_equal(clf.coef_, clf_balanced.coef_, decimal=2)
return reverse( self.namespaced_url, kwargs={ 'course_id': self.course.id, 'username': username } )
def setUp(self): super(DatabaseMicrositeTestCase, self).setUp() self.microsite = MicrositeFactory.create() MicrositeOrganizationMappingFactory.create(microsite=self.microsite, organization='TestMicrositeX')
X, y = make_regression(n_samples=200, n_features=20, n_informative=5, shuffle=False, random_state=0)
I18N_REPORT_DIR = REPORT_DIR / 'i18n'
self.assertTrue(self.video.is_button_shown('transcript_button')) self._verify_caption_text('Welcome to edX.')
factory_dict = PROBLEM_DICT['multiple choice'] problem_xml = factory_dict['factory'].build_xml(**factory_dict['kwargs'])
courses_list_by_groups, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(len(courses_list_by_groups), 1)
return {'ok': False, 'msg': msg}
redirect_url = reverse('dashboard') + '?course_closed=1%2F1%2F15%2C+12%3A00+AM' self.assertRedirects(response, redirect_url)
X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.25, random_state=42)
self._find_within(".load-response-button").click() EmptyPromise( self.is_ajax_finished, "Loading more Responses" ).fulfill()
_listen_for_course_publish('store', self.course.id) self.assertEqual(VerificationDeadline.deadline_for_course(self.course.id), self.course.end)
try:
([]),
jll = self._joint_log_likelihood(X) return self.classes_[np.argmax(jll, axis=1)]
self.certificates_section.remove_first_certificate_invalidation()
self.now = datetime.datetime.now()
self.assertEqual(self.field.to_representation(value), value)
changed_modules = StudentModule.objects.filter(module_state_key__in=self.ee_modules) for changed_module in changed_modules: self.assertEqual( json.loads(changed_module.state)['attempts'], 0 )
sample_weight = self._validate_sample_weight(sample_weight, n_samples)
X = iris.data[45:, :] y = iris.target[45:] solvers = ("lbfgs", "newton-cg") class_weight_dict = _compute_class_weight_dictionary(y)
windows = world.browser.windows assert_equal(len(windows), 2)
mock_get_request_user.return_value = AnonymousUser() mock_refund_seat.reset_mock() self.send_signal() self.assertFalse(mock_refund_seat.called)
return None
return self.enabled and self.enable_student_dashboard
mcd = MinCovDet().fit(X) err_loc_mcd[i, j] = np.sum(mcd.location_ ** 2) err_cov_mcd[i, j] = mcd.error_norm(np.eye(n_features))
super(LmsSearchResultProcessorTestCase, self).setUp() self.build_course()
trainer = yaml_parse.load(test_yaml_layer3 % {'layer0_filename': layer0_filename, 'layer1_filename': layer1_filename, 'layer2_filename': layer2_filename}) trainer.main_loop()
assert_false(hasattr(BaggingClassifier(base).fit(X, y), 'decision_function'))
#'wiki.plugins.notifications', 'course_wiki.plugins.markdownedx',
self.request.user = self.anonymous_user self.assertFalse(user_has_passed_entrance_exam(self.request, self.course))
changing_email = False if "email" in update: changing_email = True new_email = update["email"] del update["email"]
y_in_classes = in1d(y, classes) y_seen = y[y_in_classes] indices = np.searchsorted(sorted_class, y_seen) indptr = np.hstack((0, np.cumsum(y_in_classes)))
return coin_flip()
return len(self._line_start_indexes)
tag = self.runtime.service(self.mock_block, 'user_tags').get_tag(self.scope, self.key) self.assertIsNone(tag)
raise exc
return self.get_text('.certificate-description')
import numpy as np
for einput in self.BAD_DISPATCH_INPUTS: with self.assertRaisesRegexp(LTIError, "No valid user id found in endpoint URL"): self.xmodule.parse_lti_2_0_handler_suffix(einput)
class CourseModeFactory(DjangoModelFactory): class Meta(object): model = CourseMode
return self.q(css='{} .entrance-exam-task-history-table'.format(self.EE_CONTAINER)).is_present()
self.oauth_page.confirm() self.oauth_page.wait_for_element_absence( 'input[name=authorize]', 'Authorization button is not present' )
history = HistoricalRecords()
from __future__ import unicode_literals
last_indent = start if verbose >= 3: print("... " + line.rstrip())
preprocessor = GlobalContrastNormalization(subtract_mean=True, sqrt_bias=0.0, use_std=True)
return tuple(Commit.iter_items( repo, "{start}..{end}".format(start=start_ref, end=end_ref), first_parent=True, no_merges=True, ))
if values and "" in values: raise ValidationError("This field cannot be empty.")
resp = self.client.ajax_post('/course/', self.course_data) self.assertEqual(resp.status_code, 403)
self.settings_detail.refresh_page() self.settings_detail.wait_for_prerequisite_course_options() self.assertTrue(is_option_value_selected( browser_query=self.settings_detail.pre_requisite_course_options, value=pre_requisite_course_id ))
param += self.mlp.theano_rng.normal(size=param.shape, avg=0., std=self._std_dev, dtype=param.dtype) return param
section_titles = [t for t in section_titles if t]
iso = manifold.Isomap(n_components, 2) X_iso = iso.fit_transform(X)
request_uuid = self._create_credit_request_and_get_uuid() response = self._credit_provider_callback(request_uuid, 'approved', timestamp=timestamp) self.assertEqual(response.status_code, 400)
self.bulk.update_definition(self.course_key, self.definition) self.assertConnCalls(call.insert_definition(self.definition, self.course_key))
rval = X.copy() for i in xrange(rval.shape[0]): rval[i, :] /= np.abs(rval[i, :]).max() + 1e-12 return rval
sparse_results = sparse_classifier.staged_decision_function( X_test_sparse) dense_results = dense_classifier.staged_decision_function(X_test) for sprase_res, dense_res in zip(sparse_results, dense_results): assert_array_equal(sprase_res, dense_res)
return graders[self.credit_type[0]]( all_choices=all_choices, student_answer=student_answer, student_non_answers=student_non_answers )
if paginated_results.page != page: raise PageNotFoundError("Page not found (No results on this page).")
fig = plt.figure(fignum, figsize=(4, 3)) plt.clf() ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)
if request.method != 'POST': return HttpResponseNotAllowed('POST') request.backend.start() return complete(request, backend, *args, **kwargs)
H = self.mf(V)[0] downward_state = self.hidden_layers[0].downward_state(H) recons = self.visible_layer.inpaint_update( layer_above=self.hidden_layers[0], state_above=downward_state, drop_mask=None, V=None) return recons
pass
additional_requested_fields = [ 'student_view_data', 'block_counts', 'nav_depth', 'block_types_filter', ] for additional_field in additional_requested_fields: field_value = cleaned_data.get(additional_field)
FIRST_TIME_VERIFY_MSG = 'first-time-verify' VERIFY_NOW_MSG = 'verify-now' VERIFY_LATER_MSG = 'verify-later' UPGRADE_MSG = 'upgrade' PAYMENT_CONFIRMATION_MSG = 'payment-confirmation'
if "default" in kwargs: kwargs["defaultValue"] = kwargs["default"]
def __init__(self): super(MongoBulkOpsRecord, self).__init__() self.dirty = False
allowable_chars = string.ascii_letters + string.digits username = '' for _index in range(30): username = username + random.SystemRandom().choice(allowable_chars) return username
self._X_ = X = unique_X self._y_ = y = isotonic_regression(unique_y, unique_sample_weight, self.y_min, self.y_max, increasing=self.increasing_)
if rbm == rbm_list[-1]: if targets: assert len(rbm.hidden_layers) == 2 else: assert len(rbm.hidden_layers) == 1 else: assert len(rbm.hidden_layers) == 1
'ENFORCE_PASSWORD_POLICY': False,
raise NotImplementedError
n_neighbors += 1
def fit(self, X, y): self.y = y return self def predict(self, X): return self.y
self.q(css='.new-course-button').first.click() self.wait_for_ajax()
self._assert_num_requests(2)
check_lti_iframe_content("Wrong LTI signature")
self.assertIn('/courses/' + self.course_key.to_deprecated_string() + '/jump_to_id/vertical_test', html)
mock_progress.return_value = True module = CapaFactory.create() module.weight = 0 progress = module.get_progress() self.assertIsNone(progress) self.assertFalse(mock_progress.called)
course_key = self.course_key.to_deprecated_string() self._add_course_mode(mode_slug='verified') self.add_reg_code(course_key, mode_slug='verified')
filtered_answers = {} for answer_key in answers.keys(): if answer_key in allowed_field_names: filtered_answers[answer_key] = escape(answers[answer_key])
exact_dists, exact_idx = nnbrs.radius_neighbors(query, radius=1) approx_dists, approx_idx = lsfh.radius_neighbors(query, radius=1)
with patch.object(mail.message.EmailMessage, 'send') as mock_send: mock_send.side_effect = Exception("Kaboom!") cart.purchase()
super(UniqueCourseTest, self).__init__(*args, **kwargs)
inherited_settings_map.setdefault(block_key, {}).update(inheriting_settings)
enrollments = self._create_enrollments(solo_course_id, shared_course_id) meter = utils.ProgramProgressMeter(self.user, enrollments)
angle = np.arctan(u[1] / u[0])
elif self._is_correct_lti_request(): params = {k: v for k, v in self.post_dict.items() if k != 'oauth_signature'}
click_css( self, self._bounded_selector(self.ADD_BUTTON_SELECTOR), require_notification=require_notification, )
random = np.random.RandomState(seed=0) E = random.normal(size=(len(X), 2200))
httpretty.register_uri( httpretty.POST, '{}/baskets/1/'.format(TEST_API_URL), status=200, body='{}', adding_headers={'Content-Type': JSON} )
expire_dt = now + datetime.timedelta(seconds=cache_ttl) return expire_dt.strftime(HTTP_DATE_FORMAT)
diabetes = datasets.load_diabetes()
self.find_css('a.detail-toggle').first.click()
type = 'courseware' title = ugettext_noop('Course') priority = 10 view_name = 'courseware' is_movable = False is_default = False
'submission': submission,
if not include_meta_estimators: estimators = [c for c in estimators if not c[0] in META_ESTIMATORS] if type_filter is not None: if not isinstance(type_filter, list): type_filter = [type_filter] else:
parsed = urlparse.urlparse(constructed) params = urlparse.parse_qs(parsed.query)
names = sorted(str_repl, key=len, reverse=True)
self.assertEqual(response.status_code, 406) msg = Messages.NO_DEFAULT_ENROLLMENT_MODE.format(course_id=self.course.id) self.assertResponseMessage(response, msg)
assert_almost_equal((RBF(2.0) + 1.0)(X), (1.0 + RBF(2.0))(X))
self.cmap.set_overall_message("Test message")
self.verify_server_task("lms", options)
self.q(css='a[data-section=student_admin]').first.click() student_admin_section = StudentAdminPage(self.browser) student_admin_section.wait_for_page() return student_admin_section
xml.tail = self.tail return xml
pass
course = self._create_course("verified") self._enroll(course.id, "verified") response = self._get_page('verify_student_verify_now', course.id)
with modulestore().default_store(ModuleStoreEnum.Type.split): self.course = CourseFactory.create()
assert_almost_equal(s, 2.0/3.0)
assert_array_almost_equal(lr1.coef_, lr2.coef_) msg = "Arrays are not almost equal to 6 decimals" assert_raise_message(AssertionError, msg, assert_array_almost_equal, lr1.coef_, lr3.coef_)
mock_course_module = MagicMock() mock_course_module.position = 3 mock_course_module.get_display_items.return_value = [] self.assertIsNone(helpers.get_course_position(mock_course_module))
copy_Gram = True
self.assertIn('level-element', html)
self.assert_enrollment_status(as_server=True)
content = None try: content = self.load_asset_from_location(loc) except (ItemNotFoundError, NotFoundError): return HttpResponseNotFound()
scipy_works = False
scorer = make_scorer(fbeta_score, beta=2) score1 = scorer(clf, X_test, y_test) score2 = fbeta_score(y_test, clf.predict(X_test), beta=2) assert_almost_equal(score1, score2)
return SurveyAnswer.do_survey_answers_exist(self, user)
self.mock_programs_api() self.mock_credentials_api(self.user, reset_url=False)
return status in cls.PASSED_STATUSES
self.cert = GeneratedCertificate.eligible_certificates.create( user=self.student, course_id=self.CERT_COURSE_KEY, grade=self.CERT_GRADE, status=self.CERT_STATUS, mode=self.CERT_MODE, download_url=self.CERT_DOWNLOAD_URL, )
request = Mock() request.user = self.instructor return request
for attr, val in attr_dict.iteritems(): if attr in self.ATTRS_ALLOWED_TO_UPDATE: setattr(self, attr, val) else: self.fields[attr] = val
if physical_line.rstrip() == physical_line: return len(physical_line), "W292 no newline at end of file"
self._assert_courses_not_in_overview(self.course_key_1, self.course_key_2) self.command.handle(all=True)
clustering = AgglomerativeClustering( n_clusters=10, connectivity=connectivity.toarray(), affinity="manhattan", linkage="ward") assert_raises(ValueError, clustering.fit, X)
template_name = microsite.get_template_path(template_name)
return bool(getattr(content, "locked", False))
return SurveyForm.create(self.test_survey_name, self.test_form)
self.send_response(200, 'This is LTI Provider.', {'Content-type': 'text/plain'})
assert_equal(len(folds), len(labels)) for i in np.unique(folds): assert_greater_equal(tolerance, abs(sum(folds == i) - ideal_n_labels_per_fold))
scores = cross_val_score(EstimatorWithFit(), [[1], [2], [3]], [1, 0, 1], scoring=DummyScorer()) assert_array_equal(scores, 1)
FEATURES['ENABLE_CONTENT_LIBRARIES'] = True
estimator = MockImprovingEstimator(1) assert_raises(ValueError, learning_curve, estimator, X, y, exploit_incremental_learning=True)
return self.q(css="#clear-all-filters")
if correct: self.problem_page.click_choice("choice_choice_2") else: self.problem_page.click_choice("choice_choice_1")
iris = datasets.load_iris() y_true, y_pred, _ = make_prediction(dataset=iris, binary=False)
self.check_headers(self.handler._get_headers())
scores = cross_val_score(clf, X_sparse, multioutput_y) assert_array_equal(scores, clf.score(X_sparse, multioutput_y))
self.assertEquals( len(self.store.get_items(course_key.for_branch(None), settings={'display_name': display_name})), expected_number )
CourseExportManager(modulestore, contentstore, course_key, root_dir, course_dir).export()
with open(self.TEST_INDEX_FILENAME, "w+") as index_file: json.dump({}, index_file)
instructor_task = self._create_email_subtask_entry( total=total, attempted=attempted, succeeded=succeeded, skipped=skipped, task_state=SUCCESS, ) return self._test_get_status_from_result(instructor_task.task_id)
gc = AgglomerativeClustering(n_clusters=10) brc2 = Birch(n_clusters=gc) brc2.fit(X) assert_array_equal(brc1.subcluster_labels_, brc2.subcluster_labels_) assert_array_equal(brc1.labels_, brc2.labels_)
try: return CourseTeamMembership.objects.get(user__username=username, team=team) except CourseTeamMembership.DoesNotExist: raise Http404
self.n_unique_specs = 0
visited = set()
students_to_generate_certs_for = students_to_generate_certs_for.filter( certificatewhitelist__course_id=course_id, certificatewhitelist__whitelist=True )
assert correctness in ['correct', 'incorrect', 'unanswered'] assert problem_type in PROBLEM_DICT
if hasattr(instance, '_changed_fields'): del instance._changed_fields
self.assertNotEqual(display_name_before_import, display_name_after_import)
self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course.id))
self._validate_estimator()
self._update_head(usage_locator.course_key, index_entry, usage_locator.branch, new_id) result = usage_locator.course_key.for_version(new_id)
self._configure_course()
self.assertFalse(CourseEnrollment.is_enrolled(self.user, self.course_key))
module = CapaFactory.create(rerandomize=RANDOMIZATION.NEVER, done=True) self.assertTrue(module.should_show_check_button())
return hash(id(self))
form = PasswordResetFormNoActive({'email': email})
self.check_event_response_by_key('endorse_resource', resource, test_case['key'], test_case['val'])
super(DjangoBackend, self).__init__(**options) self.name = name
world.wait(1) continue
cls.html_unit = ItemFactory.create( parent_location=cls.vertical.location, category="html", display_name="Html Content", publish_item=False, )
world.disable_jquery_animations() world.css_click(component_button_css)
self.bad_user_client = Client() self.good_user_client = Client() self.non_staff_client = Client() self.admin_client = Client()
self.factory(penalty='foobar', l1_ratio=0.85)
checkpoint.add_verification_attempt(self.attempt)
visbias_a = visbias
static_tab_loc = course_key.make_usage_key('static_tab', tab.url_slug) tab.locator = static_tab_loc
self.assertEqual(orphan_sequential.location.block_type, root.location.block_type) self.assertEqual(orphan_sequential.location.block_id, root.location.block_id)
container.delete(0) self.verify_groups(container, ['alpha'], [], verify_missing_groups_not_present=False)
providers = OAuth2ProviderConfig.objects.all() pcount = len(providers)
self.assertIn( err_msg, resp.content )
if video_list: sub_attr = source_subs_name try: generate_subs_from_source({1: sub_attr}, source_subs_ext, source_subs_filedata, item)
overview = CourseOverview.get_from_id(course.id)
closest_subcluster.update(subcluster) self.init_centroids_[closest_index] = \ self.subclusters_[closest_index].centroid_ self.init_sq_norm_[closest_index] = \ self.subclusters_[closest_index].sq_norm_ return False
authenticate_lti_user(request, params['user_id'], lti_consumer)
if settings.ROOT_URLCONF != 'lms.urls': raise unittest.SkipTest('Test only valid in lms')
reg_units = theano.tensor.abs_(model.encode(X)).sum(axis=1).mean()
assert_raises(ValueError, clf.predict, X2[:, :-1])
results.append({ 'identifier': identifier, 'invalidIdentifier': True, })
title = None
username = serializers.CharField() email = serializers.CharField()
'MAX_ENROLLMENT_INSTR_BUTTONS': 200,
return NotAny( self )
kwargs_for_reverse = {key_name: unicode(key_value)} if key_name else None if kwargs: kwargs_for_reverse.update(kwargs) return reverse('contentstore.views.' + handler_name, kwargs=kwargs_for_reverse)
self.store.publish(locations['parent_sibling'], self.user_id) self.store.publish(locations['parent'], self.user_id)
super(CustomSVC, self).fit(X, y, sample_weight=sample_weight) self.data_type_ = type(X) return self
user = UserFactory.create(username="rusty", password="test") self.client.login(username="rusty", password="test")
from __future__ import unicode_literals
return self._validation_paragraph('not-configured').text[0]
return 'SubtaskStatus<%r>' % (self.to_dict(),)
self.assertEqual(_mock_pep8_violations.call_count, 1) self.assertEqual(self._mock_paver_sh.call_count, 2)
self.advanced_settings_page.visit() self.advanced_settings_page.set_values(self.course_advanced_settings) self.advanced_settings_page.wait_for_ajax()
'ENABLE_OAUTH2_PROVIDER': False,
def identity_estimator(): pass identity_estimator.decision_function = lambda y_predict: y_predict identity_estimator.predict = lambda y_predict: y_predict
assert X.ndim == 2 return T.nnet.softmax(X*self.P)
self['event_type'] = self.legacy_event_type
if not course.course_survey_name: return redirect(redirect_url)
with self.assertRaises(SearchIndexingError): reindex_course_and_check_access(self.course.id, self.user)
Y = np.concatenate(((1 - Y), Y), axis=1)
config_course_cohorts(self.course, is_cohorted=True)
export_name = escape_invalid_characters(name=filename, invalid_char_list=['/', '\\'])
LogoutPage(self.browser).visit() self._auto_auth(self.USERNAME, self.EMAIL, False)
return 1 / numpy.sinh(arg)
selection = SelectKBest(k=1)
if not should_grade_section: should_grade_section = any( descriptor.location.to_deprecated_string() in submissions_scores for descriptor in section['xmoduledescriptors'] )
return _create_item(request)
FEATURES['ENABLE_COURSEWARE_SEARCH'] = True
indptr_3 = X_sparse_unpruned.indptr[3] indptr_4 = X_sparse_unpruned.indptr[4] X_sparse_unpruned.data[indptr_3:indptr_4] = 0.0
if self.expires_at and timezone.now() > self.expires_at: return False return bool(self.entity_id and self.sso_url and self.public_key)
locator = BlockUsageLocator(course_locator, block_type='chapter', block_id='chapter1') self.assertTrue( modulestore().has_item(locator), "couldn't find chapter1" )
overall_msg = correctmap.get_overall_message() self.assertEqual(overall_msg, "Overall message")
if max_depth is None or depth <= max_depth:
using_firefox = (os.environ.get('SELENIUM_BROWSER', 'firefox') == 'firefox') validate_firefox = getattr(options, 'validate_firefox_version', using_firefox)
self.assertEqual(len(all_gradesets), 5)
dir_suffix = "-py3"
verification_checkpoint = VerificationCheckpoint.objects.create( course_id=self.course.id, checkpoint_location=checkpoint_location ) self.assertEqual( VerificationCheckpoint.get_or_create_verification_checkpoint(self.course.id, checkpoint_location), verification_checkpoint )
'options': self.xml.get('options'), 'testdat': 'hello world',
train_data, test_data, target_train, target_test = train_test_split( data, target, test_size=.1, random_state=0)
assert_raises_regexp(TypeError, 'estimator', check_consistent_length, [1, 2], RandomForestRegressor())
params_wrong_type_amt = params.copy() params_wrong_type_amt['ccAuthReply_amount'] = 'ab' with self.assertRaises(CCProcessorDataException): payment_accepted(params_wrong_type_amt)
raise ValueError("Unknown activation function %s" % self.activation)
core_samples, labels = dbscan(X, algorithm=algorithm, eps=1, min_samples=4) assert_array_equal(core_samples, []) assert_array_equal(labels, -np.ones(n_samples))
X, y = make_regression(n_samples=200, n_features=20, n_informative=5, shuffle=False, random_state=0)
container.add_missing_groups() self.verify_groups(container, ['Group B', 'Second Group', 'Group D'], ['Group ID 0'])
task_type = 'may_enroll_info_csv' task_class = calculate_may_enroll_csv task_input = {'features': features} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
try: info_module.get_html() except ValueError: self.fail("CourseInfoModule could not parse an invalid date!")
CourseEnrollment.enroll(user, course_id) self.assertTrue(CourseEnrollment.is_enrolled(user, course_id)) self.assertTrue(CourseEnrollment.is_enrolled_by_partial(user, course_id_partial)) self.assert_no_events_were_emitted()
VerificationDeadline.set_deadline(self.id, self.verification_deadline, is_explicit=True)
sparse_classifier = AdaBoostRegressor( base_estimator=CustomSVR(), random_state=1 ).fit(X_train_sparse, y_train)
latex_font_size = '11pt'
with self.assertRaisesRegexp(Exception, 'Unknown parenthesis'): preview.LatexRendered('x^2', parens='not parens')
self.check_event_response_by_http_status( 'edit_resource', self.generate_edit_resource(self.non_existing_resource_id), 400 )
return section_titles.index(title.lower()) + 1
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit()
errors = modulestore.get_course_errors(SlashSeparatedCourseKey("edX", "toy", "2012_Fall")) assert errors == []
grid_search = GridSearchCV(pipeline, parameters, n_jobs=1)
provider = PaidCourseEnrollmentReportProvider() self.assertIsNotNone(provider) self.assertTrue(isinstance(provider, PaidCourseEnrollmentReportProvider))
self.cohort_a_student_username = "cohort_a_student" self.cohort_a_student_email = "cohort_a_student@example.com" StudioAutoAuthPage( self.browser, username=self.cohort_a_student_username, email=self.cohort_a_student_email, no_login=True ).visit()
params = self._signed_callback_params("98272", self.COST, self.COST) result = process_postpay_callback(params)
'rule': Rules.python_interpolate_html
if self.cohort_config is None: return [] else: return self.cohort_config.get("auto_cohort_groups", [])
DEFAULT_GROUPS = []
import lettuce.django
self.lib_page.click_delete_button(first_block_id, confirm=True) self.assertEqual(len(self.lib_page.xblocks), 1) self.assertEqual(self.lib_page.xblocks[0].locator, second_block_id)
pass
pass
with cls.store.bulk_operations(course.id, emit_signals=False):
self.assertEquals(source_course.wiki_slug, source_wiki_slug)
if is_library: role_hierarchy = (CourseInstructorRole, CourseStaffRole, LibraryUserRole) else: role_hierarchy = (CourseInstructorRole, CourseStaffRole)
y_true[np.where(y_true == 0)] = -1 y_true_copy = y_true.copy() _test_precision_recall_curve(y_true, probas_pred) assert_array_equal(y_true_copy, y_true)
self.staff_user = User.objects.create_user( "patty", "patty@fake.edx.org", ) self.staff_user.is_staff = True
rng = check_random_state(2) X = 0.3 * rng.randn(120, 2) X_train = np.r_[X + 2, X - 2] X_train = X[:100]
if '_dtype' not in state_dict: self._dtype = theano.config.floatX
node = etree.Element('unknown') descriptor.add_xml_to_node(node)
avg_score = [] for train, test in cv: estimator.fit(X[train], y[train]) avg_score.append(scorer(estimator, X[test], y[test])) return np.mean(avg_score)
with assert_raises(ValueError): course = self.process_xml(CourseFactory.build(policy={'days_early_for_beta': 'null'}))
if not user_partitions: return
assert_raises(ValueError, sel.inverse_transform, np.array([[1], [2]]))
cls.objects.create(checkpoint=checkpoint, user_id=user_id, course_id=course_id)
self.update_state( course_key=course_key, new_state=self.State.SUCCEEDED, )
if inv: X_pred2 = kpca.inverse_transform(X_pred_transformed) assert_equal(X_pred2.shape, X_pred.shape)
return (NullSpace(), '')
return self.get_text('.message-status.error')
asset_md = store.get_all_asset_metadata(course.id, 'asset') self.assertEquals(asset_md, [])
assert_true(X_scaled is not X) assert_true(X_csr_scaled is not X_csr)
with check_mongo_calls(0): cached_structure = self._get_structure(self.new_course)
subdict_str = _select_block(dict_str[pos:], '{', '}') value = _parse_dict_recursive(subdict_str) pos_tmp = pos + len(subdict_str)
continue
grid_search_no_score = GridSearchCV(clf_no_score, {'C': Cs}) assert_raise_message(TypeError, "no scoring", grid_search_no_score.fit, [[1]])
self.assertEquals(preview.latex_preview('log2(3)'), r'\log_2(3)')
u'{"@type": "Result", "resultScore": 0.1}',
try: course_key = CourseKey.from_string(args[0]) except InvalidKeyError: try: course_key = SlashSeparatedCourseKey.from_deprecated_string(args[0]) except InvalidKeyError: raise CommandError(unicode(GitExportError.BAD_COURSE))
width, height = image_obj.size self.assertEqual(width, height) actual_sizes[width] = name
self._assertOLXBase(block_list, draft=False, published=True)
url_pattern = '/u/test#about_me' response = self._auto_auth({ 'username': 'test', 'redirect_to': url_pattern, 'staff': 'true', }, status_code=302)
self._studio_add_content(1)
return super(SoftDeleteCouponManager, self).get_queryset()
assert_raises(ValueError, plot_partial_dependence, {}, X, [0])
self.assertTrue(are_permissions_roles_seeded(second_course_id))
SECRET_KEY = '85920908f28904ed733fe576320db18cabd7b6cd'
if self.read_committed is True: if connection.vendor == 'mysql': cursor = connection.cursor() cursor.execute("SET TRANSACTION ISOLATION LEVEL READ COMMITTED")
sample_interval = 0.3 transform = AdditiveChi2Sampler(sample_steps=4, sample_interval=sample_interval) assert_equal(transform.sample_interval, sample_interval) transform.fit(X) assert_equal(transform.sample_interval_, sample_interval)
MAX_MESSAGE_LENGTH = 1000
_unique_labels = _FN_UNIQUE_LABELS.get(label_type, None) if not _unique_labels: raise ValueError("Unknown label type: %s" % repr(ys))
return ACCESS_GRANTED
url = reverse('create_mode', args=[unicode(self.course.id)]) self.client.get(url, parameters)
course_one_team = CourseTeamFactory.create(name="Course one team", course_id=self.course.id, topic_id=1)
break
create_collection_index(self.collection, '_id.category', background=True)
with remove_ccx(course_key) as (course_key, restore): return restore(self._modulestore.get_items(course_key, **kwargs))
self.courseware_page.visit() self.assertEqual(self.problem_page.problem_name, 'Test Problem 2')
self.update_masquerade(role='student') self.verify_staff_debug_present(False)
mlb = MultiLabelBinarizer() assert_array_equal(mlb.fit_transform(inp), indicator_mat) assert_array_equal(mlb.classes_, classes) assert_array_equal(mlb.inverse_transform(indicator_mat), inp)
last_el = self.table_of_contents[-1] while last_el.getchildren(): last_el = last_el[-1]
valid_input['course_modules'] = None
for key in locations: self.assertFalse(self._has_changes(locations[key]))
mode = 1 M_matvec = None Minv_matvec = None if Minv is not None: raise ValueError("Minv should not be " "specified with M = None.")
has_correct_url = self.url.endswith(self.url_path) teams_list_view_present = self.q(css='.teams-main').present return has_correct_url and teams_list_view_present
plaintext_msg = course_email_template.render_plaintext(course_email.text_message, email_context) html_msg = course_email_template.render_htmltext(course_email.html_message, email_context)
source_suffix = '.txt'
module = CapaFactory.create(max_attempts="1", attempts="0") self.assertFalse(module.closed())
return self._check_login_or_register_page(self.login_page_url, "loginUrl")
assert_equal(y[train].size + y[test].size, y.size)
print("Feature ranking:")
course = self._create_course("verified") self._set_contribution("12.34", course.id)
self.assertEqual(cert.status, ExampleCertificate.STATUS_STARTED)
super(CrowdsourcehinterProblemPage, self).__init__(browser)
mock_email_change.side_effect = [ValueError, "mock value error thrown"] self.client.login(username=self.user.username, password=self.test_password) old_email = self.user.email
if self.poll_answers is None: self.poll_answers = {}
photo_id_image = ( decode_image_data(photo_id_data) if photo_id_data is not None else None )
return self.q(css=".wrapper-register-choose").is_present()
self._enabled = False
self.client.login(username=self.non_staff_user.username, password='test') response = self.call_add_users_to_cohorts('') self.assertEqual(response.status_code, 403)
X_3d = X[:, :, np.newaxis] clf = MockClassifier(allow_nd=True) scores = cval.cross_val_score(clf, X_3d, y)
urlpath.delete()
all_y_hat = Parallel(n_jobs=n_jobs, verbose=self.verbose, backend="threading")( delayed(parallel_helper)(e, 'predict', X, check_input=False) for e in self.estimators_)
self.context['options'] = [(id_num, '<b>Option {0}</b>'.format(id_num)) for id_num in range(5)] self.context['value'] = 2
rfe = RFE(estimator=self.estimator, n_features_to_select=n_features_to_select, step=self.step)
rewritten_url = cdn_base_url.rstrip("/") + "/" + parsed.path.lstrip("/") validator = URLValidator()
matched = match.group(0) if matched == ';;': return ';' elif matched == ';_': return '/' else: return matched
return False
UserFactory.create(username=self.USERNAME, email=self.EMAIL, password=self.PASSWORD)
self.animal_partition.groups.pop() self.color_partition.groups.pop()
course = def_ms.get_course(SlashSeparatedCourseKey('MITx', 'edx4edx', 'edx4edx'))
super(ViewsExceptionTestCase, self).setUp()
self.assert_enrollment_status()
today = date.today() TUESDAY = 2 days_until_tuesday = (TUESDAY - today.isoweekday()) % 7 return today + timedelta(days=days_until_tuesday)
from __future__ import unicode_literals
self.assertIn('request_uuid', parameters) self.assertEqual(len(parameters['request_uuid']), 32)
'template',
verbose_name=_("Changed by"),
usage_key = UsageKey.from_string('i4x://edX/apis/html/interactive') usage_key.replace(course_key=self.course.id) self.assertEqual(Bookmark.get_path(usage_key), [])
processor_reply_dump = models.TextField(blank=True)
COURSE_ABOUT_VISIBILITY_PERMISSION = 'see_exists'
if label_type == 'azimuth': data_y = np.cast[config.floatX](data_y / 360.)
enrollment_exists = CourseEnrollment.objects.filter( user=self.user, course_id=self.course.id ).exists() self.assertFalse(enrollment_exists)
for y_pred in clf.staged_predict(X_test): assert_equal(y_test.shape, y_pred.shape)
if hasattr(self.beta_tester, '_roles'): del self.beta_tester._roles self.assertFalse(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))
raise ItemNotFoundError(usage_key)
raise NotImplementedError
_ = lambda text: text
currently_fixing = []
img = imread(file_path) if img.ndim is 0: raise RuntimeError("Failed to read the image file %s, " "Please make sure that libjpeg is installed" % file_path)
mock_threads.return_value = [], 1, 1
link = self._get_link(cobj) self._link_cache[full_name] = link
self.page.visit() config = self.page.experiment_group_configurations[0]
return self.q(css='.leave-team-link').present
LogoutPage(self.browser).visit()
X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.5, random_state=0)
with self.assert_signature_error_logged('Signature .* does not match'): yield
self.set_select_value(self.PROBLEM_TYPE_LABEL, value) EmptyPromise(lambda: self.capa_type == value, "problem type is updated in modal.").fulfill()
if Microsite.objects.all()[:1].exists(): return True else: return False
model = InvoiceTransaction extra = 0 readonly_fields = ( 'created', 'modified', 'created_by', 'last_modified_by' )
raise NotImplementedError()
for i, parents_index in enumerate(self.parents_map): if i == 0:
return self.q(css="div.problem section.inputtype div.incorrect span.status").is_present()
current_proba = _samme_proba(estimator, n_classes, X)
centers[center_idx] *= counts[center_idx]
trainer = yaml_parse.load(test_yaml_layer2 % {'layer0_filename': layer0_filename, 'layer1_filename': layer1_filename, 'layer2_filename': layer2_filename}) trainer.main_loop()
('paying', 'paying'),
self._set_opt_in_pref(self.user, "other_org", False)
service_variant = ''
AccessTestData(partition_groups={1: 1, 2: 2}, merged_parents_list=[{1: {3}}, {1: {1}}], expected_access=True),
if os.path.exists(filename): os.remove(filename)
response = self.api_response() self.assertNotIn('\'/static/', response.data['handouts_html'])
self.assertFalse(BulkEmailFlag.feature_enabled(course_id))
self.q(css=self.NOTE_SELECTOR).first.click() return self
return "Maxout"
classes = np.unique(y) classes = (classes[classes != -1]) self.classes_ = classes
LMS_BASE_URL = os.environ.get('lms_url', 'http://localhost:8003')
unicode_user = UserFactory(first_name=u'Ⓡⓞⓑⓞⓣ', last_name=u'ՇﻉรՇ') CourseEnrollmentFactory.create(user=unicode_user, course_id=self.course.id) self.students.append(unicode_user)
session = self.client.session session["donation_for_course"] = { unicode(course_id): amount } session.save()
return key.field_name in self._fields
return False
self.assertTrue(did_load_item)
assert_raises(VerificationException, attempt.submit)
context.update(extra_context)
X_var *= X.shape[0] X_scale = np.sqrt(X_var, X_var) del X_var X_scale[X_scale == 0] = 1 inplace_column_scale(X, 1. / X_scale)
raise NotImplementedError("Specific Modulestores must provide implementations of create_usage")
return self.rescore_submission_button.click()
with self.assertRaises(SearchIndexingError): CoursewareSearchIndexer.do_course_reindex(modulestore(), self.course.id)
return { 'course_key': unicode(credit_course.course_key), 'enabled': credit_course.enabled }
from __future__ import unicode_literals
create_collection_index(self.collection, 'definition.children', sparse=True, background=True)
self.user.passwordhistory_set.add(PasswordHistory(password='new_password')) self.user.save() self.assert_no_events_were_emitted()
self.dispatch = Pickler.dispatch.copy()
#html_use_smartypants = True
password = generate_unique_password([], 12) self.assertEquals(len(password), 12) for letter in password: self.assertNotIn(letter, 'aAeEiIoOuU1l')
current_log_likelihood = None self.converged_ = False
MULTIOUTPUT_METRICS = [ "mean_absolute_error", "mean_squared_error", "r2_score", "explained_variance_score" ]
return microsite.get_value(val_name, default=default, **kwargs)
del params["honor_code"] params["username"] = "another_test_username" params["email"] = "another_test_email@example.com" self.assert_success(params)
result = embargo_api.check_course_access(self.course.id, user=self.user, ip_address='FE80::0202:B3FF:FE1E:8329') self.assertTrue(result)
a_start, a_end = np.byte_bounds(a) m_start = np.byte_bounds(m)[0] offset = a_start - m_start
response = self.client.get(self.url, content_type="application/json") self.assertHttpOK(response)
response = client.put(self.url, data=json.dumps(json_data), content_type=content_type) self.assertEqual(expected_status, response.status_code) return response
clf = SVC() filter1 = SelectKBest(f_classif) pipe = Pipeline([('anova', filter1), ('svc', clf)])
import urllib2 urlopen = urllib2.urlopen
#html_additional_pages = {}
if num_steps != 1: for i in xrange(num_steps): layer_to_state = self.sample(layer_to_state, theano_rng, layer_to_clamp, num_steps=1) return layer_to_state
wi = W_list[i] hi_mean += T.dot(samples[i-1], wi) * beta
('BACKGROUND', (1, 4), (1, 4), '#EEEEEE'),
from tokenize import open as open_py_source
assert_raises(TypeError, KFold, n_folds=4, shuffle=None)
except (AttributeError, ValueError): return None
#html_short_title = None
return datetime.datetime.strptime(date_input.strip(), "%Y-%m-%d").replace(tzinfo=pytz.UTC)
handouts_location = self.course.id.make_usage_key('course_info', 'handouts') course_handouts_url = reverse_usage_url('xblock_handler', handouts_location)
dangling_pointer = course.id.make_usage_key('chapter', 'DanglingPointer')
return create_xblock_info( modulestore().get_item(location), include_child_info=True, include_children_predicate=ALWAYS, )
if dataset.y is not None: dataset.y = dataset.y[::patches.shape[0] / reassembled_shape[0]]
if settings.FEATURES.get('AUTOMATIC_AUTH_FOR_TESTING'): urlpatterns += ( url(r'^auto_auth$', 'student.views.auto_auth'), )
return provider_respond(server, openid_request, response, results)
course_enrollments.sort(key=lambda x: x.created, reverse=True)
self_paced_course, self_paced_section = self.setup_course(**course_options) beta_tester = BetaTesterFactory(course_key=self_paced_course.id)
paths = ['grading_policy.json'] if policy_dir: paths = [policy_dir + '/grading_policy.json'] + paths
instructor_dashboard_page = InstructorDashboardPage(self.browser, self.course_id) instructor_dashboard_page.visit() return instructor_dashboard_page
sparse_classifier = BaggingRegressor( base_estimator=CustomSVR(), random_state=1, **params ).fit(X_train_sparse, y_train) sparse_results = sparse_classifier.predict(X_test_sparse)
rendered_html = etree.XML(problem.get_html())
return self.oauth2_adapter.create_confidential_client( name='Test Confidential Application', user=user, client_id=client_id, redirect_uri=DUMMY_REDIRECT_URL, )
enet.set_params(alpha=alpha_optim) coef_ = enet.fit(X, y).coef_
UserFactory.create(username=self.USERNAME, email=self.EMAIL, password=self.PASSWORD)
self.q(css='input.calibration-feedback-button').first.click()
#html_use_opensearch = ''
self.kernel.theta = theta
self.assertTrue(getattr(vertical, "is_draft", False))
if not assume_unique: ar1, rev_idx = np.unique(ar1, return_inverse=True) ar2 = np.unique(ar2)
for student in students[6:7]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.notpassing, mode='honor' )
self.assertEqual(len(v_data['course_modes']), 2)
for part_svc in [ps_shared_cache_1, ps_diff_cache, ps_uncached]: self.assertEqual( first_group.id, part_svc.get_user_group_id_for_partition(user_partition_id) )
el.find_element_by_css_selector('#upgrade-to-verified').click()
X = iris.data y = iris.target
if on_rtd: os.environ['DJANGO_SETTINGS_MODULE'] = 'lms' else: os.environ['DJANGO_SETTINGS_MODULE'] = 'lms'
assert_raises(ValueError, agglo.fit, X[:0])
content = content or SRT_content srt_file = tempfile.NamedTemporaryFile(suffix=".srt") srt_file.content_type = 'application/x-subrip; charset=utf-8' srt_file.write(content) srt_file.seek(0) return srt_file
pass
self.estimators_ = [] self.estimator_weights_ = np.zeros(self.n_estimators, dtype=np.float64) self.estimator_errors_ = np.ones(self.n_estimators, dtype=np.float64)
self._assert_course_verification_status(VERIFY_STATUS_NEED_TO_VERIFY)
if method in self.URL_HANDLERS: handlers_list = self.URL_HANDLERS[method] else: self.log_error("Unrecognized method '{method}'".format(method=method)) return
#latex_logo = None
tracker.send(event)
true_and_pred = y_true.multiply(y_pred) tp_sum = count_nonzero(true_and_pred, axis=sum_axis, sample_weight=sample_weight) pred_sum = count_nonzero(y_pred, axis=sum_axis, sample_weight=sample_weight) true_sum = count_nonzero(y_true, axis=sum_axis, sample_weight=sample_weight)
for student in students[2:5]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.error, mode='honor', grade=default_grade )
query = 'objects:' pos = searchindex.find(query) if pos < 0: raise ValueError('"objects:" not found in search index')
courses_list, __ = _accessible_courses_list(self.request)
('saml_key', 'MIICsDCCAhmgAw'), ('saml_key_alt', 'MIICWDCCAcGgAw'),
full_url = "http://{site_name}".format(site_name=settings.SITE_NAME) parsed_url = urlparse(full_url)
self.assertEquals(parent_status.get('total'), total) self.assertEquals(parent_status.get('action_name'), action_name)
client = getattr(self, api_client) user = getattr(self, user) client.login(username=user.username, password=self.test_password) return client
params = self._signed_callback_params(self.order.id, self.COST, self.COST, decision='DECLINE') result = process_postpay_callback(params)
pass
selector = self.get_element_selector(VIDEO_MENUS["language"] + ' li.is-active') return self.q(css=selector).first.attrs('data-lang-code')[0]
courses = split_store.get_courses(BRANCH_NAME_DRAFT)
xblock_actions = {'deletable': True, 'draggable': True, 'childAddable': True} explanatory_message = None
conn = s3.connection.S3Connection( settings.AWS_ACCESS_KEY_ID, settings.AWS_SECRET_ACCESS_KEY ) return conn.get_bucket(settings.VIDEO_UPLOAD_PIPELINE["BUCKET"])
self.assertEqual(-1, split_test.user_partition_id) self.assertEqual(0, len(split_test.children))
self.q(css="#next_step_button").click() next_page_object.wait_for_page()
X, y = samples_generator.make_classification( n_features=20, n_informative=3, n_redundant=0, n_classes=4, n_clusters_per_class=2)
pass
parent_task_id = InstructorTask.objects.get(pk=entry_id).task_id task_id = subtask_status.task_id total_recipients = len(to_list) recipient_num = 0 total_recipients_successful = 0 total_recipients_failed = 0 recipients_info = Counter()
for name, TreeClassifier in CLF_TREES.items(): clf = TreeClassifier(random_state=0) clf.fit(X, y)
pass
grade_summary = self.get_grade_summary() self.assertEqual(grade_summary['percent'], percent)
response = self._get_page(payment_flow, course.id) self._assert_contribution_amount(response, "")
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course_id): parent = mongo_store.get_parent_location(self.problem_x1a_1) self.assertEqual(parent, self.vertical_x1a)
pass
self.register_page.visit()
fd, name = mkstemp(suffix='.png') os.close(fd)
always_cohort_inline_discussions = True
self.course_nav.go_to_vertical('Test Vertical-1')
super(TestGetCourseChapters, self).setUp() self.course_key = self.course.location.course_key
self.Ut = numpy.dot(self.V[:,-self.n_eigen:].transpose(), self.Xt)
if role is not None: role().add_users(user)
'django_comment_client', 'django_comment_common', 'discussion_api', 'notes',
super(BaseLmsDashboardTest, self).setUp()
pred = km.fit_predict(X) assert_array_equal(pred, km.labels_)
'f82b5416c9f54b5ce33989511bb5ef2e', self._get_anonymous_id(SlashSeparatedCourseKey('MITx', '6.00x', '2013_Spring'), descriptor_class)
self.group_configurations_page.visit() self.assertFalse(self.group_configurations_page.experiment_group_sections_present)
if self._dirty: self.redo_theano()
return [FakeEmail.FakeTarget()]
return self.child_at(index)
updates = self._get_updates(grads) for param, update in zip(self.params, updates): param += update
return get_processor_config().get('PURCHASE_ENDPOINT', '')
set_course_cohort_settings( course_key=self.course.id, is_cohorted=False, cohorted_discussions=["Topic_A"], always_cohort_inline_discussions=False, ) check_cohorted_topics([])
assert_raise_message(ValueError, error_msg % ("fake", pipe), pipe.set_params, fake__estimator='nope')
expiration_date = models.DateField(default=None, null=True, blank=True)
return get_url("TOS_AND_HONOR")
clf = DecisionTreeRegressor(max_depth=3, min_samples_split=2, criterion="mse", random_state=2) clf.fit(X, y)
self.course_info['number'] = self.unique_id[0:6]
monitoring_dataset = DenseDesignMatrix(X=X)
course.cohort_config = {'cohorted': False} self.assertFalse(course.is_cohorted)
fig, (ax1, ax2) = plt.subplots(1, 2) fig.set_size_inches(18, 7)
CourseAboutSearchIndexer.index_about_information(modulestore, structure)
y = np.mod(np.arange(len(y)), 3)
try: self._verify_modulestore_support(course_key, method) return True except NotImplementedError: return False
USER_SETTINGS_CHANGED_EVENT_NAME = u'edx.user.settings.changed'
print "checking effects..." after = EmailEnrollmentState(self.course_key, eobjs.email) self.assertEqual(after, after_ideal)
data['event_type'] = "re_validate" self.assert_request_status_code(200, url, method="POST", data=data)
FEATURES['ENABLE_S3_GRADE_DOWNLOADS'] = True FEATURES['ALLOW_COURSE_STAFF_GRADE_DOWNLOADS'] = True
digits = load_digits() X, y = digits.data[:50], digits.target[:50] X_test = sparse.csr_matrix(digits.data[50:100])
url(r'^api-admin/', include('openedx.core.djangoapps.api_admin.urls', namespace='api_admin')),
self.certificates_section.refresh()
self.code = self.capa_system.filestore.open('src/' + answer_src).read()
return X[:n_samples], X[n_samples:]
if not mime_type or mime_type not in mimetypes_list:
assert len(key) <= 250 return self.cache.get(key)
self.problem_type_lookup = {} for problem_type in self.problem_types: block = self.make_block("problem", self.library, data=self._get_capa_problem_type_xml(*problem_type)) self.problem_type_lookup[block.location] = problem_type
if make_data is csr_matrix: assert_raises(type(exc), func, X, metric=metric, n_jobs=2, **kwds) continue else: raise
self.assertEquals(5, self.response.content.count('grade_A'))
return self._get_structures_for_branch_and_locator(branch, self._create_course_locator, **kwargs)
return xblock_local_resource_url(block, uri)
deadline = course_deadlines.get(enrollment.course_id)
amount_value = decimal.Decimal(amount).quantize(decimal.Decimal('.01'), rounding=decimal.ROUND_DOWN)
manage.py ... transfer_students -f edX/Open_DemoX/edx_demo_course -t edX/Open_DemoX/new_demoX,edX/Open_DemoX/edX_Insider
assert_almost_equal(y_std_1d, y_std_2d) assert_almost_equal(y_cov_1d, y_cov_2d)
return xblock
if unicode(val) == student_answers[aid]: return '$' + key
MAX_SCREEN_LIST_LENGTH = 250
if not hasattr(self, 'n_samples_seen_'): self.n_samples_seen_ = 0 self.mean_ = .0 self.var_ = .0
import unittest from nose.plugins.attrib import attr
capa_system = test_capa_system() capa_system.can_execute_unsafe_code = lambda: False
self.assertTrue(all(isinstance(course, CourseSummary) for course in courses_list_by_staff))
module = CapaFactory.create(rerandomize=RANDOMIZATION.ALWAYS, max_attempts=0, done=True, correct=True) self.assertTrue(module.should_show_reset_button())
kwargs['choice_type'] = 'multiple' return ResponseXMLFactory.choicegroup_input_xml(**kwargs)
for student in students[5:6]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.deleted, mode='honor', grade=default_grade )
if 'order' in signature(np.copy).parameters: def safe_copy(X): return np.copy(X, order='K') else: safe_copy = np.copy
rval = (transform(raw_batch[0]),) + raw_batch[1:]
self.set_user_partitions(self.vertical_location, []) self.check_access(self.red_cat, self.vertical_location, True)
XA_checked, XB_checked = check_pairwise_arrays(XA.astype(np.float), XB) assert_equal(XA_checked.dtype, np.float) assert_equal(XB_checked.dtype, np.float)
self.assertIsNotNone(current_last_activity)
sparse_classifier = AdaBoostClassifier( base_estimator=CustomSVC(probability=True), random_state=1, algorithm="SAMME" ).fit(X_train_sparse, y_train)
cls._set_block_values(block_structure, cls.collect_data_key) cls.collect_call_count += 1
with self.assertRaises(ResponseError): problem.grade_answers({'1_2_1': '42'})
CHECKPOINT_PATTERN = r'(?P<checkpoint_name>[^/]+)'
cv = ShuffleSplit(n_iter=100, test_size=0.2, random_state=0)
segment_properties = full_segment_event.get('properties', {})
return CourseEmailTemplate._render(self.plain_template, plaintext, context)
X = [[3, 2], [1, 6]] y = [1, 0]
modulestore().mappings = {}
remove_review_policy(exam_id=exam_id)
self.factory().fit(X5, Y5, intercept_init=0)
for mode_slug in course_modes: CourseModeFactory.create( course_id=self.course.id, mode_slug=mode_slug, mode_display_name=mode_slug, )
if birth_year: self.set_birth_year(birth_year)
#unused_docs = []
return self.descriptor.is_configured
updates[mean_square_grad] = new_mean_squared_grad updates[mean_square_dx] = new_mean_square_dx updates[param] = param + delta_x_t
self.system.error_tracker(msg) return 'Oops, couldn't load grommet'
if library_role: library_role(self.lib_key).add_users(self.non_staff_user) if course_role: course_role(course.location.course_key).add_users(self.non_staff_user)
train_score = Perceptron().fit(X, y).score(X, y) assert_less(train_score, 0.8)
expected_url = course_image_url(course) self.assertEqual( course_overview_after.image_urls, { 'raw': expected_url, 'small': expected_url, 'large': expected_url } )
K_train = np.dot(X_[:180], X_[:180].T) y_train = y_[:180]
correct_ans = CapaFactory.create(showanswer='finished', max_attempts="1", attempts="0", due=self.tomorrow_str, correct=True) self.assertTrue(correct_ans.answer_available())
return "{store}[{collection}] already has {element_id} ({exception})".format( store=self.store, collection=self.collection, element_id=self.element_id, exception=Exception.__str__(self, *args, **kwargs), )
self.label_name_to_index = {} for index, name in enumerate(self.label_index_to_name): self.label_name_to_index[name] = index
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
svc = svm.SVC(kernel='linear', C=0.1, decision_function_shape='ovo') clf = svc.fit(iris.data, iris.target)
with self.assertNumQueries(0): self.assertFalse( self.bookmark_service.set_bookmarked(usage_key=UsageKey.from_string("i4x://ed/ed/ed/interactive")) )
OrderItemSubclassPK = namedtuple('OrderItemSubclassPK', ['cls', 'pk'])
for modulestore in self.modulestores: modulestore.close_connections()
return get_members(mailchimp, list_id, 'subscribed')
unicode_text = "好 各位同学".decode('utf-8') self.assertIn(unicode_text, self.video.captions_text)
return (len(active_groups) + len(inactive_groups) == len(container.xblocks) - 1, len(active_groups))
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.status = "must_retry" attempt.system_error("Error!")
MESSAGE_STORAGE = 'django.contrib.messages.storage.session.SessionStorage'
test_uuid = uuid.UUID(token, version=1) self.assertEqual(token, test_uuid.hex)
self.assertEqual(module.attempts, 3)
if 0 not in classes[j]: classes[j] = np.insert(classes[j], 0, 0) class_prob_j = np.insert(class_prob_j, 0, 0.0)
from xmodule.modulestore.mongo.draft import DraftModuleStore
self.set_programs_api_configuration() self.dashboard_page.visit() self.assertFalse(self.dashboard_page.is_programs_tab_present()) self.assertFalse(self.dashboard_page.is_new_program_button_present())
return self.runtime.get_subtree_edited_by(self)
'HTTP_REFERER': 'referer', 'HTTP_ACCEPT_LANGUAGE': 'accept_language',
responseparam_element = etree.SubElement(response_element, "responseparam") responseparam_element.set("type", "tolerance") responseparam_element.set("default", str(tolerance))
("restricted_course", "country")
response_element = etree.Element("coderesponse")
section_context.update({ 'proctoring': timed_exam_attempt_context, })
return getattr(self._modulestore, name)
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, self.course.id): self.store.delete_item(self.subsection.location, ModuleStoreEnum.UserID.test)
self.lc_block.source_library_id = unicode(self.library.location.library_key) result = self.lc_block.validate()
test_deviance = np.zeros((params['n_estimators'],), dtype=np.float64)
D = pairwise_distances(X) core3, label3 = dbscan(D, sample_weight=sample_weight, metric='precomputed') assert_array_equal(core1, core3) assert_array_equal(label1, label3)
decision_only = OneVsRestClassifier(svm.SVC(probability=False)) decision_only.fit(X_train, Y_train) assert_raises(AttributeError, decision_only.predict_proba, X_test)
from edx_oauth2_provider.tests import IDTokenTestCase, UserInfoTestCase
except ItemNotFoundError: return False
data = parse_qs(body) response = self.client.post(url, data)
from django.db import migrations, models
X = check_array(X) if X.ndim == 1: X = X[:, np.newaxis]
assert len(world.browser.windows) == 1 alert = world.browser.get_alert() alert.accept() check_no_alert()
api.add_enrollment(self.USERNAME, self.COURSE_ID, mode='audit')
self.assertTrue(self._has_changes(chapter.location)) self.assertTrue(self._has_changes(sequential.location)) self.assertTrue(self._has_changes(vertical.location))
X = check_array(X, accept_sparse='csr', dtype=np.float64) self._check_parameters() self._fit(X)
elif not entrance_exam_enabled and course_entrance_exam_present: delete_entrance_exam(request, course_key)
courses_list, __ = _accessible_courses_list(self.request) self.assertEqual(courses_list, [])
X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=rng)
with self.assertRaises(ItemNotFoundError): store.find_asset_metadata(new_asset_loc) with self.assertRaises(ItemNotFoundError): store.get_all_asset_metadata(fake_course_id, 'asset')
rval = -T.dot(state, self.bias)
limited_epoch_train(os.path.join(pylearn2.__path__[0], "scripts/autoencoder_example/hcae.yaml"))
self.assertTrue(element_has_text( page=course_outline_page, css_selector='span.section-title', text='Entrance Exam' ))
distances, neighbors = lshf.radius_neighbors(query, radius=mean_dist, return_distance=True) assert_array_less(distances[0], mean_dist)
ax.xaxis.set_major_locator(MaxNLocator(nbins=6, prune='lower')) tick_formatter = ScalarFormatter() tick_formatter.set_powerlimits((-3, 4)) ax.xaxis.set_major_formatter(tick_formatter)
print(descriptor, descriptor._field_data) self.assertEqual(descriptor.due, ImportTestCase.date.from_json(from_date_string))
self.assertFalse(self.creator_admin.has_add_permission(self.request))
self._check_non_staff_light(self.test_course) self._check_non_staff_dark(self.test_course) self._check_staff(self.course)
log.warning(u"Unknown unit in Range header: %s for content: %s", header_value, unicode(loc))
if lang_code == 'zh_HANT': self.video.select_language(lang_code) unicode_text = lang_text.decode('utf-8') self.assertIn(unicode_text, self.video.captions_text)
self.dashboard_page.visit() self.assertFalse(self.dashboard_page.pre_requisite_message_displayed())
redirect_to = get_next_url_for_login_page(request) if request.user.is_authenticated(): return redirect(redirect_to)
large_width = models.IntegerField(default=750) large_height = models.IntegerField(default=400)
output = os.popen('mongo --eval "print(\'running\')"').read() return output and "running" in output
module = self.get_module_for_user(self.student_user) module.system.publish(module, 'grade', grade_dict) return module
self.assertEqual(response.status_code, 200)
return
k = centers.shape[0] squared_diff = 0.0 for center_idx in range(k): center_mask = nearest_center == center_idx count = center_mask.sum()
with mock.patch.dict('django.conf.settings.FEATURES', {'DISABLE_COURSE_CREATION': True}): self.assert_created_course()
self.assertEqual(cached_structure, not_cached_structure)
if not sparse.issparse(X): iter_func = iter else: iter_func = _iterate_sparse_X
urlpatterns += ( url(r'^api/', include('edx_proctoring.urls')), )
if languages: language = languages[0] if language in locales_map: return FakeTranslations(locales_map[language]) return gettext.NullTranslations()
return AccountLegacyProfileSerializer.get_profile_image(user_profile, user_profile.user)
many_days = datetime.timedelta(days=60)
BadgrBackend.badges.append(EXAMPLE_SLUG) self.handler._create_badge = Mock() self.handler._ensure_badge_created(self.badge_class) self.assertFalse(self.handler._create_badge.called)
self.dismiss_ui_and_verify(rerun)
violations_count_str = "Number of pylint violations: " + str(num_violations) print violations_count_str
precompute = 'auto' Xy = None
self.reload_page() self.assertEqual(self.cohort_management_page.get_cohorted_topics_count(key), cohorted_topics)
url( r'^courses/{}/instructor$'.format( settings.COURSE_ID_PATTERN, ), 'instructor.views.instructor_dashboard.instructor_dashboard_2', name='instructor_dashboard', ),
S = np.dot(X, X.T) af = AffinityPropagation(affinity="precomputed") af.fit(S) assert_raises(ValueError, af.predict, X)
self.status = 'refunded' self.save() orderitems = OrderItem.objects.filter(order=self).select_subclasses() self._emit_order_event('Refunded Order', orderitems)
#html_use_opensearch = ''
self.wait_for_field(field_id) self.make_field_editable(field_id) return self.mode_for_field(field_id) == 'edit'
enabled_provider = provider.Registry.get(provider_id) if not enabled_provider: raise ValueError('Provider %s not enabled' % provider_id) return enabled_provider
alg.fit(X) alg.fit(X.tolist())
if ((filename_match(filename, filepatterns) and not self.excluded(filename, root))): runner(os.path.join(root, filename))
solve_triangular_args = {'check_finite': False}
params["email"] = "this_email_address_has_76_characters_in_it_so_it_is_unacceptable@example.com" assert_email_error("Email cannot be more than 75 characters long")
self.assertEqual(302, response.status_code) self.assertEqual('/register', response.get('Location'))
with remove_ccx(course_id) as (course_id, restore): return restore(self._modulestore.has_course( course_id, ignore_case=ignore_case, **kwargs ))
return self.q(css='.wrapper-content ' + self.certficate_css + ' .no-content').present
html_theme = 'default'
fields = getattr(self, 'unmixed_class', self.__class__).fields
'ENABLE_CSMH_EXTENDED': False,
XBlockDisableConfig.objects.create( disabled_blocks='', enabled=True )
Lars.fit(self, X, y) return self
match_type = match_type.group()[6:-1].lower() if match_type in html_types: context_type = 'html' elif match_type not in javascript_types: context_type = 'unknown'
self.login_page.click_third_party_dummy_provider()
ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3, color=c) ax.plot([1], [1], [1], color=c, label=label)
return template.strip().format(hotfix_hash=hotfix_hash)
version = float('.'.join(numpy.version.version.split('.')[:2]))
'5afe5d9bb03796557ee2614f5c9611fb', self._get_anonymous_id(CourseKey.from_string(course_id), descriptor_class)
courses = [] for modulestore in self.modulestores: courses.extend(modulestore.get_courses_for_wiki(wiki_slug, **kwargs)) return courses
self.dashboard_page.upgrade_enrollment(self.course_info["display_name"], self.upgrade_page)
X = np.array([[1.], [0.], [0.], [5.]]) X_csr = sparse.csr_matrix(X) X_csc = sparse.csc_matrix(X)
X = check_array(X, copy=whiten, dtype=FLOAT_DTYPES).T
X_varied, y_varied = make_blobs(n_samples=n_samples, cluster_std=[1.0, 2.5, 0.5], random_state=random_state) y_pred = KMeans(n_clusters=3, random_state=random_state).fit_predict(X_varied)
if (n_inliers_best >= self.stop_n_inliers or score_best >= self.stop_score or self.n_trials_ >= _dynamic_max_trials(n_inliers_best, n_samples, min_samples, self.stop_probability)): break
store = DjangoOpenIDStore() server = Server(store, endpoint)
for course in courses_in_progress: CourseRerunState.objects.initiated( sourse_course_key, destination_course_key=course.id, user=self.user, display_name="test course" )
return self.q(css='.page-content-secondary .team-capacity :last-child').text[0]
html = module.get_problem_html()
return self.q(css=self.BOTTOM_ADD_SECTION_BUTTON).first
n_samples = 12 n_features = 2 n_iter = 10 rng = np.random.RandomState(42) X = rng.rand(n_samples, n_features)
return getattr(settings, 'SOCIAL_AUTH_SAML_SP_PUBLIC_CERT', '')
choice, answers = choice_answers_pair
if request.method == 'GET': return _get_entrance_exam(request, course_key)
if isinstance(value, float): return datetime.timedelta(seconds=value)
files_to_fingerprint.append(sysconfig.get_python_lib())
if not settings.FEATURES.get('ENABLE_CSMH_EXTENDED'): post_save.connect(save_history, sender=StudentModule)
return JsonResponse({ 'url': reverse_url('course_handler'), 'destination_course_key': unicode(destination_course_key) })
ensemble = BaggingClassifier(base_estimator=Perceptron(), n_estimators=3)
while f1 != f2: f1=f2 (f2,ext)=os.path.splitext(f1)
self._create_course_unit_with_handout('asset.html', save_settings=False) self.video.clear_handout() self.save_unit_settings() self.assertFalse(self.video.is_handout_button_visible)
pass
logger.warning("Download was incomplete, downloading again.") os.remove(archive_path)
self.library = store.get_library(self.lib_key)
super(JavaScriptLinter, self).__init__() self._skip_javascript_dirs = SKIP_DIRS + ('i18n', 'static/coffee') self._skip_coffeescript_dirs = SKIP_DIRS self.underscore_linter = UnderscoreTemplateLinter()
score_bucket = "incorrect" if grade > 0 and grade < max_grade: score_bucket = "partial" elif grade == max_grade: score_bucket = "correct" return score_bucket
_ = lambda text: text
average_weight = score_weight score_weight = None not_average_axis = 0
b01c_shape = [result.shape[0], space.shape[0], space.shape[1], space.num_channels] result = result.flatten() result = tensor.reshape(result, newshape=b01c_shape, ndim=4)
[(CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG, CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG)]
store = self._get_modulestore_for_courselike(usage_key.course_key) return store.has_item(usage_key, **kwargs)
self.assertTrue(self.video.is_aligned(True))
projected_2 = rp.transform(data) assert_array_equal(projected_1, projected_2)
clf = MultinomialNB().fit(X_train, y_train, sample_weight=sw_train) prob_pos_clf = clf.predict_proba(X_test)[:, 1]
self.assertEqual(csv.replace('\r\n', '\n').strip(), self.CORRECT_CSV.strip())
profile = UserProfile.objects.get(user=user) return profile.name
'monitoring',
import warnings import numbers import numpy as np from scipy import linalg from scipy.stats import chi2
PLATFORM_CLASSES = {IOS.NAME: IOS, Android.NAME: Android}
tolerance_xml = xml.xpath( '//*[@id=$id]//responseparam[@type="tolerance"]/@default', id=xml.get('id') )
return transform(X)
X_train, X_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state=rng)
check_problem(step)
courses_list_by_groups, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(len(courses_list_by_groups), 1)
return self.q(css=CLASS_SELECTORS['slider_range']).visible
selector = self.prefix + ' .signatory-{}-view-{}'.format(self.mode, self.index) return ' '.join([selector, css])
if len(children) == 3: return LatexRendered( children[1].latex, parens=children[0].latex, tall=children[1].tall ) else: return children[0]
x=dataset_resolver() logger.info(x.resolve_dataset("toaster-oven")) logger.info(x.resolve_dataset("fake-dataset"))
from urllib2 import urlopen PY2 = True
if requesting_user.username == target_username: return True elif not target_username: raise TypeError("target_username must be specified") else: staff = GlobalStaff() return staff.has_user(requesting_user)
css = '.group-configuration-usage-unit' return self.find_css(css).text
problem_page.fill_answer("20") problem_page.click_check() self.assertTrue(problem_page.is_correct())
elif "+" not in argument: if argument.endswith('.el') or argument.endswith('.$el'): return True return False
ranges = world.css_find(range_css) assert_equal(len(ranges), 2) assert_not_equal(ranges.last.value, 'Failure')
pass
self.assertTrue(user(email).is_active)
self.video.wait_for_video_player_render() self.assertIn(self.video.state, ['playing', 'buffering', 'finished'])
def downward_state(self, state): return state def downward_message(self, state): return state
nb_channel = int(get_scalar_constant_value(images.shape[0])) assert nb_channel % 16 == 0
'django.middleware.clickjacking.XFrameOptionsMiddleware',
try: this_tar_file.extractall(dest_path) except Exception as e: raise IOError("[tar] error while extracting '%s'" %tar_filename) else: pass
return self.q(css=".field-exam-review-rules").visible
n_samples = len(digits.data) data = digits.data / 16. data -= data.mean(axis=0)
curr_indices = self.len_indices[curr_len][curr_pos:curr_pos + curr_batch_size]
request = RequestFactory().request() request.user = user all_tabs = get_course_tab_list(request, self.course) return any(tab.type == 'discussion' for tab in all_tabs)
client = self.login_client(api_client, user) self.send_patch(client, {}, expected_status=403 if user == "staff_user" else 404)
self.assertTrue(all(isinstance(course, CourseSummary) for course in courses_summary_list)) self.assertEqual(len(courses_summary_list), 1)
if self.level_of_education: return self.__enumerable_to_display(self.LEVEL_OF_EDUCATION_CHOICES, self.level_of_education)
assert_raises(ValueError, plot_partial_dependence, clf, X, [0])
ROLE = 'ccx_coach' def __init__(self, *args, **kwargs): super(CourseCcxCoachRole, self).__init__(self.ROLE, *args, **kwargs)
estimator.fit(X[bootstrap_idx], y[bootstrap_idx]) y_predict = estimator.predict(X)
n_samples = len(digits.images) X = digits.images.reshape((n_samples, -1)) y = digits.target
config = CourseOverviewImageConfig.current() if not config.enabled: return
for X in [X_1row, X_1col, X_list_1row, X_list_1row]:
points = [round0_25(point) for point in points]
self._has_staff_access = None
return ImageFile(open(TEST_DATA_ROOT / 'badges' / name + '.png'))
convnet_available.compiled = False convnet_available.compile_error = False
modules, funcname = get_func_name(func) modules.append(funcname) return os.path.join(*modules)
snapshot = models.TextField(blank=True)
updates, layer_to_chains = model.get_sampling_updates( layer_to_chains, self.theano_rng, num_steps=self.num_gibbs_steps, return_layer_to_updated=True)
return u"{} : {}".format(self.course_id.to_deprecated_string(), self.annotation)
check(u"('hasnt','hasn't')", [u'hasnt', u'hasn\'t'])
return { "id": self.id, "name": self.name, "version": Group.VERSION }
bulk_write_record = self._get_bulk_ops_record(course_key) if bulk_write_record.active: try: del bulk_write_record.modules[version_guid][block_key] except KeyError: pass
output[:, i:i + width, j:j + width] = dense_input[ :, idx][:, None, None] idx += 1
return slug in [cls.PROFESSIONAL, cls.NO_ID_PROFESSIONAL_MODE]
self._assert_survey_redirect(self.course)
response = self._generate( course_key=self.EXISTED_COURSE_KEY_2, username=self.STUDENT_USERNAME ) self.assertEqual(response.status_code, 200)
'js/vendor/requirejs/require.js', 'js/RequireJS-namespace-undefine.js', 'js/vendor/URI.min.js', 'common/js/vendor/backbone.js', 'edx-pattern-library/js/modernizr-custom.js',
self.assertContains(response, "super-ugly")
probas_pred = probas_pred[:, 1]
clf = svm.SVC() clf.fit(X_sp, Y) assert_array_equal(clf.predict([X[2]]), [1.])
self.assertTrue(BulkEmailFlag.feature_enabled(self.course.id))
if hasattr(clz, 'check_throttles'): clz.check_throttles = _check_throttles_decorator(clz.check_throttles)
NAME_CHARS = u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-' NAME_CHARS_W_UNICODE = NAME_CHARS + u'àĚŘǅΦШΩΣӔ'
self.stderr.write(_('Could not find a group named "{}" - skipping.').format(group_name))
leaf_count = node_counts[node_counts != 0] assert_greater(np.min(leaf_count), 4, "Failed with {0}".format(name))
X = generator.multivariate_normal(mean, cov * np.identity(n_features), (n_samples,))
self.assertEqual(headers, {'Authorization': 'Token 12345'})
request_context = get_template_request_context() if request_context: for item in request_context: context_dictionary.update(item) for item in context_instance: context_dictionary.update(item) if context: context_dictionary.update(context)
CourseFixture('foobar_org', '1117', 'seed_forum', 'seed_foo').install() print 'Forums permissions/roles data has been seeded'
if not settings.FEATURES.get('CERTIFICATES_HTML_VIEW', False): return False
depth = len(b_list)
'simple_history',
return False
self._setup_mode_and_enrollment(self.FUTURE, "verified")
kwargs['w'] = 1
with check_mongo_calls(1): cached_structure = self._get_structure(self.new_course)
mako_middleware_process_request(self.request)
projected_distances = projected_distances[non_identical]
first_checkpoint = VerificationCheckpoint.objects.create( course_id=self.course.id, checkpoint_location=self.checkpoint_midterm ) second_checkpoint = VerificationCheckpoint.objects.create( course_id=self.course.id, checkpoint_location=self.checkpoint_final )
self.assertTrue(result_dict['success'])
usage_key_string = json.loads(resp.content).get('locator') return UsageKey.from_string(usage_key_string)
access.has_access(None, 'staff', 'global', None)
with self.assertRaises(ValidationError): SurveyForm.create('badform', '<input name="oops" /><<<>')
if hasattr(error, 'order'): _record_payment_info(params, error.order) else: log.info(json.dumps(params)) return { 'success': False,
store = self._verify_modulestore_support(None, 'create_library') library = store.create_library(org, library, user_id, fields, **kwargs)
self._submit_photos(face_image=self.IMAGE_DATA)
self.check_val('0', False)
('RIGHTPADDING', (5, 0), (5, -1), 7 * mm),
mock_from_django_user.return_value = Mock()
if not is_cross_domain_request_allowed(request): log.debug("Could not set cross-domain CSRF cookie.") return response
invoice = shoppingcart.models.Invoice.objects.get(id=sale_invoice_1.id) invoice.is_valid = True invoice.save()
self.assertEquals(self.request.COOKIES[settings.SESSION_COOKIE_NAME], session_id)
([], 'credit'),
service = SERVICES.get(name, None) if service: fake_server = service['class'](port_num=service['port']) setattr(world, name, fake_server)
self.submit_student_answer(self.student_a.username, problem_a_url, [OPTION_1, OPTION_1]) self.submit_student_answer(self.student_b.username, problem_b_url, [OPTION_1, OPTION_2])
with Timer() as iteration_over_courses_time_1: courses_list, __ = _accessible_courses_list(self.request) self.assertEqual(len(courses_list), USER_COURSES_COUNT)
if self.path.startswith("/set_config"): return StubHttpRequestHandler.do_PUT(self) self._send_handler_response("PUT")
y_true_inv = ["b" if i == "a" else "a" for i in y_true]
is_default = True
chapter = self._find_url_name(toc, chapter_url_name) if chapter: return self._find_url_name(chapter['sections'], section_url_name) return None
testing.assert_array_equal(F.transform(X), np.around(X, decimals=1))
url(r'^submit_feedback$', 'util.views.submit_feedback'),
if m_p > m_n: u = x_p / x_p_nrm v = y_p / y_p_nrm sigma = m_p else: u = x_n / x_n_nrm v = y_n / y_n_nrm sigma = m_n
if data_type == 'subsection': for tooltip_dict in tooltips[index]: num_students = tooltip_dict['num_students'] subsection = tooltip_dict['subsection_name'] results.append(['', subsection, num_students])
education_level_label = _(u"Highest level of education completed")
return self.find_css('.signatory-panel-body .signatory-organization-value').first.text[0]
SplitTestFields.build_partition_values(self.user_partitions, self.get_selected_partition())
Z = Z.reshape(XX.shape) plt.figure(fignum, figsize=(4, 3)) plt.pcolormesh(XX, YY, Z, cmap=plt.cm.Paired)
_upload_file(self.srt_file, self.item_descriptor.location, uk_translation_filename)
request = RequestFactory().post('unused_url') request.user = self.user request.META['HTTP_HOST'] = "aGenericValidHostName" self.append_allowed_hosts("aGenericValidHostName")
self.set_many({kvs_key: value})
assert_raises(ValueError, next, StratifiedShuffleSplit(train_size=2).split(X, y)) assert_raises(ValueError, next, StratifiedShuffleSplit(test_size=2).split(X, y))
self.page.visit() config = self.page.experiment_group_configurations[0] config.toggle() config.click_outline_anchor()
return [ tt.lower() for tt in map(_ustr,t) ]
kwargs_param = param continue
module_class = EmptyXModuleWithChildren has_children = True
assert V is orig_V assert drop_mask is orig_drop_mask
self.cohort_default_student_username = "cohort_default_student" self.cohort_default_student_email = "cohort_default_student@example.com" StudioAutoAuthPage( self.browser, username=self.cohort_default_student_username, email=self.cohort_default_student_email, no_login=True ).visit()
self.assertTrue( bool(access.has_staff_access_to_preview_mode(self.global_staff, obj=self.course, course_key=course_key)) )
self.video.wait_for_state('pause')
url = path
if not self.transcript_language == 'en': return response
clf = cls() clf.partial_fit(X2, y2, classes=np.unique(y2)) assert_raises(ValueError, clf.partial_fit, X2, y2, classes=np.arange(42))
set_prerequisite_courses(course.id, [unicode(pre_requisite_course.id)]) completed_milestones = milestones_achieved_by_user(student, unicode(pre_requisite_course.id)) self.assertEqual(len(completed_milestones), 0)
REPORT_DIR = REPO_ROOT / 'reports' METRICS_DIR = REPORT_DIR / 'metrics'
return tensor.dot(self._hidden_activation(inputs), self.whf)
if v[-1] < (1. - self.prop_decrease) * self.best_value: self.countdown = self.N else: self.countdown = self.countdown - 1
api_path = getattr(settings, "ENROLLMENT_DATA_API", DEFAULT_DATA_API)
xblock._edit_info = payload['edit_info']
students = [instructor, staff, self.coach] + [ UserFactory.create(is_staff=False) for _ in range(3) ]
self.send_signal() self.assertTrue(mock_refund_seat.called) self.assertEqual(mock_refund_seat.call_args[0], (self.course_enrollment, self.student))
del params["password"] assert_password_error("A valid password is required")
if ENV_TOKENS.get('AUDIT_CERT_CUTOFF_DATE', None): AUDIT_CERT_CUTOFF_DATE = dateutil.parser.parse(ENV_TOKENS.get('AUDIT_CERT_CUTOFF_DATE'))
community_ta_role.inherit_permissions(moderator_role)
pass
existing_group_id, _ = cohorts.get_group_info_for_cohort(cohort) if existing_group_id is not None: unlink_cohort_partition_group(cohort)
if has_access(user, 'load', course_descriptor): world.enroll_user(user, course_descriptor.id)
#latex_appendices = []
k3 = 0.5**2 * RationalQuadratic(length_scale=1.0, alpha=1.0) k4 = 0.1**2 * RBF(length_scale=0.1) \ + WhiteKernel(noise_level=0.1**2,
return [{u"description": i, u"name": i, u"id": i} for i in map(str, xrange(num_topics))]
self._create_block_hierarchy() self.store.publish(self.course.location, self.user_id)
return None
self._verify_exam_data(sequence, expected_active)
lw = LedoitWolf(block_size=25).fit(X) assert_almost_equal(lw.covariance_, cov)
service = super(ModuleSystem, self).service(block=block, service_name=service_name) if callable(service): return service(block) return service
fields = dict(self.DEFAULTS, **kwargs) ProgramsApiConfig(**fields).save() return ProgramsApiConfig.current()
for y in clf.staged_predict(X_test): assert_equal(y.shape, y_pred.shape)
from __future__ import unicode_literals
world.disable_jquery_animations()
return self.get_selector('div.certificate-generation-status')
if invoice_transaction.amount > 0: payment_status = 'Invoice Paid' else: payment_status = 'Refunded'
return cls.PROFESSIONAL in modes_dict or cls.NO_ID_PROFESSIONAL_MODE in modes_dict
neighbors.kneighbors_graph = ignore_warnings(neighbors.kneighbors_graph) neighbors.radius_neighbors_graph = ignore_warnings( neighbors.radius_neighbors_graph)
return base64.urlsafe_b64encode(aes_encrypt(data, key))
tfidf_test2 = tv.transform(test_data).toarray() assert_array_almost_equal(tfidf_test, tfidf_test2)
dict(safe_zip(range(10), range(10))),
warnings.warn(premature, RuntimeWarning, stacklevel=2) break
try: return cls.objects.get( course__course_key=course_key, active=True, namespace=namespace, name=name ) except cls.DoesNotExist: return None
if sp.issparse(X): variances = mean_variance_axis(X, axis=0)[1] else: variances = np.var(X, axis=0) return np.mean(variances) * tol
result = _get_xblock_parent(self.vert1) self.assertEqual(result.location, self.seq1.location)
sample_weight = np.asarray(sample_weight, dtype=np.float64, order="C")
self.assertDictEqual(cookie_data1.__dict__, cookie_data2.__dict__)
self.course = CourseFactory.create(org='MITx', course='999', display_name='Robot Super Course')
self.assertTrue('success' in result and result['success'])
Microsite.objects.all().delete() microsite.clear() microsite.set_by_domain('unknown') self.assertIsNone(microsite.get_value('platform_name'))
VERSION = 1
self.navigate_to_video()
action_state.delete()
return self.retrieve(request, *args, **kwargs)
return "Oh yes!"
return self.create_public_client(self.user, self.client_id)
channels[prefix + name] = (raw_channels[name], cost_ipt, (spaces[i], sources[i]))
step_size = x if self.verbose: logger.info('best objective: {0}'.format(mn)) assert not np.isnan(mn)
figure.subplots_adjust(bottom=0.05)
module_location = module.location.map_into_course(target_id) _update_module_location(module, module_location.replace(revision=MongoRevisionKey.draft))
if not os.path.isdir(repo_dir): os.mkdir(repo_dir) self.addCleanup(shutil.rmtree, repo_dir)
response = self._credit_provider_callback(request_uuid, "approved", sig="invalid") self.assertEqual(response.status_code, 403)
return all(hasattr(file_to_test, method) for method in ['read', 'name'])
if check_course: return RandomBadgeClassFactory.create(course_id=self.course.location.course_key, **kwargs) return RandomBadgeClassFactory.create(**kwargs)
params = self._signed_callback_params(self.order.id, self.COST, "abcd") params['decision'] = u'CANCEL' result = process_postpay_callback(params)
self.server.config['test_reset'] = 'This is a reset config test'
batch_inertia /= model.batch_size centers_squared_diff /= model.batch_size
self.assertEqual(module.attempts, 0)
to_process = [] if children: to_process = self._query_children_for_cache_children(course_key, children)
response_element = etree.Element("javascriptresponse")
if not settings.FEATURES['ADVANCED_SECURITY']: return False min_diff_pw = settings.ADVANCED_SECURITY_CONFIG.get( 'MIN_DIFFERENT_STUDENT_PASSWORDS_BEFORE_REUSE', 0 ) return min_diff_pw > 0
with super(TestNavigation, cls).setUpClassAndTestData(): cls.test_course = CourseFactory.create() cls.test_course_proctored = CourseFactory.create() cls.course = CourseFactory.create()
context = { 'reorderable_items': set(), 'read_only': True } html = get_preview_fragment(request, html, context).content
with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_key): assertProblemNameEquals(problem_original_name) assertNumProblems(problem_new_name, 0)
for X in [data, csr_matrix(data)]: X = VarianceThreshold(threshold=.4).fit_transform(X) assert_equal((len(data), 1), X.shape)
(True, False), (True, True),
return self.q(css='.bookmarks-empty-detail-title').text[0]
form_data = {'course_id': self.course.id.run, 'email_enabled': True} form = CourseAuthorizationAdminForm(data=form_data) self.assertFalse(form.is_valid())
assert_equal(100, n_lines)
draft_branch = ModuleStoreEnum.BranchName.library published_branch = ModuleStoreEnum.BranchName.library
#today = '' #today_fmt = '%B %d, %Y'
ntaps += 1
n_samples = 100 n_features = 500 rank = 4 k = 10
if assignment_type: self.set_assignment_type(assignment_type)
PY2 = sys.version_info[0] == 2 PY3 = sys.version_info[0] == 3
file_to_upload = 'image.jpg' self.settings_page.upload_image('#upload-banner-image', file_to_upload) self.assertIn(file_to_upload, self.settings_page.get_uploaded_image_path('#banner-image'))
import hashlib import json import logging import requests import dogstats_wrapper as dog_stats_api
best_candidate = None best_pot = None best_dist_sq = None for trial in range(n_local_trials): new_dist_sq = np.minimum(closest_dist_sq, distance_to_candidates[trial]) new_pot = new_dist_sq.sum()
return self.icon_for_field(field_id, FIELD_ICONS[field_id])
spmatshp = (outsize*N.prod(kshp)*inshp[0],insize) if ws else\ (nkern*outsize,insize) spmat = scipy_sparse.lil_matrix(spmatshp)
if discussion_id is not None: default_query_params['commentable_id'] = discussion_id if get_team(discussion_id) is not None: default_query_params['context'] = ThreadContext.STANDALONE
return '{}[data-locator="{}"] {}'.format( self.BODY_SELECTOR, self.locator, selector )
tp = y_true == y_pred tp_bins = y_true[tp] if sample_weight is not None: tp_bins_weights = np.asarray(sample_weight)[tp] else: tp_bins_weights = None
self.html_unit = ItemFactory.create( parent_location=self.vertical.location, category="html", display_name="Html Content", modulestore=store, publish_item=False, )
lsfh = LSHForest(min_hash_match=0, n_candidates=n_points).fit(X)
return self._is_on_tab(tab_name)
maxscore = 0 for responder in self.responders.values(): maxscore += responder.get_max_score() return maxscore
elif strategy == "most_frequent": most_frequent = np.empty(len(columns))
for key in ['xqueue_header', 'xqueue_body']: if key not in data: raise Http404
_check_caller_authority(caller, role) role.add_users(*users)
if not ((user.id and CourseEnrollment.is_enrolled(user, course.id)) or has_access(user, 'staff', course)): raise UserNotEnrolled(course.id)
return self.make_call(reverse('team_membership_list'), expected_status, 'get', data, **kwargs)
ASSET_IGNORE_REGEX = r"(^\._.*$)|(^\.DS_Store$)|(^.*~$)"
import sklearn
n_population = 10
expiration_date = models.DateField(default=None, null=True, blank=True)
pass
context['courses_list'] = microsite.get_template_path('courses_list.html')
self.course_outline_page.visit() self.assertFalse(self.course_outline_page.deprecated_warning_visible)
base_url = reverse('create_mode', args=[unicode(self.course.id)]) self.client.get(base_url)
if grade_response is None: grade_response = self.server.config.get( 'default', copy.deepcopy(self.DEFAULT_GRADE_RESPONSE) )
pass
response = self.client.get(self.url, content_type="application/json") self.assertHttpOK(response)
return u"{namespace}:{name}, {value}".format( namespace=self.namespace, name=self.name, value=self.value, )
if org_to_include and course_overview.location.org != org_to_include: continue
Pickler.save(self, _ConsistentSet(set_items))
import numpy import theano from theano import tensor from theano.compat.six.moves import zip as izip, reduce
return course_metadata_utils.url_name_for_course_location(self.location)
_("There was a problem with the staff answer to this problem: empty boundary.")
self.find_css(selector).nth(index).click()
rendered_html = etree.XML(problem.get_html())
self.assert_valid_get_response(self.eligibility)
log.exception(u"Error while #{}ing student") log.exception(exc) results.append({ 'identifier': identifier, 'error': True, })
UserPartition.scheme_extensions = None
folders_list_in_path.extend(['data', 'uploads', file_name])
module_state_key = LocationKeyField(max_length=255, db_index=True, db_column='module_id') student = models.ForeignKey(User, db_index=True)
set_has_profile_image(username, True, _make_upload_dt())
self._verify_and_return_staff_page().set_staff_view_mode('Student') self.assertEqual(0, self.courseware.num_xblock_components)
state_client.set( username=admin.username, block_key=usage_key, state={'field_a': 'x', 'field_b': 'y'} )
theta = self.theta_
transformer = self.transformer_dataset.transformer out_space = self.data_specs[0] if isinstance(out_space, CompositeSpace): out_space = out_space.components[0]
est.sparsify() assert_true(sparse.issparse(est.coef_)) pred = est.predict(X) assert_array_equal(pred, pred_orig)
try: xml = self.preprocess_pmathml(self.expr)
X = [[1, 0, 0], [1, 1, 1]]
self.verify_content_existence(self.store, root_dir, course_id, 'tabs', 'static_tab', '.html')
metric = ALL_METRICS[name]
action = request.POST.get("enrollment_action") if 'course_id' not in request.POST: return HttpResponseBadRequest(_("Course id not specified"))
return self.lcp.done
last_ind = tps.searchsorted(tps[-1]) sl = slice(last_ind, None, -1) return np.r_[precision[sl], 1], np.r_[recall[sl], 0], thresholds[sl]
self.assertTrue(mock_audit_log.called)
super(UnderscoreTemplateLinter, self).__init__() self._skip_underscore_dirs = SKIP_DIRS + ('test',)
rng = np.random.RandomState(0) X = rng.rand(10, 20) y = np.arange(10).astype(np.int)
self.client.login(username=user.username, password="test")
self.set(key, _DELETED_SENTINEL)
self.assertContains(resp, 'This is a Test Microsite footer')
block_locator = course_key.make_usage_key( block_type=block_key.type, block_id=block_key.id, )
yield check_estimators_empty_data_messages
y1 = np.array([[0, 1, 1], [1, 0, 1]]) y2 = np.array([[0, 0, 1], [1, 0, 1]])
self.verify_expected_team_id(new_teams[2], 'a-really-long-team-n')
wrapped_func = wrapped_func.__func__
X_plot = np.linspace(-6, 6, 1000)[:, None] X_src = np.zeros((1, 1))
self.addCleanup(self.cleanup_modulestore) super(ModuleStoreNoSettings, self).setUp()
assert_raises(ValueError, sample_without_replacement, 0, 1) assert_raises(ValueError, sample_without_replacement, 1, 2)
nonzero = dists != 0 dists = dists[nonzero]
with open(file_path, "w") as file_handle: with self._log_execution_time(): self._write_email_opt_in_prefs(file_handle, org_list, courses)
GATING_NAMESPACE_QUALIFIER = '.gating'
'ENABLE_COURSE_SORTING_BY_START_DATE': True,
assert_equal(X_checked.format, accept_sparse[0])
corr_eq_dir = np.dot(Gram[:n_active, n_active:].T, least_squares)
country, __ = Country.objects.get_or_create(country='IR')
random_cohorts = CourseUserGroup.objects.filter( course_id=user_group.course_id, group_type=CourseUserGroup.COHORT, cohort__assignment_type=CourseCohort.RANDOM ) return len(random_cohorts) == 1 and random_cohorts[0].name == user_group.name
super(BadImplementationAbstractEnrollmentReportProvider, self)
sample_weight = (sample_weight * compute_sample_weight(self.class_weight, y))
if user is not None and user.is_authenticated(): if CourseEnrollmentAllowed.objects.filter(email=user.email, course_id=course_key): return ACCESS_GRANTED
if EventMatchTolerates.STRING_PAYLOAD in tolerate: expected = parse_event_payload(expected) actual = parse_event_payload(actual)
#latex_use_parts = False
response = self.client.get(complete_url) self.assertEqual(response.status_code, 302) self.assertEqual(response['Location'], 'http://example.none/misc/final-destination')
return urljoin(self.internal_service_url, '/api/v{}/'.format(self.api_version_number))
instructor = UserFactory() allow_access(self.course, instructor, 'instructor') self.assertTrue(CourseInstructorRole(self.course.id).has_user(instructor))
IcrvStatusEmailsConfiguration.objects.create(enabled=True) self.create_reverification_xblock()
from markdown.util import etree, AtomicString
tasks.environment.messages = []
self._course_overview = None
X_mean = X.mean(axis=-1) X -= X_mean[:, np.newaxis]
output = self._run_command(self.TEST_ORG) self._assert_output( output, (self.user, self.courses[0].id, True), expect_pref_datetime=False )
ADVANCED_PROBLEM_TYPES = [ { 'component': 'openassessment', 'boilerplate_name': None, }, ]
super(RegenerateCertificatesTest, self).setUp() self.course = self.courses[0]
self.problem_page.a11y_audit.check_for_accessibility_errors()
return list(self._get_selected_child_blocks())
from_address = theming_helpers.get_value('default_from_email', settings.DEFAULT_FROM_EMAIL) to_address = user.email
source_course = self.store.get_course( source_course.location.course_key, remove_version=False, remove_branch=False )
X = 15 * rng.rand(100, 1) y = np.sin(X).ravel()
response = self.assert_request_status_code(400, url, method="POST", data=data) self.assertIn("The sale associated with this invoice has already been invalidated.", response.content)
django_user_service = DjangoXBlockUserService(self.user, user_is_staff=False) anonymous_user_id = django_user_service.get_anonymous_user_id(username=self.user.username, course_id='edx/toy/2012_Fall') self.assertIsNone(anonymous_user_id)
payment_support_email = microsite.get_value('payment_support_email', settings.PAYMENT_SUPPORT_EMAIL)
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) second_checkpoint.add_verification_attempt(attempt) self.assertEqual(second_checkpoint.photo_verification.count(), 1)
return next((template for template in templates if template.get('display_name') == display_name), None)
SECRET_KEY = "very_secret_bok_choy_key"
APP_UPGRADE_CACHE_TIMEOUT = ENV_TOKENS.get('APP_UPGRADE_CACHE_TIMEOUT', APP_UPGRADE_CACHE_TIMEOUT)
return [ Location._from_deprecated_son(course['_id'], course['_id']['name']).course_key for course in courses ]
if requesting_user.username != username: if not requesting_user.is_staff or not allow_staff: raise UserNotAuthorized()
self._pool = None warnings.warn( 'Multiprocessing backed parallel loops cannot be nested' ' below threads, setting n_jobs=1', stacklevel=3) return 1
assert_raises( AssertionError, monitor.update_channels, 0 )
clf_base_regressor = \ CalibratedClassifierCV(RandomForestRegressor(), method="sigmoid") assert_raises(RuntimeError, clf_base_regressor.fit, X_train, y_train)
success = self.client.login(username=self.SUPPORT_USERNAME, password=self.SUPPORT_PASSWORD) self.assertTrue(success, msg="Couldn't log in as support staff")
'ENABLE_VIDEO_UPLOAD_PIPELINE': False,
self.client.logout() self._test_return_login(user_is_activated=False)
strides = a.strides total_buffer_len = (a_end - a_start) // a.itemsize
assert_raises(ValueError, _SigmoidCalibration().fit, np.vstack((exF, exF)), exY)
module = CapaFactory.create(max_attempts="1", attempts="0", due=self.yesterday_str) self.assertTrue(module.closed())
import subprocess
return os.sep.join(folders_list_in_path)
yield check_oob_score, name, csc_matrix(iris.data), iris.target
SERVICE_VARIANT = os.environ.get('SERVICE_VARIANT', None)
DEBUG = True
return self.best_estimator_.predict_log_proba(X)
first_result = SoftwareSecurePhotoVerification.get_initial_verification(user=user) self.assertIsNotNone(first_result)
instance.course_user_group.users.remove(instance.user) instance.course_user_group.save()
y = 0.5 * X.ravel() + rng.randn(n_samples, 1).ravel()
atomic_replace(os.path.join(dataset_conf_path,"installed.lst.2"), os.path.join(dataset_conf_path,"installed.lst"))
CONFIG_PREFIX = SERVICE_VARIANT + "." if SERVICE_VARIANT else ""
return HttpResponse(status=406)
self.course_info_page.visit() self.tab_nav.go_to_tab('Course') self.courseware_page.verify_tooltips_displayed()
yaml.add_multi_constructor('!obj:', multi_constructor_obj) yaml.add_multi_constructor('!pkl:', multi_constructor_pkl) yaml.add_multi_constructor('!import:', multi_constructor_import)
return self.q(css=INTRO_VIDEO_SELECTOR)
self.assert_grade(problem, answer, "correct") self.assert_grade(problem, answer.lower(), "correct")
x_scaled = assert_no_warnings(scale, x) assert_array_almost_equal(scale(x), np.zeros(8))
overlimit_block_keys = set() while len(selected) > max_count: overlimit_block_keys.add(selected.pop())
response = client2.post(self.url, creds) self._assert_response(response, success=True)
url = certs_api.get_certificate_url(self.student.id, self.course.id) self.assertEqual(url, "")
self.setup_user() self.assertFalse(access.has_ccx_coach_role(self.user, ccx_locator))
try: grad_not_implemented = theano.gradient.grad_not_implemented except: def grad_not_implemented(op, idx, ipt): return None
LTI_AGGREGATE_SCORE_PASSBACK_DELAY = ENV_TOKENS.get( 'LTI_AGGREGATE_SCORE_PASSBACK_DELAY', LTI_AGGREGATE_SCORE_PASSBACK_DELAY )
return isinstance(v, str) and len(v.strip()) == 0
self.asides = block_data.get('asides', {})
MASQUERADE_SETTINGS_KEY = 'masquerade_settings'
return self.q(css="#register-username").attrs('value')[0]
return type(self).censor_updates != Model.censor_updates
resource_map = API_SETTINGS.get('RESOURCE_MAP', {}) resource_name = kwargs.pop('resource') resource_method = request.method resource = resource_map.get(resource_name)
Z = Z.reshape(xx.shape) plt.contourf(xx, yy, Z, cmap=plt.cm.Paired, alpha=0.8)
obj = NearestCentroid() obj.fit(iris.data, iris.target) score = obj.score(iris.data, iris.target) s = pickle.dumps(obj)
ext_auth_response = _external_auth_intercept(request, initial_mode) if ext_auth_response is not None: return ext_auth_response
response = self._get_progress_page()
numtolerance_choices = {} binary_choices = {}
for chan_i in xrange(chans): channel = topo_X[..., chan_i] start_idx = foveate_channel(channel, rings, output, start_idx)
xblock_family = child.attrib.pop('xblock-family', None) if xblock_family: xblock_family = self._family_id_to_superclass(xblock_family) if issubclass(xblock_family, XBlockAside): aside_children.append(child)
METRICS_WITHOUT_SAMPLE_WEIGHT = [ "cohen_kappa_score",
self._validate_hyperparameters() if np.any(np.array(hidden_layer_sizes) <= 0): raise ValueError("hidden_layer_sizes must be > 0, got %s." % hidden_layer_sizes)
user2 = UserFactory.create() SkippedReverification.add_skipped_reverification_attempt( checkpoint=self.checkpoint, user_id=user2.id, course_id=unicode(self.course.id) )
xgrid, ygrid = construct_grids(data)
return '<mstyle' in self.expr
if sub_sampling: doc_ratio = float(self.total_samples) / n_samples score *= doc_ratio
blocked_states.append('IM') cauth.embargoed_countries = 'US, AQ, IM' cauth.save() currently_blocked = EmbargoedState.current().embargoed_countries_list
return 0
try: searcher.index(cls.DISCOVERY_DOCUMENT_TYPE, [course_info])
error_msg = models.TextField(blank=True)
self.lc_block.source_library_id = "library-v1:BAD+WOLF" result = self.lc_block.validate()
XMODULE_FIELDS_WITH_USAGE_KEYS = ['location', 'parent']
cluster_centers = _init_centroids( X, self.n_clusters, self.init, random_state=random_state, x_squared_norms=x_squared_norms, init_size=init_size)
if attempt.status == 'denied': status = 'must_reverify'
Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape)
cart = Order.get_cart_for_user(request.user) cart.clear()
detR = (np.diag(C) ** (2. / n_samples)).prod()
UserPartition.scheme_extensions = None super(GroupAccessTestCase, self).tearDown()
return 0.5 - scores
from sklearn.tree._tree import TREE_LEAF X, y = datasets.make_hastie_10_2(n_samples=100, random_state=1) k = 4
instructor_task.api.submit_bulk_course_email(request, course_id, email.id)
student_answer = self.student_answers.get(choicegroup.get('id')) expl_id_for_student_answer = None
if not scopes: scopes = ['default'] return ' '.join(scopes)
rows_broadcastable = False cols_broadcastable = False
course = CourseFactory.create() item = ItemFactory.create(parent_location=course.location) self.assertIsInstance(item, SequenceDescriptor)
request.grant_type = None
self.counters['logical lines'] += 1
TEST_RUNNER = 'openedx.core.djangolib.nose.NoseTestSuiteRunner'
termination_criterion = EpochCounter(5)
self.observers.append(observer)
active_tab = self._active_sequence_tab return active_tab and previous_tab_id != active_tab.attrs('data-id')[0]
account_settings.switch_account_settings_tabs('accounts-tab') account_settings.wait_for_link_title_for_link_field(field_id, "Unlink This Account")
return self.q(css='.outline .no-content').is_present()
return deepcopy(problemtree)
with self: if self.cmd: passed = self.run_test() if not passed: self.failed_suites.append(self)
import sass
file_path = InstructorDashboardPage.get_asset_path(filename) self.q(css=self.auto_enroll_browse_button_selector).results[0].send_keys(file_path) self.click_upload_file_button()
studio_link = None if course.course_edit_method == "Studio": studio_link = get_cms_course_link(course, page) return studio_link
return { "cc_requester": User(id=requester_id), "is_requester_privileged": is_requester_privileged, "course": CourseFactory(cohort_config={"cohorted": is_cohorted}), "thread": thread, }
line_start_indexes = [0] index = 0 while True: index = string.find('\n', index) if index < 0: break index += 1 line_start_indexes.append(index) return line_start_indexes
raise Exception
test_course = CourseFactory.create(default_store=modulestore_type, emit_signals=True) self.client.login(username="jack", password="test")
self.assertIn('display_course_number: ""', response.content)
pref = UserOrgTag.objects.filter(user=user).order_by("-modified") return pref[0].modified.isoformat(' ') if len(pref) > 0 else self.DEFAULT_DATETIME_STR
options = self.parse_options_string(options_string) self.reset_task_messages() call_task("pavelib.js_test.test_js_run", options=options) self.verify_messages(options=options, dev_mode=False)
from_xmodule = [entry_point for entry_point in entry_points if entry_point.dist.key == 'xmodule'] if from_xmodule: return default_select(identifier, from_xmodule) else: return default_select(identifier, entry_points)
results = { 'nickname': user.username, 'email': user.email, 'fullname': user.profile.name, }
delete_item(category='chapter', name='chapter_2')
U *= S[:self.n_components_]
latex_documents = [ ( 'index', 'getting_started.tex', u'edX Studio Documentation', u'EdX Doc Team', 'manual', ), ]
current_line_number = 0 for line_break_index in self._line_start_indexes: if line_break_index <= index: current_line_number += 1 else: break return current_line_number
if which_set != 'unlabeled': data_y = data['labs_ex'][set_indices] data_y = data_y[ex_range] - 1
UserSocialAuth._meta.app_label = "default" Nonce._meta.app_label = "default" Association._meta.app_label = "default" Code._meta.app_label = "default"
W_irange = 2 / numpy.sqrt(nvis * nhid)
def __init__(self, requestedLocation, currentHeadVersionGuid): super(VersionConflictError, self).__init__(u'Requested {}, but current head is {}'.format( requestedLocation, currentHeadVersionGuid ))
return models.Application.objects.get(**filters)
return ( self.video_upload_pipeline is not None and 'course_video_upload_token' in self.video_upload_pipeline )
exam_attempts_section.remove_student_attempt() self.assertFalse(exam_attempts_section.is_student_attempt_visible)
def __init__(self, **kwargs): super(FilebasedMicrositeBackend, self).__init__(**kwargs)
return True
instructor_user = UserFactory( username='test_instructor_user', email='test_instructor_user@openedx.org', password='test' ) CourseInstructorRole(self.master_course_key).add_users(instructor_user)
has_children = True reference_link = Reference(default=None, scope=Scope.content) reference_list = ReferenceList(scope=Scope.content) reference_dict = ReferenceValueDict(scope=Scope.settings)
reg = RidgeClassifier(class_weight={1: 0.001}) reg.fit(X, y)
try: face = sp.face(gray=True) except AttributeError: from scipy import misc face = misc.face(gray=True)
self.photo_id_key = rsa_encrypted_aes_key.encode('base64') self.save()
self._auto_auth() self.client.logout() self._auto_auth() self.assertEqual(User.objects.all().count(), 2)
with remove_ccx(course_id) as (course_id, restore): return restore(self._modulestore.get_modulestore_type(course_id))
y = np.array([5, 6.1, 6, 7, 10, 9, 10]) x = np.arange(len(y))
np.random.seed(0) n_samples = 2000 time = np.linspace(0, 8, n_samples)
return datetime.datetime.now(pytz.UTC) + datetime.timedelta( days=getattr(settings, "CREDIT_ELIGIBILITY_EXPIRATION_DAYS", 365) )
cache_key = programs_config.CACHE_KEY if programs_config.is_cache_enabled and not user.is_staff else None return get_edx_api_data(programs_config, user, 'programs', resource_id=program_id, cache_key=cache_key)
underlying_updates = modulestore().get_item(updates_usage_key) underlying_content = underlying_updates.items[0]['content'] if new_format else underlying_updates.data self.assertIn("\"/static/", underlying_content)
self.q(css=".subsection-header-actions .configure-button").nth(index).click() self.wait_for_element_presence('.course-outline-modal', 'Subsection settings modal is present.')
return cls.current().enabled
return self.map.get(key, default)
return course.id.course
'courseware_access': has_access( request.user, 'load_mobile', course_overview ).to_json(),
assign_coach_role_to_ccx(ccx_locator, request.user, course.id)
EmptyPromise(self.is_timestamp_visible, 'Timestamp Visible', timeout=30).fulfill()
attributes = self.q(css=self._bounded_selector('.cohort-management-assignment-type-settings')).attrs('class') if 'is-disabled' in attributes[0].split(): return True return False
if original_author_id is not None and user.id != original_author_id: return if getattr(post, "context", "course") == TEAM_DISCUSSION_CONTEXT: CourseTeamMembership.update_last_activity(user, post.commentable_id)
try: subprocess.check_call( script, stdout=sys.stdout, stderr=sys.stderr ) except Exception: os.chdir(cwd) raise
self.find_css('.actions .delete').first.click() confirm_prompt(self.page)
return self.find_css("#start_date").present
user=user, course_id=course.location.course_key, status=CertificateStatuses.downloadable
ZENDESK_USER = AUTH_TOKENS.get("ZENDESK_USER") ZENDESK_API_KEY = AUTH_TOKENS.get("ZENDESK_API_KEY")
self.assertEqual(test, expected)
course_enrollment.mode = u'verified' course_enrollment.save() self.assertEqual(course_enrollment.mode, u'verified')
attempt.upload_face_image(face_image)
raise NotImplementedError
result[discussion_id] = UsageKey.from_string(result[discussion_id]).map_into_course(self.course_id)
new_cmap = self.get_score(student_answers) self.get_hints(convert_files_to_filenames( student_answers), new_cmap, old_cmap) return new_cmap
path_cache = None parents_cache = None
DEBUG_TOOLBAR_MONGO_STACKTRACES = True
import os import inspect import pkgutil import warnings import sys import re import platform import struct
CourseModeFactory.create(mode_slug="honor", course_id=self.course.id, min_price=100)
query = self.q(css=SETTINGS_NAME_SELECTOR) return query.attrs('id')
rp = SparseRandomProjection(n_components=10, dense_output=True, random_state=0) rp.fit(data) assert isinstance(rp.transform(data), np.ndarray)
course = CourseFactory.create( org=course_location.org, number=course_location.course, run=course_location.run, default_store=store ) self._add_role_access_to_user(user, course.id) return course
return {'content': 'test1', 'data_field': 'test2'}
def __init__(self, rng): self.rng = rng
self.user.is_active = user_is_active
json_dict = kwargs.copy() json_dict['type'] = type_name return cls.from_json(json_dict)
if not isinstance(opExpr, Optional): opExpr = Optional(opExpr) matchExpr = FollowedBy(opExpr.expr + thisExpr) + Group( opExpr + thisExpr )
self.page.q(css=input_selector).fill(time) self.page.q(css=input_selector).results[0].send_keys(Keys.ENTER)
y_type = y_type.pop()
return policy.get(policy_key(usage_id), {})
display_name = 'chapter created' resp = self.create_xblock(display_name=display_name, category='chapter') chap_usage_key = self.response_usage_key(resp)
self.xml_data = "course info 463139"
if emsg: raise e
FEATURES['ENABLE_PREREQUISITE_COURSES'] = True
def test_linearsvx_loss_penalty_deprecations(): X, y = [[0.0], [1.0]], [0, 1]
n_cv = 2 cv = StratifiedKFold(n_cv) precomputed_folds = list(cv.split(train, target))
milestones_api.add_course_milestone(prerequisite_course_key, 'fulfills', milestone)
rng = np.random.RandomState(1999) n_samples = 100 n_features = 3 X = rng.randn(n_samples, n_features) + 5 * rng.rand(1, n_features)
FEATURES['ENABLE_EDXNOTES'] = True
score_subset = base_estimator.score(X_inlier_subset, y_inlier_subset)
return "{}#{} {}".format( self.BODY_SELECTOR, self.item_id, selector, )
raise SyntaxError('encoding problem: utf-8')
input_dict = {'1_2_1': 'Michigan'} correct_map = problem.grade_answers(input_dict) self.assertEquals(correct_map.get_hint('1_2_1'), "")
X_1, y_1 = datasets.make_classification(n_samples=n_samples, n_features=n_features, n_informative=5, random_state=1)
problem = self.build_problem(answer="1/3", tolerance=1e-3) correct_responses = ["1/3", "0.333333"] incorrect_responses = [] self.assert_multiple_grade(problem, correct_responses, incorrect_responses)
Y = np.array([0, 0, 0, 1])
response = self.client.get_html('/course/edX/test') self.assertEquals(response.status_code, 404)
result = self.client.login(username=self.USERNAME, password=self.OLD_PASSWORD) self.assertFalse(result)
raise ItemNotFoundError(course_key)
description = models.TextField(null=True, blank=True)
self._verify_unit_warning( self.UnitState(is_released=False, publish_state=self.PublishState.NEVER_PUBLISHED, is_locked=False), self.NEVER_PUBLISHED_WARNING )
self.assertTrue('Activate Course Enrollment' in response.content)
AUTH_ENTRY_LOGIN_API = 'login_api' AUTH_ENTRY_REGISTER_API = 'register_api'
selected_choices = [key for key in a_dict if key.endswith("bc")] for key in selected_choices: binary_choices[key] = a_dict[key]
full_event = dict(event, **task_info)
train, valid, test, transfer = utlc.load_sparse_dataset("ule", normalize=True, transfer=True) assert train.shape[0] == transfer.shape[0]
url = reverse('course_modes_choose', args=[unicode(self.course.id)]) response = self.client.get(url)
ROUTING_KEY = getattr(settings, 'CREDENTIALS_GENERATION_ROUTING_KEY', None)
return self._get_cohort_messages("errors")
make_thumbnail('images/no_image.png', thumb_file, 200, 140)
css_classes.append('xmodule_edit')
locked_toc = self._return_table_of_contents() for toc_section in self.expected_locked_toc: self.assertIn(toc_section, locked_toc)
cache.delete_many([instance_key(model, x) for x in instance_or_pk])
remove_user_from_cohort(second_cohort, self.student.username) self.assert_student_in_group(None)
pass
self.assertEqual(cached_structure, not_cached_structure)
instructor = UserFactory() allow_access(self.course, instructor, 'instructor')
for child_location, parent_location, revision in expected_results: self.assertEqual( parent_location, self.store.get_parent_location(child_location, revision=revision) )
self._assert_certs_in_queue(mock_queue, 1)
caption_line_selector = ".subtitles li[data-index='{index}']".format(index=line_number - 1) self.q(css=caption_line_selector).results[0].send_keys(Keys.ENTER)
if with_output_activation: output_activation = ACTIVATIONS[self.out_activation_] activations[i + 1] = output_activation(activations[i + 1])
self.xml.set('cfn', 'symmath_check')
block = modulestore().get_item(locator) pre_def_id = block.definition_locator.definition_id pre_version_guid = block.location.version_guid
self.returnString = matchString self.name = "'%s'" % self.returnString self.errmsg = "Expected " + self.name #self.myException.msg = self.errmsg
problem = self.store.get_item(problem.location)
queryset = queryset.order_by('name')
cet = CourseEmailTemplate.objects.get(name=None) self.assertIsNotNone(cet)
return self.q(css='.join-team .action-primary').present
check_xblock_names(active_groups + inactive_groups, container.xblocks[1:]) if verify_missing_groups_not_present: self.verify_add_missing_groups_button_not_present(container)
course = CourseFactory.create() self.verify_url( unicode(course.id.make_asset_key('asset', course.course_image)), course_image_url(course) )
user_id = context.get('user_id') course_title = context.get('course_title')
old_group = RandomUserPartitionScheme.get_group_for_user(self.MOCK_COURSE_ID, self.user, self.user_partition) self.assertIn(old_group.id, [0, 1])
assert_array_almost_equal(linkage_X_ward[:, 2], out_X_unstructured[4]) assert_array_almost_equal(linkage_X_ward[:, 2], out_X_structured[4])
clf = ForestClassifier(class_weight='the larch', random_state=0) assert_raises(ValueError, clf.fit, X, y) assert_raises(ValueError, clf.fit, X, _y)
parents = list( self.collection.find(query, {'_id': True}, sort=[SORT_REVISION_FAVOR_DRAFT]) ) if len(parents) == 0: return cache_and_return(None)
form = self.get_form(expected_valid=False) self.assertEqual(form.errors, {expected_field: [expected_message]})
PAGES_PACKAGE_DIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'pages')
self.go_to_tab_and_assert_problem(2, self.problem2_name)
DATADOG = AUTH_TOKENS.get("DATADOG", {}) DATADOG.update(ENV_TOKENS.get("DATADOG", {}))
bandwidth = cluster.estimate_bandwidth(X, quantile=0.3)
self.assertEquals( preview.latex_preview('(2+3^2)'), r'\left(2+3^{2}\right)' )
ele.value = grace_period
reorderable_items = set() if view_name == 'reorderable_container_child_preview': reorderable_items.add(xblock.location)
raise NotImplementedError()
PIPELINE_CSS_COMPRESSOR = None PIPELINE_JS_COMPRESSOR = None
from __future__ import unicode_literals
return self.lti_consumer.consumer_secret
f_init = compile_f_init() f_step = compile_f_step() self._compiled_cache = (state, indices, f_init, f_step) return self._compiled_cache[2:]
if hasattr(key, 'version_agnostic') and hasattr(key, 'for_branch'): return key.for_branch(None).version_agnostic() else: return key
SupportedFieldType(StudentViewTransformer.STUDENT_VIEW_DATA, StudentViewTransformer), SupportedFieldType(StudentViewTransformer.STUDENT_VIEW_MULTI_DEVICE, StudentViewTransformer),
if Y is not None: H_hat[-1] = Y
self.org = org self.course_id = course_id self.run = run self.language = None
y1 = np.append(y1, [2] * 4) y2 = np.append(y2, [2] * 4) assert_equal(cohen_kappa_score(y1, y2, labels=[0, 1]), kappa)
([], CourseMode.DEFAULT_MODE_SLUG),
FEATURES['ENABLE_SOFTWARE_SECURE_FAKE'] = True
self._base_test_extauth_auto_activate_user_with_flag(log_user_string="user.id: 1")
self._load_definition() if key.block_scope_id.block_type not in self.aside_fields: raise KeyError()
allow_multiple = False
simplefilter('ignore')
self.prob2 = ItemFactory.create( parent_location=self.course.location, category='problem', display_name='untitled problem 2' )
CourseModeFactory.create( course_id=self.course_key, mode_display_name="Honor Not Expired", mode_slug="honor_not_expired", expiration_datetime=future )
cache_timeout = 600
self.q(css=self._bounded_selector('.remove-admin-role')).click() wait_for_ajax_or_reload(self.browser)
self.add_license_to_xml(xml)
STUDENT_FILEUPLOAD_MAX_SIZE = ENV_TOKENS.get("STUDENT_FILEUPLOAD_MAX_SIZE", STUDENT_FILEUPLOAD_MAX_SIZE)
self.assertIn("Password Reset Email Sent", self.login_page.wait_for_success())
graph = graph.tocsr()
self.assertTrue(self.store.has_changes(self.store.get_item(self.course.location)))
EmptyPromise( lambda: self.q(css=enrollment_button).present, "Enrollment button" ).fulfill() self.q(css=enrollment_button).click()
email_feature_dict['email'] = email_info
reviewing_service = models.CharField(blank=True, max_length=255)
raise SkipTest
CourseMode.objects.create( course_id=self.verified_course_key, mode_slug="verified", mode_display_name="verified cert", min_price=self.cost )
self.assertTrue('Activate Course Enrollment' in response.content)
if context is not None: return nested(self._capture_assertion_errors(), context)
result = api.baskets.post({ 'products': [{'sku': course_mode.sku}], 'checkout': True, 'payment_processor_name': processor })
subtask_id = initial_subtask_status.task_id new_subtask = send_course_email.subtask( ( entry_id, email_id, to_list, global_email_context, initial_subtask_status.to_dict(), ), task_id=subtask_id, routing_key=routing_key, ) return new_subtask
if expected is not actual: raise AssertionError("values not identical, expected %r, actual %r" % (expected, actual))
store = modulestore() course_usage_key = store.make_course_usage_key(course_key) return BlockStructureManager(course_usage_key, store, _get_cache())
raise TypeError("Model.censor_updates has been replaced by " "Model.modify_updates.")
user = UserFactory.create() status = SoftwareSecurePhotoVerification.user_status(user) self.assertEquals(status, ('none', ''))
raise
task_key = hashlib.md5(task_key_stub).hexdigest()
CourseEnrollment.enroll(self.instructor, self.course.id) self.test_send_to_all()
return 'problem'
show_in_read_only_mode = False
assert not value or all(0 <= v < self.num_layers for v in value) self.inputs_to_layers[key] = sorted(value)
p, r, f, s = precision_recall_fscore_support(y_true, y_pred, pos_label=None, average='weighted')
first_request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO["username"])
if not settings.FEATURES.get('MILESTONES_APP', False): return None from milestones import api as milestones_api return milestones_api.get_user_milestones({'id': user.id}, namespace)
STATUS_VISIBLE = 'visible' STATUS_DELETED = 'deleted' TEMPLATE_DIR = 'courseware'
return self.lcp.get_max_score()
return self.theta.shape[0]
self.submit_question_answer('p1', {'2_1': u'Correct'})
self.delete_team(self.wind_team.team_id, 204, user='staff')
self.courseware.go_to_sequential_position(2)
types = [(MockDataFrame, MockDataFrame)] try: from pandas import Series, DataFrame types.append((DataFrame, Series)) except ImportError: pass
self.problem_page.a11y_audit.config.set_scope( include=['div#seq_content'])
self.assertIn('pre requisite course', resp.content) self.assertIn('course that has pre requisite', resp.content)
import scipy.sparse
logging.debug("[%s]: %s" % (self, msg))
X, Y = np.meshgrid(xgrid, ygrid[::-1])
ipaddr.IPNetwork(address)
press_the_notification_button(self, "save") if wait_for_confirmation: self.wait_for_element_visibility( '#alert-confirmation-title', 'Save confirmation message is visible' )
self.find_css('.action-edit .edit').first.click()
if csv_type is not None: try: redemption_set = registration_code.registrationcoderedemption_set redeemed_by = redemption_set.get(registration_code=registration_code).redeemed_by course_registration_dict['redeemed_by'] = redeemed_by.email except ObjectDoesNotExist: pass
self.client.login(username=self.user.username, password=self.test_password) response = self.send_get(self.client) self.assertEqual({}, response.data)
self.go_to_sequential_position(1) execute_video_steps(tab1_video_names)
matching_events = self.get_matching_events_from_time(start_time=start_time, event_filter=event_filter) return len(matching_events) >= number_of_matches, matching_events
xml_reports = []
mathjax_container = self.q(css=".static_tab_wrapper .MathJax_SVG") EmptyPromise( lambda: mathjax_container.present and mathjax_container.visible, "MathJax is not visible" ).fulfill()
email = staff.email password = 'test' self.login(email, password) self.enroll(self.course, verify=True)
content_location = Transcript.asset_location(location, name) content = StaticContent(content_location, name, mime_type, content) contentstore().save(content) return content_location
export_extra_content( export_fs, self.modulestore, self.courselike_key, xml_centric_courselike_key, 'about', 'about', '.html' )
return self.context["cc_requester"]["id"] in obj.get("abuse_flaggers", [])
self.set_year_of_birth(current_year - 10) self.profile.save() self.assertFalse(self.profile.has_profile_image)
self.q(css=self._bounded_selector(".annotator-item input")).first.fill(" ".join(tags))
X = dataset.get_design_matrix() m = X.shape[0] assert X.shape[1] == self.nvis
data[:, 2] /= data[:, 5]
alphas = np.tile(np.sort(alphas)[::-1], (n_l1_ratio, 1))
ret |= {"voted"} if _is_author_or_privileged(cc_content, context): ret |= {"raw_body"}
expected = self.course actual = self.ccx.course self.assertEqual(expected, actual)
rng = np.random.RandomState(0)
response = self.client.get(self.notes_page_url) self.assertEqual(response.status_code, 404)
try: value = result.get(timeout=4.0) success = True except TimeoutError: value = None success = False
CourseFixture( org='test_org', number='335535897951379478207964576572017930000', run='test_run', display_name='Test Course 335535897951379478207964576572017930000', ).install()
if len(set(ml)) != 1: raise ValueError("Composite space is empty or containing " "incompatible index spaces") return ml[0]
section = self.course_outline_page.section(SECTION_NAME) subsection = section.subsection(SUBSECTION_NAME) unit = subsection.expand_subsection().unit(UNIT_NAME) return (section, subsection, unit)
self.optimizer = 'fmin_cobyla' self.verbose = False
inputs = inputs[1:] neg_inputs = neg_inputs[1:]
return self._is_element_visible(".edit-comment-body[data-id='{}']".format(comment_id))
FEATURES['AUTOMATIC_AUTH_FOR_TESTING'] = True
group1_id = self.partition_service.get_user_group_id_for_partition(user_partition_id) self.assertEqual(group1_id, groups[0].id)
settings.apply_settings(self.settings) self.assertEqual([], provider.Registry.enabled())
loaded = yaml.load(yamlfile) logger.info(loaded) assert loaded['corruptor'] is loaded['dae'].corruptor
if presort == 'auto' and issparse(X): presort = False elif presort == 'auto': presort = True
self.scope_ids = self.scope_ids._replace(user_id=user_id)
LogoutPage(self.browser).visit() self._auto_auth("STAFF_TESTER", "staff101@example.com", True)
self.q(css='a.nav-item').filter(text=topic)[0].click()
attribute = getattr(module, attribute_name) return hasattr(attribute, __BACKUP_ATTRIBUTE_NAME)
indices = self.lambdas_.argsort()[::-1] self.lambdas_ = self.lambdas_[indices] self.alphas_ = self.alphas_[:, indices]
context = {}
AutoAuthPage(self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id, staff=False).visit()
attempt = self._submit_attempt(request.user, face_image, photo_id_image, initial_verification)
if os.environ.get('TRAVIS') == "true": raise SkipTest("This test needs to be skipped on Travis")
af = AffinityPropagation(affinity="euclidean") labels = af.fit_predict(X) labels2 = af.predict(X) assert_array_equal(labels, labels2)
epoch_num = 6 termination_criterion = EpochCounter(epoch_num)
np.maximum(R, 0, tmp) tmp.flat[::n_samples + 1] = R.flat[::n_samples + 1]
from __future__ import unicode_literals
module_class = EmptyXModule
courses = import_course_from_xml( self.store, self.user.id, TEST_DATA_DIR, ['conditional_and_poll'], static_content_store=content_store, create_if_not_present=True )
for cache in settings.CACHES: caches[cache].clear()
instructor_task = api_call() instructor_task = InstructorTask.objects.get(id=instructor_task.id) instructor_task.task_state = PROGRESS instructor_task.save() with self.assertRaises(AlreadyRunningError): api_call()
self.assertFalse(self.course.visible_to_staff_only) orig_block_structure = get_course_blocks(self.user, self.course_usage_key) self.assertFalse( VisibilityTransformer.get_visible_to_staff_only(orig_block_structure, self.course_usage_key) )
textline_element = response_element.find("div") self.assertEqual(textline_element.text, 'Input Template Render')
vector = np.zeros_like(grad) vector[1] = 1 hess_col = hess(vector)
(solution_id, subset_choices) = self.sample_from_answer_pool(choices_list, rng, num_choices)
data_train, targets_train = data[:n_samples / 2], digits.target[:n_samples / 2]
'AUTOPLAY_VIDEOS': False,
estimator = MockImprovingEstimator(1) assert_raises(ValueError, learning_curve, estimator, X, y, exploit_incremental_learning=True)
X = sparse.csr_matrix(X)
y = np.array([10, 9, 10, 7, 6, 6.1, 5]) x = np.arange(len(y))
'ENABLE_VIDEO_BEACON': False,
def g_test(x): return x ** 3, (3 * x ** 2).mean(axis=-1)
url(r'add_users_to_cohorts$', 'instructor.views.api.add_users_to_cohorts', name="add_users_to_cohorts"),
xblock.group_access = {partition_id: group_ids} self.store.update_item(xblock, self.user.id)
pass
self.enable_saml(enabled=False) response = self.client.get(self.METADATA_URL) self.assertEqual(response.status_code, 404)
def __init__(self, name): self.name = name
from django.core.management.base import BaseCommand from django.contrib.auth.models import User
resp = self.create_xblock(parent_usage_key=self.chapter_usage_key, category='sequential') self.seq_usage_key = self.response_usage_key(resp)
for char in key: if ord(char) < 33 or ord(char) == 127: return False
inline_topics = self.q(css=self._bounded_selector('.check-discussion-subcategory-inline')) return all(topic.get_attribute('disabled') == 'true' for topic in inline_topics)
elif any(requirement['status'] in non_eligible_statuses for requirement in requirement_statuses): eligibility_status = "not_eligible"
LANGUAGES = ( ('en', u'English'), ('rtl', u'Right-to-Left Test Language'),
graded = False
response = self._load_dashboard() self.assertContains(response, "credit-eligibility-msg") self.assertContains(response, "purchase-credit-btn")
from __future__ import unicode_literals
instructor = AdminFactory.create() self.client.login(username=instructor.username, password="test")
for kernel in kernels: gpr = GaussianProcessRegressor(kernel=kernel).fit(X, y) assert_equal(gpr.log_marginal_likelihood(gpr.kernel_.theta), gpr.log_marginal_likelihood())
self.assertOLXIsDraftAndPublished(block_list_to_revert) self.revert_to_published(block_list_to_revert) self.assertOLXIsPublishedOnly(block_list_to_revert)
if context is None: context = self.serializer_context return BlockSerializer( context['block_structure'], many=True, context=context, )
self.check_event_response_by_key('handle_vote', resource, 'newVotes', test_case['new_votes'])
def run_autoencoder( self,
self._assert_history([], enroll_msg='embargo', access_msg='embargo')
subsection_css = ( ".course-navigation .chapter-content-container:nth-of-type({0}) " ".menu-item a p:nth-of-type(1)" ).format(section_index)
FEATURES['ENABLE_EDXNOTES'] = enable_edxnotes with override_settings(FEATURES=FEATURES): self.assertEqual(EdxNotesTab.is_enabled(self.course), enable_edxnotes)
FEATURES['ENABLE_PREREQUISITE_COURSES'] = True
#html_use_index = True
for block_key in self.post_order_traversal(): if block_key in old_block_relations: self._add_block(pruned_block_relations, block_key)
enrollment_number = super(CourseEnrollmentManager, self).get_queryset().filter( course_id=course_id, is_active=1 ).count() return enrollment_number
return Fragment(content=u"<div>Nothing to randomize between</div>")
n_population = 100
from pylearn2.blocks import Block, StackedBlocks from pylearn2.models import Model from pylearn2.utils import sharedX from pylearn2.utils.theano_graph import is_pure_elemwise from pylearn2.utils.rng import make_np_rng, make_theano_rng from pylearn2.space import VectorSpace
attr_dict = {key: getattr(self, key) for key in self.FEATURES} attr_dict['created'] = attr_dict['created'].isoformat() return attr_dict
y_pred_proba = clf.predict_proba(X) y_pred_log_proba = clf.predict_log_proba(X) assert_array_almost_equal(np.log(y_pred_proba), y_pred_log_proba, 8)
self.assertOLXIsDraftOnly(block_list_to_revert) self.publish(block_list_to_revert) self.assertOLXIsPublishedOnly(block_list_to_revert)
return False
with self.assertRaises(Http404): self._build_and_run_request(self._anon_user, self._anon_fields)
course = self.get_item_from_modulestore(self.usage_key) self.assertIn(chap_usage_key, course.children)
if not args: format_str = urllib.unquote(format_str) return u"{0} - - [{1}] {2}\n".format( self.client_address[0], self.log_date_time_string(), format_str % args )
self.assert_social_auth_does_not_exist_for_user(created_user, strategy)
empty_distribution = grades.answer_distributions(self.course.id)
params_bad_ordernum = params.copy() params_bad_ordernum['orderNumber'] = str(order1.id + 10) with self.assertRaises(CCProcessorDataException): payment_accepted(params_bad_ordernum)
self.__dict__[attr] = val
return { 'input_type': self.html_input_type, 'choices': self.choices }
resp = self.client.post(reverse('shoppingcart.views.remove_item', args=[]), {'id': cert_item.id})
try: category = json_data['location']['category'] class_ = self.load_block_type(category)
if estimator_error == 0: break
n_samples = 200 outliers_fraction = 0.25 clusters_separation = [0, 1, 2]
return reverse_course_url('group_configurations_list_handler', self.course.id)
#default_role = None
log.debug("No module %s for user %s -- access denied?", usage_key, user) raise Http404
libraries = [LibraryFactory.create() for _ in range(3)] lib_dict = dict([(lib.location.library_key, lib) for lib in libraries])
distances = np.zeros(shape=(X.shape[0],), dtype=np.float64)
braces = '}' * num_braces rval = basic_setup + \ setup_nv_images + \ setup_nv_filters + \ setup_nv_targets + \ do_convolution + \ braces rval = rval % locals() return rval
self.assertEqual(VerificationDeadline.deadline_for_course(self.course.id), verification_deadline)
name_label = _(u"Full name")
if self.__manager: yield else: try: self.__manager = _BulkAssertionManager(self) yield except Exception: raise else: manager = self.__manager self.__manager = None manager.raise_assertion_errors()
item.is_draft = (item.location.revision == MongoRevisionKey.draft) item.location = item.location.replace(revision=MongoRevisionKey.published) return item
self.two_day_delta_str = "2 days"
def __init__(self, email, user, cenr, cea): self.email = email self.user = user self.cenr = cenr self.cea = cea
assert_array_almost_equal(huber_warm.coef_, huber_warm_coef, 1)
course = CourseFactory.create(org='edX', course='999') self.assertEquals(course_image_url(course), '/c4x/edX/999/asset/{0}'.format(course.course_image))
self.assertIn(multi_parent_html.location, orphan_vertical.children) self.assertIn(multi_parent_html.location, vertical1.children)
X = np.random.randn(10, 2) X[::2] = np.nan
rng = np.random.RandomState(0) n, p = 50, 3
gaussian_matrix_params = { "n_components": opts.n_components, "random_state": opts.random_seed } transformers["GaussianRandomProjection"] = \ GaussianRandomProjection(**gaussian_matrix_params)
attempt = SoftwareSecurePhotoVerification(user=user) attempt.mark_ready() assert_equals(attempt, SoftwareSecurePhotoVerification.active_for_user(user))
rgr = MultiOutputRegressor(GradientBoostingRegressor(random_state=0)) rgr.fit(X, y, w)
explained_variance_ = (S ** 2) / n_samples total_var = explained_variance_.sum() explained_variance_ratio_ = explained_variance_ / total_var
y_true, _, probas_pred = make_prediction(binary=True)
pass
def setUp(self): super(TestDisabledXBlockTypes, self).setUp()
content.pop('group_id', None)
if isinstance(reference, basestring): reference = BlockUsageLocator.from_string(reference) elif isinstance(reference, BlockKey): return reference return BlockKey.from_usage_key(reference)
list_staff_master_course = list_with_level(self.course, 'staff') list_instructor_master_course = list_with_level(self.course, 'instructor')
course, course_data_path = self.import_courselike( runtime, courselike_key, dest_id, source_course, ) return source_course, course, course_data_path
#html_file_suffix = ''
button_classes = self.q(css=MY_TEAMS_BUTTON_CSS).attrs('class') if len(button_classes) == 0: return False return 'is-active' in button_classes[0]
select = Select(browser_query.first.results[0]) ddl_selected_value = select.first_selected_option.get_attribute('value') return ddl_selected_value == value
sh("i18n_tool generate")
self.assertEqual(course_date, expected_course_date)
VERIFIED_MODES = [VERIFIED, PROFESSIONAL]
self.client = Client() assert_true(self.client.login(username=uname, password=password))
return [Attribute('src'), Attribute('height'), Attribute('label', ''), Attribute('width'), ]
try: fields = kwargs['context'].pop('fields', DEFAULT_FIELDS) or DEFAULT_FIELDS except KeyError: fields = DEFAULT_FIELDS super(BookmarkSerializer, self).__init__(*args, **kwargs)
NOT_CONFIGURED = "not-configured"
REQUIRE_EXCLUDE = ("build.txt",)
response = self.client.get(reverse('signup'), follow=True) self.assertEqual(response.status_code, 404)
return 'v{}.0'.format(ver)
X = csc_matrix(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
return self.q(css="table.allowance-table tr.allowance-items").present
attr = cls._translate(attr)
config_key = microsite.get_value('cybersource_config_key') if config_key: config = config['microsites'][config_key]
for processor in get_template_context_processors(): context.update(processor(request))
#
mask = [1] * 10 + [0] * 10 assert_raises(AssertionError, assert_almost_equal, matthews_corrcoef(y_1, y_2, sample_weight=mask), 0.)
)
self._paths = [prepare_path_for_serialization(path) for path in value] if value else value
assert_greater(np.min(decision_func[-2:]), np.max(decision_func[:-2])) assert_array_equal(pred, 6 * [1] + 2 * [-1])
'ENABLE_XBLOCK_VIEW_ENDPOINT': False,
url(r'^{}/all_sequential_open_distrib$'.format(settings.COURSE_ID_PATTERN), 'class_dashboard.views.all_sequential_open_distrib', name="all_sequential_open_distrib"),
all_asset_md = [] for __ in xrange(amount): all_asset_md.append(generate_random_asset_md()) return all_asset_md
reset_to_default = False try: reset_to_default = xblock.start.year < 1900 except ValueError: reset_to_default = True
from __future__ import unicode_literals
input_problem_answer(step, problem_type, correctness)
self.assertEquals( response_data["content"], strip_none(make_mock_thread_data(course=self.course, text=text, thread_id=thread_id, num_children=1)) ) mock_request.assert_called_with( "get",
else: if self.exprs: raise maxException else: raise ParseException(instring, loc, "no defined alternatives to match", self)
return self.q(css='article.content-primary').visible
eobjs = mes.create_user(self.course_key) ees = EmailEnrollmentState(self.course_key, eobjs.email) self.assertEqual(mes, ees)
indexed_count = { "count": 0 }
assert_equals(value, getattr(seq, attribute))
courses_list, __ = _accessible_courses_list(self.request) self.assertEqual(courses_list, [])
data_y = data_y - 1
run = problem_key.run if not run: problem_key = course_key.make_usage_key_from_deprecated_string(problem_location) if problem_key.course_key != course_key: raise InvalidKeyError(type(problem_key), problem_key)
digits = load_digits() X = digits.images.reshape((len(digits.images), -1)) y = digits.target
return [ m['content_id'] for m in find_gating_milestones( course.id, None, 'requires', {'id': user.id} ) ]
n_samples = n_features samples = np.arange(n_samples)
user_answer = flat_user_answer(user_answer)
clf = MockClassifier() grid_search = GridSearchCV(clf, {'foo_param': [1, 2, 3]}, refit=True) grid_search.fit(X, y)
self.certificates_section.refresh()
return False
Z = Z.reshape(xx.shape) ax.contourf(xx, yy, Z, cmap=cm, alpha=.8)
account_settings = AccountSettingsPage(self.browser).visit() account_settings.switch_account_settings_tabs('accounts-tab')
cet = CourseEmailTemplate.objects.get(name='foo') self.assertIsNotNone(cet)
proba[proba < np.finfo(proba.dtype).eps] = np.finfo(proba.dtype).eps log_proba = np.log(proba)
C = np.dot(sample_weight, y * y) * 10 if y_min is not None: y[0] = y_min sample_weight[0] = C if y_max is not None: y[-1] = y_max sample_weight[-1] = C
if include_self: query = X._fit_X else: query = None return query
log = logging.getLogger(__name__)
ddata = DummyDataset(axes=('c', 0, 1, 'b')) topo = ddata.get_topological_view()
super(DraftModuleStore, self).update_item( item, user_id, isPublish=True, is_publish_root=is_root, allow_not_found=True ) to_be_deleted.append(as_draft(item_location).to_deprecated_son())
return 0
certificates = Dict( display_name=_("Certificate Configuration"), help=_("Enter course-specific configuration information here (JSON format)"), scope=Scope.settings, )
assert is_css_present(css_selector) return retry_on_exception(lambda: css_find(css_selector)[index].html)
project = u('scikit-learn') copyright = u('2010 - 2016, scikit-learn developers (BSD License)')
self.setup_mongo_course(course_edit_method='XML') result_fragment = self.module.render(STUDENT_VIEW, context=self.default_context) self.assertNotIn('View Unit in Studio', result_fragment.content)
COURSE_CERT_AWARDED.send(**self.signal_kwargs) self.assertEqual(mock_is_certification_enabled.call_count, 1)
return _check_range_and_return('vertical shift', label, -5, 5)
self.assertTrue(is_survey_required_for_course(self.course))
self.assertFalse(result['success']) self.assertIn(u"inconsistent data", result['error_html'])
n_targets = 2 X, y = X_diabetes, y_diabetes y_n = np.tile(y, (n_targets, 1)).T
non_editable_metadata_fields = self.lc_block.non_editable_metadata_fields self.assertIn(LibraryContentDescriptor.mode, non_editable_metadata_fields) self.assertNotIn(LibraryContentDescriptor.display_name, non_editable_metadata_fields)
return (isinstance(batch, np.ndarray) or scipy.sparse.issparse(batch) or str(type(batch)) == "<type 'CudaNdarray'>")
return u"verification.{}.{}".format(user_id, unicode(course_key))
if not hasattr(self, 'chapter'): self.chapter = ItemFactory.create( parent_location=self.course.location, category='chapter' )
if field in self._dirty_fields: del self._dirty_fields[field]
self.field_exclusions.add((usage_id, field_name))
self.assertOLXIsDraftOnly(block_list_to_unpublish) with self.assertRaises(ItemNotFoundError): self.unpublish(block_list_to_unpublish)
def get_readonly_fields(self, request, obj=None):
s, v = 0.75, 0.9 c = s * v m = v - c
if test3 <= ctol: istop = 3 if test2 <= atol: istop = 2 if test1 <= rtol: istop = 1
response = self._regenerate()
corr = safe_sparse_dot(y, X) corr /= row_norms(X.T) corr /= norm(y)
result = self.service.delete_student_attempt( self.student.username, unicode(self.course.id), 'foo/bar/baz', requesting_user=self.student, ) self.assertIsNone(result)
fake_data_api.add_course(self.COURSE_ID, course_modes=['professional']) api.add_enrollment(self.USERNAME, self.COURSE_ID, mode='verified')
cv = StratifiedKFold(n_folds=6) classifier = svm.SVC(kernel='linear', probability=True, random_state=random_state)
self._find_within(".response_{} .discussion-response .wmd-input".format(response_id)).fill(new_body)
steps = [self.activations[:]]
with self.assertRaises(NotImplementedError): self.client.get(self.url)
'rule': Rules.python_wrap_html
problem_url_name = 'H1P1' self.define_option_problem(problem_url_name) location = InstructorTaskModuleTestCase.problem_location(problem_url_name) descriptor = self.module_store.get_item(location)
self._verify_editable(self._get_course_details_response(True))
assert_raises(Exception, getattr(delegator, method), delegator_data.fit_args[0])
yob_label = _(u"Year of birth")
group_id, user_partition_id = get_masquerading_group_info(self.test_user, self.course.id) self.assertEqual(group_id, 1) self.assertEqual(user_partition_id, 0)
return SelectKBest(chi2, k=k)
clf = GradientBoostingClassifier(n_estimators=100, random_state=1)
scores = cross_val_score(BernoulliNB(alpha=10), X > 4, y, cv=10) assert_greater(scores.mean(), 0.83)
errstring = "Error: too few arguments" with self.assertRaisesRegexp(CommandError, errstring): call_command('export_olx')
notes = self.server.get_all_notes() self.assertGreater(len(notes), 0, "Notes are empty.") return notes
assert_false(hasattr(SequenceDescriptor, 'rerandomize'))
redirect_url = get_redirect_url(params["course_key"], params["checkpoint"]) return JsonResponse({"url": redirect_url})
return len(self._find_within(".discussion-response"))
split_test = self._update_partition_id(0) self.assertEqual(2, len(split_test.children)) initial_group_id_to_child = split_test.group_id_to_child
self.assertListEqual( self.get_item_from_modulestore(self.seq2_usage_key).children, [unit_1_key, unit_2_key] )
_track_certificate_events(request, context, course, user, user_certificate)
zip_lib = self.capa_system.get_python_lib_zip() if zip_lib is not None: extra_files.append(("python_lib.zip", zip_lib)) python_path.append("python_lib.zip")
values = set(values.split(',')) if values else set()
skip_if_no_data() self.train = OCR(which_set='train') self.valid = OCR(which_set='valid') self.test = OCR(which_set='test')
rng = np.random.RandomState(0) X = rng.rand(5, 5)
if auth_user: set_user_preference(request.user, DARK_LANGUAGE_KEY, preview_lang)
weights = rand_data.weights g = GaussianMixture(weights_init=weights, n_components=n_components) g.fit(X) assert_array_equal(weights, g.weights_init)
for child_hierarchy in block_hierarchy.get('#children', []): self.add_parents(child_hierarchy, block_map)
history = HistoricalRecords()
unique_together = ('username', 'course', 'provider') get_latest_by = 'created'
self.verify_server_task("studio", options)
if xblock.category == 'chapter': return None
preprocessor = ZCA(filter_bias=0.0, n_components=3) preprocessed_X = self.get_preprocessed_data(preprocessor)
default_test_id = ( "{system}/djangoapps/*" " common/djangoapps/*" " openedx/core/djangoapps/*" " openedx/tests/*" " openedx/core/lib/*" )
from __future__ import unicode_literals
input_dict = {'1_2_1': '0'} correct_map = problem.grade_answers(input_dict)
with patch('xmodule.capa_module.CapaModule.get_problem_html') as mock_html: mock_html.return_value = "<div>Test HTML</div>"
client.user_credentials.post({ 'username': username, 'credential': {'program_id': program_id}, 'attributes': [] })
del subobj gc.collect()
paver.easy.sh("exit 1")
self.url = reverse( self.url_endpoint_name, kwargs={'username': self.user.username, 'preference_key': preference_key} )
call_command('manage_group', TEST_GROUP, '--remove') self.check_groups([])
clf = ARDRegression(compute_score=True) clf.fit(X, y)
result = ExampleCertificateSet.latest_status(self.COURSE_KEY) self.assertIs(result, None)
self._count += 1 self._apply_learning_rate(algorithm)
self.assertTrue(hasattr(course_overview, 'image_set')) self.assertEqual(course_overview.image_set.small_url, '') self.assertEqual(course_overview.image_set.large_url, '')
courses = self.get_courses() return [course.location.course_key for course in courses if course.wiki_slug == wiki_slug]
from __future__ import unicode_literals
url_path = embargo_api.message_url_path(self.course.id, access_point)
def is_browser_on_page(self): return self.q(css='body.view-subsection').present
return { 'is_cohorted': True, 'always_cohort_inline_discussions': True, 'cohorted_inline_discussions': [], 'cohorted_course_wide_discussions': [], 'id': 1 }
self.assertEqual( len(CourseEnrollment.objects.filter(mode='honor', user_id__in=real_user_ids)), expected_success )
if enum_value == cls.released: return cls.LAST_MONTH elif enum_value == cls.future: return cls.NEXT_MONTH else: return DEFAULT_START_DATE
response_dict = self._get_page_data(response) self.assertEqual(response_dict['course_mode_slug'], expected_mode)
assert_equal(5, KFold(5).get_n_splits(X2))
return self.q(css='.create-user-button').present
result = self.client.login(username=self.USERNAME, password=self.OLD_PASSWORD) self.assertTrue(result)
course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
self.cohort_management_page.select_cohort_some_inline_discussion() self.assertFalse(self.cohort_management_page.is_save_button_disabled(self.inline_key)) self.assertFalse(self.cohort_management_page.inline_discussion_topics_disabled())
SERVICE_VARIANT = os.environ.get('SERVICE_VARIANT', None)
([CourseMode.VERIFIED, CourseMode.AUDIT], CourseMode.DEFAULT_MODE_SLUG),
self._assert_chapter_loaded(self.course, self.chapter)
with self.assertRaises(ResponseError): problem.grade_answers({'1_2_1': '42'})
return AccountLegacyProfileSerializer.convert_empty_to_None(value)
self.payment_and_verification_flow.proceed_to_payment()
assert_equal(l[train].size + l[test].size, l.size)
#latex_preamble = ''
finish_time = time() self._ddog_histogram(evt_time, 'get_many.blks_out', block_count) self._ddog_histogram(evt_time, 'get_many.response_time', (finish_time - evt_time) * 1000)
new_user = authenticate(username=user.username, password=params['password']) login(request, new_user) request.session.set_expiry(0)
if netloc: return url
status = certs_api.example_certificates_status(self.course.id) self.assertIsNot(status, None)
with patch('student.models.cc.User.save'): uname = 'student' email = 'student@edx.org'
field_data['attempts'] = int(attempts)
msg = "no doc impacting files detected:\n" + u"\n".join(filenames) exit(msg, skip=True)
recomposed_video_tag = CourseDetails.recompose_video_tag(video_id) cls.update_about_item(course, 'video', recomposed_video_tag, user_id)
return self._folds[k]
_mock_count.return_value = None with self.assertRaises(SystemExit): call_task('pavelib.quality.run_safecommit_report')
return is_active and enrollment_mode in CourseMode.UPSELL_TO_VERIFIED_MODES
module = CapaFactory.create(max_attempts=0, done=False) self.assertTrue(module.should_show_save_button())
X -= X.mean(axis=0) y -= y.mean()
self.should_fetch_course = kwargs.get('should_fetch_course') self.imports_dir = path('test_root/courses/')
return self.q(css='a[data-section=student_admin].active-section').present
from openedx.core.djangoapps.ccxcon import tasks tasks.update_ccxcon.delay(unicode(course_key))
return "str(random.randint(0, 1e9))"
problem_location = self.problem_location(problem_url_name) modx_url = self.modx_url(problem_location, 'problem_show') resp = self.client.post(modx_url) return resp
STUDIO_EDIT_ROLES = 8 STUDIO_VIEW_USERS = 4 STUDIO_EDIT_CONTENT = 2 STUDIO_VIEW_CONTENT = 1
for section in self.sections(): if section.is_collapsed: section.expand_subsection() for subsection in section.subsections(): if subsection.is_collapsed: subsection.expand_subsection()
if is_request_from_mobile_app(request): return HttpResponse(status=401)
latex_logo = "logos/scikit-learn-logo.png"
if settings.FEATURES["ENABLE_SYSADMIN_DASHBOARD"]: urlpatterns += ( url(r'^sysadmin/', include('dashboard.sysadmin_urls')), )
self.problem_page.q( css='div.problem input.ctinput[type="text"]' ).nth(input_num).fill(value)
i18n = self.runtime.service(self, "i18n") return course_metadata_utils.course_start_datetime_text( self.start, self.advertised_start, format_string, i18n.ugettext, i18n.strftime )
json_resp = json.loads(resp.content) self.assertEqual(json_resp.get('total_cost'), self.cart.total_cost)
for train, test in cval.LabelKFold(labels, n_folds=n_folds): assert_equal(len(np.intersect1d(labels[train], labels[test])), 0)
return course.display_name_with_default.replace('<', '&lt;').replace('>', '&gt;')
published_xblock2 = self.store.create_item( self.user_id, self.course.id, 'vertical', block_id='test_vertical' )
self.assertIsNone(response.data[field_name])
ps_uncached = self._create_service(username)
if error == 0: self.input_state['queuekey'] = queuekey self.input_state['queuestate'] = 'queued' self.input_state['queuetime'] = time.time()
self.X_topo_space = self.view_converter.topo_space assert not contains_nan(self.X)
if role is not None: role().add_users(user)
'mobile_api', 'social.apps.django_app.default',
if not self or not other: return False
password = generate_unique_password(generated_passwords) errors = create_and_enroll_user( email, username, name, country, password, course_id, course_mode, request.user, email_params ) row_errors.extend(errors)
src_dir = os.path.join(sys.prefix, "src") if os.path.isdir(src_dir): files_to_fingerprint.append(src_dir)
self.assertEqual(self.account_settings_page.title_for_field(field_id), title) self.assertEqual(self.account_settings_page.value_for_readonly_field(field_id), value)
return os.path.realpath(module.__path__[0])
courses = CourseOverview.get_all_courses( org=org, filter_=filter_, ) if org == microsite_org else []
course = self.create_course_with_orphans(module_store)
X_, y_ = make_classification(n_samples=200, n_features=100, weights=[0.833, 0.167], random_state=0)
assert_raises(ValueError, k_means, X, n_clusters=X.shape[0] + 1)
cls.create_and_enroll_student( courses=[cls.test_course_1, cls.test_course_2], username='student_enrolled_both_courses_other_team' )
tsne = TSNE(metric="precomputed") assert_raises_regexp(ValueError, ".* square distance matrix", tsne.fit_transform, np.array([[0.0], [1.0]]))
return usage_id
return self.q(css='.prompt.error').visible
self.track_selection_page.visit()
return self.teams_configuration.get('topics', None)
problem1_content_before_switch = self.problem_page.problem_content
xx = np.atleast_2d(np.linspace(0, 10, 1000)).T xx = xx.astype(np.float32)
return 'dval'
correct_error_message_text = 'No playable video sources found.' self.assertIn(correct_error_message_text, self.video.error_message_text)
if answers:
world.browser.execute_script('window.prompt = function(){return %s;}') % prompt
self.video.wait_for_state(state)
with open(self.TEST_INDEX_FILENAME, "w+") as index_file: json.dump({}, index_file)
check_ortho(pls_ca.x_weights_, "x weights are not orthogonal") check_ortho(pls_ca.y_weights_, "y weights are not orthogonal")
score = float(score) if not 0 <= score <= 1: raise LTIError('score value outside the permitted range of 0-1.')
return dict(zip( header_row, [ unicode(user.id), user.email, user.username, ] + grade ))
d = dr + 1.0j * di
if self.chapter: return self._find_block(self.chapter, self.section_url_name, 'section')
self.assertEqual( course_overview.image_urls, { 'raw': expected_url, 'small': expected_url, 'large': expected_url, } ) return course_overview
n_samples_per_label = np.bincount(labels)
return ProviderApiPermissions.objects.create(client=client, provider_id=provider_id)
self.click_button('create_video', require_notification=True) self.wait_for_video_component_render()
self._closed_captions_visibility(False)
test_invalid_token("AAAAAAAAAAA=", "initialization_vector")
CourseEnrollment.enroll(self.user, self.course_key, 'verified') ret_val = CourseEnrollment.unenroll(self.user, self.course_key) self.assertFalse(ret_val)
ups[self.annealed] = annealed ups[self.iteration] = self.iteration + 1
response = self.session.post( STUDIO_BASE_URL + '/course/', data=self._encode_post_dict(self._course_dict), headers=self.headers )
X, y = make_blobs(n_samples=100, centers=10) brc = Birch(n_clusters=10) brc.fit(X)
os.remove(filename)
gd = grid_dimension[0] grid_indices[gd] = add_mod(grid_indices[gd], step, len(grid_to_short_label[gd]))
self.assertFalse(self.page.experiment_group_configurations[0].is_expanded) self.assertTrue(self.page.experiment_group_configurations[1].is_expanded)
self.q(css='.action-edit-members').first.click() self.wait_for_ajax()
self.assertIn(orphan, self.store.get_orphans(course.id))
if self.find_css('.collection-edit').present: return 'edit' elif self.find_css('.collection').present: return 'details'
return self.file_errors
self.assertSessionLangEquals( 'rel', self.process_request(preview_lang='rel') )
self._discussion_page = InlineDiscussionPage(self.browser, self.discussion_id)
if is_order_type_business: email.content_subtype = "html"
if isinstance(arg, XBlock): return unicode(arg.location) else: return unicode(arg)
self.mock_block.service_declaration.return_value = None with self.assertRaises(NoSuchServiceError): self.runtime.service(self.mock_block, 'i18n')
if self._build_requests_plus_30_for_minus_30(): if self._user_requested_plus_30_skip(): self.event[u'requested_skip_interval'] = -30
return ( {"cohort_id": cohort.id, "cohort_name": cohort.name, "user_id": user_id} for user_id in user_id_iter for cohort in cohort_iter )
mode_slug = models.CharField(max_length=100, verbose_name=_("Mode"))
obj = UTC.localize(obj)
resp = self.client.put( '/shoppingcart/payment_fake', data="failure", content_type='text/plain' ) self.assertEqual(resp.status_code, 200)
cond = np.logical_or(y == i, y == j) y = y[cond] y_binary = np.zeros_like(y) y_binary[y == j] = 1 return _partial_fit_binary(estimator, X[cond], y_binary)
self.q(css=self._bounded_selector(self.ADD_BUTTON_SELECTOR)).click()
self.emails_sent += new_subtask_status.succeeded return update_subtask_status(entry_id, current_task_id, new_subtask_status)
'API': 'https://www.youtube.com/iframe_api',
self.check_event_response_by_key( 'add_resource', self.test_recommendations[self.resource_id], 'id', self.resource_id )
return _check_range_and_return('horizontal shift', label, -5, 5)
def __init__(self, *args, **kwargs): if "resolve_entities" not in kwargs: kwargs["resolve_entities"] = False super(XMLParser, self).__init__(*args, **kwargs)
clf = AdaBoostRegressor(n_estimators=10, random_state=0) clf.fit(boston.data, boston.target, sample_weight=boston_weights)
self.create_programs_config(enable_certification=False) self._verify_response(400)
inputs = SparseType('csr', dtype=theano.config.floatX)() return theano.function([inputs], self(inputs), name=name)
return self.best_estimator_.transform(X)
import matplotlib.pyplot as plt plt.figure()
lr_tracker = LearningRateTracker() algorithm = SGD(learning_rate, cost, batch_size=batch_size, monitoring_batches=3, monitoring_dataset=monitoring_dataset, termination_criterion=termination_criterion, update_callbacks=[linear_decay, lr_tracker], set_batch_size=False)
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
if isinstance(block_locator.block_id, LocalId): self.local_modules[block_locator] = module
if (best_candidate is None) or (new_pot < best_pot): best_candidate = candidate_ids[trial] best_pot = new_pot best_dist_sq = new_dist_sq
course_key = 'non/existing/keyone' error_msg = u"Course {} does not exist.".format(course_key) with self.assertRaisesRegexp(serializers.ValidationError, error_msg): validate_course_id(course_key)
self.assertEqual(self.cart.total_cost, self.get_discount(self.cost))
is_microsite.return_value = True is_enabled = EcommerceService().is_enabled(self.user) self.assertTrue(is_enabled)
return survey_link.format(UNIQUE_ID=unique_id_for_user(user))
'openedx.core.djangoapps.self_paced',
raise NotImplementedError
if request.user.is_staff: return True user = get_object_or_404(User, username__iexact=url_username) if field_name in visible_fields(user.profile, user): return True raise Http404()
rng = np.random.RandomState(seed) X = rng.randn(10, 10) Xcsr = csr_matrix(X)
assert_raises(AssertionError, assert_raise_message, (ValueError, AttributeError), "test", _no_raise)
try: validate_uploaded_image(uploaded_file) except ImageValidationError as error: return Response( {"developer_message": error.message, "user_message": error.user_message}, status=status.HTTP_400_BAD_REQUEST, )
if not assume_centered: X = X - X.mean(0)
raise NotImplementedError()
if "full_name" in params: response = self._update_full_name(request.user, params["full_name"]) if response is not None: return response
message = "<script>alert('XSS');</script>" x = "<string>{}</strong>".format(message)
assert_raises(ValueError, gs.fit, X, y)
query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(now, query) self.assertIs(result, None)
rng = np.random.RandomState(0) rand_data = RandomData(rng, scale=5) n_samples = rand_data.n_samples n_features = rand_data.n_features n_components = rand_data.n_components
lr_tracker = LearningRateTracker() algorithm = SGD(learning_rate, cost, batch_size=batch_size, monitoring_batches=3, monitoring_dataset=monitoring_dataset, termination_criterion=termination_criterion, update_callbacks=[annealed_rate, lr_tracker], set_batch_size=False)
return BlockUsageLocator( course_key=self.course_key, block_type=block_type, block_id=block_id )
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
for mode in unexpired_modes[course_key]: if mode.min_price > 0 and not CourseMode.is_credit_mode(mode): return mode
response = self.post_with_bearer_token('/oauth2-test/') self.assertEqual(response.status_code, status.HTTP_200_OK)
dataset = obj
return self.q(css='.course-number-override')
S = cosine_similarity(X, Y) S *= -1 S += 1 return S
self.create_credentials_config() self.mock_credentials_api(self.user) actual = get_user_credentials(self.user) self.assertEqual(actual, self.CREDENTIALS_API_RESPONSE['results'])
task_progress['traceback'] = traceback_string
with self.settings(MODULESTORE_BRANCH='published-only'): for cache in settings.CACHES: caches[cache].clear()
if 'openid_error' in request.session: error = True del request.session['openid_error']
REQUIRE_STANDALONE_MODULES = {}
return self.q(css='.prompt.{dialog_type} .message'.format(dialog_type=dialog_type)).text[0]
self.runtime.set('location', self.location.to_deprecated_string())
for example in NON_ARRAY_LIKE_EXAMPLES: assert_raises(ValueError, unique_labels, example)
child_pids = p1_group.get_children(recursive=True)
self.course_hierarchy = self.get_course_hierarchy() self.blocks = self.build_course(self.course_hierarchy) self.course = self.blocks['course']
return self.conditional.log_conditional(X, theta)
_('Git Commit'), _('Last Change'), _('Last Editor')],
course_image_url = TextField() social_sharing_url = TextField(null=True) end_of_course_survey_url = TextField(null=True)
self.emit_event(EVENT_NAME_ENROLLMENT_MODE_CHANGED)
source_store.copy_all_asset_metadata(source_course_key, dest_course_key, user_id)
def get_asides(self, block): return []
for label in np.unique(labels): assert_equal(len(np.unique(folds[labels == label])), 1)
CREDIT_HELP_LINK_URL = "#"
raise NotImplementedError
return signature[start:end] + 'x' * (end - start) + signature[end:]
raise NotImplementedError(str(type(self))+" does not implement plot.")
self.assertEqual(self.captured_request.POST.get("course_id"), "edX/DemoX/Fall")
self.check_val('false', False)
call_command('seed_permissions_roles', unicode(self.course_id))
set_credit_requirement_status( user.username, course_key, 'reverification', checkpoint.checkpoint_location, status='declined' )
_sparse_kernels = ["linear", "poly", "rbf", "sigmoid", "precomputed"]
np.testing.assert_equal(mlp.get_total_input_dimension(['h0', 'h1']), 4) inp = theano.tensor.matrix()
if self.data: field_data = self._parse_video_xml(etree.fromstring(self.data)) self._field_data.set_many(self, field_data) del self.data
for course_id, store in self.mappings.iteritems(): candidate_key = store.make_course_key(org, course, run) if candidate_key == course_id: return candidate_key
stack = [descriptor] while len(stack) > 0: next_descriptor = stack.pop() stack.extend(get_dynamic_descriptor_children(next_descriptor, user_id, module_creator)) yield next_descriptor
self.assert_grade_requirement_status(None, 0)
mock_results = MagicMock(return_value=[result_factory(n) for n in range(5)]) with patch.object(StudentModule, 'objects') as patched_manager: patched_manager.filter.return_value = mock_results
self.children = []
print(grid_search.grid_scores_)
return self.best_estimator_.transform(Xt)
pairs, target, target_names = load_func( index_file_path, data_folder_path, resize=resize, color=color, slice_=slice_)
self.make_course(pdf_textbooks=[PDF_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('pdf_book', book_index=0, chapter='fooey', page='xyzzy')
return self.q(css=self._bounded_selector('.notoggleforyou')).present
return self.oauth2_adapter.create_public_client( name='Test Public Application', user=user, client_id=client_id, redirect_uri=DUMMY_REDIRECT_URL, )
revoke_access(course_ccx, staff, 'staff')
unmodified_overview = CourseOverview.get_from_id(course.id) self.assertEqual(unmodified_overview.version, 11)
css_click('#{}'.format(elem_id))
request = self.factory.get('/login') request.META['HTTP_REFERER'] = referer return request
xmin = TT.switch(cond, constant(numpy.nan), a + (-B + TT.sqrt(radical)) / (3 * A)) return xmin
[heappush(inertia, (ini[idx], k, coord_col[idx])) for idx in range(n_additions)]
for extension in self.cv_extensions: extension.setup(self.trainers)
labels = np.array([1, 1, 1, 2, 2]) assert_raises(ValueError, cval.LabelKFold, labels, n_folds=3)
CourseEnrollment.enroll(user_who_created_course, course_key)
if self.act_enc is None: act_enc = lambda x: x else: act_enc = self.act_enc return act_enc(self._hidden_input(x))
plt.figure(fignum, figsize=(9, 10))
return self.transform(T)
response = self._change_password() self.assertEqual(response.status_code, 200)
try: face = sp.face(gray=True) except AttributeError: from scipy import misc face = misc.face(gray=True)
fields['advertised_start'] = None
self.mock_module = MagicMock() self.mock_module.id = 1 self.dispatch = 'score_update'
iris = load_iris() score = cross_val_score(rfe, iris.data, iris.target) assert_greater(score.min(), .7)
false_discovery_rate = np.mean([single_fdr(alpha, n_informative, random_state) for random_state in range(30)]) assert_greater_equal(alpha, false_discovery_rate)
ActionChains(self.browser).move_to_element(self.element).click().perform() return self
EmptyPromise( lambda: self.outline_page.is_browser_on_page(), "loaded page {!r}".format(self.outline_page), timeout=30 ).fulfill()
self.assertFalse(UserPreference.objects.filter(user=user, key=NOTIFICATION_PREF_KEY)) request = self.request_factory.get("dummy") request.user = AnonymousUser()
DARK_LANGUAGE_KEY = 'dark-lang'
return (field_object.module_type, field_object.field_name)
with course_run_policy_dir.open('grading_policy.json', 'w') as grading_policy: grading_policy.write(dumps(courselike.grading_policy, cls=EdxJSONEncoder, sort_keys=True, indent=4))
master_doc = 'index'
self.test_b_grade_exact()
if which_set in ['train', 'test']: data_x, data_y = load_data("{0}{1}_32x32.mat".format(path, which_set))
weight_cdf = self.estimator_weights_[sorted_idx].cumsum(axis=1) median_or_above = weight_cdf >= 0.5 * weight_cdf[:, -1][:, np.newaxis] median_idx = median_or_above.argmax(axis=1)
n_samples_train, n_samples_test, n_features = 75, 150, 500 np.random.seed(0) coef = np.random.randn(n_features)
Group(name=settings.PAYMENT_REPORT_GENERATOR_GROUP).save() self.assertFalse(_can_download_report(self.user))
data = JUNK_FOOD_DOCS + NOTJUNK_FOOD_DOCS
self.dot_access_token.expires = datetime.utcnow() - timedelta(weeks=1) self.dot_access_token.save() self.assert_oauth_status(self.dot_access_token, status.HTTP_401_UNAUTHORIZED)
self.addCleanup(mock_sh.stop)
removed_tab = tab_ids.pop(num_orig_tabs / 2) self.assertTrue(len(tab_ids) == num_orig_tabs - 1)
metadata_to_inherit = self.cached_metadata.get(unicode(non_draft_loc), {}) inherit_metadata(module, metadata_to_inherit)
pass
if not is_credit_course(course_key): return
self.get_data_specs(model)[0].validate(data) return None
gs = GridSearchCV(clf, [{'parameter': [0, 1, 2]}], scoring='accuracy', refit=False, error_score='raise')
raise ValueError("Cannot use a custom kernel function. " "Precompute the kernel matrix instead.")
if sp.issparse(predictions[0]): predictions = sp.vstack(predictions, format=predictions[0].format) else: predictions = np.concatenate(predictions) return predictions[inv_test_indices]
textvalue = "x^2+2*x+y" if correct else 'x^2' self.problem_page.fill_answer(textvalue)
return u"{verification_reminder} {refund_reminder}".format( verification_reminder=verification_reminder, refund_reminder=refund_reminder )
kwargs.pop('_view_name')
connectivity = grid_to_graph(*face.shape)
assert x.ndim == 4 x_axes = self.input_axes assert len(x_axes) == 4
return None if value == "" else value
self.assertNotIn('Search for a course', response.content)
pass
students = self._create_students(5)
d = TreeEstimator(random_state=0, max_depth=max_depth).fit(X, y) s = TreeEstimator(random_state=0, max_depth=max_depth).fit(X_sparse, y)
self.courseware_page.visit() self.courseware_page.wait_for_page() self.assertFalse(element_has_text( page=self.courseware_page, css_selector=entrance_exam_link_selector, text='Entrance Exam' ))
for email in ('bad_email', 'bad_email@', '@bad_email'): self.assertEqual(self.do_email_validation(email), 'Valid e-mail address required.')
xi_, yi, swi, idx = dataset._random_py() xi = sp.csr_matrix((xi_), shape=(1, X.shape[1]))
data_home = get_data_home(data_home=data_home) data_home = join(data_home, 'mldata') if not exists(data_home): os.makedirs(data_home)
email.to_option = next( ( t_type for t_type in ( target.target_type for target in email.targets.all() ) if t_type in EMAIL_TARGETS ), SEND_TO_MYSELF ) email.save()
with Timer() as iteration_over_groups_time_1: courses_list, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(len(courses_list), USER_COURSES_COUNT)
selector = self.get_element_selector(VIDEO_MENUS['transcript-skip']) return self.q(css=selector).visible
self.assert_enrollment_activation(False, selected_mode)
raise NotImplementedError(str(self.__class__) + " does not implement " "conditional_expectation.")
raise CoursewareAccessException(access_response)
CLIENT_NAME = "edx-notes" DEFAULT_PAGE = 1 DEFAULT_PAGE_SIZE = 25
self.assertEqual(len(mail.outbox), 0)
AutoAuthPage(self.browser, course_id=self.course_id).visit()
if request.user.is_authenticated(): return redirect(redirect_to)
del self.lc_block._xmodule._selected_set
'edxval',
list_staff_master_course = list_with_level(self.course, 'staff') list_instructor_master_course = list_with_level(self.course, 'instructor')
return None, phi_a1
import Tkinter as Tk
from __future__ import unicode_literals
student = require_student_from_identifier(request.GET.get('student')) course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id)) return JsonResponse(dump_student_extensions(course, student))
self.page = CourseTeamPage( self.browser, self.course_info['org'], self.course_info['number'], self.course_info['run'] ) self._go_to_course_team_page()
self.course.html_textbooks = [] self.assertNotIn( {'type': 'html_textbooks'}, list(xmodule_tabs.CourseTabList.iterate_displayable(self.course, inline_collections=False)), )
self.assertFalse(auth.user_has_role(self.user, CourseCreatorRole()))
auth = self._create_authorization_header(token) return self.csrf_client.post(target_url, HTTP_AUTHORIZATION=auth)
video_url = world.browser.url
form = self._admin_form(course_mode) self._set_form_verification_deadline(form, self.VERIFICATION_DEADLINE) self._assert_form_has_error(form, "Verification deadline can be set only for verified modes.")
X = self._check_non_neg_array(X, "LatentDirichletAllocation.score") doc_topic_distr = self.transform(X) score = self._approx_bound(X, doc_topic_distr, sub_sampling=False) return score
assert_almost_equal(clf.coef_, clf_weighted.coef_, decimal=2)
self.assertEqual(expected_title, unit.release_title) self.assertEqual(expected_date, unit.release_date)
unlink_cohort_partition_group( test_cohort, ) self.assert_student_in_group(None)
course_keys = CourseOverview.get_all_course_keys() for expected_course_key in courses: self.assertNotIn(expected_course_key, course_keys)
student = request.user
self.unit_page = None
unicode_text = "好 各位同学".decode('utf-8') self.assertTrue(self.video.downloaded_transcript_contains_text('srt', unicode_text))
LogoutPage(self.browser).visit() self._auto_auth("STAFF_TESTER", "staff101@example.com", True) self.course_outline.visit()
config_course_cohorts( course, is_cohorted=True, auto_cohorts=["AutoGroup"] )
user = StaffFactory.create(course_key=course.id) self.assertTrue(access._has_access_course(user, 'enroll', course))
return settings.FEATURES.get('USE_MICROSITES', False)
for k in xrange(n_folds): this_blocks = [] for i, layer in enumerate(layers): this_blocks.append(layer[k]) this_stacked_blocks = StackedBlocks(this_blocks) stacked_blocks.append(this_stacked_blocks)
get_edx_api_data(program_config, self.user, 'programs', cache_key=cache_key) get_edx_api_data(program_config, self.user, 'programs', resource_id=resource_id, cache_key=cache_key)
self.assertTrue(self.video.select_language('zh'))
return uuid4().hex.decode('ascii')
n_samples, n_features = iris.data.shape target = iris.target_names[iris.target] clf = LogisticRegression(random_state=0).fit(iris.data, target)
if sp.issparse(X): return inertia, _k_means._mini_batch_update_csr( X, x_squared_norms, centers, counts, nearest_center, old_center_buffer, compute_squared_diff)
return Fragment(content=u"<div>Nothing here. Move along.</div>")
for database_name in DATABASES: DATABASES[database_name]['ATOMIC_REQUESTS'] = False
[adapt_references(child, destination_course_key, export_fs) for child in subtree.get_children()]
nsqrt = sqrt(n_samples) llconst = n_features * log(2. * np.pi) + n_components var = np.var(X, axis=0)
self.assertContains(resp, 'payment-button')
self.current_view = self.MAPPING["search"](self.browser) if text.strip(): self.current_view.wait_for_page()
if y is None: return self.fit(X, **fit_params).transform(X) else: return self.fit(X, y, **fit_params).transform(X)
shutil.rmtree(root_dir)
from yaml import Loader, SafeLoader
continue
if key == "ROOT" or key == "COURSES": continue
reraise_as("Couldn't open {0}".format(filepath))
'METADATA_URL': 'https://www.googleapis.com/youtube/v3/videos',
if not multilabel: labels = frombuffer_empty(labels, np.float64) data = frombuffer_empty(data, actual_dtype) indices = frombuffer_empty(ind, np.intc)
lock_content = cls.create_image(prefix, (32, 32), 'green', '{}_lock.png', locked=True)
self.assertFalse(hasattr(course_overview, 'image_set'))
E = np.empty(0) assert_raises(ValueError, _fast_dot, E, E)
my_stdout = my_stdout.replace( my_globals['__doc__'], '')
LINEAR_CHILDREN_MAP = [[1], [2], [3], []]
return Client.objects.create( client_id=self.client_id, client_type=PUBLIC, )
self.prob1 = ItemFactory.create( parent_location=self.vert1.location, category='problem', display_name='untitled problem 1' )
cause_copy = sharedX(np.zeros((num_samples,))).dimshuffle(0,'x') v_state = v_state[0,:] + cause_copy y_state = y_state[0,:] + cause_copy
self.assertIn("'position': {}".format(expected_position), rendered_html)
self.lcp.ungraded_response(score_msg, queuekey) self.set_state_from_lcp() return dict()
self.q(css=self._bounded_selector("div.form-actions .action-save")).first.click()
payment_data = payment_data['payment_form_data']
X, y = hastie_X, hastie_y ForestEstimator = FOREST_ESTIMATORS[name] clf = ForestEstimator(n_estimators=5, max_depth=1, warm_start=False, random_state=1) clf.fit(X, y)
if (isinstance(self, SparseSGDClassifierTestCase) or isinstance(self, SparseSGDRegressorTestCase)): decay = .01
self.module_system.process_xml = Mock()
ccx = CustomCourseForEdX.objects.get() course_enrollments = get_override_for_ccx(ccx, self.course, 'max_student_enrollments_allowed') self.assertEqual(course_enrollments, settings.CCX_MAX_STUDENTS_ALLOWED)
return self.q(css='.wrapper-alert.is-shown').is_present()
return self.output_space
get_request_dict = {} result = module.reset_problem(get_request_dict)
self.assertEqual(len(httpretty.httpretty.latest_requests), 1)
self.make_course(pdf_textbooks=[PDF_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('pdf_book', book_index='fooey', chapter=1)
del self.bias_from_marginals
partition.scheme.set_group_for_user(user, partition, group)
saved_fields.extend(key.field_name for key in set_many_data)
page_num = ((offset / MAX_STUDENTS_PER_PAGE_GRADE_BOOK) + 1)
user = self.create_user_and_enroll('verified') self.add_verification_status(user, VerificationStatus.APPROVED_STATUS) with self.assertNumQueries(4): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
self.factory(loss="foobar")
key = safe_key('key', 'prefix', 'a' * 300) self.assertTrue(self._is_valid_key(key))
np.array([[[0, 1], [2, 3]], [[4, 5], [6, 7]]]),
for average in ['macro', 'weighted', 'micro']: assert_not_equal(recall_13(average=average), recall_all(average=average))
return key.block_scope_id
course_key = CourseKey.from_string(course_id) certs_api.generate_example_certificates(course_key) return redirect(_instructor_dash_url(course_key, section='certificates'))
A = rng.random_sample([2, 2]) for dtype in ['f8', 'f4']: A = A.astype(dtype) B = B.astype(dtype)
with patch('capa.capa_problem.LoncapaProblem.grade_answers') as mock_grade: mock_grade.side_effect = exception_class('test error')
self.assertEqual(views.get_cosmetic_display_price(self.course, registration_price), "Free")
self.colors = [np.asarray([1, 1, 0]), np.asarray([1, 0, 1]), np.asarray([0, 1, 0])]
cv = check_cv(self.cv, classifier=False)
rng = check_random_state(0) n_features = 5 n_samples = 50 n_output = 3
return self._check_login_or_register_page(self.register_page_url, "registerUrl")
content = self.get_courseware_page().content self.assertTrue(self.sequential_display_name in content, "Subsection should be visible") self.assertEqual(staff_debug_expected, 'Staff Debug Info' in content)
pstate['sg2'] += param_val ** 2 dx_t = - (scale * learning_rate / np.sqrt(pstate['sg2']) * param_val) rval += [param_val + dx_t]
params = estimator.get_params() original_params = deepcopy(params)
mmd = min_dists.mean()
first_name_label = _(u"First Name")
category_msgs = msg_dict[category] for category_msg in category_msgs: msg.append(message_dict[(category, category_msg)])
DEBUG_TOOLBAR_MONGO_STACKTRACES = False
__ = CourseOverview.get_from_id(self.course.id)
return descriptor.location.library_key
assert_raises(ValueError, _fast_dot, A.T, np.array([A, A]))
SEARCH_ENGINE = "search.tests.mock_search_engine.MockSearchEngine"
with with_edx_domain_context(is_edx_domain): response = self.client.get(reverse(url_name), params)
textvalue = "pi + 1" if correct else str(random.randint(-2, 2)) self.problem_page.fill_answer(textvalue)
iris = datasets.load_iris() rng = check_random_state(42) perm = rng.permutation(iris.target.size) iris.data = iris.data[perm] iris.target = iris.target[perm]
indexed_count = self.reindex_course(store) self.assertFalse(indexed_count)
coef = safe_sparse_dot(self.dual_coef_, self.support_vectors_)
self.update_masquerade(role='student', user_name=self.student_user.username) self.assertEqual(self.get_progress_detail(), u'2/2')
msg = "Wait for status to be {}".format(status) selector = ', '.join(self.status_indicators[status]) self.problem_page.wait_for_element_visibility(selector, msg)
self.client.logout()
next_offset = None
p.join()
return len(self.q(css=self.subsection_selector))
query = self.q(css=self._bounded_selector('.copy-error')) if query.visible: return query.text[0] return ''
modal = self.edit() modal.is_explicitly_locked = is_locked modal.save()
face = face.mean(axis=2)
return self.error_msg
full_segment_event = request.json
BULK_EMAIL_ROUTING_KEY_SMALL_JOBS = LOW_PRIORITY_QUEUE
revoke_access(course_ccx, instructor, 'instructor')
return os.geteuid()==0
return _is_batch_all(batch, lambda x: isinstance(x, theano.gof.Variable))
if data.get('essential'): return super(IDTokenHandler, self).claim_instructor_courses(data) else: return None
assert_raises(ValueError, check_symmetric, arr_bad)
if (i + 1) != (self.n_layers_ - 1): activations[i + 1] = hidden_activation(activations[i + 1])
cache_key = cls.CACHE_KEY.format(course_key=course_key) cache.delete(cache_key) log.info("Invalidated country access list for course %s", course_key)
epoch_num = 6 termination_criterion = EpochCounter(epoch_num)
status_code = status.HTTP_400_BAD_REQUEST
from .tasks import update_course_structure
return self.best_estimator_.predict(X)
click_css(self, 'a.delete-button', source_index, require_notification=False) confirm_prompt(self)
yield prev_end, "E225 missing whitespace around operator"
self._optimizer.iteration_ends(self.t_)
req_status = api.get_credit_requirement_status(self.course_key, "bob", namespace="grade", name="grade") self.assertEqual(req_status, [])
Env.METRICS_DIR.makedirs_p() _prepare_report_dir(complexity_report_dir)
OverrideFieldData.provider_classes = None
current_subs = data.get('current_subs') if current_subs is not None: for sub in current_subs: remove_subs_from_store(sub, item)
self.assertProfessionalModeBypassed()
with check_exact_number_of_calls(store, '_get_cached_metadata_inheritance_tree', 1):
INSTALLED_APPS += ('django_extensions',)
CourseEnrollmentFactory.create(user=self.user, course_id=self.course.id, is_active=True)
del params["email"] assert_email_error("A properly formatted e-mail is required")
g.precisions_init = rand_data.precisions[covar_type] g.fit(X) assert_array_equal(rand_data.precisions[covar_type], g.precisions_init)
tstart = datetime.now() clf = DecisionTreeRegressor() clf.fit(X, Y).predict(X) delta = (datetime.now() - tstart)
course.mobile_available = False with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred): self.store.update_item(course, ModuleStoreEnum.UserID.test)
css = {'scss': [resource_string(__name__, 'css/codemirror/codemirror.scss')]} js = {'coffee': [resource_string(__name__, 'js/src/raw/edit/json.coffee')]} js_module_name = "JSONEditingDescriptor"
self.settings_patcher = patch.dict('django.conf.settings.FEATURES', {'MILESTONES_APP': True}) self.settings_patcher.start()
self.assertEqual(len(self.store.get_orphans(course_key)), number)
link_cohort_to_partition_group( cohort, self.user_partition.id, self.groups[0].id, )
users = [UserFactory() for _ in range(3)] self._enroll_users(users, self.course.id)
MOBILE_STORE_URLS = { 'apple': '#', 'google': '#' }
assert_array_almost_equal((tfidf ** 2).sum(axis=1), [1., 1., 1.])
self.certificates_section.wait_for_certificate_exceptions_section()
urls = { 'raw': raw_image_url, 'small': raw_image_url, 'large': raw_image_url, }
self.assert_has_xpath(xml_root, xpath, context_dict, exact_num=0)
items = self.store.get_items(course_key) self.assertIn(orphan, [item.location for item in items]) self.assertEqual(len(items), 3)
self.assertFalse([ requirement for requirement in requirements if requirement['namespace'] == 'proctored_exam' ])
self.client.login(username=self.student.username, password=self.PASSWORD) response = self.client.get(reverse("dashboard"))
multi_db = True
self._epochs_seen += 1
return ''
for block in blocks: if blocks[block]['block_type'] == 'sequential': block_format = blocks[block]['format'] if block_format not in assignments: assignments[block_format] = OrderedDict() assignments[block_format][block] = list()
try: certificate_invalidation_data = parse_request_data(request) certificate = validate_request_data_and_get_certificate(certificate_invalidation_data, course_key) except ValueError as error: return JsonResponse({'message': error.message}, status=400)
from __future__ import unicode_literals
self._ddog_histogram(evt_time, 'set_many.fields_in', len(state))
self.notes_page.wait_for_ajax() note = self.notes_page.notes[1] assert_page(note, self.raw_note_list[2]['usage_id'], "Location in Course")
row_items = [E.TD(x) for x in items] self.table.append(E.TR(*row_items))
super(CacheBackedAuthenticationMiddleware, self).process_request(request)
if depth is not None: depth -= 1
cache.clear()
try: return request.user.username except AttributeError: return ''
def __init__(self, url): super(Redirect, self).__init__() self.url = url
assert_allclose(f(x_mlp).flatten(), g(x).flatten(), rtol=1e-5, atol=5e-5)
x = np.atleast_2d(np.linspace(0, 10, 1000)).T
if not is_request_in_microsite(): return relative_path return TEMPLATES_BACKEND.get_template_path(relative_path, **kwargs)
self.assertEquals(293, self.response.content.count('grade_None'))
self.assertFalse(payload.get('success')) self.assertIn('There was an error receiving your login information', payload.get('value'))
latest_version_config = cls.objects.filter(platform=platform, enabled=True).first() if latest_version_config: return latest_version_config.version
pass
cache.clear()
rng = np.random.RandomState(0) X = rng.rand(10, 20)
if array.size > 0: mode = stats.mode(array) most_frequent_value = mode[0][0] most_frequent_count = mode[1][0] else: most_frequent_value = 0 most_frequent_count = 0
if layer_to_clamp is None: layer_to_clamp = OrderedDict()
click_css(self, 'a.action-save')
true_importances = np.zeros(n_features)
try: return request.user.pk except AttributeError: return ''
i_nbrs = nbrs.radius_neighbors([my_mean], bandwidth, return_distance=False)[0] points_within = X[i_nbrs] if len(points_within) == 0:
self.course.discussion_blackouts = [[]] self.assertTrue(self.course.forum_posts_allowed)
check_predictions(LogisticRegression(random_state=0), X, Y1) check_predictions(LogisticRegression(random_state=0), X_sp, Y1)
request_uuid = self._create_credit_request_and_get_uuid()
self.notes_page.go_to_page(3) self._verify_pagination_info( notes_count_on_current_page=1, header_text='Showing 26-26 out of 26 total', previous_button_enabled=True, next_button_enabled=False, current_page_number=2, total_pages=2 )
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit() attempt.deny("error") self._assert_can_reverify()
OAUTH2_PROVIDER_APPLICATION_MODEL = 'oauth2_provider.Application'
course_modules_json = json.dumps(valid_input.get('course_modules'))
for student in students[:7]: CertificateWhitelistFactory.create(user=student, course_id=self.course.id, whitelist=True)
self.check_permissions(clone_request(self.request, 'POST'))
help=_("What format this module is in (used for deciding which " "grader to apply, and what to show in the TOC)"), scope=Scope.settings,
if len(err_rows) > 1: upload_csv_to_report_store(err_rows, 'grade_report_err', course_id, start_date)
self.client.login(username=username, password="password")
payload = self.default_payload(user=user, ttl=ttl) payload.update(overrides) return self.generate_token(payload)
self.dashboard_page.visit()
self.assertEqual(views.get_cosmetic_display_price(self.course, registration_price), "$99")
self.system.modulestore.update_item(self, None)
return cls.read_data_file('{}.key'.format(key_name))
effort = self.store.get_item(course_key.make_usage_key('about', 'end_date')) self.assertEqual(effort.data, 'TBD')
'SHOW_BUMPER_PERIODICITY': 7 * 24 * 3600,
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
request = Request.blank('') response = self.item_descriptor.studio_transcript(request=request, dispatch='translation/uk') self.assertEqual(response.status, '400 Bad Request')
last_modified_at_str = content.last_modified_at.strftime(HTTP_DATE_FORMAT) if 'HTTP_IF_MODIFIED_SINCE' in request.META: if_modified_since = request.META['HTTP_IF_MODIFIED_SINCE'] if if_modified_since == last_modified_at_str: return HttpResponseNotModified()
ccx_course_key = CCXLocator.from_course_locator(course.id, '1') self._add_role_access_to_user(self.user, ccx_course_key)
self.assertEqual(xblock_info['is_proctored_exam'], True) self.assertEqual(xblock_info['is_time_limited'], True) self.assertEqual(xblock_info['default_time_limit_minutes'], 100)
SEARCH_SKIP_ENROLLMENT_START_DATE_FILTERING = True
task_type = 'grade_problems' task_class = calculate_problem_grade_report task_input = {} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
self.assertTrue(self._has_changes(locations['grandparent'])) self.assertTrue(self._has_changes(locations['parent']))
self._publish_events(block_structure, block_key, previous_count, max_count, block_keys) all_selected_children.update(usage_info.course_key.make_usage_key(s[0], s[1]) for s in selected)
patch_extractor = sp_extract_patches(IR, IC, KR, KC, CH, RasterOrders.channel_row_col, RasterOrders.channel_row_col, subsample, border_mode, flip_patches=True).tocsc()
validate_xml(input_xsd, output_xml)
with check_mongo_calls(1): cached_structure = self._get_structure(self.new_course)
coefs = coefs[np.newaxis, :, :] y_offset = np.atleast_1d(y_offset) y_test = y_test[:, np.newaxis]
sampling_algorithm["custom-auto"] = \ lambda n_population, n_samples, random_state=None: \ sample_without_replacement(n_population, n_samples, method="auto", random_state=random_state)
self.assertEqual(record.course_key, self.course_key)
train, test = set(train), set(test)
pos_class = classes[1]
_update_badge_context(context, course, user)
mako_middleware_process_request(request)
ans = True
XBlockDisableConfig.objects.create( disabled_create_blocks='annotatable', enabled=True ) self.assertEqual(XBlockDisableConfig.disabled_create_block_types(), ['annotatable', 'poll', 'survey'])
predicted = cross_val_predict(lr, boston.data, y, cv=10)
attempt.mark_ready() self._assert_course_verification_status(VERIFY_STATUS_NEED_TO_VERIFY)
self.db_connection.ensure_indexes()
_check_fields( get_editable_fields(cc_content, context), data, "This field is not editable." )
VERIFICATION_DEADLINE = "verification" UPGRADE_DEADLINE = "upgrade"
options.ignore = ('',) if options.select else tuple(options.ignore)
TestScenario((self.demo_course,), "Empty"), TestScenario((self.html_course,), "Intro to &lt;html&gt;"),
import_course_from_xml( source_store, 'test_user', TEST_DATA_DIR, source_dirs=['manual-testing-complete'], static_content_store=source_content, target_id=source_course_key, create_if_not_present=True, raise_on_failure=True, )
if module.has_children: new_children = [] for child_loc in module.children: child_loc = child_loc.map_into_course(dest_course_id) new_children.append(child_loc)
orig_score = self.lcp.get_score() event_info['orig_score'] = orig_score['score'] event_info['orig_total'] = orig_score['total']
CREDIT_REQUIREMENT_XBLOCK_CATEGORIES = [ "edx-reverification-block", ]
return self.q(css='body.view-course-create-rerun').present
self.assertEqual(cert.status, ExampleCertificate.STATUS_ERROR) self.assertIn(self.ERROR_MSG, cert.error_reason)
result = process_postpay_callback(params) self.assertTrue(result['success']) self.assert_dump_recorded(result['order'])
role.add_users(self.student) role.remove_users(self.student) self.assertFalse(role.has_user(self.student))
if self.status in ORDER_STATUS_MAP.values(): return
export_extra_content( export_fs, self.modulestore, self.courselike_key, xml_centric_courselike_key, 'static_tab', 'tabs', '.html' )
world.scenario_dict['COURSE'] = world.CourseFactory.create( org='edx', number=course, display_name='Test Course' )
return dict( super(GradingPolicySerializer, self).to_representation( defaultdict(lambda: None, obj) ) )
x_squared_norms = (X ** 2).sum(axis=1) labels_array, inertia_array = _labels_inertia( X, x_squared_norms, noisy_centers) assert_array_almost_equal(inertia_array, inertia_gold) assert_array_equal(labels_array, labels_gold)
modulestore().update_item(descriptor, request.user.id)
batch_size = old_batch_size
mean = species.cov_train.mean(axis=0) std = species.cov_train.std(axis=0) train_cover_std = (species.cov_train - mean) / std
response = self._generate()
store = self._verify_modulestore_support(location.course_key, 'convert_to_draft') return store.convert_to_draft(location, user_id)
M = np.zeros((N, N), dtype=np.float64) for i in range(N): s_i = s_range[i]
award = Mock()
settings.DEFAULT_TEMPLATE_ENGINE['DIRS'] = [ path for path in settings.DEFAULT_TEMPLATE_ENGINE['DIRS'] if path != settings.MICROSITE_ROOT_DIR ]
scenario.steps = [] return
FEATURES['ENABLE_MKTG_SITE'] = True FEATURES['USE_MICROSITES'] = True
serialized_value = unicode(safe_cookie_data_1)
self.assertEqual(toy.graded, True)
self.assertFalse(result['success']) self.assertIn(u"badly-typed value", result['error_html'])
from __future__ import unicode_literals
return _write_styles('.xmodule_edit', output_root, _list_descriptors())
verify_group_id_not_present(profiled_user=self.student, pass_group_id=False) verify_group_id_not_present(profiled_user=self.moderator, pass_group_id=False)
print problem.get_html()
if sample_weight is None: sample_weight = np.ones(n_samples, dtype=np.float64, order='C')
'clone']
self.courseware.go_to_sequential_position(position) self.video.wait_for_video_player_render()
BROKER_HEARTBEAT = 10.0 BROKER_HEARTBEAT_CHECKRATE = 2
self.thread_page_2.check_focus_is_set(selector=".discussion-article")
container = self.go_to_nested_container_page() self.verify_groups(container, ['alpha', 'gamma'], ['beta'])
self.instructor = AdminFactory.create() self.client.login(username=self.instructor.username, password="test")
attempt_2 = SoftwareSecurePhotoVerification(user=user) attempt_2.mark_ready() assert_equals(attempt_2, SoftwareSecurePhotoVerification.active_for_user(user))
(new_options, __) = parser.parse_args([])
user = self.create_user_and_enroll('honor') with self.assertNumQueries(3): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
self._cache = cache
return self.encode(inputs)
),
after = expiration + timedelta(seconds=1) self.assertFalse(attempt.active_at_datetime(after))
sh("i18n_tool generate")
response = views.container_handler( request=request, usage_key_string=unicode(self.vertical.location) ) self.assertEqual(response.status_code, 200)
return hasattr(self, '_has_mask')
VerificationDeadline.objects.all().delete()
success = _retry_and_check(5, lambda: _reset_and_get_seed(module) != seed)
if sample_weight.sum() <= 0: raise ValueError( "Attempting to fit with a non-positive " "weighted number of samples.")
K = self._centerer.fit_transform(K)
if prerequisite_course_keys: for prerequisite_course_key_string in prerequisite_course_keys: prerequisite_course_key = CourseKey.from_string(prerequisite_course_key_string) add_prerequisite_course(course_key, prerequisite_course_key)
return settings.FEATURES.get('ENTRANCE_EXAMS', False)
valid_get_dict = MultiDict({'input_1[]': 'test'}) result = CapaModule.make_dict_of_responses(valid_get_dict) self.assertEqual(result['1'], ['test'])
return BACKEND.get_value(val_name, default, **kwargs)
PIPELINE_DISABLE_WRAPPER = True
n_runs = 5
@ignore_warnings def test_explained_variance(): rng = np.random.RandomState(0) n_samples = 100 n_features = 80
self.save()
fpr, tpr, thresholds = roc_curve(y_true, y_score, drop_intermediate=False) assert_equal(thresholds.size, np.unique(np.round(thresholds, 2)).size)
print('explained variance ratio (first two components): %s' % str(pca.explained_variance_ratio_))
xblock = _update_with_callback(xblock, user, old_metadata, old_content)
X = np.arange(100).reshape(10, 10) y = np.array([0] * 5 + [1] * 5)
name = 'elevation' _check_is_integral(name, label) _check_range(name, label, -1, 8) if label == -1: return None else: return label * 5 + 30
return [part.strip() for part in self.q(css='.path').text[0].split('>')]
raise NotImplementedError("%s doesn't implement make_state" % type(self))
exc_type, exc_value, exc_tb = sys.exc_info()
self.course.teams_configuration['topics'] = [] self.assert_serializer_output([], num_teams_per_topic=0, num_queries=0)
comb_name = comb_name.decode('utf-8', 'replace')
return os.path.getsize(self.path(name))
assert_allclose(np.cov(preprocessed_X.transpose(), bias=1), identity, rtol=1e-4, atol=1e-4)
assert_raises(ValueError, chi2_kernel, csr_matrix(X), csr_matrix(Y)) assert_raises(ValueError, additive_chi2_kernel, csr_matrix(X), csr_matrix(Y))
self.set_state_from_lcp()
return self.q( css='#paging-header-select option' ).filter( lambda e: e.is_selected() ).results[0].text.strip()
add_user_to_cohort(cohorts[cohort_index], self.user.username)
CommerceConfiguration.objects.create( checkout_on_ecommerce_service=enabled, single_course_checkout_page=checkout_page )
self.assertRaises(ValueError, Progress, 0, 0) self.assertRaises(ValueError, Progress, 2, 0) self.assertRaises(ValueError, Progress, 1, -2)
expected_y = y.mf_update( state_below = v.upward_state(v_state))
self.q(css=self.search_bar_selector + ' input[type="text"]').fill(text)
for block_type, block_id in self.selected_children(): yield self.runtime.get_block(self.location.course_key.make_usage_key(block_type, block_id))
call_task('pavelib.assets.watch_assets', options={'background': True})
assert_raises(ValueError, calibration_curve, [1.1], [-0.1], normalize=False)
return y - np.nan_to_num(np.exp(pred[:, k] - logsumexp(pred, axis=1)))
self.restricted_course.delete() self._assert_history_deleted()
self.create_programs_config() self.mock_programs_api(data={'results': []}) actual = utils.get_programs_for_dashboard(self.user, self.COURSE_KEYS) self.assertEqual(actual, {})
if isinstance(metric, partial): metric.__module__ = 'tmp' metric.__name__ = name
random_state = check_random_state(0) tsne = TSNE(metric="chebyshev") X = random_state.randn(5, 2) tsne.fit_transform(X)
try: from pyamg import smoothed_aggregation_solver except ImportError: raise SkipTest("pyamg not available.")
msg = Messages.ORDER_COMPLETED.format(order_number=response_data['order']['number']) log.debug(msg) response = DetailResponse(msg)
merged_access[partition_id] = group_ids
max_squared_sum = 4 + 9 + 16 max_squared_sum_ = row_norms(X, squared=True).max() assert_almost_equal(max_squared_sum, max_squared_sum_, decimal=4)
options = self.q(css="body.discussion .forum-nav-sort-control option") return options.filter(lambda el: el.is_selected())[0].get_attribute("value")
return Fragment(self.get_html())
self.q(css="input.practice_exam").first.click()
raise
rows_broadcastable = False cols_broadcastable = False
raise CommandError(e)
y4 = np.array([1, 1, 1, 1, 1, 1, 1, 1, 2])
problem = self.store.get_item(problem.location)
self.client.logout() response = self.client.get(self.url) self.assertEqual(response.status_code, 302)
self.assertFalse(is_valid) self.assertEqual(len(errors), 3) self.assertFalse(test_model)
for parent_ref in parents: parent_block = modulestore().get_item(block_map[parent_ref].location) parent_block.children.append(block_key) block_map[parent_ref] = update_block(parent_block)
data.update(invalid_fields)
dog_stats_api.histogram( 'DjangoXBlockUserStateClient.{}'.format(evt_name), value, timestamp=evt_time, sample_rate=self.API_DATADOG_SAMPLE_RATE, )
if len(tree) == 1: return tree[0][0] if len(tree) == 3: return " <sup>{num}</sup>&frasl;<sub>{den}</sub> ".format(num=tree[0][0], den=tree[2][0]) return "Error"
FilterActs = None WeightActs = None
self._send_handler_response("GET")
self.courseware_page.a11y_audit.config.set_scope( include=['div.sequence-nav']) self.courseware_page.a11y_audit.check_for_accessibility_errors()
try: cert = GeneratedCertificate.eligible_certificates.get( user__username=username, course_id=course_key ) except GeneratedCertificate.DoesNotExist: return None return format_certificate_for_user(username, cert)
[DISPLAY_NAME, 'Video', False], ['Default Video URL', 'https://www.youtube.com/watch?v=3_yD_cEKoCk, , ', False],
self._assert_certs_in_queue(mock_queue, 2)
module.save_problem(get_request_dict)
return sig.replace(parameters=tuple(sig.parameters.values())[1:])
'lms.djangoapps.teams',
xml_file = export_fs.open(LIBRARY_ROOT, 'w') xml_file.write(lxml.etree.tostring(root, pretty_print=True, encoding='utf-8')) xml_file.close()
greet = Word( alphas ) + "," + Word( alphas ) + "!"
expected_fields = CourseSummary.course_info_fields + ['id', 'location'] return all([hasattr(course_summary, field) for field in expected_fields])
perf_test = True
titles = ['SVC with linear kernel', 'LinearSVC (linear kernel)', 'SVC with RBF kernel', 'SVC with polynomial (degree 3) kernel']
seq_css = "ol#sequence-list>li:nth-of-type({0})>.nav-item".format(seq_index + 1) self.q(css=seq_css).first.click() self.wait_for_ajax()
logistic_classifier = linear_model.LogisticRegression(C=100.0) logistic_classifier.fit(X_train, Y_train)
form = self._admin_form(course_mode)
return self.reset_attempts_button.is_present()
raise NotImplementedError(str(self.__class__) + " does not implement " "initialize_parameters")
return (super(ExternalDiscussionCourseTab, cls).validate(tab_dict, raise_error) and key_checker(['link'])(tab_dict, raise_error))
self._assert_can_reverify()
d = d[:nreturned] z = z[:, :nreturned]
X_train, y_train, sw_train = \ X[:n_samples], y[:n_samples], sample_weight[:n_samples] X_test, y_test = X[n_samples:], y[n_samples:]
upload_finish_time = datetime.utcnow().replace(microsecond=0, second=0)
y = 0.5 * X.ravel() \ + np.random.randn(n_samples, 1).ravel()
return get_branch_setting()
if rest.endswith('?raw'): return original
has_skipped = cls.objects.filter(user_id=user_id, course_id=course_id).exists() return has_skipped
cache[cache.keys()[0]] = ("Hey there!", {})
exclude_trees = ['_build', 'templates', 'includes']
urlpatterns += patterns( '',
test_course_data = self.assert_created_course(number_suffix=uuid4().hex) self.assertTrue(are_permissions_roles_seeded(_get_course_id(self.store, test_course_data)))
with warnings.catch_warnings(record=True): test_bins = get_bin_seeds(X, 0.01, 1) assert_array_equal(test_bins, X)
if flip_y >= 0.0: flip_mask = generator.rand(n_samples) < flip_y y[flip_mask] = generator.randint(n_classes, size=flip_mask.sum())
languages = dict(settings.ALL_LANGUAGES) try: return languages[self.course_team.language] except KeyError: return self.course_team.language
if settings.FEATURES.get('ENABLE_THIRD_PARTY_AUTH', False): enable_third_party_auth()
httpretty.register_uri( httpretty.PUT, "http://localhost:4567/api/v1/threads/{}".format(thread_data["id"]), body=_get_thread_callback(thread_data) )
self.assertEqual(provider_redirect_url, self.url_prefix + self.complete_url) return self.client.get(provider_redirect_url)
clf = svm.LinearSVC(penalty='l1', loss='squared_hinge', dual=False, random_state=0).fit(X, Y) assert_array_equal(clf.predict(T), true_result)
admin = AdminFactory.create()
targets = email_obj.targets.all() global_email_context = _get_course_email_context(course)
return y
for axes_row in all_axes: for axes in axes_row: axes.get_xaxis().set_visible(False) axes.get_yaxis().set_visible(False)
return u"//{}/{}/{}".format(settings.CMS_BASE, page, block.location)
for student in students[2:5]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.error, mode='honor' )
html_module_location = course_key.make_usage_key('html', 'nonportable_link') html_module = self.store.get_item(html_module_location) self.assertIn('/jump_to_id/nonportable_link', html_module.data)
self.assertNotContains(resp, 'Hidden_course')
ordered_key_fields = ['category', 'name', 'course', 'tag', 'org', 'revision']
clf = OneVsRestClassifier(base_clf).fit(X, Y) y_pred = clf.predict([[0, 0, 4]])[0] assert_array_equal(y_pred, [0, 0, 1])
return self._get_course_info(request, course)
if 'children' in draft_block.fields: return any( [has_changes_subtree(child_block_id) for child_block_id in draft_block.fields['children']] )
return modulestore.get_library(structure_key, depth=None)
is_increasing = assert_no_warnings(check_increasing, x, y) assert_false(is_increasing)
icrv_location = self.icrv.location self.store.delete_item( self.icrv.location, ModuleStoreEnum.UserID.test, revision=ModuleStoreEnum.RevisionOption.published_only ) self._update_partitions()
url(r'^edge/(?P<org>[^/]+)/(?P<course>[^/]+)/course/(?P<coursename>[^/]+)$', 'contentstore.views.landing', name='landing'),
user, created = User.objects.get_or_create(username=USERNAME, email=EMAIL) if created: user.set_unusable_password() user.save()
assert source == '' return None
response = func(*args, **kwargs) remove_headers_from_response(response, *headers) return response
try: json = self.module_data[location] except KeyError: json = self.modulestore._find_one(location) self.module_data[location] = json return json
CSRF_COOKIE_SECURE = ENV_TOKENS.get('CSRF_COOKIE_SECURE', False)
if self.display_organization: return self.display_organization return self.location.org
response = requests.put(self.url, data={'test_unicode': u'\u2603 the snowman'}) self.assertEqual(response.status_code, 400)
regr.fit(diabetes_X_train, diabetes_y_train)
children = self.q(css='.note') return [EdxNotesPageItem(self.browser, child.get_attribute("id")) for child in children]
seed = rng.randint(1, np.iinfo(np.int32).max)
sum_comb_c = sum(comb2(n_c) for n_c in contingency.sum(axis=1)) sum_comb_k = sum(comb2(n_k) for n_k in contingency.sum(axis=0))
from course_modes.models import CourseMode
index = 1 for child in subsection.get_children(): if child.location == unit.location: break index += 1
if not settings.FEATURES.get(feature_name, False): return HttpResponseBadRequest() return view_func(request, *args, **kwargs)
_, sap, _ = randomized_svd(X, k, power_iteration_normalizer=normalizer, random_state=0)
attempt.status = "submitted" attempt.deny(DENY_ERROR_MSG) attempt.status = "submitted" attempt.approve()
PIPELINE_UGLIFYJS_BINARY = 'node_modules/.bin/uglifyjs'
self.assertEqual( other_cmap.get_overall_message(), self.cmap.get_overall_message() )
self.make_course() url = self.make_url('html_book', book_index=0, chapter=1) response = self.client.get(url) self.assertEqual(response.status_code, 404)
try: etype = etype.__name__ except AttributeError: pass
from xmodule.modulestore.inheritance import InheritanceMixin from xmodule.modulestore import prefer_xmodules from xmodule.x_module import XModuleMixin
std_error = scores_std / np.sqrt(n_folds)
INSTALLED_APPS += ('lettuce.django',) LETTUCE_APPS = ('courseware', 'instructor')
A = neighbors.kneighbors_graph(X, 1, mode='connectivity', include_self=True) assert_array_equal(A.toarray(), np.eye(A.shape[0]))
credit_requirements = get_credit_requirements(course_key) paired_requirements = {} for requirement in credit_requirements: namespace = requirement.pop("namespace") paired_requirements.setdefault(namespace, []).append(requirement)
self._do_mstep(X, z, self.params)
self._test_email_address_failures(SESIllegalAddressError(554, "Email address is illegal"))
call_command('manage_group', TEST_GROUP, '--permissions', 'auth:Group:add_group') self.check_groups([TEST_GROUP]) self.check_permissions(TEST_GROUP, ['add_group'])
response = ( _visible_to_nonstaff_users(courselike) and _can_access_descriptor_with_start_date(user, courselike, courselike.id) ) return ( ACCESS_GRANTED if (response or _has_staff_access_to_descriptor(user, courselike, courselike.id)) else response )
X = JUNK_FOOD_DOCS
self.assertBlockHasContent(child_usage_key, 'data', child_data)
updates[sum_square_grad] = new_sum_squared_grad updates[param] = param + delta_x_t
self._upload_file('auto_reg_enrollment.csv')
survey = self._create_test_survey() self.assertEquals(len(survey.get_answers()), 0)
db_config = { 'host': MONGO_HOST, 'port': MONGO_PORT_NUM, 'db': 'test_xmodule', }
random_state = np.random.RandomState(0) n_samples, n_features = X.shape X = np.c_[X, random_state.randn(n_samples, 200 * n_features)]
X, y = datasets.make_hastie_10_2(n_samples=100, random_state=1) all_estimators = [GradientBoostingRegressor, GradientBoostingClassifier]
__ = source_store.find_asset_metadata(asset_key)
self.assertNotEqual(old_tab.is_hidden, new_is_hidden_setting)
call_command('git_add_course', self.TEST_REPO, directory_path=self.git_repo_dir / 'edx4edx_lite', repository_branch=self.TEST_BRANCH)
prev_coef = coef prev_alpha[0] = alpha[0] coef = np.zeros_like(coef)
self.assertEqual(len(mail.outbox), 0)
log.exception("Could not send notification email for initial verification for user %s", user.id)
ANALYTICS_DASHBOARD_URL = None
self.client.ajax_post(course_update_url)
self.certificates_section.wait_for_certificate_exceptions_section() self.certificates_section.click_add_exception_button()
y = iris.target
return self.make_call(reverse('teams_detail', args=[team_id]), expected_status, 'get', data, **kwargs)
this_extensions = deepcopy(extensions)
if world.is_css_present('div#login_error'): assert_false(world.css_visible('div#login_error'))
return u'grades'
for key in wrong: params = baseline.copy() params[key] = wrong[key] with self.assertRaises(CCProcessorDataException): payment_accepted(params)
if not has_studio_read_access(user, course_key): raise PermissionDenied() course_module = modulestore().get_course(course_key, depth=depth) return course_module
return super(SplitMongoKVS, self).default(key)
mako_middleware_process_request(request)
p = T.switch(p > 0., p, self.left_slope * p) return p
for cls, fields_list in class_dict.items(): for fields in fields_list: yield (cls, fields)
if isinstance(value, basestring): return value return json.dumps(value, cls=EdxJSONEncoder)
return self.field_decorator(field_value)
return not self == other
return self.log_p_x_given_z(X, theta)
data_specs[0].np_validate(data) assert not [contains_nan(X) for X in data] raise NotImplementedError()
assert_equal(len(slo), n_iter)
X, y = make_classification(n_samples=1000, n_features=25, n_informative=3, n_redundant=2, n_repeated=0, n_classes=8, n_clusters_per_class=1, random_state=0)
return self.cleaned_data.get("page") or 1
obj, filename = self._write_array(obj, filename) self._filenames.append(filename) self._npy_counter += 1
chapter = self.store.get_item(self.chapter_loc) self.assertIn(self.seq_loc, chapter.children)
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
SuperWeightDoubling = WeightDoubling
self.assert_query_params_equal(httpretty.last_request(), expected_params)
iris = load_iris()
self.assertTrue(self._is_location_published(location)) self.assertFalse(modulestore().has_changes(modulestore().get_item(location)))
request = RequestFactory().get('/url') request.user = self.user account_settings = get_account_settings(request) self.assertEqual(account_settings['name'], full_name)
element = self.q(css=".is-empty").first if element: return element.text[0] else: return None
y_lower = clf.predict(xx)
y_true, y_pred, _ = make_prediction(binary=True)
assert_equal(_top_import_error, None)
response = self.client.get(index_url, {}, HTTP_ACCEPT='application/json') self.assertEqual(response.status_code, 500)
courses_list_by_staff, __ = get_courses_accessible_to_user(self.request) self.assertEqual(len(courses_list_by_staff), TOTAL_COURSES_COUNT)
from urllib.request import Request, build_opener
return getattr(settings, 'SOCIAL_AUTH_OAUTH_SECRETS', {}).get(self.backend_name, '')
self.q(css=self.editor_mode_css).click() self.browser.execute_script("tinyMCE.activeEditor.setContent('%s')" % content)
return
LANGUAGES = ENV_TOKENS.get('LANGUAGES', LANGUAGES) LANGUAGE_CODE = ENV_TOKENS.get('LANGUAGE_CODE', LANGUAGE_CODE) USE_I18N = ENV_TOKENS.get('USE_I18N', USE_I18N)
self.course_nav.q(css='fieldset label:nth-child(3) input').nth(0).click()
to_json_val = {'type': self.type, 'name': self.name} if self.is_hidden: to_json_val.update({'is_hidden': True}) return to_json_val
self._install_masquerade(self.course_instructor) self.assertEqual( 'student', access.get_user_role(self.course_instructor, self.course_key) )
results.append({ 'identifier': identifier, 'error': error, 'userDoesNotExist': user_does_not_exist })
self.user.profile.mailing_address = None self.user.profile.save()
course_mode = CourseMode.objects.get(pk=1) self.assertEqual(course_mode.expiration_datetime.replace(tzinfo=None), expiration.replace(tzinfo=None))
self.verify_discussion_topics_after_reload(self.inline_key, cohorted_topics_after)
self.active = False self.save()
for i, tab in enumerate(xmodule_tabs.CourseTabList.iterate_displayable( self.course, inline_collections=False )): self.assertEquals(tab.type, self.course.tabs[i].type)
distance_to_candidates = euclidean_distances( X[candidate_ids], X, Y_norm_squared=x_squared_norms, squared=True)
self._action_btn_for_xblock_id(xblock_id, "duplicate").click() wait_for_notification(self) self.wait_for_ajax()
if abs(r - round(r)) > 0.01: return False r = int(round(r))
precompute = np.empty(shape=(n_features, n_features), dtype=X.dtype, order='C') np.dot(X.T, X, out=precompute)
self.assertEqual(len(mail.outbox), 1) self.assertEqual( mail.outbox[0].subject, 'You are eligible for credit from Hogwarts School of Witchcraft and Wizardry' )
if staff not in list_staff_ccx: try: enroll_email( course_id=ccx_key, student_email=staff.email, auto_enroll=True, email_students=send_email, email_params=email_params, )
n_samples_range = np.logspace(1, 9, 9)
self.components_ = np.empty((0, X.shape[1]))
hasher = RandomTreesEmbedding(n_estimators=30, random_state=1) assert_array_equal(hasher.fit(X).transform(X).toarray(), X_transformed.toarray())
import itertools from abc import ABCMeta, abstractmethod import warnings
expected_mongo_calls = 1 serializer_class = CourseDetailSerializer
'rest_framework', 'openedx.core.djangoapps.user_api',
return self.q(css='#course-pace-toggle-tip').results[0].text
def __init__(self): pass
staff = AdminFactory(password=self.password) self.client.logout() self.client.login(username=staff.username, password=self.password) self.assert_valid_get_response(self.eligibility)
disturb_mem.disturb_mem() rng = np.random.RandomState([2012, 11, 27])
return [Attribute('size', '20'), Attribute('label', ''), ]
CourseOverview.objects.filter(id=course_key).delete() CourseOverview.load_from_module_store(course_key)
stats_a = os.stat(filename_a) stats_b = os.stat(filename_b) return stats_a.st_dev == stats_b.st_dev;
self.assertTrue(self.cohort_management_page.is_category_selected())
n_samples, n_features = 6, 5 y = rng.randn(n_samples) X = rng.randn(n_samples, n_features)
prev = _OVERRIDES_DISABLED.disabled _OVERRIDES_DISABLED.disabled += (True,) yield _OVERRIDES_DISABLED.disabled = prev
should_display = models.BooleanField(default=False)
if credit_type is not None: response_element.set('partial_credit', str(credit_type))
self.mean_ = np.mean(X, axis=0) X -= self.mean_
config.add_subpackage('tests')
([], []),
dog_stats_api.increment( DEPRECATION_VSCOMPAT_EVENT, tags=["location:customtag_descriptor_render_template"] )
parents_map = [[], [0], [0], [1], [1], [2], [2, 4]]
run = problem_key.run if not run: problem_key = course_key.make_usage_key_from_deprecated_string(problem_location) if problem_key.course_key != course_key: return []
patch_stack = patches.reshape((B*OR*OC, KR*KC*CH))
with self.assertNumQueries(1): all_deadlines = VerificationDeadline.deadlines_for_courses(course_keys) self.assertEqual(all_deadlines, {})
CourseRerunState.objects.failed(course_key=destination_course_key) logging.exception(u'Course Rerun Error') return "duplicate course"
course = xml.CourseFactory.build() sequence = xml.SequenceFactory.build(parent=course) vertical = xml.VerticalFactory.build(parent=sequence)
estimator_weight = self.learning_rate * np.log(1. / beta)
if not self.check_enough_space(remote_name, local_name): log.warning(common_msg + "File %s not cached: Not enough free space" % remote_name) self.release_writelock() return filename
self.assertIn("What is the sum of 17 and 3?", problem_page.problem_text)
milestones = milestones_api.get_milestones("{usage_key}{qualifier}".format( usage_key=prereq_content_key, qualifier=GATING_NAMESPACE_QUALIFIER )) for milestone in milestones: milestones_api.remove_milestone(milestone.get('id'))
pass
slug = hashlib.sha256(slug + unicode(badge_class.course_id)).hexdigest()
problem.display_name = "updated before calling revert" self.store.update_item(problem, self.user_id) self.store.revert_to_published(self.vertical_x1a, self.user_id)
assert_event_matches(expected, actual, tolerate=EventMatchTolerates.strict())
pass
query_features = microsite.get_value('student_profile_download_fields')
attempt = SoftwareSecurePhotoVerification(user=user, photo_id_key="dummy_photo_id_key") attempt.status = 'approved' attempt.save()
return reverse_url(handler_name, 'usage_key_string', usage_key, kwargs)
with remove_ccx(course_key) as (course_key, restore): return restore(self._modulestore.import_xblock( user_id, course_key, block_type, block_id, fields=fields, runtime=runtime, **kwargs ))
position = getattr(self.system, 'position', None) if position is not None: assert isinstance(position, int) self.position = self.system.position
param_grid = [param_grid]
axes = ('b', 's', 0, 1, 'c') view_converter = StereoViewConverter(datum_shape, axes)
social_auths = strategy.storage.user.get_social_auth_for_user( user, provider=self.provider.backend_name) self.assertEqual(0, len(social_auths))
least_squares[...] = 1 AA = 1.
world.wait_for_ajax_complete()
assert_equal(X_r2inv.getnnz(), X_r.getnnz())
course_orphans = self.store.get_orphans(course_locator) self.assertEqual(len(course_orphans), 0) self.store.delete_item(vertical.location, self.user_id)
page.wait_for_component_menu() click_css(page, 'button>span.large-html-icon', menu_index, require_notification=False)
self.user = UserFactory.create( username="inactive", email="inactive@example.com", password=self.PASSWORD, is_active=True )
tmp *= 1 - damping R *= damping R += tmp
STATICFILES_STORAGE = 'openedx.core.lib.django_require.staticstorage.OptimizedCachedRequireJsStorage'
assert_raises(ValueError, chi2_kernel, [[0, -1]]) assert_raises(ValueError, chi2_kernel, [[0, -1]], [[-1, -1]]) assert_raises(ValueError, chi2_kernel, [[0, 1]], [[-1, -1]])
return Fraction(treedic['1 factors'][0] / treedic['2 factors'][0])
dest_modulestore = self._get_modulestore_for_courselike(dest_course_id) if source_modulestore == dest_modulestore: return source_modulestore.clone_course(source_course_id, dest_course_id, user_id, fields, **kwargs)
return json.loads(reactivation_email_for_user(user).content)
with self.assertNumQueries(1): self.field_data_cache = FieldDataCache( [mock_descriptor([mock_field(Scope.user_state, 'a_field')])], course_id, self.user )
child.display_name = 'Changed Display Name' self.store.update_item(child, user_id=self.user_id)
huge = 2 ** (n_bits - 1) - 1 clf = DecisionTreeClassifier(splitter='best', max_leaf_nodes=huge) assert_raises(MemoryError, clf.fit, X, y)
if settings.FEATURES['CLASS_DASHBOARD'] and access['staff']: sections.append(_section_metrics(course, access))
self.user_partition.get_scheme(self.non_random_scheme.name) self.user_partition.get_scheme(self.random_scheme.name)
data = { "email": self.EMAIL, "name": self.NAME, "username": self.USERNAME, "password": self.PASSWORD, }
testing.assert_array_equal(F.transform(X), np.around(X, decimals=3))
role = CourseCcxCoachRole(self._course.id) role.add_users(coach) ccx = CcxFactory(course_id=self._course.id, coach=self.coach)
CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] ).install()
refetched = self.client.get_json(first_update_url) self.assertHTMLEqual( content, json.loads(refetched.content)['content'], "get w/ provided id" )
problem = self.build_problem(answer="1+1j", tolerance=1e-3) self.assert_grade(problem, '1+j', 'correct')
return func(X, Y, **kwds)
TIME_ZONE = ENV_TOKENS.get('TIME_ZONE', TIME_ZONE)
cv = check_cv(self.cv, y, classifier=True) folds = list(cv.split(X, y))
self.assertFalse(EmbargoedCourse.is_embargoed(course_id))
children_unstructured = out_unstructured[0] children_structured = out_structured[0]
with self.assertRaises(SearchIndexingError): self.reindex_library(store)
self.assertFalse(CourseEnrollment.is_enrolled(self.user, self.course.id))
proc.wait()
for kernel in kernels: if not kernel.is_stationary(): continue K = kernel(X, X + 1) assert_almost_equal(K[0, 0], np.diag(K))
patched_from_string.assert_called_once_with(mock_problem_location) patched_manager.filter.assert_called_once_with( course_id=self.course_key, module_state_key=mock_problem_key )
with self.assertNumQueries(0): embargo_api.message_url_path(self.course.id, "enrollment")
self.assertTrue(self.enrollment.refundable())
self.client.login(username=self.global_staff.username, password='test') response = self.client.post(url) self.assertEqual(response.status_code, 302)
pipe_results = False if filename == '-': filename = mktemp() pipe_results = True
self.mean_ = np.mean(X, axis=0) X -= self.mean_ if self.n_components is None: n_components = X.shape[1] else: n_components = self.n_components
_, model_0_path, model_1_path = sys.argv
CATEGORY = "vertical" DATA = '' METADATA = {} MODEL_DATA = {'data': '<some_module></some_module>'}
for label_index, weight in enumerate(n_samples_per_label): lightest_fold = np.argmin(n_samples_per_fold) n_samples_per_fold[lightest_fold] += weight label_to_fold[indices[label_index]] = lightest_fold
CELERY_ALWAYS_EAGER = True HTTPS = 'off'
self.user.is_staff = True self.assertTrue(user_has_role(self.user, CourseCreatorRole()))
request.session['ExternalAuthMap'] = eamap
LogoutPage(self.browser).visit() self._login_as_a_verified_user() self.courseware_page.visit()
resp = self.client.post( '/course/bad/course/key/entrance_exam', {}, http_accept='text/html' ) self.assertEqual(resp.status_code, 400)
self.assertEquals(destination_course.wiki_slug, destination_wiki_slug)
v = TfidfVectorizer(binary=True, use_idf=False, norm=None) assert_true(v.binary)
H_hat[-1] = Y
has_children = False
lw = LedoitWolf(store_precision=False) lw.fit(X) assert_almost_equal(lw.score(X), score_, 4) assert(lw.precision_ is None)
entry.save_now() return task_progress
key = safe_key(key, '', '')
return auth.user_has_role(user, CourseStaffRole(CourseKey.from_string(course_id)))
agc = AgglomerativeClustering(n_clusters=2, connectivity=connectivity) agc.fit(X) n_samples = X.shape[0] n_nodes = agc.children_.shape[0] assert_equal(n_nodes, n_samples - 1)
latex_documents = [ ('index', 'pylearn2.tex', 'Pylearn2 Documentation', 'LISA lab, University of Montreal', 'manual'), ]
courses_list, __ = _accessible_courses_list(self.request) self.assertEqual(len(courses_list), 1)
'msg': '', 'value': '3', 'params': params, 'display_file': display_file, 'display_class': display_class, 'problem_state': problem_state,
if self.algorithm in _STOCHASTIC_ALGOS: self._fit_stochastic(X, y, activations, deltas, coef_grads, intercept_grads, layer_units, incremental)
confirm_prompt(self, require_notification=False) self.wait_for_ajax()
del self.lc_block._xmodule._selected_set initial_blocks_assigned = self.lc_block.get_child_descriptors() self.assertEqual(len(initial_blocks_assigned), 2)
self.assertTrue(PasswordHistory.is_allowable_password_reuse(user, "test")) self.assertTrue(PasswordHistory.is_allowable_password_reuse(staff, "test"))
save_course_update_items(location, course_updates, course_update_items, user) if "status" in course_update_dict: del course_update_dict["status"] return course_update_dict
assert_raises(ValueError, ir.fit, x, y)
course_id = None
self.assertTrue('Activate Course Enrollment' in response.content)
mock_get_scores.assert_called_with( self.course.id.to_deprecated_string(), anonymous_id_for_user(self.student_user, self.course.id) )
return etree.Element("choiceresponse")
return (-2 * self.score(X).sum() + self._n_parameters() * np.log(X.shape[0]))
self.wait_for_field(field_id) query = self.q(css='.u-field-{} .u-field-message-help'.format(field_id)) return query.text[0] if query.present else None
ENROLLMENT_COURSE_DETAILS_CACHE_TIMEOUT = 60
mock_get_cache.return_value = self.cache
ms = MeanShift(bandwidth=1.2) labels = ms.fit_predict(X) labels2 = ms.predict(X) assert_array_equal(labels, labels2)
CourseEnrollment.unenroll(self.user, self.courses[3].id, skip_refund=True)
return self.matching_events_were_emitted( start_time=start_time, event_filter=event_filter, number_of_matches=number_of_matches )
return self.q(css='body.view-library').present
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
assert_array_equal(np.sort(s1[:23149]), np.sort(s2))
return self.best_estimator_.predict_proba(X)
VS_batch = VS.make_theano_batch() new_SVS_batch = VS.format_as(VS_batch, VS_sparse) new_VS_batch = VS.undo_format_as(new_SVS_batch, VS_sparse) assert new_VS_batch is VS_batch assert new_SVS_batch is not VS_batch
raised = False try: fmt = OneHotFormatter(max_labels=-10) except ValueError: raised = True assert raised
likelihood = np.exp(values - values.max(axis=1)[:, np.newaxis]) return likelihood / likelihood.sum(axis=1)[:, np.newaxis]
self.assertNotIn('error_code', json.loads(response.content))
alpha = 1.5 beta = 0.75
enrollment = CourseEnrollment.get_enrollment(student, self.course.id) self.assertEqual(enrollment.is_active, False)
n_samples_per_fold = np.zeros(n_folds)
clf = MultiTaskLasso(alpha=1, tol=1e-8).fit(X, Y) assert_true(0 < clf.dual_gap_ < 1e-5) assert_array_almost_equal(clf.coef_[0], clf.coef_[1])
raise ValueError( 'Wrong number of arguments for %s:\n' ' %s was called.' % (_signature_str(name, arg_spec), _function_called_str(name, args, kwargs)) )
if publish == "discard_changes": store.revert_to_published(xblock.location, user.id) return JsonResponse({'id': unicode(xblock.location)})
return super(SoftDeleteCouponManager, self).get_queryset().filter(is_active=True)
many_days = datetime.timedelta(days=60)
for definition in bulk_write_record.definitions.values(): definition_id = definition.get('_id') if definition_id in ids: ids.remove(definition_id) definitions.append(definition)
fake_data_api.add_course(self.COURSE_ID, course_modes=['honor']) api.update_enrollment(self.USERNAME, self.COURSE_ID, mode='honor', is_active=False)
indexed_count = self.reindex_library(store) self.assertFalse(indexed_count)
expected_callback_dict = { 'xqueue_header': expected_header, 'xqueue_body': expected_body, }
cmd_str = ( 'pa11ycrawler json-to-html --pa11ycrawler-reports-dir={report_dir}' ).format(report_dir=self.pa11y_report_dir) sh(cmd_str)
return super(StudioValidation, self).empty and not self.summary
self.assertIsNone(getattr(self.request, 'session', None))
self.refit()
sequential = self.store.create_child( self.user_id, chapter.location, 'sequential', block_id='subsection_one' ) self.store.publish(sequential.location, self.user_id)
with patch('student.views.cert_info', return_value=None): response = self.client.get(reverse('dashboard')) self.assertEqual(response.status_code, 200)
if self.signal_handler: self.signal_handler.send("course_deleted", course_key=course_key)
world.retry_on_exception(lambda: link.click())
response = self.client.get(self.dashboard_url) self.assertContains(response, attempt.expiration_datetime.strftime("%m/%d/%Y"))
action_name = ugettext_noop('reset') update_fcn = partial(reset_attempts_module_state, xmodule_instance_args) visit_fcn = partial(perform_module_state_update, update_fcn, None) return run_main_task(entry_id, visit_fcn, action_name)
module = CapaFactory.create(rerandomize=RANDOMIZATION.ALWAYS, done=True) self.assertFalse(module.should_show_check_button())
set_user_preference(self.user, ACCOUNT_VISIBILITY_PREF_KEY, preference_visibility) self.create_mock_profile(self.user) response = self.send_get(client)
X = np.ascontiguousarray(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
if settings.ROOT_URLCONF == 'lms.urls': url_pattern = '/dashboard' else: url_pattern = '/home'
self.assertFalse(views.is_course_passed(self.course, None, self.student, self.request))
from config_models.models import cache
self.check_event_response_by_http_status( 'edit_resource', self.generate_edit_resource(self.resource_id), 200 )
self.assertIn('test error', result['success'])
response = self.client.post(self.url, self.params) self.assertEqual(response.status_code, 400)
IPFilter.objects.create( whitelist="192.168.10.20", enabled=True )
self.assertEqual(response.status_code, 200) result = json.loads(response.content)
with open(filename) as f: results = f.read() os.remove(filename) return results
for p, y, expected in cases: assert_almost_equal(loss_function.dloss(p, y), expected)
self.browser.execute_script(script) time.sleep(DELAY) self.wait_for_ajax()
return self.thread.context
sanitized_html_id = re.sub(r'[:-]', '_', html_id) return sanitized_html_id
other_course = CourseLocator(org='other', course='other', run='other') self._assert_enabled_for_course(other_course, False)
response = self.http_get_for_course(HTTP_AUTHORIZATION=auth_header) self.assertEqual(response.status_code, 200)
UNICODE_CHAR_CODES = (range(30) + [127] + [129, 500, 2 ** 8 - 1, 2 ** 8 + 1, 2 ** 16 - 1])
student_dict['cohort'] = next( (cohort.name for cohort in student.course_groups.all() if cohort.course_id == course_key), "[unassigned]" )
students_require_certs = students_to_generate_certs_for
self.course_nav.go_to_vertical('Test Vertical-2') self.video.wait_for_video_player_render()
pass
raise NotImplementedError("Not used")
PAID_COURSE_REGISTRATION_CURRENCY = ENV_TOKENS.get('PAID_COURSE_REGISTRATION_CURRENCY', PAID_COURSE_REGISTRATION_CURRENCY)
self.q(css='nav.%s * .next-page-link' % position)[0].click() self.wait_until_ready()
alt_class = BadgeClassFactory.create( slug=badge_class.slug, issuing_component=badge_class.issuing_component, course_id=CourseFactory.create().location.course_key ) BadgeAssertionFactory.create(user=self.user, badge_class=alt_class)
set_course_cohort_settings(course_key=self.course.id, is_cohorted=True) check_cohorted(True)
if not ( self._is_anonymous(self.context["thread"]) and not self._is_user_privileged(endorser_id) ): return DjangoUser.objects.get(id=endorser_id).username
return self.mlp.get_lr_scalers()
return X
if hasattr(self, 'scale_'): del self.scale_ del self.n_samples_seen_ del self.max_abs_
if record.failure_count >= max_failures_allowed: lockout_period_secs = settings.MAX_FAILED_LOGIN_ATTEMPTS_LOCKOUT_PERIOD_SECS record.lockout_until = datetime.now(UTC) + timedelta(seconds=lockout_period_secs)
standard_scaler = StandardScaler() Xtr_s = standard_scaler.fit_transform(X_train) Xte_s = standard_scaler.transform(X_test)
some_sample_ids = (2286, 3274, 14042) for sample_id in some_sample_ids: idx1 = s1.tolist().index(sample_id) idx2 = s2.tolist().index(sample_id)
pass
course_key = usage_key.course_key
contentstore().generate_thumbnail(unlock_content, dimensions=(16, 16)) contentstore().generate_thumbnail(lock_content, dimensions=(16, 16))
library2_key = self._create_library(library="lib2") self._login_as_non_staff_user()
class MyEstimator(BaseEstimator):
correct = 0 for key in correct_map: correct += correct_map.get_npoints(key)
if fexpect == fsym: return {'ok': True, 'msg': msg}
verify_order(self.html_usage_key, self.usage_key)
if not hasattr(self, 'W_lr_scale'): self.W_lr_scale = None
self.wait_for_ajax()
url_path = StaticContent.serialize_asset_key_with_slash( course_key.make_asset_key('asset', placeholder_id).for_branch(None) ) return url_path.replace(placeholder_id, '')
from openedx.core.djangoapps.programs.models import ProgramsApiConfig
with self._mock_xqueue() as mock_queue: certs_api.generate_example_certificates(self.COURSE_KEY)
email, password = self._create_unique_user()
('ALIGN', (2, 1), (2, -1), 'CENTER'),
assert world.is_css_not_present(modal_css, wait_time=10)
return self.browser.execute_script("return $('{}').is(':focus')".format(selector))
self.reset_tracker() different_client = APIClient() different_client.login(username=different_user.username, password=TEST_PASSWORD) response = different_client.delete(self.url) self.check_response(response, 404)
SignalHandler.course_published.disconnect(listen_for_course_publish)
_mock_counts.return_value = {'total': 0} with self.assertRaises(SystemExit): call_task('pavelib.quality.run_safelint', options={"thresholds": "invalid"})
if (len(set(isinstance(label, string_types) for label in ys_labels)) > 1): raise ValueError("Mix of label input types (string and number)")
module = CapaFactory.create() module.get_progress = Mock(wraps=module.get_progress) module.get_html() module.get_progress.assert_called_once_with()
self._assert_steps_displayed( response, PayAndVerifyView.PAYMENT_STEPS + PayAndVerifyView.VERIFICATION_STEPS, PayAndVerifyView.PAYMENT_CONFIRMATION_STEP, )
manager = CourseImportManager(*args, **kwargs) return list(manager.run_imports())
if url is None: url = cls._get_message_url_path_from_db(course_key, access_point) cache.set(cache_key, url)
return _('Free')
if not value.strip(): raise ValidationError("This field may not be blank.")
registration.activate()
y_subpopulation = np.zeros((max(n_subsamples, n_features))) lstsq, = get_lapack_funcs(('gelss',), (X_subpopulation, y_subpopulation))
meta_features = [] for feature in features: if 'meta.' in feature: meta_key = feature.split('.')[1] meta_features.append((feature, meta_key))
X, y = make_classification(n_samples=200, n_features=20, n_informative=3, n_redundant=2, n_repeated=0, n_classes=8, n_clusters_per_class=1, flip_y=0.0, class_sep=10, shuffle=False, random_state=0)
self.X_topo_space = view_converter.topo_space
Env.METRICS_DIR.makedirs_p()
return self.get_selector('div.running-tasks-container')
try: role = Role.objects.get(name=rolename, course_id=course_id) except Role.DoesNotExist: return False return role.users.filter(username=uname).exists()
self.process_root(root, export_fs)
user=user, course_id=course.location.course_key, status=CertificateStatuses.downloadable
raise NotImplementedError
return UserPartition.from_json(self.configuration)
return u",".join([u'"{}"'.format(val) for val in values])
store.get_items(SlashSeparatedCourseKey('a', 'b', 'c'), qualifiers={'category': 'vertical'})
y_pred, sigma = gp.predict(x, return_std=True)
settings.ALLOWED_HOSTS = [request.META['HTTP_HOST']] self.assertEqual(safe_get_host(request), request.META['HTTP_HOST'])
assert isinstance(error, MemoryError) if str(error): raise error else: raise TypicalMemoryError(msg)
TEST_DATA_MONGO_MODULESTORE = functools.partial(mixed_store_config, mkdtemp_clean(), {})
mathml_start = '<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true">' mathml_end = '</mstyle></math>'
self.create_programs_config(enable_studio_tab=False) response = self.client.get(self.path) self.assertEqual(response.status_code, 404)
cc_thread, context = _get_thread_and_context( request, thread_id, retrieve_kwargs={"user_id": unicode(request.user.id)} ) serializer = ThreadSerializer(cc_thread, context=context) return serializer.data
world.browser.execute_script('window.confirm = function(){return false;} ; window.alert = function(){return;}')
for i, this_layer in list(enumerate(self.dbm.hidden_layers))[1::2]:
sorted_grid_scores = list(sorted(search.grid_scores_, key=lambda x: x.mean_validation_score)) best_score = sorted_grid_scores[-1].mean_validation_score assert_equal(search.best_score_, best_score)
self.fit_transform(raw_documents) return self
youtube_id = deserialize_field(cls.youtube_id_1_0, pieces[1]) ret[speed] = youtube_id
random_instance = check_random_state(random_state) sample_indices = random_instance.randint(0, n_samples, n_samples) return sample_indices
super(MongoModuleStore, self)._drop_database(database, collections, connections)
resp = self.client.delete(reverse_usage_url("xblock_handler", chapter1_usage_key)) self.assertEqual(resp.status_code, 204)
widget = TrueCheckbox
return "{}/v1/issuer/issuers/{}".format(settings.BADGR_BASE_URL, settings.BADGR_ISSUER_SLUG)
if last_expression is not None: results.violations.append(ExpressionRuleViolation( rule, last_expression ))
doc_resolvers = {} doc_resolvers['sklearn'] = SphinxDocLinkResolver(app.builder.outdir, relative=True)
lc_block = self._add_library_content_block(course, self.lib_key) lc_block = self._refresh_children(lc_block) self.assertEqual(len(lc_block.children), 1)
module = CapaFactory.create(rerandomize=RANDOMIZATION.NEVER, max_attempts=0, done=True, correct=True) self.assertFalse(module.should_show_reset_button())
self._create_cert(self.courses[0].id, self.user, CertificateStatuses.error) self._create_cert(self.courses[1].id, self.user, other_status)
cov = ShrunkCovariance(shrinkage=0.) cov.fit(X) assert_array_almost_equal(empirical_covariance(X), cov.covariance_, 4)
post_params = sign(self.CLIENT_POST_PARAMS)
self.payment_and_verification_flow.proceed_to_payment()
return settings.FEATURES.get('ENABLE_PREREQUISITE_COURSES', False) \ and settings.FEATURES.get('MILESTONES_APP', False)
assert_raises(ValueError, lambda X, y: GradientBoostingClassifier( loss='deviance').fit(X, y), X, [0, 0, 0, 0])
response = self.client.post(self.send_mail_url, test_email) self.assertEquals(json.loads(response.content), self.success_content)
FEATURES['DISABLE_START_DATES'] = True
if self.display_coursenumber: return self.display_coursenumber return self.number
REQUIRE_DEBUG = DEBUG
return course_metadata_utils.may_certify_for_course( self.certificates_display_behavior, self.certificates_show_before_end, self.has_ended() )
self.wait_for_captions() captions_selector = self.q(css=CSS_CLASS_NAMES['captions_text_getter']) captions_selector.click()
with self.assertRaises(ItemNotFoundError): are_permissions_roles_seeded(course_id)
self.library = modulestore().get_library(self.lib_key)
VS = VectorSpace(dim=27) VS_sparse = VectorSpace(dim=27, sparse=True)
leaves = est.apply(X) leave_indicator = [node_indicator[i, j] for i, j in enumerate(leaves)] assert_array_almost_equal(leave_indicator, np.ones(shape=n_samples))
from util.testing import patch_testcase, patch_sessions patch_testcase() patch_sessions()
assert_true(X_scaled is not X)
assert_equal(len(folds), len(labels)) for i in np.unique(folds): assert_greater_equal(tolerance, abs(sum(folds == i) - ideal_n_labels_per_fold))
display_name = 'Nicely created' resp = self.create_xblock(display_name=display_name, category='chapter')
return urlparse(handler_url(self.block, handler_name, suffix=suffix)).path
return '{}{:02d}'.format(block_type, num)
self.previous_version = self.update_version = self.definition_locator = None self.xmodule_runtime = None
certificate.click_delete_certificate_button() self.certificates_page.click_confirmation_prompt_primary_button()
Yt = IncrementalPCA(n_components=2).fit(X).transform(Xt)
return self._convert_django_user_to_xblock_user(self._django_user)
self.assertFalse(res_json['success'])
params = self.correct_inputs.get(answer_name, {'answer': 0})
task_type = 'exec_summary_report' task_class = exec_summary_report_csv task_input = {} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
total_num_subtasks = _get_number_of_subtasks(total_num_items, items_per_task) subtask_id_list = [str(uuid4()) for _ in range(total_num_subtasks)]
if entrance_exam_minimum_score_pct is None: entrance_exam_minimum_score_pct = _get_default_entrance_exam_minimum_pct()
location = self.old_course_key.make_usage_key('discussion', block_id='Discussion1') self.draft_mongo.delete_item(location, self.user_id)
return self
cv_score = cv_estimate(3)
ir = IsotonicRegression(increasing='auto', out_of_bounds="raise") ir.fit(x, y)
self.client.logout() response = self.client.get(self.url) self.assertEqual(response.status_code, 302)
module = inspect.getmodule(method) if module is not None: if not module.__name__.startswith('pylearn2'): return method_errors
MEDIA_ROOT = '/edx/var/edxapp/media/' MEDIA_URL = '/media/'
if sys.platform.startswith('win'): return max(0, t - .1) else: return t
resp_status = self.client.get( reverse_course_url( 'import_status_handler', self.course.id, kwargs={'filename': os.path.split(self.bad_tar)[1]} ) )
problem_location = self.problem_location(problem_url_name) modx_url = self.modx_url(problem_location, 'problem_reset') resp = self.client.post(modx_url) return resp
try: group_id = get_group_id_for_comments_service(request, course_key, commentable_id) except ValueError: return HttpResponseBadRequest("Invalid cohort id") if group_id is not None: thread.group_id = group_id
pred_entropies = stats.distributions.entropy(lp_model.label_distributions_.T)
BOK_CHOY_STUB_DIR = REPO_ROOT / "common" / "djangoapps" / "terrain"
self.init_.fit(X, y, sample_weight)
email_params = get_email_params(self.course, True) email_params["email_address"] = "user@example.com" email_params["full_name"] = "Jean Reno" return email_params
assert not any([key in rval for key in contrib]) assert all([key in params for key in contrib])
self.q(css="input.no_special_exam").first.click()
i, j = np.triu_indices(X.shape[0], k=1) X = X[i, j]
if self.is_legacy_event: self._set_legacy_event_type() self.process_legacy_fields() self.process_event() self.dump_payload()
desc = "currently at section '{0}' and subsection '{1}'".format(section_title, subsection_title) return EmptyPromise( lambda: self.is_on_section(section_title, subsection_title), desc )
self.course = CourseFactory.create(default_store=default_store)
from scipy.sparse import csc_matrix
return _get_array_element('contrast change', label, (0.8, 1.3))
if getattr(self, 'video_speed_optimizations', True) and cdn_url: branding_info = BrandingInfoConfig.get_config().get(self.system.user_location)
self.asset_collection.update( {'_id': course_assets.doc_id}, {'$set': {self._make_mongo_asset_key(asset_key.asset_type): all_asset_info}} ) return 1
problem = new_loncapa_problem(xml_str, capa_system=self.capa_system)
cet = CourseEmailTemplate.objects.get(name='foo') self.assertIsNotNone(cet)
self.learning_rates = {} self.base_lr = theano._asarray(base_lr, dtype=theano.config.floatX)
m_space, m_source = model.get_monitoring_data_specs() spaces.append(m_space) sources.append(m_source)
enrollment_record = CourseEnrollment.objects.get( user=user, course_id=course_id ) self.assertFalse(enrollment_record.is_active)
quoteChar = quoteChar.strip() if len(quoteChar) == 0: warnings.warn("quoteChar cannot be the empty string",SyntaxWarning,stacklevel=2) raise SyntaxError()
self._verify_split_test_import( 'split_test_copy', 'split_test_module', 'split1', {"0": 'sample_0', "2": 'sample_2'}, )
request = RequestFactory().get('/') request.user = student return request
course_id = student_module.course_id student = student_module.student usage_key = student_module.module_state_key
CourseModeFactory.create(mode_slug=mode, course_id=self.course.id, min_price=1)
self.assertEquals( preview.latex_preview('epsilon_max', variables=['epsilon_max']), r'\epsilon_{max}' )
return JsonResponse({"error": "Assignment type must be specified."}, 400)
problems = { "checkbox_two_choices": checkbox_two_choices, "checkbox_2_choices_2_inputs": checkbox_two_choices_two_inputs }
i = np.argsort(dist2, axis=1) row_ind = np.arange(n_rows)[:, None] dist2 = dist2[row_ind, i] ind2 = ind2[row_ind, i]
raise NotImplementedError
self.record_visit_outline()
return "<LibraryFixture: org='{org}', number='{number}'>".format(**self.library_info)
r2_scorer = make_scorer(r2_score) mean_squared_error_scorer = make_scorer(mean_squared_error, greater_is_better=False) mean_absolute_error_scorer = make_scorer(mean_absolute_error, greater_is_better=False) median_absolute_error_scorer = make_scorer(median_absolute_error, greater_is_better=False)
for stream in (self.stdout, self.stderr): stream.flush()
return aside_id.aside_type
self.assertNotIn(malicious_code, resp.content)
return self.q(css="#register-email").attrs('value')[0]
return -np.sum((pi / pi_sum) * (np.log(pi) - log(pi_sum)))
response = requests.get(self.url + "?test_param=") self.assertEqual(response.status_code, 400)
assert_almost_equal(s[:k], sap, decimal=3)
return self.q(css=self._bounded_selector('.visibility-button')).is_present()
ml_cost = (self.free_energy_given_v(pos_v).mean() - self.free_energy_given_v(neg_v).mean())
return "library_content"
lc_block = self._add_library_content_block(course, self.lib_key) lc_block = self._refresh_children(lc_block) self.assertEqual(len(lc_block.children), 0)
self.assertEqual(len(response['results']), expected_length) unused_class = self.create_badge_class(check_course, slug='unused_slug', issuing_component='unused_component')
yield_results[current_node] = should_yield_node
with self.assertRaises(AssertionError): self.kvs.set(self.other_key_factory(self.existing_field_name), "new_value")
self.url = reverse('course_modes_choose', args=[unicode(self.course.id)])
self.q(css='div.problem button.reset').click() self.wait_for_ajax()
return self.runtime.get_edited_on(self)
blocks = get_course_blocks(user, usage_key, transformers)
ir = IsotonicRegression(increasing='auto', out_of_bounds="xyz")
global_admin = AdminFactory() for role in (CourseStaffRole, CourseInstructorRole): auth.add_users(global_admin, role(course.id), user)
return MockBucket(bucket_name)
self.course.start = _LAST_WEEK self.assertTrue(self.course.has_started()) self.course.start = _NEXT_WEEK self.assertFalse(self.course.has_started())
COURSE_BLOCK_ACCESS_TRANSFORMERS = [ library_content.ContentLibraryTransformer(), start_date.StartDateTransformer(), user_partitions.UserPartitionTransformer(), visibility.VisibilityTransformer(), ]
'milestones',
request = self.factory.get('/') request.user = AnonymousUser() mako_middleware_process_request(request) student.views.index(request)
serialized_tab = tab.to_json() deserialized_tab = tab.from_json(serialized_tab) self.assertEquals(serialized_tab, deserialized_tab)
rng = check_random_state(0) n_features = 5 n_samples = 40 n_output = 4
layers = [model.visible_layer] + model.hidden_layers
conditional_params = self.mlp.fprop(X) if not type(conditional_params) == tuple: conditional_params = (conditional_params, ) return conditional_params
world.visit('/') assert_in(uname, world.css_text('span.account-username', timeout=10))
return self._xblock_map[usage_key]
lc_block = self._add_library_content_block(course, self.lib_key) lc_block = self._refresh_children(lc_block) course_block = modulestore().get_item(lc_block.children[0])
for child in old_block_relations[block_key].children: if child in pruned_block_relations: self._add_to_relations(pruned_block_relations, block_key, child)
self.assertNotEqual(prg1, prg2) self.assertEqual(prg1, prg3)
self.client.login(username=self.coach.username, password="test")
CourseEnrollment.unenroll(self.student, self.EXISTED_COURSE_KEY_2)
self.create_thread_helper(mock_request, extra_response_data={'context': ThreadContext.STANDALONE})
nearest_center, inertia = _labels_inertia(X, x_squared_norms, centers, distances=distances)
log.debug("No refund opened for user [%s], course [%s]", unenrolled_user.id, course_key_str)
predictions = cval.cross_val_predict(clf, X_sparse, X) assert_equal(predictions.shape, (10, 2))
log.warning( "Error while previewing chemical formula", exc_info=True) result['error'] = _("Error while rendering preview")
CourseEnrollmentFactory.create(user=self.user, course_id=self.course.id, is_active=True)
self.assertRedirects(resp, settings.LOGIN_REDIRECT_URL + '?next=' + reverse('dashboard'))
self.find_css('.certificate-course-title-input').first.fill(value)
if isinstance(instance, RestrictedCourse): CourseAccessRuleHistory.save_snapshot(instance) elif isinstance(instance, CountryAccessRule): CourseAccessRuleHistory.save_snapshot(instance.restricted_course)
module_path, _, name = engine_path.rpartition('.') return getattr(import_module(module_path), name)
form = self.get_form(expected_valid=True) self.assertDictEqual(form.cleaned_data, self.cleaned_data)
self.wait_for_certificate_delete_button() self.find_css('.actions .delete.action-icon').first.click()
if X.shape[1] == 1: ddof = 0
CourseEnrollment.enroll(self.user, self.course.id, mode="honor")
AccessTestData( partition_groups={1: 1, 2: 2}, xblock_access={1: [1]}, merged_parents_list=[{1: {3}}, {1: {1}}], expected_access=True, ),
resource['id'] = self.resource_id_second self.check_event_response_by_key('handle_vote', resource, 'newVotes', test_case['new_votes'])
DELAY = 0.5
n_fits = len(out) n_folds = len(cv)
ground_truth_coef = rng.randn(n_features) y = np.dot(X, ground_truth_coef)
if self.escChar: ret = re.sub(self.escCharReplacePattern,"\g<1>",ret)
self._initialize_mixed(contentstore=contentstore, mappings={})
output = self._run_command(self.TEST_ORG) self._assert_output(output, (self.user, self.courses[0].id, opt_in_pref))
'unsubmitted': 'unanswered', 'incomplete': 'incorrect', 'queued': 'processing',
video_id = cls.fetch_youtube_video_id(course_key) if video_id: return "http://www.youtube.com/watch?v={0}".format(video_id)
manage.py ... transfer_students -f edX/Open_DemoX/edx_demo_course -t edX/Open_DemoX/new_demoX
REMOVE_SPAN_TAG_RE = re.compile(r'</span>(.+)<span')
response_dict = self.put_handler(self.course, expected_response_code=400) self.assertEqual("Cohort name must be specified.", response_dict.get("error"))
num_purchases = 0 for item in purchases: num_purchases += 1 self.assertEqual(num_purchases, 2)
train_sizes_abs = _translate_train_sizes(train_sizes, n_max_training_samples) n_unique_ticks = train_sizes_abs.shape[0] if verbose > 0: print("[learning_curve] Training set sizes: " + str(train_sizes_abs))
context.update(configuration.get(user_certificate.mode, {}))
ANALYTICS_SERVER_URL = ENV_TOKENS.get("ANALYTICS_SERVER_URL") ANALYTICS_API_KEY = AUTH_TOKENS.get("ANALYTICS_API_KEY", "")
milestones_helpers.remove_course_content_user_milestones( course_key=usage_key.course_key, content_key=usage_key, user=student, relationship='fulfills' )
self.q(css='.dismiss-button').click()
if text: wait_for(lambda _: css_text(css_selector, index=index))
return unicode(course_id) in cls._get_restricted_courses_from_cache()
for field in ('traits', 'integrations', 'userAgent'): if field in context['client']: del context['client'][field]
def edge(request): return redirect('/')
try: while True: observer.join(2) except KeyboardInterrupt: observer.stop() print("\nStopped asset watcher.")
return self.q(css=self.BOOKMARKS_BUTTON_SELECTOR).visible
if self._is_field_visible("terms_of_service"): terms_text = _(u"Honor Code")
return False
return value.isoformat()
return element.is_displayed() and all(size > 0 for size in element.size.itervalues())
def get_context(self): context = super(TodaysDate, self).get_context() context['date'] = '' return context
filedata = json.dumps(subs, indent=2) filename = subs_filename(subs_id, language) return save_to_store(filedata, filename, 'application/json', item.location)
request2 = self.request_factory.post('/create_account', data=postvars) request2.session = client.session request2.user = AnonymousUser()
X = np.array(list(product(range(N_per_side), repeat=2)))
return self.scope_ids.usage_id.course_key.library
self.user = UserFactory(password=self.password, is_staff=True) self.client.login(username=self.user.username, password=self.password)
top_idx = set(component.argsort()[-3:][::-1]) assert_true(tuple(sorted(top_idx)) in correct_idx_grps)
'survey',
'ratelimitbackend.middleware.RateLimitMiddleware', 'edxmako.middleware.MakoMiddleware',
cov = pca.get_covariance() precision = pca.get_precision() assert_array_almost_equal(np.dot(cov, precision), np.eye(d), 12)
self.assertFalse(self.page.intro_video_element.visible)
session_status = request.session.setdefault("import_status", {}) courselike_string = unicode(courselike_key) + filename _save_request_status(request, courselike_string, 0)
VerificationStatus.add_verification_status( checkpoint=self.first_checkpoint, user=self.user, status='submitted', ) attempt = SoftwareSecurePhotoVerification.objects.filter(user=self.user)
return 1 / numpy.cos(arg)
new_mean_squared_grad = ( self.decay * mean_square_grad + (1 - self.decay) * T.sqr(grads[param]) )
return super(NullBackend, self).has_override_value(val_name)
p_idx = rng.randint(num_p)
from multiprocessing.pool import Pool
return _check_range_and_return('lumination_change', label, -19, 19)
gated_content = gating_api.get_gated_content(self.course, self.effective_user) if gated_content: if unicode(self.section.location) in gated_content: raise Http404
with self.assertRaises(VersionConflictError): _fail = modulestore().create_child( user, new_course.location, 'chapter', fields={'display_name': 'chapter 3'}, )
clf = IsolationForest(max_samples=100, random_state=rng) clf.fit(X_train) y_pred_train = clf.predict(X_train) y_pred_test = clf.predict(X_test) y_pred_outliers = clf.predict(X_outliers)
if hasattr(locator, 'version_agnostic'): locator = locator.version_agnostic() if hasattr(locator, 'branch'): locator = locator.replace(branch=None) return locator
def test_user_role(): return 'staff'
self.assertRaises( IntegrityError, BadgeClass.get_badge_class, slug='new_slug', issuing_component='new_component', image_file_handle=get_image('good') )
ecommerce_url_root = helpers.get_value('ECOMMERCE_PUBLIC_URL_ROOT', settings.ECOMMERCE_PUBLIC_URL_ROOT) return urljoin(ecommerce_url_root, self.config.single_course_checkout_page)
attempt.mark_ready() assert_equals(attempt.status, "ready")
np.random.seed(0) n_samples, n_features = 100, 100
n_nonzero_coefs = max(int(0.1 * X.shape[1]), 1)
raise NotImplementedError
with self.assertRaises(xmodule.exceptions.NotFoundError): get_request_dict = {CapaFactory.input_key(): '3.14'} module.check_problem(get_request_dict)
n_fits = len(out)
self.assertEquals(self.get_about_page_link(), None)
blocks_stack.extend(children)
StudentModule.objects.create( student=user, course_id=self.course_key, module_state_key=problem_location, state=json.dumps({}) )
Yt /= np.sqrt((Yt ** 2).sum())
return Registration.objects.get(user__email=email)
if len(col_names) == 1: data_name = col_names[0] dataset['data'] = matlab_dict[data_name] else: for name in col_names: dataset[name] = matlab_dict[name]
self.assertEqual( len(CourseEnrollment.objects.filter(mode='honor', user_id__in=user_ids)), expected_conversions )
from __future__ import unicode_literals
username_label = _(u"Public username")
self.assertIn('id', team) self.assertIn('discussion_topic_id', team) self.assertEqual(team['id'], self._expected_team_id(team, expected_prefix))
perms_map = DjangoModelPermissions.perms_map.copy() perms_map['GET'] = perms_map['OPTIONS'] = perms_map['HEAD'] = perms_map['POST']
elif strategy == "most_frequent":
self._assert_request_status(request_uuid, 'pending')
LANGUAGES_BIDI = ("he", "ar", "fa", "ur", "fa-ir", "rtl")
return descriptor.id
answer.field_value = value answer.course_key = course_key answer.save()
self.assertIn(error_msg, result['success'])
instructor = self.make_instructor() self.assertTrue(CourseInstructorRole(self.course.id).has_user(instructor))
root_dir = path(mkdtemp_clean()) print 'Exporting to tempdir = {0}'.format(root_dir) export_course_to_xml(self.store, content_store, course.id, root_dir, 'test_export')
features_in_first_mlp = 5 features_in_second_mlp = 10 targets_in_first_mlp = 2 targets_in_second_mlp = 2
return ( _has_catalog_visibility(courselike, CATALOG_VISIBILITY_CATALOG_AND_ABOUT) or _has_staff_access_to_descriptor(user, courselike, courselike.id) )
self.q(css='a[data-section=data_download]').first.click() data_download_section = DataDownloadPage(self.browser) data_download_section.wait_for_page() return data_download_section
'sources': [u'example.mp4', u'example.webm', u'http://www.meowmix.com'],
GeneratedCertificate.eligible_certificates.all().delete()
return {key: getattr(self, key) for key in self.FEATURES}
assert images[3] == kerns[3] flops = kerns[1] * kerns[2] * 2 #nb flops by output image flops *= out[1] * out[2] flops *= images[3] * kerns[0] * images[0] return flops
return cls.PROFILE_COUNTRY_CACHE_KEY.format(user_id=user_id)
pass
pass
self.descriptor.display_name = '\x1e' with self.assertRaises(ValueError): self.descriptor.definition_to_xml(None)
video = self.store.get_item(child_to_move_location)
PROGRAMS_STUB_URL = os.environ.get('programs_url', 'http://localhost:8090')
no_ids = [] self.reload_course() for textbook in self.course.pdf_textbooks: del textbook["id"] no_ids.append(textbook) self.assertEqual(no_ids, textbooks)
self.refund_window_microseconds = int(refund_window.total_seconds() * 1000000)
return [Attribute('options', transform=cls.parse_options), Attribute('label', ''), Attribute('inline', False)]
if isinstance(to_space, CompositeSpace):
predict = pipe.predict(X) assert_equal(predict.shape, (n_samples,))
sampling_algorithm = dict((key, value) for key, value in sampling_algorithm.items() if key in selected_algorithm)
Y_neg = Y.copy() Y_neg[0, 0] = -1 assert_raises(ValueError, transform.transform, Y_neg)
X, y = _rescale_data(X, y, sample_weight)
headers_str = "{}\n\n{}".format(method, header_string(headers_dict)) body_str = body_string(body_dict) message = headers_str + body_str return message
AutoAuthPage(self.browser, course_id=self.course_id).visit() self.team_page.visit() self.assertFalse(self.team_page.edit_team_button_present)
nvcc_compiler.add_standard_rpath(cuda_convnet_loc)
if user: self.q(css='input[id^=sd_fu_]').first.fill(user) self.q(css='section.staff-modal a.staff-debug-reset').click()
if not sparse.isspmatrix_lil(connectivity): if not sparse.isspmatrix(connectivity): connectivity = sparse.lil_matrix(connectivity) else: connectivity = connectivity.tolil()
STRING_PAYLOAD = 'string_payload'
if strategy == "median": median = np.empty(len(columns)) for i, column in enumerate(columns): median[i] = _get_median(column, n_zeros_axis[i])
val = Decimal("{0:.2f}".format(Decimal(self.percentage_discount / 100.00) * cost)) return cost - val
top_level_logger.propagate = False
course = get_dummy_course('2012-12-02T12:00') self.assertEqual('', course.end_datetime_text("DATE_TIME"))
assert_raises(TypeError, csc_median_axis_0, sp.csr_matrix(X))
return EmptyPromise( lambda: self.q(css='#replace-courselike-button')[0], "Upload button appears", timeout=30 ).fulfill()
resp = self.client.get('/') self.assertEqual(resp.status_code, 200) self.assertContains(resp, 'footer-openedx')
keep_lambda = lambda_ < self.threshold_lambda coef_[~keep_lambda] = 0
self.fake_payment_page.submit_payment()
s = X.shape if len(s) > 1: return tuple(tuplify(row) for row in X) else: return tuple(r for r in X)
for i, hyperparameter in enumerate(kernel.hyperparameters): theta[i] = np.log(42) kernel.theta = theta assert_almost_equal(getattr(kernel, hyperparameter.name), 42)
self.assertEquals(preview.latex_preview('x', variables=['x']), 'x')
self.assertEqual(sysex.exception.args, (1,))
pass
print("Estimated betas") print(np.round(pls1.coef_, 1))
cache_key = u"{}".format(course.id)
if not isinstance(content, str): raise AssertionError("Expected content to be of type str, got " + str(type(content)))
return modules_to_update.filter(state__contains='"done": true')
pass
out = StringIO() assert_raises(IndexError, export_graphviz, clf, out, class_names=[])
if getattr(settings, "THEME_NAME", "") == "": settings.THEME_NAME = None return
class_priority = ['video', 'problem']
sorted_languages = sorted(languages.items(), key=itemgetter(1))
inline_xml = kwargs.pop('inline_xml')
block_structure._collect_requested_xblock_fields()
X, y = iris.data, iris.target base = DecisionTreeClassifier()
self.save()
expected = { "action": "add", "results": [ { "identifier": identifier, "error": False, "userDoesNotExist": False } ] }
set_input_value(page, css, value).send_keys(Keys.ENTER) page.wait_for_ajax()
module.system.user_is_staff = False
for n_samples, n_features in ((6, 5), ):
users_state = self._get_users_state()
ind = self.subclusters_.index(subcluster) self.subclusters_[ind] = new_subcluster1 self.init_centroids_[ind] = new_subcluster1.centroid_ self.init_sq_norm_[ind] = new_subcluster1.sq_norm_ self.append_subcluster(new_subcluster2)
url = reverse('create_mode', args=[unicode(self.course.id)]) response = self.client.get(url)
resp = self.client.post( '/course/bad/course/key/entrance_exam', {}, http_accept='application/json' ) self.assertEqual(resp.status_code, 400)
iris = datasets.load_iris()
if hasattr(clusterer, "random_state"): clusterer.set_params(random_state=0)
ridge = Ridge(alpha=penalties[:-1]) assert_raises(ValueError, ridge.fit, X, y)
try: indent = min(len(s) - len(s.lstrip()) for s in docstring if s.strip()) except ValueError: indent = 0
query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(None, query) self.assertEqual(result, attempt)
if self.metadata_inheritance_cache_subsystem is not None: self.metadata_inheritance_cache_subsystem.set(unicode(course_id), tree)
GlobalStaff().add_users(self.user) self.client.login(username=self.user.username, password='foo')
ridge.fit(X, y, sample_weight=np.ones(n_samples)) assert_greater(ridge.score(X, y), 0.9)
seq_css = 'ol#sequence-list>li>.nav-item>.sequence-tooltip' return self.q(css=seq_css).map(self._clean_seq_titles).results
self.cohort_management_page.select_always_inline_discussion()
if len(student) != 2: if len(student) > 0: build_row_errors('data_format_error', student[user_index], row_num)
with self.assertRaises(InvalidKeyError): call_command('reindex_library', invalid_key)
response = organizations_helpers.get_organization_by_short_name('non_existing') self.assertIsNone(response)
BLACKLIST = [ 'CompositeLayer',
self.assertEqual( res_json['message'], "{user} is not enrolled in this course. Please check your spelling and retry.".format( user=self.certificate_exception['user_name'] ) )
skip_if_no_sklearn() mapping = {'dataset_iterator': 'DatasetKFold'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
indices = np.array(indices, dtype=int) indices.shape = (-1, 2) return indices
return self.cache_ttl > 0
self._necessary_X_, self._necessary_y_ = X, y
self.assertEquals( value, request.session.get(LANGUAGE_SESSION_KEY, UNSET) )
launch_mcd_on_dataset(1000, 5, 450, 0.1, 0.1, 540)
clf = ExtraTreesClassifier(n_estimators=500, max_features=1, criterion="entropy", random_state=0).fit(X, y)
return None
mlp = MLP(nvis=10, layers=[Linear(layer_name='h', dim=10, irange=0.01)]) Conditional(mlp=mlp, name='conditional')
layer_to_state = dbm.make_layer_to_state(1) v_state = layer_to_state[v] h1_state = layer_to_state[h1] h2_state = layer_to_state[h2]
db_table = 'django_comment_client_permission'
linkedin_config = LinkedInAddToProfileConfiguration.current()
_ = lambda text: text
return list(whitelist_countries - blacklist_countries)
field_data_cache = FieldDataCache([], course.id, request.user) about_module = get_module( request.user, request, loc, field_data_cache, log_if_not_found=False, wrap_xmodule_display=False, static_asset_path=course.static_asset_path, course=course )
start=datetime.datetime(2012, 2, 3, tzinfo=UTC)
def test_real_user(useless): useless_user = Mock(email='fake@fake.com', id=useless) return useless_user
list_check = lambda x: isinstance(x, list) clf = CheckingClassifier(check_X=list_check) scores = cval.cross_val_score(clf, X.tolist(), y.tolist())
if stop_words is not None: tokens = [w for w in tokens if w not in stop_words]
self.wait_for_closed_captions() closed_captions_selector = self.get_element_selector(CSS_CLASS_NAMES['closed_captions']) subs = self.q(css=closed_captions_selector).html return ' '.join(subs)
reg = svm.SVR(kernel='linear', C=0.1).fit(X, y)
lc_block = self._add_library_content_block(course, self.lib_key) lc_block = self._refresh_children(lc_block) self.assertEqual(len(lc_block.children), 1)
remove_entrance_exam_graders(course_key, request.user)
err = Exception mock_index_dictionary.return_value = err
LOOKUP.clear()
emit_field_changed_events( user, user, sender._meta.db_table, excluded_fields=['last_login', 'first_name', 'last_name'], hidden_fields=['password'] )
return models.AccessToken.objects.get(token=token_string)
return CourseDetails.fetch_about_attribute(course_overview.id, 'overview')
return self.q(css='.action-publish').first
return self._find_within('.discussion-thread#thread_{}'.format(thread_id)).present
self.client.defaults['SERVER_NAME'] = 'example.none' self.url_prefix = 'http://example.none'
if 'open_in_browser_url' in self.context: self['page'] = self.context.pop('open_in_browser_url').rpartition('/')[0]
pred = pred.ravel() return 2.0 * (y - pred > 0.0) - 1.0
KEY_CSRF_TOKENS = ('csrf_token', 'csrf') for key in KEY_CSRF_TOKENS: if key in context_dictionary: context_dictionary[key] = unicode(context_dictionary[key])
self.B = sharedX(numpy.zeros(self.nvis) + B0, name='B', borrow=True)
if not GlobalStaff().has_user(user): course_keys = [course_key for course_key in course_keys if has_access(user, access_type, course_key)]
U, mu, V = fbpca.pca(X, n_comps, raw=True, n_iter=n_iter, l=n_oversamples+n_comps) call_time = time() - t0
assert_equal(np.sum(s_clf.coef_ != 0.0), n_informative)
microsite.set_by_domain(domain) return func(request, *args, **kwargs)
return bool(self.get_configuration())
if not history_entries: raise self.DoesNotExist()
X = iris.data[:, pair] y = iris.target
from pylearn2.utils import serial from pylearn2.utils.logger import ( CustomStreamHandler, CustomFormatter, restore_defaults )
return self.children()
while True: self.len_idx = np.mod(self.len_idx+1, len(self.len_unique)) curr_len = self.len_unique[self.len_idx] if self.len_curr_counts[curr_len] > 0: break
self.model.enforce_constraints()
raise InvalidCreditRequirements
if (('python2.7/site-packages/gunicorn/workers/sync.py' in exc_str) and ('[Errno 11] Resource temporarily unavailable' in exc_str)): exc_str = ''
self._create_course_unit() self.assertFalse(self.video.is_autoplay_enabled)
if six.PY3: py_integer_types = (int, np.integer) py_number_types = (int, float, complex, np.number) else:
response = self._load_dashboard() self.assertContains(response, "credit-request-approved-msg")
self.wait_for_element_visibility( self._bounded_selector(self.EDITOR_SELECTOR), "Note Editor is visible." )
else: log.error(traceback.format_exc()) _ = self.capa_system.i18n.ugettext raise ResponseError( _("CustomResponse: check function returned an invalid dictionary!") )
#texinfo_appendices = []
raw_image_url = self.course_image_url
course_key = CourseKeyField() class Meta(object): model = CreditCourse exclude = ('id',)
rnn_mo = neighbors.RadiusNeighborsClassifier(weights=weights, algorithm=algorithm) rnn_mo.fit(X_train, y_train) y_pred_mo = rnn_mo.predict(X_test)
def __init__(self): self.data = {}
clf = IsolationForest(random_state=rng, contamination=0.25) clf.fit(X) decision_func = - clf.decision_function(X) pred = clf.predict(X)
if self.system.resources_fs is None: self.syllabus_present = False else: self.syllabus_present = self.system.resources_fs.exists(path('syllabus'))
self.assertEqual( descriptor._xmodule.get_html(), descriptor.render(STUDENT_VIEW).content )
msg = "LinearSVC does not support sample_weight." assert_warns_message( UserWarning, msg, calibrated_clf.fit, X_train, y_train, sample_weight=sw_train) probs_with_sw = calibrated_clf.predict_proba(X_test)
source_suffix = '.rst'
event_info['correct_map'] = correct_map.get_dict() event_info['success'] = success event_info['attempts'] = self.attempts self.track_function_unmask('problem_rescore', event_info)
cls.objects.filter(id__in=requirement_ids).update(active=False)
response_element = etree.Element("stringresponse")
self.assertInCourseListing(source_course_key) self.assertInCourseListing(destination_course_key)
def __init__(self, location): super(InvalidVersionError, self).__init__() self.location = location
pass
with Timer() as iteration_over_groups_time_2: courses_list, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(len(courses_list), USER_COURSES_COUNT)
self.assertEqual(self.course_info_page.num_updates, 1)
return self.q(css='.page-content-secondary .team-language :last-child').text[0]
module = ''
return _get_backing_memmap(b)
self.assert_register_response_before_pipeline_looks_correct(self.client.get('/register'))
if not self.warm_start: self._clear_state()
return urljoin(self.public_service_url, '/api/v{}/'.format(self.api_version_number))
pr_url = os.environ.get('CI_PULL_REQUEST') if not pr_url: exit("not a pull request")
override_field_for_ccx( ccx_course_object, master_course_object, 'max_student_enrollments_allowed', valid_input['max_students_allowed'] )
visibility_editor = self.edit_component_visibility(component) for label in labels: visibility_editor.select_option(label, save=False) visibility_editor.save()
return self.client.get(reverse("dashboard"))
resp = self.create_xblock(category='vertical') usage_key = self.response_usage_key(resp)
y_error = np.zeros(n_test)
create_account(self.USERNAME, self.PASSWORD, self.EMAIL)
incorrect = y_predict != y
certificate_html_view_configuration_model = apps.get_model("certificates", "CertificateHtmlViewConfiguration") certificate_html_view_configuration_model.objects.all().delete()
dbm = make_random_basic_binary_dbm( rng = rng, pool_size_1 = pool_size_1, )
#today = '' today_fmt = '%B %d, %Y'
resp = self.create_xblock(category='static_tab', parent_usage_key=course.location) usage_key = self.response_usage_key(resp)
@ignore_warnings def test_random_hasher(): hasher = RandomTreesEmbedding(n_estimators=30, random_state=1) X, y = datasets.make_circles(factor=0.5) X_transformed = hasher.fit_transform(X)
number_aware_alphabetical_key = cmp_to_key(number_aware_alphabetical_cmp)
all_assets[asset_idx] = mdata.to_storable() return all_assets
if matched == ';': return ';;' elif matched == '/': return ';_' else: return matched
return [Attribute('height'), Attribute('width'), Attribute('molecules'), Attribute('geometries'), ]
rng = np.random.RandomState(42) X = rng.randint(20, size=(4, 5))
"weighted_f0.5_score", "weighted_f1_score", "weighted_f2_score", "weighted_precision_score", "weighted_recall_score",
elif usage_key.category in DIRECT_ONLY_CATEGORIES: return get_published()
self.send_response(500, 'Bad Request: does not contain API key') self.send_header('Content-type', 'text/plain') self.end_headers() return False
config.add_subpackage('__check_build') config.add_subpackage('_build_utils')
if course is None: course = modulestore().get_course(xblock.location.course_key)
course.self_paced = True self.store.update_item(course, self.user.id) self.assertTrue(course.self_paced)
return restore( self._modulestore._clean_locator_for_mapping(locator) )
self.events.append({"event": event, "event_type": event_type}) old_publish(block, event_type, event)
old_inertia, incremental_diff = _mini_batch_step( X_mb, x_mb_squared_norms, new_centers, counts, buffer, 1, None, random_reassign=False) assert_greater(old_inertia, 0.0)
return (BlockTypeKeyV1(key.block_family, key.block_scope_id), key.field_name)
clamped_val = clamp * initial
from __future__ import unicode_literals
query_time = query.get('duration', 0) / 1000
component_css = 'button[data-category={}]'.format(name) page.wait_for_element_visibility(component_css, 'Advanced component {} is visible'.format(name))
GITHUB_REPO_ROOT = ENV_TOKENS.get('GITHUB_REPO_ROOT', GITHUB_REPO_ROOT)
return _("regenerated") if self.is_regeneration else _("generated")
return JsonResponse({"error": "Cohort name must be specified."}, 400)
if not include_expired: found_course_modes = found_course_modes.filter( Q(_expiration_datetime__isnull=True) | Q(_expiration_datetime__gte=now) )
self._click_button('save_settings')
from __future__ import unicode_literals
user.is_staff = True
result[mask] = 0.0
A_xT = self.rmul(self.transpose_right(x, True)) rval = self.transpose_left(A_xT, True) return rval
resp = self.client.get_html(get_url('container_handler', self.vert_loc)) self.assertEqual(resp.status_code, 200)
self.q(css='.new-library-button').first.click() self.wait_for_ajax()
return ModuleStoreEnum.Type.split
self.teams_page.click_specific_topic("Example Topic") self.teams_page.verify_topic_team_count(1)
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, source_course_key): component = self.store.get_item(unit.location) self.assertEqual(component.display_name, updated_display_name)
self.assertFalse(payload.get('success')) self.assertIn('incorrect', payload.get('value'))
X = [[0], [0]] Y = [[1], [2]] D = paired_euclidean_distances(X, Y) assert_array_almost_equal(D, [1., 2.])
if hasattr(variable, 'name') and variable.name is not None: return variable.name return anon
self.assertEqual( course_complete.badge_description(self.course, 'honor'), 'Completed the course "Badged" (honor, 2015-05-19 - 2015-05-20)' )
logging.warning("Did not find key commentable_id in content.") passes_condition = False
joined += ','
log.exception("Error in django view.") return render_to_response(template_path, context)
if dE < tol * errors[-1]: if verbose == 1: print("") elif verbose: print("--- Convergence reached after %d iterations" % ii) break
with self.assertRaises(IndexError): mocked_request = self.get_signed_grade_mock_request(namespace_lti_v1p1=False) self.xmodule.parse_grade_xml_body(mocked_request.body)
return self.q(css='.breadcrumb').present
certs_api.set_cert_generation_enabled(self.course.id, True)
EDXNOTES_STUB_URL = os.environ.get('edxnotes_url', 'http://localhost:8042')
LogoutPage(self.browser).visit()
self.check_discussion( tab_list=self.tabs_with_discussion, expected_discussion_link="default_discussion_link", expected_can_display_value=True, )
if key.scope not in self.VALID_SCOPES: raise InvalidScopeError(key, self.VALID_SCOPES) if key.scope == Scope.content: self._load_definition()
le = LabelEncoder() ret = le.fit_transform([1, 1, 4, 5, -1, 0]) assert_array_equal(ret, [2, 2, 3, 4, 0, 1])
self._assert_course_verification_status(None)
pipeline = Pipeline([ ('vect', CountVectorizer()), ('tfidf', TfidfTransformer()), ('clf', SGDClassifier()), ])
while (svd_restarts < max_svd_restarts) and not has_converged:
module.system.DEBUG = True
r = 0.1 real_cov = toeplitz(r ** np.arange(n_features)) coloring_matrix = cholesky(real_cov)
linkedin = 'LinkedIn' facebook = 'Facebook' twitter = 'Twitter'
module_class = SplitTestModule
self.q(css=self.COMPONENT_BUTTONS[button_name]).first.click() self.wait_for_ajax()
G_iso = neighbors.kneighbors_graph(clf.embedding_, n_neighbors, mode='distance').toarray()
self.q(css='a[data-section=certificates]').first.click() certificates_section = CertificatesPage(self.browser) certificates_section.wait_for_page() return certificates_section
location = u'i4x://edX/DemoX/edx-reverification-block/invalid_location' checkpoint = VerificationCheckpoint.get_or_create_verification_checkpoint(self.course.id, location)
click_css(self, '.view-live-button', require_notification=False) self.browser.switch_to_window(self.browser.window_handles[-1])
for name in SCORERS.keys(): yield check_scorer_memmap, name
self.reindex_button.click()
kpca = KernelPCA() Xt = kpca.fit_transform(X) assert_equal(Xt.shape, (3, 0))
self.store.publish(locations['parent'], self.user_id)
keep_idx = numpy.arange(not marginalize_odd, depth, 2) for i in keep_idx: fe -= T.dot(samples[i], b_list[i]) * beta
freq = defaultdict(int) for tok in tokens(doc): freq[tok] += 1 return freq
return self.func(*args)
sampler_updates = self.sampler.updates()
assert_raises(NotImplementedError, conv_model.cost, Y, Y_hat) assert_raises(NotImplementedError, mlp_model.cost, Y1, Y1_hat)
self.course_db = {}
sorted_block_requirements = sorted( block_requirements, key=lambda x: (x['start_date'] is None, x['start_date'], x['display_name']) )
ScopeIds(None, category, loc, loc), DictFieldData(data_content),
for desc in xblock_descriptions: loc = self.create_xblock(parent_loc, desc) self._create_xblock_children(loc, desc.children)
status_by_req = defaultdict(lambda: False) for status in CreditRequirementStatus.get_statuses(requirements, username): status_by_req[status.requirement.id] = status.status
self.url = reverse('instructor_dashboard', kwargs={'course_id': self.course.id.to_deprecated_string()})
resources = find_release_resources() sh("i18n_tool transifex push " + " ".join(resources))
setattr(self, hyperparameter.name, np.exp(theta[i:i + hyperparameter.n_elements])) i += hyperparameter.n_elements
'ENABLE_DISCUSSION_SERVICE': True, 'ENABLE_TEXTBOOK': True,
recipient_selector_css = "input[name='send_to'][value='{}']".format(recipient) self.q(css=self._bounded_selector(recipient_selector_css))[0].click()
self.verify_success_on_file_content( 'username,cohort\nfoo_username,bar_cohort', mock_store_upload, mock_cohort_task )
raise ValueError("Invalid value for test_size: %r" % test_size)
course = self.runtime.modulestore.get_course(self.course_id) return course
return self.pdf.current_page_count() == 1
all_assets = course_assets[asset_key.asset_type] md = AssetMetadata(asset_key, asset_key.path) md.from_storable(all_assets[asset_idx]) md.update(attr_dict)
distances[k - n_samples] = edge.weight
self.assertEqual(self.problem_page.problem_name, self.problem_name)
CertificateGenerationConfiguration.objects.create(enabled=True)
BULK_EMAIL_ROUTING_KEY_SMALL_JOBS = LOW_PRIORITY_QUEUE
for key, value in attrs.items(): self.assertEquals(getattr(video, key), value)
pass
import matplotlib.pyplot as plt
db_query = models.StudentModule.objects.filter( course_id__exact=course_id, module_type__exact="sequential", ).values('module_state_key').annotate(count_sequential=Count('module_state_key'))
assert_raises(ValueError, cval.KFold, 2.5, 2)
self.login(email, password) self.enroll(self.course, verify=True)
problem_child = self.store.create_child(self.user_id, chapter_location, 'problem', 'Problem_Child') self.assertFalse(self.store.has_published_version(problem_child))
self.exp_dirichlet_component_ = np.exp( _dirichlet_expectation_2d(self.components_)) self.n_batch_iter_ += 1 return
output = assets._get_asset_json("my_file", content_type, upload_date, location, thumbnail_location, True)
if library: return component_templates
return self._bookmarks_cache(course_key, fetch=True)
try: code_redemption = cls.objects.get(registration_code__code=code, registration_code__course_id=course_id) except cls.DoesNotExist: code_redemption = None return code_redemption
self._check_linkedin_visibility(False)
self.assertIsNone(getattr(self.request, 'session', None)) self.assertIsNone(getattr(self.request, 'safe_cookie_verified_user_id', None))
self._forward_pass(activations, with_output_activation=False) y_pred = activations[-1]
log.info("background task (%s), state %s: result: %s", task_id, result_state, returned_result) task_output = InstructorTask.create_output_for_success(returned_result)
if not xblock.has_children: return False for child in xblock.get_children(): if is_visible_to_specific_content_groups(child): return True return False
hasher = HashingVectorizer(n_features=opts.n_features, stop_words='english', non_negative=True, norm=None, binary=False) vectorizer = make_pipeline(hasher, TfidfTransformer())
self.xblock.location = Location("org", "import", "run", "category", "stubxblock") self.xblock.save()
num_choices = len(self.descriptor.get_children())
top_level_logger.propagate = True
if cur_retry < 5: update_ccxcon.apply_async( kwargs={'course_id': course_id, 'cur_retry': cur_retry + 1},
self.assertCourseSummaryFields(course_summaries)
try: content = contentstore().find(self.content_location) contentstore().delete(content.location) except NotFoundError: pass
CONFIG_PREFIX = SERVICE_VARIANT + "." if SERVICE_VARIANT else ""
BULK_EMAIL_FAILURE_ERRORS = (
input_dict = {'1_2_1': '42', '1_2_2': '42'} correct_map = problem.grade_answers(input_dict)
course = modulestore().get_course(self.toy_course_key) config_course_cohorts(course, is_cohorted=True) self.assertEqual([], cohorts.get_course_cohorts(course))
from datetime import timedelta, datetime import json
return StackedBlocks(layers)
BULK_EMAIL_EMAILS_PER_TASK = 100
assert_almost_equal(np.diag(y_cov), np.exp(kernel.theta[0]), 5)
super(OAuth2ProviderConfig, self).clean() self.other_settings = clean_json(self.other_settings, dict)
CELERY_RESULT_BACKEND = 'djcelery.backends.cache:CacheBackend'
csgraph_from_dense = None
num_to_add = max_count - len(selected)
self.assertEqual(self.export_page.header_text, 'Course Export')
(14, True, u"True"),
with self.assertNumQueries(12): api.set_credit_requirement_status( user.username, self.course_key, requirements[0]["namespace"], requirements[0]["name"] )
module = CapaFactory.create(done=False)
CONFIG_PREFIX = SERVICE_VARIANT + "." if SERVICE_VARIANT else ""
return create_xblock_info( course_module, include_child_info=True, course_outline=True, include_children_predicate=lambda xblock: not xblock.category == 'vertical', user=request.user )
if isinstance(obj, CourseDescriptor): return _has_access_course(user, action, obj)
kwargs['explanation_text'] = None return super(CodeResponseXMLFactory, self).build_xml(**kwargs)
caption_line_selector = ".subtitles li[data-index='{index}']".format(index=line_number - 1) attributes = self.q(css=caption_line_selector).attrs('class') return 'focused' in attributes
self.course_fixture.create_xblock( parent_vertical.locator, XBlockFixtureDesc(category='poll', display_name="", data=load_data_str('poll_markdown.xml')) ) self.course_outline_page.visit()
certs_api.set_cert_generation_enabled(self.course.id, False) self._assert_enable_certs_button_is_disabled()
disabled_create_block_types = XBlockDisableConfig.disabled_create_block_types() return [c_type for c_type in ADVANCED_COMPONENT_TYPES if c_type not in disabled_create_block_types]
resp = self._change_enrollment('enroll') self.assertEqual(resp.status_code, 403)
module1.set_state_from_lcp() self.assertEqual(module1.lcp.inputs.keys(), module1.input_state.keys())
print("\r[dl] %6.2f%% %s" % (min(totalsize,blocks*blocksize)*100.0/totalsize, hook_download_filename), end='') sys.stdout.flush()
skip_if_no_sklearn() trainer = yaml_parse.load(test_yaml_ovr) trainer.main_loop()
permutation_option = None if response.has_shuffle(): permutation_option = 'shuffle' elif response.has_answerpool(): permutation_option = 'answerpool'
hidden_layer_sizes = self.hidden_layer_sizes if not hasattr(hidden_layer_sizes, "__iter__"): hidden_layer_sizes = [hidden_layer_sizes] hidden_layer_sizes = list(hidden_layer_sizes)
]
test_course_data = self.assert_created_course() course_id = _get_course_id(self.store, test_course_data) delete_course_and_groups(course_id, self.user.id) self.assert_created_course()
return np.hstack([l.ravel() for l in coefs_ + intercepts_])
template = self.system.render_template('lti_form.html', self.get_context()) return Response(template, content_type='text/html')
oldcmap = self.correct_map
THIRD_PARTY_AUTH_CUSTOM_AUTH_FORMS = AUTH_TOKENS.get('THIRD_PARTY_AUTH_CUSTOM_AUTH_FORMS', {})
if '/' == asset_key_string[0]: asset_key_string = asset_key_string[1:] asset_key = AssetKey.from_string(asset_key_string) try: delete_asset(course_key, asset_key) except AssetNotFoundException: pass
return 'xqueue/submit' in self.path
self._check_verticals([self.vert_loc])
c_mapping = DataSpecsMapping(channel.data_specs) channel_inputs = c_mapping.flatten(channel.graph_input, return_tuple=True) inputs = c_mapping.flatten(nested_theano_args[i + 1], return_tuple=True)
scaler_batch = MaxAbsScaler().fit(X)
B, C, IR, IC = ishp4 K, CH, KR, KC = kshp4
user = XBlockUser() user.opt_attrs['edx-platform.username'] = 'test user' return user
#latex_domain_indices = True
instructor_user = User.objects.create_user('test_instructor_user', 'test_instructor_user@openedx.org', 'test') CourseInstructorRole(self.master_course_key).add_users(instructor_user)
true_sum = pred_sum = tp_sum = np.zeros(len(labels))
from courseware.module_render import get_module_for_descriptor field_data_cache = FieldDataCache([descriptor], course.id, request.user) return get_module_for_descriptor( request.user, request, descriptor, field_data_cache, course.id, course=course )
self.assertIsNone(VerificationDeadline.deadline_for_course(self.course.id))
'ADDITIONAL_OPTIONS': { 'trashcan': { 'bucket': 'trash_fs' } }
template_dir_name = "about" module_class = AboutModule
return location in self._locations_to_scores
conv_first_part = ConvElemwise(8, [2, 2], 'sf1', SigmoidConvNonlinearity(), .1) mlp_first_part = MLP(layers=[conv_first_part], input_space=Conv2DSpace(shape=[5, 5], num_channels=2))
self.method = method self.submit_url = submit_url self.fields = [] self._field_overrides = defaultdict(dict)
filesystem = OSFS(root_dir / 'test_export/static') exported_static_files = filesystem.listdir() self.assertTrue(filesystem.exists(asset_displayname)) self.assertEqual(len(exported_static_files), 1)
from __future__ import unicode_literals
index_entry = self._get_index_if_valid(course_key, force) structure = self._lookup_course(course_key).structure
ipca = IncrementalPCA(n_components=2, batch_size=10).fit(X) Y = ipca.transform(X) Y_inverse = ipca.inverse_transform(Y) assert_almost_equal(X, Y_inverse, decimal=3)
BlockDepthTransformer().transform(usage_info=None, block_structure=block_structure) BlockNavigationTransformer(0).transform(usage_info=None, block_structure=block_structure) block_structure._prune_unreachable()
cached_module = self.modulestore.get_cached_block(course_key, version_guid, block_key) if cached_module: return cached_module
label_bg_color = Attribute('label_bg_color', default=None).parse_from_xml(self.xml) if label_bg_color: to_js['label_bg_color'] = label_bg_color
assert_raises(ValueError, compute_sample_weight, [{1: 2, 2: 1}], y_)
assert_almost_equal(dists[3], 2, decimal=5)
NPM_VENDOR_DIRECTORY = path("common/static/common/js/vendor")
bandwidth = 1.2
location = Location("HarvardX", "ER22x", "2013_Spring", "conditional", "condone")
self.assertEqual(bookmark, bookmark2) self.assertEqual(bookmark.xblock_cache, bookmark2.xblock_cache) self.assert_bookmark_model_is_valid(bookmark2, bookmark_data)
clf.fit(X, y) assert_array_equal(np.diff(clf.scores_) > 0, True)
return get_instructions(xmltree)
return ResponseXMLFactory.choicegroup_input_xml(**kwargs)
TRANSFORMER_VERSION_KEY = '_version'
course = modulestore().get_course(course_id, depth=2)
return [(k,self[k]) for k in self.__tokdict.keys()]
self.assertTrue(self._is_location_published(location)) self.assertTrue(modulestore().has_changes(modulestore().get_item(location)))
y_true, _, probas_pred = make_prediction(binary=True)
url(r'^api/courses/', include('course_api.urls')),
return self._line_start_indexes[line_number - 1]
return submit_rescore_problem_for_all_students(self.create_task_request(instructor), InstructorTaskModuleTestCase.problem_location(problem_url_name))
CreditProvider.objects.create( provider_id="ASU", enable_integration=True, provider_url="https://credit.example.com/request", )
raise CommandError(_( 'Invalid permission option: "{}". Please specify permissions ' 'using the format: app_label:model_name:permission_codename.' ).format(permission))
SEARCH_ENGINE = "search.tests.mock_search_engine.MockSearchEngine" MOCK_SEARCH_BACKING_FILE = ( TEST_ROOT / "index_file.dat" ).abspath()
X = csr_matrix(Xdigits[:4])
self.lc_block.get_child_descriptors() event_data = self._assert_event_was_published("assigned")
for row in unicodecsv.DictReader(csv_file): if row.get('Username') == username: self.assertEqual(row[column_header], expected_cell_content)
self.assertIn(SESSION_KEY, self.client.session)
snapshot = json.loads(record.snapshot) self.assertEqual(snapshot['enroll_msg'], enroll_msg) self.assertEqual(snapshot['access_msg'], access_msg)
AutoAuthPage(self.browser).visit()
bulk_write_record = self._get_bulk_ops_record(course_key) if bulk_write_record.active: bulk_write_record.index = updated_index_entry else: self.db_connection.update_course_index(updated_index_entry, course_context=course_key)
intersphinx_mapping = {'http://docs.python.org/': None}
EmptyPromise(self.is_filename_error_showing, 'Upload Error Displayed', timeout=30).fulfill()
obj = OAuth2ProviderConfig(**kwargs) obj.save() return obj
#html_additional_pages = {}
from edxmako.shortcuts import render_to_response from mako.exceptions import TopLevelLookupException from django.http import HttpResponseNotFound
self.current_request_configuration.data = {} self.current_request_configuration.cache = {}
'ALLOW_UNICODE_COURSE_ID': False,
data = rng.binomial(1, 0.5, size=np.size(indices)) * 2 - 1
child = self.store.get_item(locations['child']) child.display_name = 'Changed Display Name' self.store.update_item(child, self.user_id)
self.assertEquals(self.middleware.process_request(self.request), None)
has_skipped = cache_values.get(has_skipped_cache_key) if has_skipped is None: has_skipped = SkippedReverification.check_user_skipped_reverification_exists(user, course_key) cache.set(has_skipped_cache_key, has_skipped)
resp = self.client.get(course_wiki_page, follow=False) self.assertEqual(resp.status_code, 302)
CourseModeFactory.create( course_id=self.course.id, mode_slug=CourseMode.HONOR, mode_display_name=CourseMode.HONOR, )
js = {'coffee': [resource_string(__name__, 'js/src/raw/edit/metadata-only.coffee')]} js_module_name = "MetadataOnlyEditingDescriptor" mako_template = "widgets/metadata-only-edit.html"
comment = kwargs['post'] handle_activity(kwargs['user'], comment, long(comment.thread.user_id))
xblock_desc.publish = "not-applicable"
range_ = T.tile(range_.dimshuffle(0, 'x'), (1, self.binary_target_dim)).flatten()
self.client.logout() response = self.client.post(reverse('commerce:checkout_receipt')) self.assertEqual(response.status_code, 302)
return view_auth_classes(is_user)
assert all([layer in layer_to_updated for layer in layer_to_state]) assert all([layer in layer_to_state for layer in layer_to_updated]) assert all([(layer_to_state[layer] is layer_to_updated[layer]) == layer_to_clamp[layer] for layer in layer_to_state])
self.assertEqual(result['order'].status, 'purchased') self.assert_dump_recorded(result['order'])
if class_probability is None: class_prob_j = np.empty(shape=classes[j].shape[0]) class_prob_j.fill(1 / classes[j].shape[0]) else: class_prob_j = np.asarray(class_probability[j])
assert X.ndim == 2 return T.nnet.softmax(X * self.P)
return mode_slug in cls.VERIFIED_MODES
ignore_warnings(lshf.partial_fit)(X) assert_array_equal(X, lshf._fit_X)
GITHUB_REPO_ROOT = (TEST_ROOT / "data").abspath() LOG_DIR = (TEST_ROOT / "log").abspath()
if not settings.FEATURES.get('MILESTONES_APP', False): return None from milestones import api as milestones_api return milestones_api.add_milestone(milestone_data)
'badges',
EmptyPromise( lambda: self.is_focused_on_element(selector), "Focus is on other element" ).fulfill()
task_input = {'student_set': "all_whitelisted"}
payload = json.loads(response.content) thread = extract_thread(payload) if extract_thread else payload self._assert_thread_contains_group_info(thread)
return {"username": settings.SAUCE.get('USERNAME'), "access-key": settings.SAUCE.get('ACCESS_ID')}
train_sizes_abs = _translate_train_sizes(train_sizes, n_max_training_samples) n_unique_ticks = train_sizes_abs.shape[0] if verbose > 0: print("[learning_curve] Training set sizes: " + str(train_sizes_abs))
np.random.seed(0)
if not isinstance(Y, np.ndarray): raise ValueError("y_pred should be an array of floats.")
normalizer = (1.0 - pow(self.gamma, self.n_observations)) / \ (1.0 - self.gamma)
if use_org_level_role: OrgLibraryUserRole(self.lib_key.org).add_users(self.non_staff_user) else: LibraryUserRole(self.lib_key).add_users(self.non_staff_user)
self.assertEqual(self.server.config, {})
qs_args = { 'issuing_component': badge_class.issuing_component, 'slug': badge_class.slug, } if check_course: qs_args['course_id'] = self.get_course_id(wildcard, badge_class) return qs_args
new_user_partition = UserPartition(
grade_distrib = get_problem_set_grade_distrib(course_id, problem_set)
self.course_fixture = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
with remove_ccx(location) as (location, restore): return restore( self._modulestore.delete_item(location, user_id, **kwargs) )
length = int(self.headers.getheader('content-length')) data_string = self.rfile.read(length) post_dict = json.loads(data_string)
self.course_outline.open_subsection_settings_dialog()
self.assertTrue(CourseEnrollment.is_enrolled(self.user, course_key)) return test_course_data
course_mode = CourseMode.DEFAULT_SHOPPINGCART_MODE
return np.vstack([kernel.bounds for kernel in self.kernels])
'ENABLE_COURSEWARE_INDEX': False,
self.course_outline.open_subsection_settings_dialog()
if self.should_show_check_button(): check_button = self.check_button_name() check_button_checking = self.check_button_checking_name() else: check_button = False check_button_checking = False
task_args = [entry_id, {}] return task_class.apply(task_args, task_id=task_id).get()
from __future__ import unicode_literals
_update_context_with_user_info(context, user, user_certificate)
self.children.extend(args) return self
CourseEnrollmentFactory( is_active=True, course_id=self.course.id, user=self.user )
course_usage_main_vertical = self.lc_block.children[0] course_usage_inner_vertical = self.store.get_item(course_usage_main_vertical).children[0] inner_vertical_in_course = self.store.get_item(course_usage_inner_vertical) course_usage_html = inner_vertical_in_course.children[0] course_usage_problem = inner_vertical_in_course.children[1]
return fragment
monitor = lm.LiveMonitor() monitor.update_channels(['train_objective'], start=1, end=2) assert(len(monitor.channels['train_objective'].val_record) == 1)
self.assertIsInstance(response, HttpResponseRedirect)
return unicode(obj.course.course_key)
if self.name == "edx.video.seeked": self['name'] = "edx.video.position.changed"
problem_section = ItemFactory.create(parent_location=chapter.location, category='sequential', metadata={'graded': True, 'format': problem_section_format}, display_name=problem_section_name)
pv = PatchViewer(grid_shape, vis_chains.shape[1:3], is_color=vis_chains.shape[-1] == 3) for i in xrange(m): pv.add_patch(vis_chains[i, :], rescale=False) return pv
def setUp(self): super(TestCourseActionStateManagerBase, self).setUp() self.course_key = CourseLocator("test_org", "test_course_num", "test_run")
X, y = make_classification(n_samples=20, n_features=10, shuffle=False, random_state=0)
v3.set_params = '_invalid_analyzer_type_' assert_raises(ValueError, v3.build_analyzer)
iris = datasets.load_iris()
redeem_url = reverse('register_code_redemption', args=[context['reg_code_info_list'][0]['code']])
self.assertGreater(len(params['signed_date_time']), 0) self.assertGreater(len(params['transaction_uuid']), 0)
yield check_oob_score, name, csc_matrix(boston.data), boston.target, 50
CACHE_TOOLBOX_DEFAULT_TIMEOUT = getattr( settings, 'CACHE_TOOLBOX_DEFAULT_TIMEOUT', 60 * 60 * 24 * 3, )
self.q( css='#paging-header-select option[value={sort_order}]'.format(sort_order=sort_order) ).click() self.wait_for_ajax()
self.assertEqual(response.status_code, 400)
for visible in self.VISIBLE_CONTENT[user_tag]: self.assertIn(visible, content)
err_string = "Invalid course_key: '{0}'".format(invalid_key) with self.assertRaisesRegexp(CommandError, err_string): call_command('reindex_course', invalid_key)
'idset': idset,
return VisibilityState.needs_attention
y = np.dot(X, w) y = np.sign(y)
__, course_ids = mock_get_programs.call_args[0] self.assertEqual(list(course_ids), [self.course_1.id]) self._assert_responses(response, 1)
self.assertNotIn( 'test_content_field', new_version.get_explicitly_set_fields_by_scope(scope=Scope.content) ) self.assertNotIn( 'test_settings_field', new_version.get_explicitly_set_fields_by_scope(scope=Scope.settings) )
yaml_parse = None control = None cuda = None
self._validate(is_numeric, batch)
self.enrollment.delete()
iris = load_iris() X = iris.data y = iris.target transft = TransfT() pipeline = Pipeline([('mock', transft)])
DarkLangConfig( released_languages=('es-419, es, es-es'), changed_by=self.user, enabled=True ).save() self.assertAcceptEquals( expected, self.process_request(accept=accept_header) )
iris = datasets.load_iris()
response = self.session.post( url, data=self._encode_post_dict(details), headers=self.headers, )
internal_result = self.check_formula(ans1, ans2, self.samples) return internal_result == "correct"
if problemtree in self.responders: overall_msg = self.correct_map.get_overall_message() return self.responders[problemtree].render_html( self._extract_html, response_msg=overall_msg )
assert isinstance(key_or_alias, string_types) try: return super(alias_dict, self).__getitem__(key_or_alias) except KeyError: return super(alias_dict, self).__getitem__( self.__a2k__[key_or_alias])
PYTHON_COVERAGERC = REPO_ROOT / ".coveragerc"
self.register_page.visit() self.assertScreenshot('#register .login-providers', 'register-providers-{}'.format(self.browser.name))
sampling_algorithm["custom-tracking-selection"] = \ lambda n_population, n_samples, random_state=None: \ sample_without_replacement(n_population, n_samples, method="tracking_selection", random_state=random_state)
response = self.client.get(self.programs_path) self.assertEquals(response.status_code, status_code) return response
_base_iterator_cls = None
text_document = self._white_spaces.sub(" ", text_document)
while k < maxiter: fgrad, fhess_p = grad_hess(xk, *args)
ManualEnrollmentAudit.create_manual_enrollment_audit( manual_enrollment_audit.enrolled_by, student.email, ALLOWEDTOENROLL_TO_ENROLLED, manual_enrollment_audit.reason, enrollment )
self.assertGroupContent( groups[0], title=u"cool (2)", notes=[u"Third note", None] )
return SurveyForm.get_field_names_from_html(self.form)
normalizer = (1.0 - pow(self.gamma, self.n_observations - self.minibatch_index)) /\ (1.0 - self.gamma)
email = student[EMAIL_INDEX] username = student[USERNAME_INDEX] name = student[NAME_INDEX] country = student[COUNTRY_INDEX][:2]
gp.fit(X, y)
orphans = self.store.get_orphans(course_key) self.assertIn(orphan, orphans) self.assertEqual(len(orphans), 1)
sh("mongo {host}:{port} {repo_root}/scripts/delete-mongo-test-dbs.js".format( host=MONGO_HOST, port=MONGO_PORT_NUM, repo_root=Env.REPO_ROOT, ))
if cache: cleaned_results = json_safe(globals_dict) cache.set(key, (emsg, cleaned_results))
try: return CreditProvider.objects.get(active=True, provider_id=provider_id) except cls.DoesNotExist: return None
return self.q(css=self._bounded_selector('.cohorts-state')).selected
ItemFactory.create( parent=parent, category='discussion', display_name='scheduled', start=self.future, )
if location.category in DIRECT_ONLY_CATEGORIES: raise InvalidVersionError(location)
return _get_block_structure_manager(course_key).update_collected()
self.expect_error_on_file_content( '', "The file must contain a 'cohort' column containing cohort names." )
with self.assertNumQueries(1): self.field_data_cache = FieldDataCache([self.mock_descriptor], course_id, self.user) self.kvs = DjangoKeyValueStore(self.field_data_cache)
LogoutPage(self.browser).visit() AutoAuthPage(self.browser, course_id=self.course_id, staff=True).visit()
name_is_eq = (other.get('name') is None or self.name == other['name'])
assert_false(world.css_has_class('.CodeMirror', 'is-inactive')) assert_true(world.is_css_not_present('.tiny-mce')) type_in_codemirror(0, text)
folds = list(cv.split(X)) best_mse = np.inf
return [child.tag for child in elem]
plt.figure(fignum, figsize=(4, 3)) plt.clf()
course_org_filter = microsite.get_value('course_org_filter') if course_org_filter: field_dictionary['org'] = course_org_filter
with self.assertNumQueries(0): RestrictedCourse.is_restricted_course(new_course_id) RestrictedCourse.is_disabled_access_check(new_course_id)
return self.page.q(css=self.prefix + selector)
self._breadth_first(convert_item, [location])
response = self.http_get_for_course(HTTP_AUTHORIZATION=None) self.assertEqual(response.status_code, 401)
enrollment_start = DateTimeField(null=True) enrollment_end = DateTimeField(null=True) enrollment_domain = TextField(null=True) invitation_only = BooleanField(default=False) max_student_enrollments_allowed = IntegerField(null=True)
est = TreeEstimator() y2 = y[:-1] assert_raises(ValueError, est.fit, X, y2)
elif response.status_code != 200 or not success: if response.status_code == 200: response.status_code = 400 response.content = msg
bt = BallTree(X) distances_nn, neighbors_nn = bt.query(X, k=k + 1) neighbors_nn = neighbors_nn[:, 1:]
n_samples = 60 n_features = 20
self.navigate_to_video()
instance = cls.current() json_data = json.loads(instance.configuration) if instance.enabled else {} return json_data
self.assertEquals(4, len(response.content.splitlines()))
'ENABLE_SERVICE_STATUS': False,
'ENABLE_EDXNOTES': False,
mean_proba = np.zeros((X.shape[0], len(self.classes_))) for calibrated_classifier in self.calibrated_classifiers_: proba = calibrated_classifier.predict_proba(X) mean_proba += proba
return self.q(css="#prereq_min_score").visible
return any(role.has_permission(permission) for role in user.roles.filter(course_id=course_id))
many_days = datetime.timedelta(days=60)
sequential_open_distrib = {} for row in db_query: row_loc = course_id.make_usage_key_from_deprecated_string(row['module_state_key']) sequential_open_distrib[row_loc] = row['count_sequential']
user_id = abs(hash(username))
kwargs.setdefault("name", "Dummy") kwargs.setdefault("backend_name", "dummy") return cls.configure_oauth_provider(**kwargs)
module = CapaFactory.create(due=self.yesterday_str) self.assertFalse(module.should_show_check_button())
(ModuleStoreEnum.RevisionOption.published_only, 'assertOLXIsDraftOnly'), (ModuleStoreEnum.RevisionOption.all, 'assertOLXIsDeleted'), (None, 'assertOLXIsDeleted'),
return "{}/library/{}/team/".format(BASE_URL, unicode(self.locator))
for arr_format, arr in test_arrays.items(): assert_warns(UserWarning, check_symmetric, arr) assert_raises(ValueError, check_symmetric, arr, raise_exception=True)
msg_format = _("Status: {action} {succeeded} of {attempted}")
return self.q(css=self._bounded_selector(child_class.BODY_SELECTOR)).map( lambda el: child_class(self.browser, el.get_attribute('data-locator'))).results
module = CapaFactory.create(attempts=1, done=True)
self.assertFalse(has_access(self.normal_student, 'load', self.content, self.course.id))
X = X_2d n = X.shape[0]
try: return StudentModule.objects.get( student=user, course_id=course_key, module_state_key=block_key, state__contains='"selected": [[' ) except StudentModule.DoesNotExist: return None
return self.test_passed('.js-init-run')
search_engine = cls.engine() serialized_course_team = CourseTeamIndexer(course_team).data() search_engine.index(cls.DOCUMENT_TYPE_NAME, [serialized_course_team])
if not hasattr(view_converter, 'topo_space'): raise NotImplementedError("Not able to get a topo_space " "from this converter: %s" % view_converter)
y = check_array(y, accept_sparse='csr', ensure_2d=False, dtype=None)
return _("All learners")
raise NotImplementedError()
expected = inspect.getargspec(load_ndarray_dataset)[0][1:] data = load_ndarray_dataset(conf['dataset'], **subdict(conf, expected))
result = self.get_result(allow_cache_miss) self.verify_result_with_fallback_and_youtube(result)
self.assertTrue(self_paced_course.self_paced) self.assertEqual(self_paced_course.start, one_month_from_now) self.assertIsNone(self_paced_section.start)
assert_equal((i + 1), scaler_incr.n_samples_seen_)
Z = Z.reshape(xx.shape) plt.figure() plt.pcolormesh(xx, yy, Z, cmap=cmap_light)
return ''
descriptor = modulestore().get_item(self.course.location) section_grader_type = CourseGradingModel.get_section_grader_type(self.course.location)
layer_trainers[-1].main_loop()
module = CapaFactory.create(attempts=1)
return len(self.q(css=self.BOOKMARKED_ITEMS_SELECTOR).results)
ensemble = BaggingClassifier(base_estimator=DecisionTreeClassifier(), random_state=rng).fit(X_train, y_train)
from __future__ import unicode_literals
self._assert_course_verification_status(None)
X, y = iris.data, iris.target
formulahint_element.set("samples", sample_str)
if xblock.category == 'chapter': return xblock
if hasattr(self, 'dbm'): return self.dbm return None
if survey.utils.must_answer_survey(course, request.user): return redirect(reverse('course_survey', args=[unicode(course.id)]))
verbose = getattr(options, "verbose", None) cmd = "i18n_tool extract" if verbose: cmd += " -vv" sh(cmd)
('union', FeatureUnion( transformer_list=[
for verification in candidates: if verification.active_at_datetime(deadline): return verification
l_ups, learn_rates = self.learning_rate_updates(gradients) safe_update(ups, l_ups)
def __init__( self, contentstore=None,
bulk_ops_record = self._get_bulk_ops_record(structure_key) if not bulk_ops_record.active: return
if all_students or delete_module: if not has_access(request.user, 'instructor', course): return HttpResponseForbidden("Requires instructor access.")
n_samples_curr_lab = np.sum(mask) - 1 if n_samples_curr_lab != 0: intra_clust_dists[mask] = np.sum( current_distances[:, mask], axis=1) / n_samples_curr_lab
assert_not_in('rerandomize', seq.xml_attributes)
verify_group_id_present(profiled_user=self.student, pass_group_id=True) verify_group_id_present(profiled_user=self.moderator, pass_group_id=True) verify_group_id_present( profiled_user=self.student, pass_group_id=True, requested_cohort=self.student_cohort )
user_partititons = self.course.user_partitions self.assertEqual(len(user_partititons), 1) self.assertEqual(len(user_partititons[0].groups), 3)
X1[:, -1] = 1.0
if rolename == FORUM_ROLE_ADMINISTRATOR and not has_instructor_access: return HttpResponseBadRequest("Operation requires instructor access.")
status_headings = sorted( set([status for course in cert_data for status in cert_data[course]]) )
call = _get_user_defined_method(type(obj), '__call__', 'im_func') if call is not None: sig = signature(call)
self._check_params(n_samples)
self.batch_axis=list(axes).index('b') self.axes_to_sum = list(range(len(axes))) self.axes_to_sum.remove(self.batch_axis)
module = CapaFactory.create(due=self.yesterday_str, done=True) self.assertFalse(module.should_show_reset_button())
NOTIFICATION_EMAIL_CSS = "templates/credit_notifications/credit_notification.css" NOTIFICATION_EMAIL_EDX_LOGO = "templates/credit_notifications/edx-logo-header.png"
incxml = etree.XML(ifp.read())
resp = self.create_xblock(category='problem', boilerplate='nosuchboilerplate.yaml') self.assertEqual(resp.status_code, 200)
return {'queue_len': self.queue_len, }
html_last_updated_fmt = '%b %d, %Y'
self.set_many({kvs_key: value})
if publish: unit.publish_action.click() unit.view_published_version() self.assertEqual(len(self.browser.window_handles), 2) courseware_page.wait_for_page()
if '_dataset' in d: d['_datasets'] = [d['_dataset']] del d['_dataset']
return modulestore().has_item(location, revision=ModuleStoreEnum.RevisionOption.published_only)
mongo_store.collection.update( self.vertical_x1b.to_deprecated_son('_id.'), {'$push': {'definition.children': unicode(self.problem_x1a_1)}} )
split_test = self._update_partition_id(-50) self.assertEqual(2, len(split_test.children)) self.assertEqual(initial_group_id_to_child, split_test.group_id_to_child)
assert_raises(ValueError, check_is_fitted, ARDRegression, "coef_") assert_raises(TypeError, check_is_fitted, "SVR", "support_")
#html_use_index = True
self._test_missing_current_task(generate_certificates)
self._add_to_relations(self._block_relations, parent_key, child_key)
probas_ = self.predict_proba(X) return np.log(probas_)
save_submission(conf, valid_repr, test_repr)
self.assertContains(response, "<li class=\"wrapper-organization\">", 1)
response = JsonResponse(payment_data)
return self.q(css=MODAL_SELECTOR).present
assert_warns(UserWarning, BaggingRegressor(base_estimator=DecisionTreeRegressor(), n_estimators=1, bootstrap=True, oob_score=True, random_state=rng).fit, X_train, y_train)
contentstore('trashcan').save(content)
pass
urlpatterns += (url(r'^%s$' % key.lower(), 'static_template_view.views.render', {'template': template}, name=value),)
component.edit_visibility() return ComponentVisibilityEditorView(self.browser, component.locator)
with storebuilder.build() as (__, store): course = CourseFactory.create(modulestore=store)
return _check_range_and_return('instance', label, -1, 9, -1)
scores = cross_val_score(pipeline, X[:, np.newaxis], y, scoring="mean_squared_error", cv=10)
os.environ.clear() os.environ.update(_orig_environ)
self.q(css='.wrapper-create-library .new-library-save').click()
loss_l = self.loss.lower()
pass
sample_str = self._sample_str(sample_dict, num_samples, tolerance) response_element.set("samples", sample_str)
self.xmodule.verify_oauth_body_sign(self.get_signed_grade_mock_request())
elif request.method == 'DELETE': try: re_validate_certificate(request, course_key, certificate) except ValueError as error: return JsonResponse({'message': error.message}, status=400)
self.assertNotIn(self.seq_loc, chapter.children)
pathname = name_to_pathname(self.url_name) filepath = u'{category}/{pathname}.html'.format( category=self.category, pathname=pathname )
self.check_tab_json_methods(tab)
#epub_identifier = ''
le = LabelEncoder() assert_raises(ValueError, le.transform, []) assert_raises(ValueError, le.inverse_transform, [])
self.assertEqual(response.status_code, 204)
self.assertIsInstance( microsite.get_backend( 'microsite_configuration.backends.database.DatabaseMicrositeBackend', BaseMicrositeBackend ), DatabaseMicrositeBackend )
clf = svm.SVC(kernel='linear') clf.fit(X, Y)
response = self.session.get(url, headers=self.headers)
raise NotImplementedError()
depth = len(b_list)
clf = self.factory(loss='squared_loss', learning_rate='constant', eta0=eta, alpha=alpha, fit_intercept=True, n_iter=1, average=True, shuffle=False)
REQUIRE_DEBUG = False
'monitoring',
return cls._do_reindex(modulestore, course_key)
self.courseware_page.click_next_button_on_top() self.assert_navigation_state('Test Section 2', 'Test Subsection 2,1', 0, next_enabled=False, prev_enabled=True)
return self._create_user(username, email, is_staff=False, mode=mode)
score_bucket = get_score_bucket(grade, max_grade)
providers = OAuth2ProviderConfig.objects.all() self.assertEquals(len(providers), pcount + 2) self.assertEquals(providers[pcount].id, provider1.id) provider2 = providers[pcount + 1]
X = check_array(X, accept_sparse=('csr', 'csc'), copy=False, ensure_2d=False, dtype=FLOAT_DTYPES) original_ndim = X.ndim
self.wait_for_element_visibility( '#alert-confirmation-title', 'Alert confirmation title element is available' ) return self.get_element('#alert-confirmation-title')
if contains_nan(mu): logger.info('nan found') return X
store_iterator = iter(modulestores) next_modulestore = lambda *args, **kwargs: store_iterator.next()
return u"{course}, {provider}, {status}".format( course=self.course.course_key, provider=self.provider.provider_id, status=self.status, )
iris = load_iris() X = iris.data pca = PCA(n_components=2, svd_solver='full') pipeline = Pipeline([('pca', pca)])
title = ugettext_noop('Discussion') priority = None is_default = False
send_mail_to_student(student_email, email_params, language=language)
transactions = self._latest_history()['transactions'] self.assertItemsEqual(transactions, expected_transactions)
self.add_course_to_user_cart(self.xss_course_key) self.assertEquals(self.cart.orderitem_set.count(), 1)
exif_dict = piexif.load(exif) exif_dict['0th'][piexif.ImageIFD.Orientation] = orientation return piexif.dump(exif_dict)
self.request.user = user self.assertEqual(self.permission.has_object_permission(self.request, None, self.obj), permitted)
config.groups[1].remove() config.groups[0].name = "First Group" config.save()
self.assertTrue(self.cohort_management_page.is_category_selected())
config = cls.current() if not config.enabled: return () return config.disabled_blocks.split()
CertificateGenerationConfiguration.objects.create(enabled=False) cache.clear()
results = data.get_course_enrollments(self.user.username) self.assertEqual(results, created_enrollments)
NOT_SYMMETRIC_METRICS = [ "explained_variance_score", "r2_score", "confusion_matrix",
X_dense = check_array([[1, 2], [3, 4]]) assert_true(isinstance(X_dense, np.ndarray)) assert_raises(ValueError, check_array, X_ndim.tolist())
mode = 2 if Minv is None: Minv_matvec = get_inv_matvec(M, symmetric=True, tol=tol) else: Minv = _aslinearoperator_with_dtype(Minv) Minv_matvec = Minv.matvec M_matvec = _aslinearoperator_with_dtype(M).matvec
modulestore = XMLModuleStore(DATA_DIR, source_dirs=['toy']) courses = modulestore.get_courses() self.assertEquals(len(courses), 1) course = courses[0]
var_f_star = self.kernel_.diag(X) - np.einsum("ij,ij->j", v, v)
try: return int(value) except (ValueError, TypeError): return 0
return 'edx.mit.edu'
state = self.v_sample0 ki = 0
self.set_up_books(1)
if self._module_system: delattr(self._module_system, name) delattr(self._descriptor_system, name)
if value == 0: return 0 return math.pow(2, math.ceil(math.log(value, 2)))
user.is_staff = False user.save()
courses2 = import_course_from_xml( self.store, self.user_id, self.export_dir, source_dirs=[top_level_export_dir], static_content_store=contentstore, target_id=dest_course_key2, create_if_not_present=True, raise_on_failure=True, )
dense_classifier = AdaBoostClassifier( base_estimator=CustomSVC(probability=True), random_state=1, algorithm="SAMME" ).fit(X_train, y_train)
regex = r'\d+.\d+'
self.assertListEqual( self.get_item_from_modulestore(self.seq2_usage_key).children, [unit_1_key, unit_2_key], ) self.assertListEqual( self.get_item_from_modulestore(self.seq_usage_key).children,
self.assertFalse(user.badgeassertion_set.all())
for database_name in DATABASES: DATABASES[database_name]['ATOMIC_REQUESTS'] = False
'USE_YOUTUBE_OBJECT_API': False,
self.course_info['number'] = "335535897951379478207964576572017930000"
if perm != 'global': debug("Deny: invalid permission '%s'", perm) return ACCESS_DENIED return ACCESS_GRANTED if GlobalStaff().has_user(user) else ACCESS_DENIED
names = F.readline().strip().split(',')
query = [[1., 0.]]
new_sum_squared_grad = ( sum_square_grad + T.sqr(grads[param]) )
if requested_sort == 'date_added': requested_sort = 'uploadDate' elif requested_sort == 'display_name': requested_sort = 'displayname' sort = [(requested_sort, sort_direction)]
ONLOAD_BEACON_SAMPLE_RATE = 0.0
default_pc = 0.5
self.generated_certificate.invalidate()
app.add_javascript('js/copybutton.js') app.connect('autodoc-process-docstring', generate_example_rst)
response = self.client.get_json(make_url_for_lib(key_str)) self.assertEqual(response.status_code, 404)
def _str_header(self, name, symbol='`'): return ['.. rubric:: ' + name, '']
return super(DraftVersioningModuleStore, self)._find_course_assets( self._map_revision_to_branch(course_key) )
id_token = get_id_token(student, api_config.OAUTH2_CLIENT_NAME) return EdxRestApiClient(api_config.internal_api_url, jwt=id_token)
self.wait_for_ajax() super(LibraryEditPage, self).wait_until_ready()
self.find_css('.group-configuration-description-input').first.fill(value)
if 'course_id' in data and data['course_id'] is None:
msg = 'Unable to load file contents at path %s for item %s: %s ' % ( filepath, def_id, err) raise Exception, msg, sys.exc_info()[2]
'django_countries',
X, y = make_regression(n_samples=200, n_features=20, n_informative=5, shuffle=False, random_state=0, noise=10)
result = self.get_result(allow_cache_miss) self.verify_result_with_val_profile(result)
error_rate = OrderedDict((label, []) for label, _ in ensemble_clfs)
create_manual_course_enrollment( user=user, course_id=course_id, mode=course_mode, enrolled_by=enrolled_by, reason='Enrolling via csv upload', state_transition=UNENROLLED_TO_ENROLLED, )
verification_deadline = datetime(year=2020, month=12, day=31, tzinfo=pytz.utc) expiration_datetime = datetime.now(pytz.utc) response, expected = self._get_update_response_and_expected_data(expiration_datetime, verification_deadline)
self.verify_run_all_servers_task(options)
estimators = [("Tree", DecisionTreeRegressor()), ("Bagging(Tree)", BaggingRegressor(DecisionTreeRegressor()))]
self.assertEquals(USER_COUNT + 1, len(response.content.splitlines()))
root = etree.Element("problem")
return xmodule_instance_args.get('task_id', UNKNOWN_TASK_ID) if xmodule_instance_args is not None else UNKNOWN_TASK_ID
return self.find_css("#grading_type").present
return get_default_time_display(xblock.start) if xblock.start != DEFAULT_START_DATE else None
raise NotImplementedError
course_key = CourseKey.from_string(course_id) with modulestore().bulk_operations(course_key): response = get_course_topics(request, course_key) return Response(response)
'openedx.core.djangoapps.safe_sessions.middleware.SafeSessionMiddleware',
if self.warm_start and len(self.estimators_) > 0: random_state.randint(MAX_INT, size=len(self.estimators_))
still_in_grace = CapaFactory.create(showanswer='correct_or_past_due', max_attempts="1", attempts="1", due=self.yesterday_str, graceperiod=self.two_day_delta_str) self.assertFalse(still_in_grace.answer_available())
assert_raises(ValueError, clf.fit(X_, y_).predict, rng.random_sample((3, 12)))
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
test_model = CourseMetadata.fetch(self.fullcourse) self.assertNotIn('edxnotes', test_model)
upload_csv_to_report_store(csv_rows, 'course_survey_results', course_id, start_date)
try: return self[key] except KeyError: return default
return None
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit() attempt.approve()
user = User.objects.get(pk=user.pk)
list_check = lambda x: isinstance(x, list) clf = CheckingClassifier(check_X=list_check) predictions = cross_val_predict(clf, X.tolist(), y.tolist())
self.find_css('.signatory-name-input').first.fill(value)
'course_structure_api',
coef = 1. / (binomial(k, n_features) * (n_features - k))
self.user = UserFactory.create(username=self.USERNAME, password=self.PASSWORD) self.user.profile.name = self.USER_FULL_NAME self.user.profile.save()
non_eligible_statuses = ['failed', 'declined']
neighbors_nn = np.argsort(distances, axis=1)[:, :k]
return xml_import_data.policy.get(policy_key(usage_id), {})
milestones_api.add_course_milestone(course_key, 'requires', milestone)
if isinstance(space, CompositeSpace): return all(specifies_all_dtypes(subspace) for subspace in space.components) else: return space.dtype is not None
self.assertFalse(request.is_secure()) return SENTINEL
yield super(SharedModuleStoreTestCase, cls).setUpClass()
k = redirects.get(k, k) return index_map.setdefault(k, len(index_map))
templates_path = add_base(['_templates'])
self.submit_question_answer('p1', {'2_1': u'Correct'})
return render_message_to_string( subject_template, message_template, self.get_email_params_ccx() )
return field_object.field_name
'ENABLE_VERIFIED_CERTIFICATES': False,
url(r'^get_proctored_exam_results$', 'instructor.views.api.get_proctored_exam_results', name="get_proctored_exam_results"),
self.assertEqual(certificate.get_text('.action-primary'), "Create") certificate.click_create_certificate_button() self.assertIn(course_title_override, certificate.course_title) return certificate
for name in ALL_TREES: yield (check_no_sparse_y_support, name)
default=_("Text")
rng = rng = np.random.RandomState(42)
X, y = hastie_X, hastie_y ForestEstimator = FOREST_ESTIMATORS[name] clf = ForestEstimator(n_estimators=5, max_depth=3, warm_start=True, random_state=1) clf.fit(X, y)
if self.failed_only: opts += "--failed"
self._assert_course_verification_status(VERIFY_STATUS_MISSED_DEADLINE)
cls.mapping[transformer.match_key] = transformer return transformer
response_element.set("answer", str(answer))
if child.parent is None or child.parent > descriptor.scope_ids.usage_id: child.parent = descriptor.location child.save()
layer_to_state = dbm.make_layer_to_state(1) v_state = layer_to_state[v] y_state = layer_to_state[y]
try: item = cls.objects.select_related('microsite').get(organization=org) return item.microsite except ObjectDoesNotExist: return None
'ratelimitbackend.middleware.RateLimitMiddleware',
self.s_rng = make_theano_rng(seed, which_method="uniform")
instructor_role = CourseInstructorRole(course_id)
thumbs = store.get_all_content_thumbnails_for_course(course_loc) for thumb in thumbs: print "Deleting {0}...".format(thumb) store.delete(thumb['_id'])
ActionChains(self.browser).move_to_element(self.element).perform() self.wait_for_viewer_visibility() return self
adjusted_rand_scorer = make_scorer(adjusted_rand_score)
serialization_options = { 'favorite_editor': { 'default': 'vim', }, }
all = 'rev-opt-all'
grid = np.random.rand(10, 2, 1) assert_raises(ValueError, partial_dependence, clf, [0], grid=grid)
call_command("loaddata", "course_email_template.json")
buckets = 10 bucket_width = 1. / float(buckets) for i in xrange(buckets): lower_lim = i * bucket_width upper_lim = (i+1) * bucket_width
if position == "denominator": latex += render_frac(numerator, denominator) else: num_latex = r"\cdot ".join(k.latex for k in numerator) latex += num_latex
dd_intercept = np.squeeze(np.array(dX.sum(axis=0)))
try: assert_is_none(world.browser.get_alert()) except NoAlertPresentException: pass
raise NotImplementedError()
reg = svm.SVR(kernel='rbf', gamma=1).fit(X, y)
if self.find_css('.collection-edit').present: return 'edit' elif self.find_css('.collection').present: return 'details'
X = np.sqrt(fac) * (Xc / std) U, S, V = linalg.svd(X, full_matrices=False)
credit_request, created = CreditRequest.objects.get_or_create( course=credit_course, provider=credit_provider, username=username, )
self.assertEqual(CourseEnrollment.objects.count(), 1) enrollment = CourseEnrollment.objects.get(course_id=course_key) self.assertEqual(enrollment.user.username, "test")
response = requests.get(self._get_url("api/v1/annotations"), params={ "user": "dummy-user-id", "page": 2, "page_size": 3 })
X = np.asarray(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
self.assert_grade( problem, submission, correctness, msg="{0} should be {1}".format(name, correctness) )
return cls.current().base_url
'openedx.core.djangoapps.content.course_overviews', 'openedx.core.djangoapps.content.course_structures', 'lms.djangoapps.course_blocks',
h = hashlib.md5() h.update(str(seed)) return h.hexdigest()
self.assertTrue("success_file" in os.path.basename(filename)) store_file_data(storage, filename)
_ = lambda text: text
return self.find_css('.wrapper-delete-button').first.attrs('data-tooltip')[0]
self.assertTrue(hasattr(user, 'profile'))
@ignore_warnings def test_factor_analysis(): rng = np.random.RandomState(0) n_samples, n_features, n_components = 20, 5, 3
ROLE = 'finance_admin' def __init__(self, *args, **kwargs): super(CourseFinanceAdminRole, self).__init__(self.ROLE, *args, **kwargs)
out_file.write('%d -> %d ;\n' % (parent, node_id))
if RateLimitConfiguration.current().enabled: return func(*args, **kwargs) else: msg = "Rate limiting is disabled because `RateLimitConfiguration` is not enabled." LOGGER.info(msg) return
self.assertEqual(response.status_code, 400)
self.assertDeserializeEqual('10:20:30', '"10:20:30"')
self.q(css=selector).first.click() return self
CourseEnrollmentFactory(user=self.student, course_id=self.course_id)
try: from mpl_toolkits.basemap import Basemap basemap = True except ImportError: basemap = False
options.mode = 'run' test_js(options)
responses = self.xml.xpath('//stringresponse[@id=$id]', id=self.id) if responses: response = responses[0]
if minimum_grade_credit is not None: minimum_grade_credit = minimum_grade_credit
if not SignatureValidator(lti_consumer).verify(request): return HttpResponseForbidden()
@method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): return super(CreditCourseViewSet, self).dispatch(request, *args, **kwargs)
assert_true(world.css_contains_text(problem_css, category))
self.assertIn("Welcome to edX.", self.video.captions_text)
return u"Course '{}': Instructor Email {}Enabled".format(self.course_id.to_deprecated_string(), not_en)
template_context['js_init_parameters'] = json.dumps(frag.json_init_args).replace("/", r"\/")
y_true *= 2 y_pred *= 2 loss = log_loss(y_true, y_pred, normalize=False) assert_almost_equal(loss, 0.6904911 * 6, decimal=6)
selector = RFE(estimator, step=0.01) sel = selector.fit(X, y) assert_equal(sel.support_.sum(), n_features // 2)
safe_course_key = loc.course_key if safe_course_key.run is None: safe_course_key = safe_course_key.replace(run='only')
self._configure_message_timeout(10000)
result = self.service.delete_student_attempt( self.student.username, unicode(self.course.id), self.other_problem_urlname, requesting_user=self.student, ) self.assertIsNone(result)
#html_domain_indices = True
n_jobs, n_estimators, starts = _partition_estimators(n_more_estimators, self.n_jobs) total_n_estimators = sum(n_estimators)
for page in self.pages: page.visit()
y_type = type_of_target(y) if y_type == "multiclass": inversed = _inverse_binarize_multiclass(binarized, classes=classes)
if not hasattr(self, 'center'): self.center = False if not hasattr(self, 'gcn'): self.gcn = False
args.append(arg)
track_function = _get_track_function_for_task(student_module.student, xmodule_instance_args) track_function('problem_delete_state', {}) return UPDATE_STATUS_SUCCEEDED
pass
FEATURES['ENABLE_DASHBOARD_SEARCH'] = True
correct_map = problem.grade_answers({'1_2_1': 'choice_0'}) self.assertAlmostEqual(correct_map.get_npoints('1_2_1'), 1)
rng = self.mlp.rng if self.irange is None: raise ValueError("Recurrent layer requires an irange value in " "order to initialize its weight matrices")
for line in f:
X = X_2d[:100, :] n = X.shape[0]
self.q(css="input[name=authorize]").click()
courses_list = list(get_course_enrollments(self.student, None, [])) self.assertEqual(len(courses_list), 0)
try: api.regenerate_user_certificates(params["user"], params["course_key"], course=course)
SYSTEM_SHARED_MEM_FS = '/dev/shm'
self.login(self.email, self.pw)
self.assertEqual(0, CourseMode.min_course_price_for_currency(self.course_key, 'usd'))
log_ais_w = numpy.zeros(batch_size, dtype=floatX)
attempt.created_at = attempt.created_at - timedelta(days=364) attempt.save()
return "http://fake-edx-s3.edx.org/"
self.logout() self.login(self.instructor_user) self.assertTrue(self.enroll(self.course))
instance = model(pk=pk, **data)
assert not world.is_css_present('.link_lti_new_window', wait_time=0)
self.problem.system.is_author_mode = True self.assertEqual("original_get_html", self.problem.get_html())
return submit_rescore_problem_for_student(self.create_task_request(instructor), InstructorTaskModuleTestCase.problem_location(problem_url_name), student)
tasks = instructor_task.api.get_entrance_exam_instructor_task_history(course_id, entrance_exam_key)
combined = ":".join([key_prefix, version, key])
return self.q(css=".error").present
user = User.objects.get(username=username)
try: content = contentstore().find(asset_key) except NotFoundError: raise AssetNotFoundException
selector = self.get_element_selector(CSS_CLASS_NAMES['video_time']) current_seek_position = self.q(css=selector).text[0] return current_seek_position.split('/')[0].strip()
return course_mode_tuple.slug in cls.VERIFIED_MODES
privacy_policy = branding_api.get_privacy_url() if privacy_policy != branding_api.EMPTY_URL: data.update({'company_privacy_url': privacy_policy})
return "{}/container/{}".format(BASE_URL, self.locator)
self.assertEqual(result['success'], 'incorrect')
NEVER_PUBLISHED = 1 UNPUBLISHED_CHANGES = 2 PUBLISHED = 3 VALUES = [NEVER_PUBLISHED, UNPUBLISHED_CHANGES, PUBLISHED]
for dtype in ['f8', 'f4']: A = A.astype(dtype) B = B.astype(dtype)
instructor = AdminFactory.create() self.client.login(username=instructor.username, password="test")
raise NotImplementedError
REQUIRE_DEBUG = DEBUG
filterwarnings('ignore', message='No request passed to the backend, unable to rate-limit')
rng = np.random.RandomState(0) n_samples = 100 n_features = 10
item.video_bumper["transcripts"][lang] = filename
problem_not_specified = self.build_problem(answer="Second") problems = [problem_specified, problem_not_specified]
for index, (name, label, (x, y)) in enumerate( zip(names, labels, embedding.T)):
assert key.user_id == self.user.id
u, d, _ = linalg.svd(X, full_matrices=False)
email = user.email if user.is_authenticated() else request.POST.get('email')
self.set_state_from_lcp()
self.assert_social_auth_exists_for_user(request.user, strategy) self.assert_account_settings_context_looks_correct(account_settings_context(request), request.user, linked=True)
request.user = user request.scopes = [SCOPE_VALUE_DICT[scope]] request.client = client request.state = None request.refresh_token = None request.extra_credentials = None request.grant_type = client.authorization_grant_type
return { 'Content-type': 'application/json', 'Accept': 'application/json', 'X-CSRFToken': self.session_cookies.get('csrftoken', '') }
with override_settings(CREDIT_PROVIDER_SECRET_KEYS={}): response = self.post_credit_request(self.user.username, self.eligibility.course.course_key) self.assertEqual(response.status_code, 400)
enrollment_mode, is_active = CourseEnrollment.enrollment_mode_for_user(student, course_key) show_generate_cert_btn = ( is_active and CourseMode.is_eligible_for_certificate(enrollment_mode) and certs_api.cert_generation_enabled(course_key) )
self.cohort_management_page.select_cohort_some_inline_discussion()
self.matrices_save_path = None
self.assertEqual( 'student', access.get_user_role(self.anonymous_user, self.course_key) )
self.create_programs_config(program_listing_enabled=False) response = self.client.get(path=self.view_path) self.assertContains(response, '<li class="item nav-global-01">')
resp = self.client.post('/password_reset_confirm/{0}-{1}/'.format(uidb36, token), { 'new_password1': 'bar', 'new_password2': 'bar' }, follow=True)
return {"library": unicode(self.library.location.library_key.replace(version_guid=None, branch=None))}
course = modulestore().get_course(course_key) if course is None: return HttpResponse(status=400)
exp_doc_topic_d = exp_doc_topic[idx_d, :].copy() exp_topic_word_d = exp_topic_word_distr[:, ids]
return chapter_titles.index(title.lower()) + 1
self.check_group('checkboxtextgroup', 'choice', 'checkbox')
([[400, 150, 400, 1], [400, 450, 600, 2], [300, 225, 300, 3]],
student_id = AutoAuthPage(self.browser, course_id=self.course_id).visit().get_user_id()
kwargs['course_id'] = self.course.id.to_deprecated_string() url = reverse(url_name, kwargs=kwargs) return url
pls_ca = pls_.PLSCanonical(n_components=X.shape[1]) pls_ca.fit(X, Y)
url(r'^api/user/', include('openedx.core.djangoapps.user_api.urls')),
return self.relative_path_to_absolute_uri(self.ACCOUNT_SETTINGS_REFERER)
_ = lambda text: text
return getattr(settings, 'SOCIAL_AUTH_SAML_SP_PRIVATE_KEY', '')
from pylearn2.utils import serial
self._each_parens(r'\{x+y\}', 'x+y', '{')
if (not hasattr(openid_request, 'return_to') or not openid_request.return_to): log.error('empty return_to') return False
mode = CourseModeFactory.create() mode.course_id = self.course.id mode.min_price = 1 mode.save()
course_outline_page = CourseOutlinePage( self.browser, self.course_org, self.course_number, self.course_run ) course_outline_page.visit() course_outline_page.wait_for_page()
bounds = np.tile([-np.inf, np.inf], (parameters.shape[0], 1)) bounds[-1][0] = 1e-12
G = neighbors.kneighbors_graph(X, n_neighbors, mode='distance').toarray()
options = self.parse_options_string(options_string) self.reset_task_messages() call_task("pavelib.js_test.test_js_dev", options=options) self.verify_messages(options=options, dev_mode=True)
os.remove(filename)
xblock_info.update(_get_gating_info(course, xblock))
'EMBARGO': False,
clf = NearestCentroid() clf.fit(X, y) assert_array_equal(clf.predict(T), true_result)
self.client.logout() self.assert_can_create_course(HTTP_X_EDX_API_KEY=settings.EDX_API_KEY)
from __future__ import unicode_literals
self.assertTrue( self._check_equality(source_usage_key, usage_key, parent_usage_key, check_asides=check_asides), "Duplicated item differs from original" )
classifier = OneVsRestClassifier(svm.SVC(kernel='linear', probability=True, random_state=random_state)) y_score = classifier.fit(X_train, y_train).decision_function(X_test)
user2 = UserFactory.create() module.descriptor.bind_for_student(module.system, user2.id)
utf8_comment = b("It is true that\n\xc2\xbd\xc2\xb2 = \xc2\xbc") f = BytesIO() assert_raises(UnicodeDecodeError, dump_svmlight_file, X, y, f, comment=utf8_comment)
return JsonResponse(data)
rng = np.random.RandomState(0) X = rng.randn(10, 2) connectivity = kneighbors_graph(X, 5, include_self=False)
max_date = block_data.edit_info.edited_on max_date_by = block_data.edit_info.edited_by
'session_inactivity_timeout.middleware.SessionInactivityTimeout',
self.user.is_staff = True self.user.save() video_outline = self.api_response().data self.assertEqual(len(video_outline), 2)
for _ in xrange(30): self._send_bad_redirection_login()
X = iris.data batch_size = X.shape[0] // 3 ipca = IncrementalPCA(n_components=2, batch_size=batch_size) pca = PCA(n_components=2) pca.fit_transform(X)
child_id_regex = None child_type = None if child_types_ids: child_type = child_types_ids[0][0] child_id_regex = '|'.join([child[1] for child in child_types_ids])
url_path = ""
to_input = self.to_input(batch) return self.orig_view_converter.get_formatted_batch(to_input, dspace)
P3P_HEADER = 'CP="Open EdX does not have a P3P policy."'
n_jobs = 1
G_diag = G_diag[:, np.newaxis]
self.make_course(pdf_textbooks=[PDF_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('pdf_book', book_index=0, page='xyzzy')
if privacy == self.PRIVACY_PUBLIC: self.assertEqual(profile_page.privacy, 'all_users') else: self.assertEqual(profile_page.privacy, 'private')
return self.event[u'current_tab'] == self.event[u'tab_count']
selector = self.get_element_selector(VIDEO_BUTTONS['quality']) classes = self.q(css=selector).attrs('class')[0].split() return 'active' in classes
tol = 2 * np.finfo(M.dtype).eps
'user_message': _(u"The ordering {ordering} is not supported").format(ordering=ordering),
import contracts contracts.disable_all()
X_, y_ = make_classification(n_samples=200, n_features=100, random_state=0)
course_id = CourseKeyField(max_length=255, db_index=True, verbose_name=_("Course"))
self.navigate_to_video()
self.store.revert_to_published(vertical.location, self.user_id) self.assertFalse(self._has_changes(vertical.location))
step = n_samples // n_classes
return LibraryLocator(org=org, library=library)
self.client.logout()
clf = LinearDiscriminantAnalysis(priors=[0.5, 0.5]) clf.fit(X, y)
g = GaussianMixture(n_components=n_components, n_init=1, max_iter=2, reg_covar=0, random_state=random_state, warm_start=False) h = GaussianMixture(n_components=n_components, n_init=1, max_iter=1, reg_covar=0, random_state=random_state, warm_start=True)
html = self.get_page_html(xblock) self.assertIn(expected_section_tag, html) self.assertRegexpMatches(html, expected_breadcrumbs)
return self.q(css=self.selector).present
return VisibilityError() if descriptor.visible_to_staff_only else ACCESS_GRANTED
if fit_intercept: ret[:n_features] += s[-1] * dd_intercept ret[-1] = dd_intercept.dot(s[:n_features]) ret[-1] += d.sum() * s[-1] return ret
new_display_name = "The Trouble with Tribbles" new_weight = 20 problem_block_course.display_name = new_display_name problem_block_course.weight = new_weight self.store.update_item(problem_block_course, self.user_id)
return { key: value for key, value in self.cleaned_data.items() if key in self.extended_profile_fields and value is not None }
simplefilter('ignore')
log.warning('Failed to retrieve CourseOverview for [%s]. Using empty course name.', course_id) return None
regressor.n_components = 1
self.save() self.runtime.modulestore.update_item(self, user.id)
tags = list(set(tags))
self.fs.delete(location_or_id)
redirect_url = embargo_api.redirect_if_blocked( course_id, user=user, ip_address=get_ip(request), url=request.path ) if redirect_url: return HttpResponse(redirect_url)
extra['w'] = extra.get('w', 0)
course_email = CourseEmail.create( self.course.id, self.instructor, [SEND_TO_MYSELF, SEND_TO_STAFF, SEND_TO_LEARNERS], "Test Subject", "<p>This is a test message</p>" ) return course_email.id
can_skip = False if is_entrance_exams_enabled(): try: record = EntranceExamConfiguration.objects.get(user=user, course_id=course_key) can_skip = record.skip_entrance_exam except EntranceExamConfiguration.DoesNotExist: can_skip = False return can_skip
PROVIDER_NAME = "override" PROVIDER_BACKEND = "override" PROVIDER_ID = "override" USER_EMAIL = "override" USER_NAME = "override" USER_USERNAME = "override"
self.course_info_page.visit() self.tab_nav.go_to_tab('Course') self.course_nav.go_to_section('Test Section', 'Test Subsection')
return InstructorTask.create(course_id, task_type, task_key, task_input, requester)
new_nsamples[not marginalize_odd] += pa_bias * (1. - beta)
self._enable_cohorting() self._create_verified_cohort() self.assertFalse(VerifiedTrackCohortedCourse.is_verified_track_cohort_enabled(self.course.id)) self._verify_no_automatic_cohorting() self.assertFalse(error_logger.called)
if self.course_key is None: self.course_key = CourseKeyField.Empty entries = User.objects.filter( courseaccessrole__role=self._role_name, courseaccessrole__org=self.org, courseaccessrole__course_id=self.course_key ) return entries
if should_grade_section: scores = []
self.client.login(username=self.staff_usr, password='test') resp = self.client.get(self.url_locked) self.assertEqual(resp.status_code, 200)
fields = field_dictionary if field_dictionary else self._get_default_search() return self.searcher.search(query_string=query_string, field_dictionary=fields, doc_type=self.DOCUMENT_TYPE)
Y = iris.target
return [JsTestSubSuite(test_id, **self.opts) for test_id in Env.JS_TEST_ID_KEYS]
return self.children()
yield prev_end, "E225 missing whitespace around operator" need_space = False
self._verify_xblock_info_state(xblock_info, 'visibility_state', expected_state, path, should_equal)
iris = datasets.load_iris() rng = check_random_state(0) perm = rng.permutation(iris.target.size) iris.data = iris.data[perm] iris.target = iris.target[perm]
X_, y_ = make_classification(n_samples=200, n_features=100, random_state=0)
return modulestore().make_course_key(org, course, run).make_usage_key(block_type, block_id)
return AES.new(key, AES.MODE_CBC, generate_aes_iv(key))
from __future__ import unicode_literals
assert_true(id1, id2)
result_dict = json.loads(response.content)
assert_raises(ValueError, partial_dependence, {}, [0], X=X)
alpha1 = dual_coef[class2 - 1, sv_locs[class1]:sv_locs[class1 + 1]] alpha2 = dual_coef[class1, sv_locs[class2]:sv_locs[class2 + 1]]
old_time = datetime.datetime.now(UTC) self.store.publish(component.location, publish_user) updated_component = self.store.get_item(component.location)
if cls.has_professional_mode(modes_dict): return False
X_train = X_train.astype(np.float64) X_test = X_test.astype(np.float64) normalize(X_train, copy=False) normalize(X_test, copy=False)
est.fit(X, y) t = np.asarray(T) assert_raises(ValueError, est.predict, t[:, 1:])
self.assert_enrollment_status(as_server=True, mode=CourseMode.VERIFIED)
'ENABLE_MAX_FAILED_LOGIN_ATTEMPTS': True,
self._assert_enable_certs_button(False)
self.assertTrue(mock_audit_log.called)
set_user_preference(self.user, "dict_pref", {"int_key": 10}) set_user_preference(self.user, "string_pref", "value")
return sorted(iteritems(d), key=operator.itemgetter(1), reverse=True)
root_dir = path(mkdtemp_clean()) print 'Exporting to tempdir = {0}'.format(root_dir) export_course_to_xml(self.store, content_store, course.id, root_dir, 'test_export')
super(TestCohorts, self).setUp() self.toy_course_key = ToyCourseFactory.create().id
self.assertOLXIsPublishedOnly(block_list_to_delete) self.delete_item(block_list_to_delete, revision=revision) self._check_for_item_deletion(block_list_to_delete, result) self.assertOLXIsDeleted(autopublished_children) self.assertOLXIsDeleted(block_list_draft_children)
digits = load_digits() data = digits.data
key = safe_key('a' * 300, 'prefix', 'version') self.assertTrue(self._is_valid_key(key))
return s
X_trans = pipeline.fit_transform(X, y) X_trans2 = transft.fit(X, y).transform(X) assert_array_almost_equal(X_trans, X_trans2)
params = self._signed_callback_params( self.order.id, self.COST, self.COST, card_number='nodigits' ) result = process_postpay_callback(params)
return _click_edit(self, '.edit-button', '.xblock-studio_view', self._bounded_selector)
store = self._get_modulestore_for_courselike(course_id) with store.bulk_operations(course_id, emit_signals): yield
return self.get_selector('div.white-listed-students table tr:last-child td')
return 'shoppingcart/receipt.html'
folders_list_in_path = folders_list_in_path[:-4]
self.settings_page.wait_for_ajax() self.settings_page.wait_for_jquery_value('input#course-name:text', 'test_run')
left_mask = np.tril(np.ones((tri_size, tri_size), dtype=int))[:, 1:] right_mask = left_mask[::-1, ::-1]
name = event.get(u'name') return cls.mapping[name](event)
this_sample = this_layer.sample(state_below=state_below, state_above=state_above, layer_above=layer_above, theano_rng=theano_rng)
XBLOCK_MIXINS = ( LmsBlockMixin, InheritanceMixin, XModuleMixin, EditInfoMixin, AuthoringMixin, )
return self.q(css=TEAMS_HEADER_CSS + ' .page-title')[0].text
for param, value in params.items(): self.assertIn(param, allowed_params) self.assertIn('{}={}'.format(param, value[0]), expected)
rng = np.random.RandomState(0) X_ = rng.random_sample((5, 10)) y_ = np.ones(X_.shape[0]) y_[0] = 0
return User.objects.filter( courseenrollment__course_id=course_id )
indptr_3 = X_sparse_unpruned.indptr[3] indptr_4 = X_sparse_unpruned.indptr[4] X_sparse_unpruned.data[indptr_3:indptr_4] = 0.0
from openedx.core.djangoapps.credit.api.eligibility import ( is_credit_course, )
if np.any(classes != sorted_class): indices = np.searchsorted(sorted_class, classes) Y = Y[:, indices]
COURSES_WITH_UNSAFE_CODE = []
t2 = TfidfTransformer(norm='l1', use_idf=False) tf = t2.fit(counts_train).transform(counts_train).toarray() assert_equal(t2.idf_, None)
self.assert_error(params, field, expected_error)
self.url = reverse('dashboard') self.site_lang = settings.LANGUAGE_CODE
assert_true(np.all(np.diff(distances[0]) >= 0))
del post_data[post_key] expected_pattern = r"<title>(\s+)Receipt"
plt.scatter(diabetes_X_test, diabetes_y_test, color='black') plt.plot(diabetes_X_test, regr.predict(diabetes_X_test), color='blue', linewidth=3)
ext_user = User.objects.get(email=self.ext_user.email) self.assertFalse(auth.user_has_role(ext_user, CourseInstructorRole(self.course.id)))
assert_greater(roc_auc_score(y_test, y_pred), 0.98)
assert_array_almost_equal(np.diag(K), np.ones(5))
num_vis = rng.randint(1,11) n_classes = rng.randint(1, 11)
axes = self.input_space.axes assert len(axes) == 4
if CourseMode.is_white_label(course_id): course_mode = CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG else: course_mode = None
return self._is_element_visible("#wmd-input-comment-body-{}".format(response_id))
self.split_test_module.user_partition_id = 2 [active_children, inactive_children] = split_test_module.active_and_inactive_children() self.assertEqual(active_children, []) self.assertEqual(inactive_children, children)
stringified_sources_list = map(lambda loc: loc.to_deprecated_string(), self.sources_list) self.xml_attributes['sources'] = ';'.join(stringified_sources_list) return xml_object
self.profile.gender = "unknown" with self.assertRaises(IntegrityError): self.profile.save() self.assert_no_events_were_emitted()
return total / coeff_sum
continue
self.cache.clear() self.addCleanup(self.cache.clear)
reg_code = CourseRegistrationCode.objects.get(code=reg_code.code) self.assertEqual(reg_code.is_valid, False)
return SlashSeparatedCourseKey(org, course, url_name)
if usage_info.has_staff_access: return
partial_credit = xml.xpath('.')[0].get('partial_credit', default=False)
clf.classes_ = unique_labels(classes) return True
self.assertEqual( self.store.has_published_version(course1_item), self.store.has_published_version(course2_item) )
self.cart, __ = self._create_cart()
self._initialize(y, layer_units)
sample_dict = {'x': (-10, 10), 'y': (-10, 10)}
CourseFinanceAdminRole(self.course.id).remove_users(self.instructor)
assert_equal(set(SYMMETRIC_METRICS).union( NOT_SYMMETRIC_METRICS, THRESHOLDED_METRICS, METRIC_UNDEFINED_BINARY_MULTICLASS), set(ALL_METRICS))
def __init__(self, message, error_list): super(SearchIndexingError, self).__init__(message) self.error_list = error_list
X = datasets.make_classification(n_samples, n_features, n_informative=n_features-2, random_state=rng)[0]
uncertainty_index = uncertainty_index = np.argsort(pred_entropies)[-5:]
estimator = _make_estimators(X_train, y_train, y_ml_train)
errorlog = make_error_tracker()
self.q(css="input.timed_exam").first.click()
self.settings_detail.refresh_page() self.settings_detail.wait_for_prerequisite_course_options() dropdown_status = is_option_value_selected( browser_query=self.settings_detail.pre_requisite_course_options, value=pre_requisite_course_id ) self.assertTrue(dropdown_status)
FEATURES['ENTRANCE_EXAMS'] = True ENTRANCE_EXAM_MIN_SCORE_PCT = 50
return first_line.split(':')[2][0:10]
mock_user = MagicMock() mock_user.is_authenticated.return_value = False self.assertEqual(views.user_groups(mock_user), [])
self.check_assertion_structure(assertion, response['results'][0])
user = cc.User.from_django_user(request.user) commentable = cc.Commentable.find(commentable_id) user.unfollow(commentable) return JsonResponse({})
labels = birch_model.labels_ centroids = birch_model.subcluster_centers_ n_clusters = np.unique(labels).size print("n_clusters : %d" % n_clusters)
context = { "profiles": [self.TEST_PROFILE], "allow_cache_miss": "True" if allow_cache_miss else "False" } return self.video.student_view_data(context)
for i, clf in enumerate((kernel_svm, nystroem_approx_svm, fourier_approx_svm)): plt.subplot(1, 3, i + 1) Z = clf.predict(flat_grid)
import logging
self.course_outline.visit() subsection = self.course_outline.section_at(section_index).subsection_at(0) subsection.expand_subsection() subsection.add_unit()
course = item.get_parent() item_dict['index'] = get_index(item_dict['location'], course.children)
loss[np.logical_or(n_positives == 0, n_positives == n_labels)] = 0.
clf = LogisticRegression(random_state=0) clf.fit(X, Y1) clf.coef_[:] = 0 clf.intercept_[:] = 0 assert_array_almost_equal(clf.decision_function(X), 0)
with patch('mongodb_proxy.MongoProxy') as mock_proxy: mock_proxy.return_value.alive.return_value = False useless_conn = MongoConnection('useless', 'useless', 'useless')
with patch('xmodule.capa_module.CapaModule.closed') as mock_closed: mock_closed.return_value = True
user_requested_access(self.user) self.assertEqual('granted', get_course_creator_status(self.user))
for student in students[:]: CertificateWhitelistFactory.create(user=student, course_id=self.course.id, whitelist=True)
X = np.arange(100).reshape(10, 10) y = np.array([0] * 5 + [1] * 5)
drag_handle_html = '<span data-tooltip="Drag to reorder" class="drag-handle action"></span>' self.assertIn(drag_handle_html, html)
return ['platform', 'version', 'expire_at', 'enabled', 'created_at', 'updated_at']
self._verify_split_test_import( 'split_test_copy_with_draft', 'split_test_module_draft', 'fb34c21fe64941999eaead421a8711b8', {"0": '9f0941d021414798836ef140fb5f6841', "1": '0faf29473cf1497baa33fcc828b179cd'}, )
mean_tpr /= n_classes
super(InheritingFieldData, self).__init__(**kwargs) self.inheritable_names = set(inheritable_names)
self.video.show_captions()
return - T.nnet.sigmoid(self.G(X, model))
self.request.user = staff_user unlocked_toc = self._return_table_of_contents() for toc_section in self.expected_unlocked_toc: self.assertIn(toc_section, unlocked_toc)
self._textbooks.append({"chapters": chapters, "tab_title": book_title})
logging.basicConfig(level=logging.DEBUG, format="%(levelname)s %(message)s")
self.login_page.visit().login(email=email, password=password)
return event['event_type'] == self.CHANGE_INITIATED_EVENT_NAME
return cls.__name__
return course.cert_html_view_enabled if course else False
assert self.xmodule_instance is not None return self.handler_url(self.xmodule_instance, 'xmodule_handler', '', '').rstrip('/?')
altered_grader = CourseGradingModel.fetch(self.course.id) self.assertDictEqual(test_grader.grade_cutoffs, altered_grader.grade_cutoffs, "Noop update")
from __future__ import print_function
objects = models.Manager()
from __future__ import unicode_literals
content = json.loads(response.content) self.assertEqual(response.status_code, 200) self.assertEqual(content['return_code'], 0)
string_lines = StringLines(file_string) for violation in self.violations: violation.prepare_results(self.full_path, string_lines) if line_comment_delim is not None: self._filter_commented_code(line_comment_delim)
'ADVANCED_SECURITY': False,
self.assertFalse(form.is_valid())
for X in (X_dense, X_sparse_pruned, X_sparse_unpruned):
return social_auth.uid[len(self.idp_slug) + 1:]
plt.scatter(X[:, 0], X[:, 1], c=targets_train, cmap=plt.cm.Paired)
np.random.seed(0)
resp = self.client.get(billing_url) self.assertEqual(resp.status_code, 404)
self.assertFalse(self.user.is_active)
with self._secondary_action_menu_open("#comment_{}".format(comment_id)): return self._is_element_visible("#comment_{} .action-delete".format(comment_id))
self.wait_for_add_certificate_button() self.q(css=self.certficate_css + " .action-add").first.click()
return int(self.q(css=self.TOTAL_PAGES_CSS).text[0])
self.assertEqual(module.attempts, 0)
out_shape = [(ishp + tsp) * tshp - tsp for ishp, tshp, tsp in zip(img_shape, tile_shape, tile_spacing)]
modulestore().get_course(self.course.id, depth=None)
from sklearn import datasets datasets.mldata.urlopen = urlopen
course_keys = CourseOverview.get_all_course_keys() for expected_course_key in courses: self.assertIn(expected_course_key, course_keys)
cohort = CohortFactory(course_id=self.course.id, users=[]) response_dict = self.request_remove_user_from_cohort(None, cohort) self.verify_removed_user_from_cohort( None, response_dict, cohort, expected_error_msg='No username specified' )
warnings.simplefilter('always') sp.csr_matrix([1.0, 2.0, 3.0]).max(axis=0)
mode = 1 M_matvec = None Minv_matvec = None if Minv is not None: raise ValueError("Minv should not be " "specified with M = None.")
from_addr = course_email.from_addr if course_email.from_addr else \ _get_source_address(course_email.course_id, course_title)
rng = np.random.RandomState(0)
for student in students[5:7]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.unavailable, mode='honor', grade=default_grade )
#
QUERY_INTERVAL = 1000
assert_almost_equal(np.std(y - np.dot(X, c)), 1.0, decimal=1)
self._assert_course_verification_status(VERIFY_STATUS_MISSED_DEADLINE)
second_checkpoint.photo_verification.remove(attempt) self.assertEqual(second_checkpoint.photo_verification.count(), 0)
self._pool = None self._output = None self._jobs = list() self._managed_pool = False
labels = km.predict(X) assert_equal(v_measure_score(true_labels, labels), 1.0)
if callback is not None: callback(locals())
X_csr_scaled = scale(X_csr, with_mean=False, with_std=False, copy=True) assert_array_almost_equal(X_csr.toarray(), X_csr_scaled.toarray())
return (requested_fields or set()) | {'type', 'display_name'}
t_start = datetime.now() clf.transform(X) delta = (datetime.now() - t_start) time_to_transform = compute_time(t_start, delta)
exists_ce = is_active is not None and is_active full_name = user.profile.name
COURSE_TAB_NAMESPACE = 'openedx.course_tab'
disable_animations(annotation_component_page)
serialized_course_team['pk'] = self.course_team.pk serialized_course_team.pop('membership', None)
axes = self.input_space.axes assert len(axes) == 4
num_certs = GeneratedCertificate.eligible_certificates.filter(user=self.student).count() self.assertEqual(num_certs, 1)
self.assertEqual(auth_settings._SOCIAL_AUTH_LOGIN_REDIRECT_URL, response.get('Location'))
n_clusters_1 = len(set(labels)) - int(-1 in labels) assert_equal(n_clusters_1, n_clusters)
locals().update(_mk_common_exceptions())
path = list() n_alphas = self.alphas inner_verbose = max(0, self.verbose - 1)
FEATURES['ENABLE_TEAMS'] = True
return _is_staff_for_article(article, user)
clf = TreeClassifier(class_weight=[{-1: 0.5, 1: 1.}], random_state=0) assert_raises(ValueError, clf.fit, X, _y)
clf = AdaBoostClassifier(RandomForestClassifier()) clf.fit(X, y_regr)
if self._channel_name is None: v = monitor.channels['objective'].val_record else: v = monitor.channels[self._channel_name].val_record
y_hat = sum(all_y_hat) / len(self.estimators_)
response = searcher.search(field_dictionary={"library": library_search_key}) self.assertEqual(response["total"], 2)
return iter(getattr(d, _iterlists)(**kw))
bad_id = SlashSeparatedCourseKey(u'Broken{}'.format(self.course.id.org), 'hello', self.course.id.run + '_typo')
actual_field = None for field in form_desc["fields"]: if field["name"] == expected_field["name"]: actual_field = field break
clf = GradientBoostingRegressor(n_estimators=100, random_state=1, max_features=0) assert_raises(ValueError, clf.fit, X, y)
ccx = CcxFactory(course_id=self.course.id, coach=self.coach) override_field_for_ccx(ccx, self.course, 'max_student_enrollments_allowed', max_students_allowed) return ccx
self._enroll_students_in_course(self.course.id, extra_count) return {}
with self.assertRaisesRegexp(CommandError, "Error: too few arguments"): call_command('fix_not_found')
if not GlobalStatusMessage.current().enabled: return None
return token.client
self.assertDeserializeEqual(False, 'false') self.assertDeserializeEqual(True, 'true')
from .tasks import update_search_index
query = self._qs(self.browser.current_url) return 'access_denied' in query['error']
for course in self.list_courses(): if course['org'] == org and course['number'] == number and course['run'] == run: return True return False
self.assertEqual(len(email_info), 1)
click_css(self, 'a.action-discard', 0, require_notification=False) confirm_prompt(self) self.wait_for_ajax()
self.assertEqual(len(res_json['certificates']), 2)
self.assertFalse(all_gradesets[student3]) self.assertFalse(all_gradesets[student4])
if not already_paid: url = reverse('verify_student_upgrade_and_verify', kwargs=course_kwargs)
self.coefs_ = self._best_coefs self.intercepts_ = self._best_intercepts
settings = partitioned_fields[Scope.settings] settings = self._serialize_fields(block_key.type, settings) if not is_updated: is_updated = self._compare_settings(settings, original_entry.fields)
self.assert_user_setting_event_emitted( setting='profile_image_uploaded_at', old=old, new=new )
return self.q(css=VIDEO_MODAL_SELECTOR)
n_samples = 200 X, y = make_circles(n_samples=n_samples, shuffle=False) outer, inner = 0, 1 labels = -np.ones(n_samples) labels[0] = outer labels[-1] = inner
self.assert_requirement_status(0.70, self.EXPIRED_DUE_DATE, 'failed')
assert_raises(ValueError, plot_partial_dependence, clf, iris.data, [0, 1], grid_resolution=grid_resolution)
'mailing',
ForestEstimator = FOREST_ESTIMATORS[name] rng = np.random.RandomState(0) weights = rng.rand(X.shape[0]) total_weight = np.sum(weights)
for _ in range(300): prev_log_likelihood = current_log_likelihood try: current_log_likelihood = gmm.fit(X).score(X) except ConvergenceWarning: pass assert_greater_equal(current_log_likelihood, prev_log_likelihood)
self.generated_certificate.invalidate()
arguments = [] for name in argument_names: arguments.append(getattr(self, name)) return check(*arguments)
duplicated_item.location = original_item.location duplicated_item.display_name = original_item.display_name duplicated_item.parent = original_item.parent
assert_raises(ValueError, cross_val_score, svm, linear_kernel.tolist(), y)
ccx = self.make_ccx(max_students_allowed=2) ccx_course_key = CCXLocator.from_course_locator(self.course.id, ccx.id) staff = self.make_staff() instructor = self.make_instructor()
choose_track_url = reverse('course_modes_choose', args=[unicode(self.course.id)]) response = self.client.get(choose_track_url)
nodes = modulestore().get_items(reusable_location, qualifiers={'category': 'chapter'}) new_course_loc = modulestore().delete_item(nodes[0].location, self.user_id)
return []
self.q(css='button.signatory-panel-close').click() self.mode = 'details' self.wait_for_signatory_detail_view()
config.floatX = self.prev_floatX
self.assertNotIn(REG_STR, resp.content)
resp_params = PaymentFakeView.response_post_params(post_params) self.assertEqual(resp_params.get('decision'), 'DECLINE')
if not isinstance(notes, list): notes = [notes] for note in notes: self.notes.append(note)
return self.conditional.conditional_expectation(theta)
from . import signals
return self.make_call(reverse('teams_detail', args=[team_id]), expected_status, 'delete', **kwargs)
pylint_pattern = re.compile(r".(\d+):\ \[(\D\d+.+\]).")
assert_true(sp.issparse(X1)) assert_true(sp.issparse(Y1)) assert_equal(60915113, X1.data.size) assert_equal(2606875, Y1.data.size)
return super(SplitBulkWriteMixin, self)._get_bulk_ops_record( course_key.replace(branch=None, version_guid=None), ignore_case )
assert False, "student_view should produce valid html"
problem_page.click_hint()
if inline_collections: for item in tab.items(course): yield item elif len(list(tab.items(course))) > 0: yield tab
if class_weight in ("auto", "balanced"): class_weight_ = compute_class_weight(class_weight, mask_classes, y_bin) sample_weight *= class_weight_[le.fit_transform(y_bin)]
time.sleep(self.server.config.get('time_to_response', self.DEFAULT_DELAY_SEC))
small_width = models.IntegerField(default=375) small_height = models.IntegerField(default=200)
mask_missing_values = _get_mask(X.data, missing_values) mask_valids = np.logical_not(mask_missing_values)
after_due_date = CapaFactory.create(showanswer='closed', max_attempts="1", attempts="0", due=self.yesterday_str)
extract_dir_relative = path.relpath(extract_dir, settings.DATA_DIR)
with self.assertRaises(UnsupportedRevisionError): self.store.get_item(self.fake_location, revision=ModuleStoreEnum.RevisionOption.draft_preferred)
X_true -= X_true.mean()
children = self.get_item_from_modulestore(self.seq_usage_key).children self.assertEqual(unit1_usage_key, children[1]) self.assertEqual(unit2_usage_key, children[2])
(['honor', 'verified', 'audit'], 'verified'),
module = get_module( user, request, problem.scope_ids.usage_id, field_data_cache, )._xmodule module.system.publish(problem, 'grade', grade_dict)
user_id = entry.requester.id task_id = entry.task_id
pred_decision = column_or_1d(pred_decision) pred_decision = np.ravel(pred_decision)
self.assertEqual(updated_course.display_coursenumber, None)
user = User.objects.get(email=email) user.set_password(new_password) user.save() history = PasswordHistory() history.create(user)
self.assertContains(resp, 'visible_course')
FEATURES['ENABLE_FINANCIAL_ASSISTANCE_FORM'] = True
EXAMPLE_FULL_NAME = u'John Doë'
assert_raises(ValueError, auc, [1.0, 0.0, 0.5], [0.0, 0.0, 0.0])
with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
if (not hasattr(openid_request, 'trust_root') or not openid_request.trust_root): log.error('no trust_root') return False
req = django_to_webob_request(request) try: resp = instance.handle(handler, req, suffix)
lines = '\n'.join(l.rstrip(' ') for l in lines.split('\n')) return lines
if not predicate: raise ProfileDistribution.ValidationError()
assert_almost_equal(ref_i.coef_, clf_i.coef_, decimal=3) assert_almost_equal(ref_w.coef_, clf_w.coef_, decimal=3) assert_almost_equal(ref_i.intercept_, clf_i.intercept_, decimal=3)
plot_gallery = True
status = 'satisfied' reason = {'final_grade': grade_summary['percent']}
Z = np.ones((data.Ny, data.Nx), dtype=np.float64)
embargo_redirect = embargo_api.redirect_if_blocked( course_key, user=request.user, ip_address=get_ip(request), url=request.path ) if embargo_redirect: return redirect(embargo_redirect)
raise NotImplementedError( str(type(self)) + " does not implement " + "continue_learning.")
self.assertEqual(CourseMode.auto_enroll_mode(self.course_key, modes), result)
bulk_write_record = self._get_bulk_ops_record(course_key) if bulk_write_record.active: bulk_write_record.modules[version_guid][block_key] = block
self._verify_unit_warning( self.UnitState(is_released=False, publish_state=self.PublishState.UNPUBLISHED_CHANGES, is_locked=False), self.FUTURE_UNPUBLISHED_WARNING )
return redirect_with_get('register_user', request.GET)
return self.q(css='div.csh_hint_text').text
Z = Z.reshape(xx.shape) plt.figure(1, figsize=(4, 3)) plt.pcolormesh(xx, yy, Z, cmap=plt.cm.Paired)
uniform_batch_size = False
self.assert_not_enrolled()
return [Attribute('genex_dna_sequence'), Attribute('genex_problem_number') ]
padding_len = AES.block_size - len(input_str) % AES.block_size return input_str + padding_len * chr(padding_len)
exception_classes = [StudentInputError, LoncapaProblemError, ResponseError] for exception_class in exception_classes:
self.student_answers = dict() self.correct_map = CorrectMap() self.done = False
clf.partial_fit(X3, Y3)
cache.clear()
return self._get_groups(self.experiment_groups_css)
self.publish((('html', 'html00'),))
arguments[kwargs_param.name] = kwargs
self.assertOrphanCount(course.id, 0) self.assertOrphanCount(published_branch, 1) self.assertIn(orphan, self.store.get_items(published_branch))
rbf_transform = RBFSampler(gamma=gamma, n_components=1000, random_state=42) X_trans = rbf_transform.fit_transform(X) Y_trans = rbf_transform.transform(Y) kernel_approx = np.dot(X_trans, Y_trans.T)
#modindex_common_prefix = []
func_name = "H{}".format(level) self.body.append(getattr(E, func_name)(text))
actual = GroupConfiguration.get_content_groups_usage_info(self.store, self.course) self.assertEqual(actual.keys(), [0])
delete_course_and_groups(course_key, self.user.id)
Y = np.array([e.predict_proba(X)[:, 1] for e in self.estimators_]).T
return usage_id
try: os.makedirs(self._temp_folder) os.chmod(self._temp_folder, FOLDER_PERMISSIONS) except OSError as e: if e.errno != errno.EEXIST: raise e
if value == 'course_org_filter': return alternate return default
out = [] for res in self.__toklist: if isinstance(res,ParseResults): out.append( res.asList() ) else: out.append( res ) return out
if privacy is not None: profile_page.visit()
from safe_lxml import defuse_xml_libs defuse_xml_libs()
pass
import numpy as np import matplotlib.pyplot as plt from sklearn import neighbors
log.exception( "Unexpected exception while attempting to initiate refund for user [%s], course [%s]", course_enrollment.user.id, course_enrollment.course_id, )
xnorml = xnorm dl2s = [x for x in xs] xs = [x + tau * d for x, d in zip(xs, ds)]
request = self.context['request'] return request.build_absolute_uri(reverse('course_structure_api:v0:detail', kwargs={'course_id': course.id}))
self.dashboard_page.visit() self.assertTrue(self.dashboard_page.has_library(name=name, org=org, number=number))
wrappers=wrappers, wrappers_asides=wrappers_asides, error_descriptor_class=ErrorDescriptor, get_user_role=lambda: get_user_role(request.user, course_id),
return bool(obj["pinned"])
w = clf.coef_[0] a = -w[0] / w[1]
unique_username = 'user' + str(uuid.uuid4().hex)[:12] unique_email = unique_username + "@example.com" return unique_username, unique_email
METRIC_UNDEFINED_MULTICLASS = [ "brier_score_loss", "matthews_corrcoef_score", ]
user_perms = get_user_permissions(request.user, course_key) if not user_perms & STUDIO_VIEW_USERS: raise PermissionDenied()
response = client.get(path='/shib-login/', data={}, follow=False, **identity)
assert_equal(sample_without_replacement(5, 0).shape, (0, )) assert_equal(sample_without_replacement(5, 1).shape, (1, ))
messages = [
leaf_count = node_counts[node_counts != 0] assert_greater(np.min(leaf_count), len(X) * 0.25 - 1, "Failed with {0}".format(name))
self._setup_mode_and_enrollment(self.FUTURE, "verified")
self.testing_cost = 20 self.testing_course_mode = CourseMode( course_id=self.testing_course.id, mode_slug=CourseMode.HONOR, mode_display_name="testing honor cert", min_price=self.testing_cost ) self.testing_course_mode.save()
client = self.login_client(api_client, user) new_value = "new value" self.send_put(client, new_value, expected_status=403 if user == "staff_user" else 404)
self.X1_bool = self.X1.round(0) self.X2_bool = self.X2.round(0)
mlb = MultiLabelBinarizer(classes=[1, 3, 2]) assert_array_equal(mlb.fit(inp).transform(inp), indicator_mat) assert_array_equal(mlb.classes_, [1, 3, 2])
if which_set == 'test': content = content[1:] content = content[:-1]
L = np.zeros((max_features, max_features), dtype=X.dtype)
self.assert_account_settings_context_looks_correct(account_settings_context(request), request.user, linked=False) self.assert_social_auth_does_not_exist_for_user(request.user, strategy)
response = self.client.get(url) email_section = '<div class="vert-left send-email" id="section-send-email">' self.assertIn(email_section, response.content)
self.assertEqual(self.cmap.get_overall_message(), "Test message")
self._active_count += 1
self.assert_payload_contains_ids(load_video_event)
return self.q(css='{} input[name=rescore-entrance-exam]'.format(self.EE_CONTAINER))
def downward_state(self, state): return state def downward_message(self, state): return state
module = CapaFactory.create(max_attempts="0", attempts="2") self.assertTrue(module.closed())
(27, True, u"True"),
subtask_status.increment(retried_nomax=1, state=RETRY) return _submit_for_retry( entry_id, email_id, to_list, global_email_context, exc, subtask_status, skip_retry_max=True )
suggested_prices = models.CommaSeparatedIntegerField(max_length=255, blank=True, default='')
self.last_submission_time = datetime.datetime.now(UTC())
self.lc_block.max_count = 10 self.lc_block.capa_type = 'multiplechoiceresponse' self.lc_block.refresh_children() result = self.lc_block.validate()
X = np.array([
problem_text = re.sub(r"startouttext\s*/", "text", problem_text) problem_text = re.sub(r"endouttext\s*/", "/text", problem_text) self.problem_text = problem_text
return [self.parameter_name]
ica = FastICA(n_components=3)
if instructor_task.task_state not in READY_STATES: result = AsyncResult(task_id) _update_instructor_task(instructor_task, result)
context_dict.setdefault("STATIC_URL", "/dummy-static/") try: xml_str = self.template.render_unicode(**context_dict) except: raise TemplateError(exceptions.text_error_template().render())
return obj.get("votes", {}).get("up_count", 0)
func = getattr(block.__class__, handler_name, None) if not func: raise ValueError("{!r} is not a function name".format(handler_name))
html5_ids = [x.split('/')[-1].rsplit('.', 1)[0] for x in html5_sources] return html5_ids
self.browser.execute_script("jQuery.fx.off = true;")
tag = 'split_test'
rnd = np.random.RandomState(0) X = rnd.uniform(size=(10, 4))
raise NotImplementedError()
formulahint_element = etree.SubElement(hintgroup_element, "formulahint")
self.store.convert_to_draft(self.vertical_x1a, self.user_id) item = self.store.get_item(self.vertical_x1a) self.assertTrue(self.store.has_published_version(item))
self.f_ = lambda x: y.repeat(x.shape)
assert_equal(5, StratifiedKFold(5).get_n_splits(X, y))
plt.title(model_title)
assign_default_role(instance.course_id, instance.user)
response = searcher.search( doc_type=CoursewareSearchIndexer.DOCUMENT_TYPE, field_dictionary={"course": unicode(self.course.id)} ) self.assertEqual(response["total"], 3)
req_status = api.get_credit_requirement_status(self.course_key, "bob", namespace="grade", name="grade") self.assertEqual(len(req_status), 0)
GITHUB_REPO_ROOT = ENV_ROOT / "data"
self.assertIsNotNone(self.page.new_post_button) self.page.click_new_post_button() self.assertIsNotNone(self.page.new_post_form)
course_key = CourseKey.from_string(self._course_key) return unicode(course_key.make_usage_key('course_info', 'handouts'))
ensemble = BaggingClassifier(base_estimator=LogisticRegression(), random_state=rng, max_samples=5).fit(X_train, y_train)
pred = mb_k_means.predict(mb_k_means.cluster_centers_) assert_array_equal(pred, np.arange(n_clusters))
if not DarkLangConfig.current().enabled: return self._clean_accept_headers(request) self._activate_preview_language(request)
title_css = ".csv-upload .message-title" detail_css = ".csv-upload .summary-item" return self._get_messages(title_css, detail_css)
assert_greater(ridge_outlier_score, huber_outlier_score)
"xmodule_js", "common_static",
BULK_EMAIL_RETRY_DELAY_BETWEEN_SENDS = 0.02
X = check_array(X, order='C', dtype='float64') assert_raises(ValueError, clf.fit, X, y, check_input=False)
assert_raises(ValueError, Pipeline, [('svc', SVC()), ('svc', SVC())])
pass
file_handle.seek(0) return magic
self.create_credentials_config() self.create_programs_config()
DEPRECATED_BLOCK_TYPES = ['poll', 'survey']
self.publish_item(store, self.vertical.location) with self.assertRaises(SearchIndexingError): self.reindex_course(store)
'ALLOW_COURSE_STAFF_GRADE_DOWNLOADS': False,
response = self.client.get(self._get_url(self.course_key, "invalid_checkpoint")) self.assertEqual(response.status_code, 404)
batch_size = self.batch_size
self.assertEqual(len(partition.groups), 2) self.assertItemsEqual( [g.id for g in partition.groups], [ VerificationPartitionScheme.ALLOW, VerificationPartitionScheme.DENY, ] )
return not resolved(joinpath(base, path)).startswith(base)
grade_response = None
RateLimitConfiguration.objects.create(enabled=True)
assert False, "studio_view should produce valid html"
course_key = CourseKey.from_string(course_id) CourseMode.objects.get_or_create(course_id=course_key, **PARAMETERS)
def utcoffset(self, _dt): return timedelta(hours=-3) def dst(self, _dt): return timedelta(0)
email_obj = CourseEmail.objects.get(id=email_id) targets = [target.target_type for target in email_obj.targets.all()]
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_key_string) get_course_with_access(request.user, 'staff', course_key)
chunk = self.data[self.cursor:(self.cursor + chunk_size)] self.cursor += chunk_size return chunk
self.assertEqual(course_date, expected_course_date)
self.course = modulestore().get_course(self.course.id)
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
if self.get_compound_hints(new_cmap, student_answers): return
self.certificates_section.add_certificate_exception(self.user_name, '')
X_train = np.array([[0, 0, 0], [1, 1, 1]]) y_train = [0, 1]
estimator_error = (sample_weight * error_vect).sum()
from distutils.version import LooseVersion from sklearn.utils.extmath import svd_flip
if not hasattr(user, '_roles'): user._roles = RoleCache(user)
self.set_time("#start_time", time)
n_samples_min = int(1e3) n_samples_max = int(1e5) n_features = 100 n_centers = 100 n_queries = 100 n_steps = 6 n_iter = 5
req = django_to_webob_request(request)
skip_if_no_sklearn() mapping = {'dataset_iterator': 'DatasetValidationShuffleSplit'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
course_id, _ = strip_ccx(course_id) with self._modulestore.branch_setting(branch_setting, course_id): yield
new_mixed_setting = convert_module_store_setting_if_needed(copy.deepcopy(old_setting))
vocabulary = defaultdict() vocabulary.default_factory = vocabulary.__len__
return aside_id.usage_key
from safe_lxml import defuse_xml_libs defuse_xml_libs()
X = np.arange(10000)[:, np.newaxis] y = np.arange(10000)
rng = check_random_state(0) X_train, X_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state=rng)
with self.assertRaises(ValueError): self.settings_service.get_settings_bucket(None)
FEATURES['ENABLE_COURSEWARE_SEARCH'] = True
PAYMENT_REPORT_GENERATOR_GROUP = 'shoppingcart_report_access'
self.assertEqual(len(mail.outbox), 0)
X, y = make_blobs(random_state=1) for Model in [DPGMM, VBGMM]: dpgmm = Model(n_components=10, random_state=1, alpha=20, n_iter=50, verbose=1)
return self.child(title)
assert_raises(ValueError, cval.cross_val_score, svm, linear_kernel.tolist(), y)
os.remove(tmp.name)
return [Attribute('params', None), Attribute('problem_state', None), Attribute('display_class', None), Attribute('display_file', None), ]
X_transformed_parallel2 = fs_parallel2.transform(X) assert_array_equal( X_transformed.toarray(), X_transformed_parallel2.toarray() )
BODY_SELECTOR = "#recent-panel" TAB_SELECTOR = ".tab#view-recent-activity"
self.assertFalse(BulkEmailFlag.feature_enabled(self.course.id)) response = self.client.get(self.url) self.assertNotIn(self.email_modal_link, response.content)
'edx-ui-toolkit/js/utils/global-loader.js', 'edx-ui-toolkit/js/utils/string-utils.js', 'edx-ui-toolkit/js/utils/html-utils.js',
'PREVENT_CONCURRENT_LOGINS': False,
return self.q(css='div.csh_hint_text').attrs('student_answer')
return self.q(css="#register-name").attrs('value')[0]
self.fed.append('&%s;' % name)
request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO["username"]) self.assertEqual(request["parameters"]["user_mailing_address"], "")
if self.embargoed_countries == '': return [] return [country.strip().upper() for country in self.embargoed_countries.split(',')]
return unicode(obj)
raise NotImplementedError(_("Problem's definition does not support rescoring."))
self.login(self.unenrolled_user) self.assertFalse(self.enroll(self.course)) self.assertTrue(self.enroll(self.test_course))
from scipy import misc face = misc.face(gray=True)
self.load_data()
return self.get_selector('#btn-start-generating-certificates')
user = self._authenticate(username=username, password=password) if user is not None: request.user = user return True return False
xblock_class = XBlock.load_class(block_type, select=settings.XBLOCK_SELECT_FUNCTION) content = xblock_class.open_local_resource(uri)
self.assertEqual(len(course.children), 2) self.assertIn(dangling_pointer, course.children)
train_object.algorithm.termination_criterion.prop_decrease = 0.5 train_object.algorithm.termination_criterion.N = 1
def squared_dloss(p, y): return p - y
raise NotImplementedError
self.assertFalse(self.cohort_management_page.is_category_selected())
data_stream = stream_reuters_documents()
uid_patch = patch('onelogin.saml2.utils.OneLogin_Saml2_Utils.generate_unique_id', return_value='TESTID') uid_patch.start() self.addCleanup(uid_patch.stop)
if ( settings.FEATURES.get('AUTH_USE_SHIB') and course.enrollment_domain and course.enrollment_domain.startswith(SHIBBOLETH_DOMAIN_PREFIX) ): return redirect_with_get('shib-login', request.GET)
visible_fields = _visible_fields
X = random_state.rand(n_samples * n_components) X = X.reshape((n_samples, n_components))
self.mock.reset_mock() request = self._create_ssl_request(self.MOCK_URL) request.user = UserFactory() dec_mock(request) self.assertTrue(self.mock.called)
filename = subs_filename(subs_id, lang) Transcript.delete_asset(item.location, filename)
module = CapaFactory.create(attempts=attempts, max_attempts=attempts, done=True) self.assertFalse(module.should_show_reset_button())
if new_datetime is not None: self.expiration_datetime_is_explicit = True self._expiration_datetime = new_datetime
drop_mask_Y = T.zeros_like(Y)
graph.data = np.exp(-graph.data / graph.data.std())
with self.assertNumQueries(3): embargo_api.check_course_access(self.course.id, user=self.user, ip_address='0.0.0.0')
return frozenset(child.display_name for child in self.library_fixture.children)
docs_train, docs_test, y_train, y_test = train_test_split( dataset.data, dataset.target, test_size=0.5)
self._create_block_hierarchy()
display_name = models.CharField(max_length=255, default="", blank=True)
outline_page = self.course_outline_page.visit() outline_page.q(css='.outline-item.outline-subsection.is-collapsed .ui-toggle-expansion').click() verify_ordering(self, outline_page, expected_ordering)
help = "Create a course in one of {}".format([ModuleStoreEnum.Type.mongo, ModuleStoreEnum.Type.split]) args = "modulestore user org course run"
assert len(self.hidden_layers) > 0
tasks.update_xblocks_cache.apply_async([unicode(course_key)], countdown=0)
self.assertEqual(course.display_name, u"Φυσικά το όνομα Unicode")
error = unicode(self) return HttpResponseBadRequest(json.dumps({'error': error}))
resp = self.create_xblock(parent_usage_key=self.chapter_usage_key, category='sequential') self.seq_usage_key = self.response_usage_key(resp)
from __future__ import unicode_literals
url(r'^post_metrics_data_csv_url', 'class_dashboard.dashboard_data.post_metrics_data_csv', name="post_metrics_data_csv"),
return v[::-1], W.T[:, ::-1]
zero_mean = rng.normal(size=shape) * self.sigma return zero_mean + v_mean
return self.q(css='.wrapper-content ' + prefix + ' .no-content')
def render(self, name, value, attrs=None): return super(ViewersWidget, self).render(name, ', '.join(value), attrs)
if os.path.isfile(join(dirname(abspath(__file__)), 'private.py')):
with remove_ccx(course_key) as (course_key, restore): return restore(self._modulestore.fill_in_run(course_key))
pass
user_country_from_profile = _get_user_country_from_profile(user)
CourseModeFactory.create(course_id=self.COURSE_KEY, mode_slug=CourseMode.HONOR) data = certs_api.get_certificate_footer_context()
if not np.any(Y_ == i): continue plt.scatter(X[Y_ == i, 0], X[Y_ == i, 1], .8, color=color)
('LEFTPADDING', (0, 1), (0, 1), 5 * mm),
bookmark_data = self.get_bookmark_data(self.vertical_4) bookmark, __ = Bookmark.create(bookmark_data) bookmark_data['display_name'] = self.vertical_4.display_name_with_default self.assert_bookmark_model_is_valid(bookmark, bookmark_data)
'ALLOW_COURSE_RERUNS': True,
atom = (tables.Int32Atom() if config.floatX == 'float32' else tables.Int64Atom())
import json from functools import partial import factory from factory.django import DjangoModelFactory
thumbnail_name = StaticContent.generate_thumbnail_name( content.location.name, dimensions=dimensions ) thumbnail_file_location = StaticContent.compute_location( content.location.course_key, thumbnail_name, is_thumbnail=True )
'ALLOW_AUTOMATED_SIGNUPS': False,
self.assertContains(response, 'course-container', 1) self.assertIn('Pursue a Certificate of Achievement to highlight', response.content)
self.assertTrue(views.is_course_passed(self.course, None, self.student, self.request))
return self.submit_question_answer( self.problem_display_name, {'2_1': response1, '2_2': response2} )
element = self.find_css('#grading_type')[0] return self.get_selected_option_text(element)
parents = self.collection.find(query, {'_id': True}, sort=[SORT_REVISION_FAVOR_DRAFT])
def default(self, obj): if isinstance(obj, datetime): return get_default_time_display(obj) return json.JSONEncoder.default(self, obj)
history = HistoricalRecords()
self.assertEqual(settings.XBLOCK_SETTINGS, {self.xblock_setting_key1: 42}) self.assertEqual(self.settings_service.get_settings_bucket(self.xblock_mock), 42)
FEATURES['ENABLE_OPENBADGES'] = True
assert_raises(ValueError, compute_sample_weight, {1: 2, 2: 1}, y, range(4))
if curr_problem in prob_grade_distrib: prob_grade_distrib[curr_problem]['grade_distrib'].append((row['grade'], row['count_grade']))
self.track_selection_page.enroll('verified')
return reverse_url(handler_name, 'library_key_string', library_key, kwargs)
resp = self.client.post(reverse('shoppingcart.views.use_code'), {'code': coupon.code}) self.assertEqual(resp.status_code, 200)
resp = self.client.post( '/shoppingcart/payment_fake', dict(post_params) )
response = self.client.get(course_one_teams_url) self.assertIn('"teams": {"count": 1', response.content)
xml = etree.fromstring(expr) xml = self.formulaInstance.preprocess_pmathml(xml) test = etree.tostring(xml)
self.youtube_configuration.update({ 'time_to_response': 2.0, 'youtube_api_blocked': True, })
with make_uploaded_file(extension=extension, content_type=content_type) as uploaded_file: self.check_validation_result(uploaded_file, expected_failure_message)
bdt = AdaBoostClassifier(DecisionTreeClassifier(max_depth=1), algorithm="SAMME", n_estimators=200)
if self.request_cache is not None: return self.request_cache.data.setdefault('parent-location-{}'.format(branch), ParentLocationCache()) else: return ParentLocationCache()
self._auto_auth("STAFF_TESTER", "staff101@example.com", True)
self.assertEqual(userreport['city'], "None") self.assertEqual(userreport['country'], "")
for section_format, sections in grading_context['graded_sections'].iteritems(): format_scores = [] for section in sections: section_descriptor = section['section_descriptor'] section_name = section_descriptor.display_name_with_default_escaped
assert_warns(UserWarning, f) failed = True
proxy = False mongo_db = connect_to_mongodb( db, host, port=port, tz_aware=tz_aware, user=user, password=password, proxy=proxy, **kwargs )
vertical = self.store.create_child( self.user_id, sequential.location, 'vertical', block_id='moon_unit' )
colors_hsv = colors_hsv.reshape((1, )+colors_hsv.shape) colors_rgb = matplotlib.colors.hsv_to_rgb(colors_hsv) colors_rgb = colors_rgb[0]
n_features = 2 n_classes = 2 n_samples = 1000 X, y = make_blobs(n_samples=n_samples, n_features=n_features, centers=n_classes, random_state=11)
clf = svm.SVC(kernel='linear', probability=True, random_state=0) probas_pred = clf.fit(X[:half], y[:half]).predict_proba(X[half:])
LINKED_USERS = (ALICE_USERNAME, STAFF_USERNAME, ADMIN_USERNAME) PASSWORD = "edx"
user = User.objects.get(email=staff_email) token = default_token_generator.make_token(user) uidb36 = int_to_base36(user.id)
assert_array_equal(np.intersect1d(train, test), [])
self.assertEqual(xblock_info['enable_proctored_exams'], True)
resp = self.client.post('/courses/def/abc/in_valid/generate_user_cert') self.assertEqual(resp.status_code, HttpResponseBadRequest.status_code) self.assertIn("Course is not valid", resp.content)
try: remove_all_instructors(course_key) except Exception as err: log.error("Error in deleting course groups for {0}: {1}".format(course_key, err))
BADGR_API_TOKEN = None BADGR_BASE_URL = "http://localhost:8005" BADGR_ISSUER_SLUG = "example-issuer" BADGR_TIMEOUT = 10
service = ReverificationService() status = service.get_status(self.user.id, unicode(self.course_id), self.final_checkpoint_location) self.assertEqual(status, service.NON_VERIFIED_TRACK)
return self.construct_scalar(node)
if (children_left[node_id] != children_right[node_id]): stack.append((children_left[node_id], parent_depth + 1)) stack.append((children_right[node_id], parent_depth + 1)) else: is_leaves[node_id] = True
rval = [None] * self.n_unique_specs
self.custom_fields = kwargs.pop('custom_fields', [])
default_tolerance = '0.001%'
field_data['attempts'] = int(attempts)
y_pred = clf.classes_.take(y_proba.argmax(axis=1), axis=0) assert_array_equal(y_pred, true_result)
X_dense = theano.sparse.dense_from_sparse(X) noise = self.random_stream.binomial(size=X_dense.shape, n=1, prob=self.ratio, ndim=None)
'organizations',
scheme = u"https" if settings.HTTPS == "on" else u"http" return u'{}://{}'.format(scheme, settings.SITE_NAME)
after = expiration + timedelta(seconds=1) query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(after, query) self.assertIs(result, None)
self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course_key))
self.assertIn(draft_video.location, public_vertical.children)
_update_organization_context(context, course)
return (super(ExternalLinkCourseTab, cls).validate(tab_dict, raise_error) and key_checker(['link', 'name'])(tab_dict, raise_error))
description = cls._line_item_description(course_id=course_id)
clf = DecisionTreeClassifier(max_depth=2, min_samples_split=2, criterion="gini", random_state=2) clf = clf.fit(X, y2, sample_weight=w)
from __future__ import unicode_literals
new_course = modulestore().create_course( org, number, run, user.id, fields=fields, )
CourseEnrollment.enroll(self.user, course.id)
out = StringIO() DummyCommand().execute(*args, stdout=out, **kwargs) out.seek(0) return json.loads(out.read())
reload_the_page(step) edit_component_and_select_settings()
assert self.conv2d.get_params() == [self.filters]
options = {'statsd': True}
X, = data assert X.shape[0] == self.counter_idx + 1 assert X[0,0] == self.counter_idx prereq_counter = self.counter prereq_counter.set_value(prereq_counter.get_value() + 1)
if course.discussion_link: discussion_tab = CourseTab.load( 'external_discussion', name=_('External Discussion'), link=course.discussion_link ) else: discussion_tab = CourseTab.load('discussion')
self.verify_staff_debug_present(False)
for student in students[5:6]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.deleted, mode='honor' )
on_course_publish(self.course.id) requirements = get_credit_requirements(self.course.id, namespace="reverification") self.assertEqual(len(requirements), 0)
self._make_eligible() self._purchase_credit() request_uuid = self._initiate_request() self._set_request_status(request_uuid, "approved")
return submit_reset_problem_attempts_for_all_students(self.create_task_request(instructor), location)
self.elapsed = 0 self.total_errors = 0 self.counters = dict.fromkeys(self._benchmark_keys, 0) self.messages = {}
if sample_weight is None: break
random_state = check_random_state(random_state) r = random_state.randint(0, n_samples_abnormal, 3377) abnormal_samples = abnormal_samples[r] abnormal_targets = abnormal_targets[r]
@ignore_warnings(category=DeprecationWarning) def test_verbose_first_level(): X = rng.randn(30, 5) X[:10] += 2 g = mixture.GMM(n_components=2, n_init=2, verbose=1)
container = unit.xblocks[1].go_to_container() return container
def __init__(self, method, detail=None): if isinstance(detail, dict): self.detail = detail else: super(MethodNotAllowed, self).__init__(method, detail)
a = svm.SVC(C=1, kernel=lambda x, y: x * y.T, probability=True, random_state=0) b = base.clone(a)
array = np.array(array, dtype=dtype, order=order, copy=copy)
#html_file_suffix = None
if youtube_stub_config: YouTubeStubConfig.configure(youtube_stub_config) if subtitles: self.assets.append('subs_3_yD_cEKoCk.srt.sjson') self.navigate_to_course_unit()
if self.presort == 'auto' and issparse(X): presort = False elif self.presort == 'auto': presort = True
if world.is_css_present('{}.is-shown'.format(saving_mini_css)): world.css_find('{}.is-hiding'.format(saving_mini_css))
self._auto_auth(self.USERNAME, self.EMAIL, False) self.dashboard.visit()
rmtree(fs_root, ignore_errors=True)
self.assertIn(orphan_vertical.location, self.store.get_orphans(course.id))
DarkLangConfig = apps.get_model("dark_lang", "DarkLangConfig") objects = DarkLangConfig.objects if not objects.exists(): objects.create(enabled=True)
if xblock.fields['visible_to_staff_only'].is_set_on(xblock): return xblock
cat = [False, False, False] _check_one_hot(X, X2, cat, 3)
task_entry = self._create_input_entry() with self.assertRaises(ItemNotFoundError): self._run_task_with_mock_celery(task_class, task_entry.id, task_entry.task_id)
X_ = np.asarray(X) grid = np.unique(X_[:, 0]) pdp_2, axes = partial_dependence(clf, [0], grid=grid)
assert_equal(X_pred.shape[0], n_samples)
task_key = hashlib.md5(task_key_stub).hexdigest() return submit_task(request, task_type, task_class, course_key, task_input, task_key)
prob_sum = prob.sum(axis=1) all_zero = (prob_sum == 0) if np.any(all_zero): prob[all_zero, :] = 1 prob_sum[all_zero] = len(self.classes_)
self.modulestore = modulestore self.course_key = course_key self.definition_locator = DefinitionLocator(block_type, definition_id) self.field_converter = field_converter
linter = MakoTemplateLinter() self.assertEqual(linter._is_valid_directory(data['directory']), data['expected'])
is_small_course = False enrollment_count = CourseEnrollment.objects.num_enrolled_in(course_key) max_enrollment_for_buttons = settings.FEATURES.get("MAX_ENROLLMENT_INSTR_BUTTONS") if max_enrollment_for_buttons is not None: is_small_course = enrollment_count <= max_enrollment_for_buttons return is_small_course
if mode == 'connectivity': A_data = np.ones(n_samples1 * n_neighbors) A_ind = self.kneighbors(X, n_neighbors, return_distance=False)
print "{:>26}".format("course ID"), print ' '.join(["{:>16}".format(heading) for heading in status_headings])
self.store.publish(sequential.location, self.user_id) self.assertFalse(self._has_changes(sequential.location))
return X
assert_warns(RuntimeWarning, k_means, X, n_clusters=n_clusters, init=centers)
self._assert_chapter_loaded(self.course, self.chapter)
for from_space in composite_spaces: for to_dtype in composite_dtypes: test_get_origin_batch(from_space, to_dtype) test_make_shared_batch(from_space, to_dtype) test_make_theano_batch(from_space, to_dtype) test_dtype_setter(from_space, to_dtype)
if comment_id in self.server.config.get('comments', {}): comment = self.server.config['comments'][comment_id] self.send_json_response(comment)
self.x_sum *= self.gamma self.x_sum += x
message = 'foo: bar="baz", qux="quux"' self.assertTrue(mock_log.info.called_with(message))
self.converged_ = False
lowest_passing_grade = DecimalField(max_digits=5, decimal_places=2, null=True)
SEARCH_ENGINE = "search.elastic.ElasticSearchEngine"
if not hasattr(self, 'inference_procedure') or \ self.inference_procedure is None: self.inference_procedure = WeightDoubling() self.inference_procedure.set_dbm(self)
coupon = Coupon( code='test_code', description='test_description', course_id=self.course.id, percentage_discount='10', created_by=self.instructor, is_active=True ) coupon.save()
resp = self.create_xblock(parent_usage_key=self.usage_key, category='chapter') self.chapter_usage_key = self.response_usage_key(resp)
self.q(css="input[name=cancel]").click()
assert_raises(VerificationException, attempt.approve) assert_raises(VerificationException, attempt.deny)
self.assertNotEqual(draft_version, published_version)
attempts = random.randint(1, 10) module = CapaFactory.create(attempts=attempts - 1, max_attempts=attempts) self.assertEqual(module.check_button_name(), "Final Check")
self.assertEqual(len(self.certificates_page.certificates), 1) course_number = self.certificates_page.get_course_number() self.assertEqual(self.course_info['number'], course_number)
Order.get_cart_for_user(self.user).start_purchase() Order.get_cart_for_user(self.user).start_purchase() Order.get_cart_for_user(self.user).start_purchase()
for word in self.student_words: temp_all_words[word] = temp_all_words.get(word, 0) + 1
user = User.objects.get(username=self.USERNAME) request = RequestFactory().get("/api/user/v1/accounts/") request.user = user account_settings = get_account_settings(request)
'transcript': 'http://video.google.com/timedtext?lang=en&v=3_yD_cEKoCk',
return isinstance(op, _ElemwiseNoGradient)
assert_greater(np.abs(s[:k] - sa).max(), 0.01)
clf = neighbors.KNeighborsClassifier(n_neighbors, weights=weights) clf.fit(X, y)
covars = np.asarray(covars) _validate_covars(covars, self.covariance_type, self.n_components) self.covars_ = covars
params["email"] = "not_an_email_address" assert_email_error("A properly formatted e-mail is required")
response = self.client.get(reverse('signin_user')) self.assertEqual(200, response.status_code) self.assertTrue('login-and-registration-container' in response.content)
msg = "No valid user id found in endpoint URL" log.info("[LTI]: {}".format(msg)) raise LTIError(msg)
self.n_classes = np.unique(y).shape[0] if self.n_classes == 2: self.n_classes = 1
with open(Env.METRICS_DIR / "pylint", "w") as f: f.write(violations_count_str)
lib_key = LibraryLocator(org=org, library=library) if lib_key in self.mappings: raise DuplicateCourseError(lib_key, lib_key)
CACHE_TIMEOUT = 0
return "user_partitions"
cache_key = self._cache_key_for_kvs_key(kvs_key) field_object = self._cache.get(cache_key) if field_object is None: raise KeyError(kvs_key.field_name) field_object.delete() del self._cache[cache_key]
train_with_monitoring_datasets( train_dataset=dataset1, monitoring_datasets=uneven_monitoring_datasets, model_force_batch_size=False, train_iteration_mode='sequential', monitor_iteration_mode='sequential')
return { 'id': user.id, }
return self.delete_student_state_button.is_present()
self.assertIn('You must wait', result['success'])
self.assertIsNotNone(account_settings['date_joined']) del account_settings['date_joined']
self.assertEqual(response.status_code, 200)
new_data = kde.sample(44, random_state=0) new_data = pca.inverse_transform(new_data)
parent = block.get_parent() while parent: yield parent parent = parent.get_parent()
courses_summary_list, __ = _accessible_courses_summary_list(self.request)
input_dict = {'1_2_1': 'California'} correct_map = problem.grade_answers(input_dict) self.assertEquals(correct_map.get_hint('1_2_1'), "")
if not settings.FEATURES.get('MILESTONES_APP', False): return None from milestones import api as milestones_api return milestones_api.get_course_milestones_fulfillment_paths( course_id, user_id )
from .models import CourseStructure
vectorizer = TfidfVectorizer(ngram_range=(1, 3), analyzer='char', use_idf=False)
self._zendesk_instance.update_ticket(ticket_id=ticket_id, data=update)
self.assertEqual(search_results_page.header_name, 'Team Search') self.assertEqual( search_results_page.header_description, 'Showing results for "{search_query}"'.format(search_query=search_query) )
if local_loglevel not in LOG_LEVELS: local_loglevel = 'INFO'
if dispatch == 'preview_chemcalc': return self.preview_chemcalc(data) return {}
publish_event( "removed", result=format_block_keys(block_keys['selected']), removed=format_block_keys(block_keys['invalid']), reason="invalid" )
math_interpreter = ParseAugmenter(math_expr, case_sensitive) math_interpreter.parse_algebra()
self.user.profile.country = unrestricted_country.country self.user.profile.save() self.assert_enrollment_status()
CourseInstructorRole(dest_course_id).add_users( *CourseInstructorRole(source_course_id).users_with_role() ) CourseStaffRole(dest_course_id).add_users( *CourseStaffRole(source_course_id).users_with_role() )
self.assertIsInstance(BadgeClass().backend, DummyBackend)
err = Exception mock_index_dictionary.return_value = err
with patch('django.http.HttpResponse.set_cookie') as mock_delete_cookie: self.assert_response(set_request_user=set_request_user, set_session_cookie=set_session_cookie) self.assertEquals(mock_delete_cookie.called, expect_delete_called)
descriptor.save() return descriptor
clf = BernoulliNB(alpha=1.0) clf.fit(X, Y)
aside1 = AsideFoo(scope_ids=ScopeIds('user', block_type1, def_id, usage_id), runtime=self.runtime) aside1.field11 = 'new_value11' aside1.field12 = 'new_value12'
DATA_DIR = MODULE_DIR.parent.parent.parent.parent / "test" / "data"
courses = [ course_with_prereq, CourseFactory.create(start=self.NEXT_WEEK, mobile_available=True), CourseFactory.create(visible_to_staff_only=True, mobile_available=True), CourseFactory.create(start=self.LAST_WEEK, mobile_available=True, visible_to_staff_only=False), ]
assert_raises(ValueError, pairwise_distances, X, Y, metric="blah")
'AUTOMATIC_AUTH_FOR_TESTING': False,
with self.settings(FEATURES={'CUSTOM_COURSES_EDX': ccx_feature_flag}): course = self.ccx_enabled_course if enable_ccx else self.ccx_disabled_course self.assertEquals( expected_result, self.check_ccx_tab(course) )
assert_almost_equal(X_unwhitened.std(axis=0).std(), 74.1, 1)
return _load_output(output_dir, _get_func_fullname(self.func), timestamp=self.timestamp, mmap_mode=self.mmap_mode, verbose=self._verbose)
CMS_SEGMENT_KEY = None
X = rng.randn(100, 2)
if not has_studio_write_access(user, course_key): raise PermissionDenied() course_module = modulestore().get_course(course_key, depth=depth) return course_module
for max_leaf_nodes, name in product((None, 1000), ALL_TREES.keys()): TreeEstimator = ALL_TREES[name]
config_course_cohorts( course, is_cohorted=True, discussion_topics=["General", "Feedback"], cohorted_discussions=["Feedback"] )
emails = instructor_task.api.get_instructor_task_history(course_id, task_type=task_type)
return True
wait_for_xblock_initialization(self, '.xblock[data-block-type="split_test"]')
CourseEnrollmentFactory.create( user=user, course_id=course_key, mode=mode )
CORRECTMAP_PY = inspect.getsource(correctmap)
self.user.is_staff = True self.assertTrue(user_has_role(self.user, CourseCreatorRole()))
'simple_history',
self.xml_data = "about page 463139"
cohort = CohortFactory(course_id=self.course.id, users=[]) self._verify_non_staff_cannot_access( remove_user_from_cohort, "POST", [unicode(self.course.id), cohort.id] )
x = np.arange(plots.shape[1]) x += n_min
mock_response = mock.Mock() mock_response.status_code = 500 mock_post.return_value = mock_response with self.assertRaises(ccxconapi.CCXConnServerError): ccxconapi.course_info_to_ccxcon(self.course_key)
'EMBARGO': False,
if hasattr(self, 'scale_'): del self.scale_ del self.min_ del self.n_samples_seen_ del self.data_min_ del self.data_max_ del self.data_range_
return self.best_estimator_.predict_log_proba(X)
query = self._course_key_to_son(location.course_key) query['definition.children'] = unicode(location)
user = User.objects.get(email=email)
AUTH_ENTRY_LOGIN = 'login' AUTH_ENTRY_REGISTER = 'register' AUTH_ENTRY_ACCOUNT_SETTINGS = 'account_settings'
outliers_sw = sample_weight[outliers_mask] n_sw_outliers = np.sum(outliers_sw) outlier_loss = (2. * epsilon * np.sum(outliers_sw * outliers) - sigma * n_sw_outliers * epsilon ** 2)
return label.split(' (')[0]
config = cls.current() if not config.enabled: return False return block_type in config.disabled_blocks.split()
return queryset
MASQUERADE_DATA_KEY = 'masquerade_data'
items = store.get_items(course.id, settings={'group_access': {'$exists': True}}, include_orphans=False) return GroupConfiguration._get_content_groups_usage_info(course, items)
self.browser.refresh() self.wait_for_page()
self.batch_size = batch_size if (isinstance(dataset[0], theano.Variable)): self.dataset = [set.get_value(borrow=True) for set in dataset] else: self.dataset = dataset
from openedx.core.djangoapps.credit import api
return len(self.q(css='.team-member'))
new_stores = get_mixed_stores(new_mixed_setting) self.assertIsInstance(new_stores, list)
self._each_parens(r'\left(x^y\right)', 'x^y', '(', tall=True)
queryset = CourseMode.objects.all()
root = etree.Element("glassets") with self.assertRaises(ContractNotRespected): AssetMetadata.add_all_assets_as_xml(root, self.course_assets)
assert_page_correct( page=3, page_size=4, expected_start=8, expected_stop=10, expected_next=None, expected_prev=2 )
with self.assertRaises(Exception): self.build_problem(math_display=True, expect="2*x+3*y", num_inputs=3)
self.toggle_button('done_0', {}, False) self.toggle_button('done_1', {}, True)
with self.assertRaises(LTIError): req = self.get_signed_grade_mock_request() self.xmodule.verify_oauth_body_sign(req)
ordering = ['country']
self.assertEqual(actual_padding, expected_padding)
return "{0},{1}".format(bookmark.user.username, bookmark.usage_key)
self.request.social_strategy.clean_partial_pipeline() raise OAuthValidationError( { "error": "invalid_grant", "error_description": "access_token is not valid", } )
AUTHOR_VIEW = 'author_view'
self.assertEqual(response.status_code, 200) certificate_exception = json.loads(response.content)
z = mask[:, None] * z + (1 - mask[:, None]) * state_before
self.assertIn(settings.EDXMKTG_LOGGED_IN_COOKIE_NAME, self.client.cookies) self.assertIn(settings.EDXMKTG_USER_INFO_COOKIE_NAME, self.client.cookies)
errors = self.errors return (bool(errors), errors)
self.assertFalse(section.due_date) self.assertFalse(section.policy)
if len(name) > 10: name = name[:10] return name.replace(' ', '_').strip()
from __future__ import unicode_literals
APP.config_from_object('django.conf:settings') APP.autodiscover_tasks(lambda: settings.INSTALLED_APPS)
@patch.object(OrderItem, 'purchased_callback') @patch.object(OrderItem, 'pdf_receipt_display_name')
super(ExponentialLoss, self).__init__(1)
if self.system.anonymous_student_id: return self.data.replace("%%USER_ID%%", self.system.anonymous_student_id) return self.data
self.assertFalse(self.store.has_changes(new_blocks["about"])) self.assertTrue(published_version_exists(new_blocks["chapter"]))
clf = GridSearchCV(clf, {'anova__percentile': [5, 10, 20]}, cv=cv)
urlpatterns += ( url(r'^xdomain_proxy.html$', 'cors_csrf.views.xdomain_proxy', name='xdomain_proxy'), )
with self.assertNumQueries(0): all_deadlines = VerificationDeadline.deadlines_for_courses(course_keys) self.assertEqual(all_deadlines, deadlines)
X_train_fit, y_train_fit = slow_model._build_y(X_train, y_train, sample_weight=weights, trim_duplicates=False) slow_model._build_f(X_train_fit, y_train_fit)
return module.seed
fgroups = hgroups filters_per_group = hcolors_per_group
self.some_url = '/'
#epub_pre_files = []
self.courseware_page.click_next_button_on_bottom() self.assert_navigation_state('Test Section 1', 'Test Subsection 1,2', 0, next_enabled=True, prev_enabled=True)
self.release_languages('ar, es-419')
skip_if_no_sklearn() mapping = {'dataset_iterator': 'DatasetValidationKFold'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
no_courses = get_courses(user, org=primary) self.assertEqual(no_courses, [])
spmat = spmat.ensure_sorted_indices()
X_transformed_parallel2 = fs_parallel2.fit_transform(X) assert_array_equal( X_transformed.toarray(), X_transformed_parallel2.toarray() )
def convert_to_draft(self, location, user_id): raise NotImplementedError()
scores = cross_val_score(GaussianNB(), X, y, cv=10) assert_greater(scores.mean(), 0.77)
xpath = "//div[@class='indicator-container']/span" self.assert_no_xpath(xml, xpath, self.context)
return self.q(css='ul.listing-courses')
return self.to_storable() == edit_info.to_storable()
return self._stacks[stack]
for user in [self.alpha_user, self.beta_user, self.non_cohorted_user]: self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))
plt.figure() fig = plt.gcf() cls_runtime = [] for cls_name, stats in sorted(cls_stats.items()): cls_runtime.append(stats['total_fit_time'])
datasets = list(datasets[label] for label in data_subsets.keys()) if len(datasets) == 1: datasets, = datasets
_ = lambda text: text
CDN_VIDEO_URLS = {}
this_img = scale_to_unit_interval( this_x.reshape(img_shape))
lp_model = label_propagation.LabelSpreading(gamma=0.25, max_iter=5) lp_model.fit(X, y_train) predicted_labels = lp_model.transduction_[unlabeled_set] true_labels = y[unlabeled_set]
self._verify_visibility_state(xblock_info, VisibilityState.ready)
sys = 'cms' if sys == 'studio' else sys return cmd("python manage.py", sys, "--settings={}".format(settings), *args)
user = UserFactory.create(username="ma1", email="ma1@ma1.info", password="edx") self.assertFalse(EdxNotesTab.is_enabled(self.course, user=user))
self.store.delete_item(published_xblock.location, self.user_id)
self.update_enrollment(mode=mode)
component = self.store.create_child( self.user_id, test_course.location, 'vertical', )
self.select_content_group_radio_button() select_option_by_text( self.q(css=self._bounded_selector(self.content_group_selector_css)), content_group )
return tensor.dot(inputs[0], self.wxf)
mean = X.mean(axis=0) mean_matrix = csr_matrix(mean.repeat(n).reshape((d, n))).T X = X - mean_matrix
self.assertEqual(len(mail.outbox), 1)
return estimator.score(*args, **kwargs)
#latex_appendices = []
y = zca_dataset.mapback(zca_dataset.X) assert_allclose(x[start:stop], y)
x = np.arange(len(channel.batch_record))
self.assertFalse(res_json['success'])
try: key = unicode(key, 'utf-8') value = unicode(value, 'utf-8') except UnicodeDecodeError: self.log_message("Could not decode request params as UTF-8")
has_partial_range = tree.xpath('responseparam[@partial_range]') if has_partial_range: partial_range = float(has_partial_range[0].get('partial_range', default='2')) else: partial_range = 2
expr = Forward()
return self.q(css=self.BOOKMARKS_BUTTON_SELECTOR).visible
if not self.q(css="input.no_special_exam").present: return False
return topic_name_to_id(course, name)
return super(NullBackend, self).get_dict(dict_name, default, **kwargs)
if hasattr(self.beta_tester, '_roles'): del self.beta_tester._roles self.assertFalse(CourseBetaTesterRole(self.course.id).has_user(self.beta_tester))
wait_for( func=lambda _: EC.presence_of_element_located((By.CSS_SELECTOR, css_selector,)), timeout=timeout, timeout_msg="Timed out waiting for {} to be present.".format(css_selector) )
self.assertTrue(hasattr(course_overview, 'image_set'))
self.dbm = dbm
expected_msg = u'Error: test error \u03a9' self.assertEqual(result['success'], expected_msg)
y = np.array([3, 7, 5, 9, 8, 7, 10]) x = np.arange(len(y))
ind -= total
top_idx = set(component.argsort()[-3:][::-1]) assert_true(tuple(sorted(top_idx)) in correct_idx_grps)
problem = self.build_problem(options=["hasnot", "hasn't", "has'nt"], correct_option="hasn't")
self.assertFalse(utils.is_commentable_cohorted(course.id, team.discussion_topic_id)) self.assertTrue(utils.is_commentable_cohorted(course.id, "random"))
kf = cval.KFold(17, 3) check_cv_coverage(kf, expected_n_iter=3, n_samples=17)
X = [[-2, -1], [-1, -1], [-1, -2], [1, 1], [1, 2], [2, 1], [6, 3], [-4, 7]]
if len(self.credit_type) > 1: raise LoncapaProblemError('Only one type of partial credit is allowed for Multiple Choice problems.')
if url is not None: return redirect(url)
self.login() self.api_response(expected_response_code=404, username=other.username)
self.options.report = (reporter or self.options.reporter)(self.options) return self.options.report
cart.start_purchase()
self.login() response = self.api_response(expected_response_code=302) self.assertTrue(self.username in response['location'])
AUTH_BASE_URL = os.environ.get('test_url', 'http://localhost:8031')
self.thread_page_1.click_and_open_thread(thread_id=self.thread_ids[1]) self.assertTrue(self.thread_page_2.is_browser_on_page())
u"{user}@example.com".format( user=(u'e' * (EMAIL_MAX_LENGTH - 11)) )
response = self.searcher.search(field_dictionary={"course": self.course_id}) self.assertEqual(response["total"], expected_count)
mlp._coef_grads = [0] * (mlp.n_layers_ - 1) mlp._intercept_grads = [0] * (mlp.n_layers_ - 1)
with patch('openedx.core.djangoapps.safe_sessions.middleware.log.' + log_level) as mock_log: yield mock_log.assert_any_call(log_string)
self.assertFalse(response_data['success']) self.assertEquals(expected_error, response_data['error']) self.assertFalse(self.user.email_user.called)
asset_key = asset_metadata_list[0].asset_id course_key = asset_key.course_key
laplacian = _set_diag(laplacian, 1, norm_laplacian)
return self.get_attrs(location).get(attr, default)
self.assertTrue(hasattr(course_overview_after, 'image_set')) image_set = course_overview_after.image_set self.assertEqual(image_set.small_url, broken_small_url) self.assertEqual(image_set.large_url, broken_large_url)
assert_array_equal(np.log(proba[k]), log_proba[k])
self.assertTrue(self._search_for_content(self.EDITED_SEARCH_STRING))
if self._match_pattern(handlers_list): return else: self.send_response(404, content="404 Not Found")
self.mstore = modulestore()
transform = AdditiveChi2Sampler(sample_steps=4) assert_raises(ValueError, transform.fit, X)
return context["is_requester_privileged"] or _is_author(cc_content, context)
configuration_id = content.pop("id") group_ids = [group.pop("id") for group in content["groups"]] return (configuration_id, group_ids)
'microsite_configuration',
pinv2_args = {'check_finite': False}
instructor_dashboard_page = self.visit_instructor_dashboard() exam_attempts_section = instructor_dashboard_page.select_special_exams().select_exam_attempts_section()
MESSAGE = _('git clone or pull failed!')
return self.q(css='.sidebar').present
if node.attr == 'format': self.contains_format_call = True else: self.generic_visit(node)
self.assertFalse(ApiAccessRequest.objects.all().exists()) response = self.client.post(self.url, VALID_DATA) self._assert_post_success(response)
scale = 0.5
labels, y = np.unique(y, return_inverse=True)
assert_true(clf.fit_intercept)
for key in locations: self.assertFalse(self._has_changes(locations[key]))
"corruptor" : *corr
self.wait_for_ajax()
request, strategy = self.get_request_and_strategy( auth_entry=pipeline.AUTH_ENTRY_REGISTER, redirect_uri='social:complete') strategy.request.backend.auth_complete = mock.MagicMock(return_value=self.fake_auth_complete(strategy))
user_profile._changed_fields = get_changed_fields_dict(user_profile, sender)
assert_true(ocur == X.shape[1])
obj = LTIProviderConfig(**kwargs) obj.save() return obj
#np.sum(np.abs(y_hat - y), axis=1) != 0
for arrow in ARROWS: left, a, right = eq.partition(arrow) if a != '': return left, a, right
BODY_SELECTOR = "#search-results-panel" TAB_SELECTOR = ".tab#view-search-results"
self.send_delete(self.client, expected_status=404)
response = self.client.post(self.send_mail_url, test_email) self.assertEquals(json.loads(response.content), self.success_content)
'ENABLE_LIBRARY_INDEX': False,
if self.remove_zero_eig or self.n_components is None: self.alphas_ = self.alphas_[:, self.lambdas_ > 0] self.lambdas_ = self.lambdas_[self.lambdas_ > 0]
info_log.assert_called_with( u"user already exists with username '%s' and email '%s'", 'test_student_1', 'test_student@example.com' )
self.q(css="input.proctored_exam").first.click() self.q(css=".action-save").first.click() self.wait_for_ajax()
rng = np.random.RandomState(0) rand_data = RandomData(rng, scale=7) n_components = rand_data.n_components
credit_api.set_credit_requirements(
content_store.set_attr(self.LOCKED_ASSET_KEY, 'locked', True)
metadata['xml_attributes'][attr] = value
if self.y is None: return self.X else: return (self.X, self.y)
print_monitor_cv.main(filename)
UserProfileFactory(user=self.user)
my_X = X.copy() km = KMeans(copy_x=False, n_clusters=n_clusters, random_state=42) km.fit(my_X) _check_fitted_model(km)
pass
'WHAT_IS_VERIFIED_CERT': 'verified-certificate',
w = rng.randn(num_features)
X = np.asfortranarray(iris.data.astype(tree._tree.DTYPE)) y = iris.target
selector = self._bounded_selector(".annotator-outer") self.wait_for_element_invisibility(selector, text)
with remove_ccx(location) as (location, restore): return restore( self._modulestore.convert_to_draft(location, user_id) )
self.client.ajax_post( self.problem_update_url, data={'publish': 'make_public'} )
self.assert_grade(problem, answer, "correct")
self.assertLessEqual(old_time, updated_component.published_on) self.assertEqual(updated_component.published_by, publish_user)
course_key = self.make_course_key(org, course, run) if course_key in self.mappings and self.mappings[course_key].has_course(course_key): raise DuplicateCourseError(course_key, course_key)
self.all_words = temp_all_words
self.assertGroupContent( groups[3], title=u"[no tags] (2)", notes=["Fifth note", "First note"] )
def make_thunk(self, node, storage_map, compute_map, no_recycling): if not convnet_available(): raise RuntimeError('Could not compile cuda_convnet')
copy_or_rename_transcript(new_name, old_name, item, user=request.user)
module = CapaFactory.create(attempts=1)
self.assert_grade(problem, json.dumps({0: 4}), "correct") self.assert_grade(problem, json.dumps({0: 5}), "incorrect")
y = iris.target
assert zca_dataset.has_targets()
if youtube_id: return 'https://www.youtube.com/watch?v={0}'.format(youtube_id) else: return ''
msg += _('Failed in authenticating {username}, error {error}\n').format( username=euser, error=err ) continue
try: import gen_rst except: pass
self.click(".action-cancel")
chapter_aside.data_field = 'new value' self.store.update_item(new_chapter, self.user_id, asides=[chapter_aside])
hash_val = ",".join([ "{0}={1}".format(key, post_params[key]) for key in signed_fields ]) public_sig = processor_hash(hash_val)
self.assert_function_values( 'sqrt',
def test_user_role(): return 'staff'
expect = kwargs.get('expect', '') options = kwargs.get('options', [])
segment_event_name = segment_properties['name'] disallowed_substring_names = [ a.lower() for a in getattr(settings, 'TRACKING_SEGMENTIO_DISALLOWED_SUBSTRING_NAMES', []) ]
split = 'split' mongo = 'mongo'
get_request_dict = {} result = module.reset_problem(get_request_dict)
filter_rows_broadcastable = False filter_cols_broadcastable = False output_channels_broadcastable = hid_grads.type.broadcastable[0]
for asset in assets: asset_node = etree.SubElement(node, "asset") asset.to_xml(asset_node)
self._redirect_if_needed_to_pay_for_course() self._redirect_if_needed_to_register() self._redirect_if_needed_for_prereqs() self._redirect_if_needed_for_course_survey()
self.video.wait_for( lambda: (text in self.video.closed_captions_text), u'Closed captions contain "{}" text'.format(text), timeout=5 )
self.wait_for_ajax() return self.q(css='.u-field-{}'.format(field_id)).visible
self.assert_grade(problem, "invalid_option", "incorrect")
prob /= prob_sum.reshape((prob.shape[0], -1))
if len(cur_state_below) == 1: cur_state_below, = cur_state_below
'SQUELCH_PII_IN_LOGS': True,
X, y = make_classification(n_samples=20, n_classes=2, random_state=0)
response = MagicMock() response.status_code = status response.content = xml.format(major_code=major_code).encode('ascii', 'ignore') return response
clf_samme.algorithm = "SAMME.R" assert_array_less(0, np.abs(clf_samme.predict_proba(iris.data) - prob_samme))
response = self.the_input.handle_ajax("obviously_not_real", {}) self.assertEqual(response, {})
(12, True, False, u"False")
problem = self.build_problem(answer=script)
from xmodule.modulestore.inheritance import InheritanceMixin from xmodule.modulestore import prefer_xmodules from xmodule.x_module import XModuleMixin
return v
self.edit_info = EditInfo(**block_data.get('edit_info', {}))
_ = lambda text: text
block, _ = get_module_by_usage_id( request, unicode(course_key), unicode(usage_key), disable_staff_debug_info=True, course=course )
else: yield enrollment
instructor = UserFactory() allow_access(self.course, instructor, 'instructor') self.assertTrue(CourseInstructorRole(self.course.id).has_user(instructor))
est = TreeEstimator(random_state=0) est.fit(X, y, sample_weight=sample_weight) assert_equal(est.tree_.max_depth, 1)
if hasattr(self, '_target_space'): return self._target_space else: return self.get_output_space()
_delete_item(usage_key, request.user)
external_solver = ['Isomap', 'KernelPCA', 'LocallyLinearEmbedding', 'RandomizedLasso', 'LogisticRegressionCV']
receipt_id = self.receipt_id if override_receipt_id is None else override_receipt_id
if solution_element is None: continue
url_user_invoice_preference = reverse('get_user_invoice_preference', kwargs={'course_id': self.course.id.to_deprecated_string()})
retval = self.service.set_credit_requirement_status( self.user.id, self.course.id, 'grade', 'grade' ) self.assertIsNone(retval)
self._click_programs_tab() return self.q(css='div.programs-tab.active a.new-program-button').present
return {}
self.client.logout()
xml = renderer.get_html() context = extract_context(xml) self.assertEqual(context, {'id': 'solution_12'})
Sigma = Sigma[::-1] U, VT = svd_flip(U[:, ::-1], VT[::-1])
for resource_id, resource in self.test_recommendations.iteritems(): for xblock_name in self.XBLOCK_NAMES: result = self.call_event('add_resource', resource, xblock_name)
n_words = 0 while n_words == 0: n_words = generator.poisson(length)
url = reverse('verify_student_verify_now', kwargs={'course_id': unicode(course_id)}) self.assertRedirects(response, url, status_code)
s_1 = .5 * a.T.dot(C).dot(a) - .5 * R.T.ravel().dot(C.ravel())
SupportStaffRole().remove_users(self.admin) response = self.client.get('/support/') self.assertTrue(response.status_code, 302)
self.course_key = SlashSeparatedCourseKey('edX', 'toy', '2012_Fall')
resp = self.client.delete('/course/bad/course/key/entrance_exam') self.assertEqual(resp.status_code, 400)
self.verify_end_date("edX/test_about_blob_end_date/2012_Fall", "Learning never ends")
y = [0, 1, 2, 3] * 3 + [4, 5] * 5 X = np.ones_like(y)
for alg in ['SAMME', 'SAMME.R']: clf = AdaBoostClassifier(algorithm=alg, n_estimators=10) clf.fit(iris.data, iris.target, sample_weight=iris_weights)
ndar = ndar.copy() ndar -= ndar.min() ndar *= 1.0 / (ndar.max() + eps) return ndar
self._assert_course_verification_status(VERIFY_STATUS_NEED_TO_REVERIFY)
student_id = AutoAuthPage(self.browser).visit().get_user_id()
mock_refund_seat.reset_mock() self.send_signal(skip_refund=True) self.assertFalse(mock_refund_seat.called)
try: try: return super(PutAsCreateMixin, self).update(request, *args, **kwargs) except Http404: return super(PutAsCreateMixin, self).create(request, *args, **kwargs)
self.page.visit() config = self.page.experiment_group_configurations[0] config.toggle() usage = config.usages[0] config.click_unit_anchor()
_view_name = None client_class = PatchedClient
X_test = np.array([[0, 1, 1, 0, 0, 1]])
if existing_id: dest_id = existing_id
days_early_for_beta = FloatField(null=True) mobile_available = BooleanField(default=False) visible_to_staff_only = BooleanField(default=False)
course_key = SlashSeparatedCourseKey('mitX', '101', 'test') return utils.get_lms_link_for_about_page(course_key)
p_shared = sharedX(zv[:, :, 0:rows:pool_rows, 0:cols:pool_cols]) h_shared = sharedX(zv) z_shared = sharedX(zv)
connectivity = kneighbors_graph(X, n_neighbors=10, include_self=False) connectivity = 0.5 * (connectivity + connectivity.T)
self.assert_redirect_to_register_looks_correct(actions.do_complete(backend, social_views._do_login))
self.assertFalse(library_container.has_validation_error) self.assertFalse(library_container.has_validation_warning)
assert_false(np.may_share_memory(b_float32, a_int32))
xpath = "//option[@value='option_2_dummy_default']" self.assert_has_xpath(xml, xpath, self.context)
ASSET_XML_TAG = 'asset'
n_classes = n_classes.astype(theano.config.floatX) return sm * (1 - n_classes * min_val) + min_val
('purchased', 'purchased'),
X = check_array(X, accept_sparse=['csc'], ensure_2d=False) if issparse(X): X.sort_indices()
composite_dtypes = ((None, 'int8'), ('complex128', theano.config.floatX))
CUSTOM_THEME_OVERRIDES = { 'embargo': BlockedMessage( description='Embargo', template='static_templates/theme-embargo.html' ) }
status = 'pending'
AutoAuthPage( self.browser, username="testprogress", email="progress@example.com", password="testuser", course_id=self.course_id ).visit()
super(FormatInterpolateVisitor, self).__init__(file_contents, results) self.interpolates_text_or_html = False self.format_caller_node = None
'ENABLE_CREATOR_GROUP': False,
return self._modulestore._get_modulestore_for_courselike(locator)
unicode_text = "好 各位同学".decode('utf-8') self.assertTrue(self.video.downloaded_transcript_contains_text('srt', unicode_text))
response = getattr(self.client, verb)(LIBRARY_REST_URL) self.assertEqual(response.status_code, 405)
v2 = CountVectorizer(vocabulary=v1.vocabulary_)
MESSAGE = _('The underlying module store does not support import.')
'error': _("Refresh the page and make an attempt before resetting."),
for block_key in block_structure.topological_traversal(): block_structure.set_transformer_block_field( block_key, cls, data_key, cls._create_block_value(block_key, data_key) )
n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)
CourseEnrollment.enroll(user, course_key=course.location.course_key) self.assertFalse(user.badgeassertion_set.all())
self.courseware_page.click_previous_button_on_bottom() self.assert_navigation_state('Test Section 1', 'Test Subsection 1,1', 3, next_enabled=True, prev_enabled=True)
if Minv is not None: raise ValueError("Minv should not be specified when sigma is")
tracker._initialize_backends_from_django_settings()
unit.view_published_version() self.assertEqual(len(self.browser.window_handles), 2) self.courseware.wait_for_page()
if not isinstance(validation, Validation): raise TypeError("Copy must be called with a Validation instance") studio_validation = cls(validation.xblock_id) studio_validation.messages = validation.messages return studio_validation
return self._get_xblocks()
if course_message: msg = u"{} <br /> {}".format(msg, course_message.message)
assert_array_equal(linkage_X_ward[:, :2], out_X_unstructured[0]) assert_array_equal(linkage_X_ward[:, :2], out_X_structured[0])
with warnings.catch_warnings(record=True) as w: warnings.simplefilter("always")
license_text = self.q(css='section.license span.license-text') if license_text.is_present(): return license_text.text[0] return None
for course_key in courses: self.assertFalse(is_course_in_block_structure_cache(course_key, self.store))
assert_raises(ValueError, GaussianNB().partial_fit, X, y, classes=[0, 1])
oa = OAS(store_precision=False, assume_centered=True) oa.fit(X_centered) assert_almost_equal(oa.score(X_centered), score_, 4) assert(oa.precision_ is None)
return { 'user': self.user, 'enrollment': self.enrollment, 'allowed': self.allowed, 'auto_enroll': self.auto_enroll, }
self.course.edxnotes = _edxnotes self.assertEqual(helpers.is_feature_enabled(self.course), _edxnotes)
assert_almost_equal(np.abs(np.dot(d1[:2], [1, 0])), 1.0)
self._corrupt_switch = True
username, user_id = self.log_in_as_unique_user() profile_page = self.visit_profile_page(username) self.verify_profile_page_is_public(profile_page)
elif revision == ModuleStoreEnum.RevisionOption.draft_only: return get_draft()
if depth == 0: self.load_item.side_effect = lambda x: LeafModuleFactory(descriptor_cls=HtmlDescriptor) else: self.load_item.side_effect = lambda x: ContainerModuleFactory( descriptor_cls=VerticalBlock, depth=depth - 1 )
if not hasattr(self.current_request_configuration, 'data'): return {} return self.current_request_configuration.data
variables, functions = add_defaults(variables, functions, case_sensitive)
raise ThreadNotFoundError("Thread not found.")
response = client.post(self.path, data=json.dumps(data), content_type=JSON, HTTP_X_CSRFTOKEN=csrf_token) self.assertEqual(response.status_code, 201)
return modulestore().get_item(child.location)
self.assertIn(self.SUCCESSFUL_RESPONSE, response.content) self.assertEqual(response.status_code, 200)
self.child_module = self._get_module(course.id, child_descriptor, child_descriptor.location)
return comb(n, 2, exact=1)
self.theta0 = np.atleast_2d(self.theta0) lth = self.theta0.size
self.assertEquals(preview.latex_preview('pi'), r'\pi')
self.assertEqual(d1, d2) self.assertNotEqual(d1.keys(), d2.keys())
super(ContentStoreToyCourseTest, self).setUp() self.staff_usr = AdminFactory.create() self.non_staff_usr = UserFactory.create() self.client = Client()
return xblock.has_children
clf = pickle.loads(pickle.dumps(clf)) assert_true(sp.issparse(clf.coef_)) pred = clf.predict(X) assert_array_equal(pred, Y)
return self.find_css('#staff_lock')[0].is_selected()
temp_all_words = self.all_words
'courseware.middleware.RedirectUnenrolledMiddleware',
try: return dict1[key] except KeyError: if default is None: return dict2[key] else: return dict2.get(key, default)
pass
courses_list_by_groups, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(courses_list_by_groups, []) self.assertEqual(courses_list, courses_list_by_groups)
latex += render_frac(numerator, denominator) + r"\cdot "
'openedx.core.djangoapps.site_configuration',
if self.current_group: return self.current_group groups = user_partition.groups if not groups or len(groups) == 0: return None return groups[0]
cohort = get_cohort(user, course_key, use_cached=use_cached) return None if cohort is None else cohort.id
example_input[0, 0] = -2.5
path = urlparse.urlparse(url).path resolver = resolve(path) ccx_key = resolver.kwargs['course_id']
p = mp.Process(target=train_mlp) p.start()
X = check_array(X, accept_sparse=['csr', 'csc'])
self.factory(shuffle="false")
raise SkipTest
json.dumps(assets._get_asset_json( "sample_static.txt", content_type, upload_date, asset_location, None, lock)), "application/json"
arg_spec_for_format = arg_spec[:7 if PY3_OR_LATER else 4]
return result.get('payment_data')
num_padded_bytes = ord(padded_data[-1]) return padded_data[:-num_padded_bytes]
return RequestFactory( SERVER_NAME=parsed_url.hostname, SERVER_PORT=parsed_url.port or 80, ).get("/")
with filesystem.open('updates.html', 'r') as course_policy: on_disk = course_policy.read() self.assertEqual(course_updates.data, on_disk)
epoch_num = 6 termination_criterion = EpochCounter(epoch_num)
if self.server.delete_note(note_id): self.respond(204, "No Content") else: self.respond(404, "404 Not Found")
group1_id = RandomUserPartitionScheme.get_group_for_user(self.MOCK_COURSE_ID, self.user, self.user_partition)
SKIP_STEPS = [ INTRO_STEP, ]
grandfathered_student = UserFactory() grandfathered_student.date_joined = timezone.now()
return 1 / numpy.sin(arg)
self.set_state_from_lcp()
if 'X-Edx-Api-Key' in self.headers: response = self.server._response_str logger.debug("Comment Service: sending response %s", json.dumps(response))
try: new_configuration = GroupConfiguration(request.body, course, group_configuration_id).get_user_partition() except GroupConfigurationsValidationError as err: return JsonResponse({"error": err.message}, status=400)
course_id = CourseKeyField(max_length=255, db_index=True)
self.annealed = sharedX(base_lr, 'annealed')
self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course_key))
self.validate_preview_html(self.video, STUDENT_VIEW, can_add=False)
perf_test = True
return tab_dict
self.q(css='.label-username').first.click()
if design_batch.ndim != 2: design_batch = dataset.get_design_matrix(design_batch) mapped_batch_design = dataset.mapback_for_viewer(design_batch) mapped_batch = dataset.get_topological_view(mapped_batch_design) return mapped_batch
self.assertTrue(self.coach_dashboard_page.is_browser_on_enrollment_page())
self.set_user_partitions(self.vertical_location, [split_test_partition, self.animal_partition]) self.check_access(self.red_cat, self.vertical_location, False)
username = re.sub(r'\s', '', _flatten_to_ascii(eamap.external_name), flags=re.UNICODE)
continue
past_due_date = CapaFactory.create(showanswer='correct_or_past_due', max_attempts="1", attempts="0", due=self.yesterday_str) self.assertTrue(past_due_date.answer_available())
problem = new_loncapa_problem(xml_str)
return professional_mode if professional_mode else verified_mode
'ALWAYS_REDIRECT_HOMEPAGE_TO_DASHBOARD_FOR_AUTHENTICATED_USER': True,
regular_values = np.linspace(0, 256, n_clusters + 1) regular_labels = np.searchsorted(regular_values, face) - 1
for other_label in unique_labels: if other_label != curr_label: other_mask = labels == other_label other_distances = np.mean( current_distances[:, other_mask], axis=1) inter_clust_dists[mask] = np.minimum( inter_clust_dists[mask], other_distances)
dist_dict = defaultdict(int) dist_dict.update(single_source_shortest_path_length(dist_matrix, i))
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
rval = X.copy()
current_time = json.loads(video_event['event'])['currentTime'] self.assertAlmostEqual(current_time, time_in_seconds, delta=1)
clf = Pipeline([ ('vec', vectorizer), ('clf', Perceptron()), ])
CourseModeFactory.create(mode_slug='honor', course_id=self.course.id) CourseModeFactory.create(mode_slug='verified', course_id=self.course.id, min_price=1)
return _xblock_type_and_display_name(find_release_date_source(xblock))
reload(sklearn.lda) return sklearn.lda
action_name = ugettext_noop('rescored') update_fcn = partial(rescore_problem_module_state, xmodule_instance_args)
course_wide_entries = discussion_category_map.pop('entries')
y += 0.01 * np.random.normal((n_samples,))
if profile_country is not None: self.user.profile.country = profile_country self.user.profile.save()
if n_active: linalg.solve_triangular(L[:n_active, :n_active], L[n_active, :n_active], trans=0, lower=1, overwrite_b=True, **solve_triangular_args)
y = 0.5 * X.ravel()
original_distances = original_distances[non_identical]
self.assertFalse(result['success']) self.assertIn(u"payment was declined", result['error_html'])
return self._doc_id
self.wait_for_element_visibility( '#entrance-exam-enabled', 'Entrance exam checkbox is available' ) return self.get_element('#entrance-exam-enabled')
('ALIGN', (1, 0), (1, -1), 'LEFT'),
self.assertEqual(expected_item.fields, actual_item.fields)
n_class = dual_coef.shape[0] + 1
if xblock_name is None: xblock_name = TestCrowdsourceHinter.XBLOCK_NAMES[0] url = self.get_handler_url(handler, xblock_name) return self.client.post(url, json.dumps(resource), '')
self._test_dropdown_field( u'country', u'Country or Region', u'', [u'Pakistan', u'Palau'], )
return progress
if user: self.q(css='input[id^=sd_fu_]').fill(user) self.q(css='section.staff-modal a.staff-debug-sdelete').click()
assert_raises(ValueError, sel.inverse_transform, np.array([[1], [2]]))
module = CapaFactory.create(rerandomize=rerandomize, done=True)
assert_raises(ValueError, _hc_cut, n_leaves + 1, children, n_leaves)
self.get_dummy_course(START)
self.assert_correct_json_response(json_response)
add_user_with_status_unrequested(user) course_creator_status = get_course_creator_status(user)
pass
upload_start_time = datetime.utcnow().replace(microsecond=0, second=0) self.import_page.upload_tarball(self.tarball_name) self.import_page.wait_for_upload()
self.assertEqual(data['course_mode_slug'], "verified")
clf = svm.SVC(kernel='linear', C=0.1, decision_function_shape='ovo').fit(iris.data, iris.target)
'ENABLE_DISCUSSION_HOME_PANEL': False,
except ValidationError as err: return Response(err.messages, status=status.HTTP_400_BAD_REQUEST)
self._studio_publish_content(0)
radio_button = self.q(css=self._bounded_selector(self.select_content_group_button_css)).results[0] radio_button.click() return radio_button.is_selected()
return logistic_sigmoid(X, out=X)
n_folds = 5 n_iter = 1000
self.mappings[lib_key] = store
input_type = kwargs.get('type', 'radiotextgroup') input_element = etree.Element(input_type)
clf = ForestClassifier(class_weight=[{-1: 0.5, 1: 1.}], random_state=0) assert_raises(ValueError, clf.fit, X, _y)
data = fetch_species_distributions()
course_id = course.id if course else self.course.id for mode_slug in course_modes: CourseModeFactory.create( course_id=course_id, mode_slug=mode_slug, mode_display_name=mode_slug, )
self.q(css=self.BOOKMARKS_BUTTON_SELECTOR).first.click() if wait_for_results: EmptyPromise(self.results_present, "Bookmarks results present").fulfill()
cached_calls = [ [num_uncached_mongo_calls, num_uncached_sql_queries], [num_cached_mongo_calls, num_cached_sql_queries], ] for expected_mongo_calls, expected_sql_queries in cached_calls: with self.assertNumQueries(expected_sql_queries): with check_mongo_calls(expected_mongo_calls): call_single_thread()
clf = DecisionTreeClassifier().fit(X, y)
return "SELECT MAX(id) FROM {table_name} GROUP BY {key_fields}".format( key_fields=', '.join(key_fields_escaped),
return np.abs(y_truth - y_prediction).sum() > tol
self.login_page.visit().password_reset(email=email)
if partition_id not in user_groups: return False
return self.q(css=".badges-modal").is_focused()
if store is not None and i not in (4, 5): store.save_asset_metadata(asset_md, asset[4])
Uhat, s, V = linalg.svd(B, full_matrices=False) del B U = np.dot(Q, Uhat)
set_user_preference(self.user, LANGUAGE_KEY, 'eo') self.middleware.process_request(self.request) self.assertEquals(self.request.session[LANGUAGE_SESSION_KEY], 'eo')
self.assertGroupContent( groups[1], title=u"review (2)", notes=[u"Fourth note", None] )
self.assertEquals(3, self.response.content.count('grade_C'))
mock = MagicMock(return_value=return_value) new_patch = patch(function_name, new=mock) new_patch.start() self.addCleanup(new_patch.stop) return mock
actual_collection = get_edx_api_data(program_config, self.user, 'programs', cache_key=cache_key) self.assertEqual(actual_collection, expected_collection)
request = Mock() request.GET = request.POST = {'task_id': task_id} return instructor_task_status(request)
X.indptr[m + 2:n] += nz_n - nz_m X.indptr[m + 1] = m_start + nz_n X.indptr[n] = n_stop - nz_m
return get_members(mailchimp, list_id, 'cleaned')
raise NotImplementedError()
descriptor.bind_for_student = partial(xblock_class.bind_for_student, descriptor)
return cls.objects.filter(user=user, status='cart').exists()
cls.apply_policy(metadata, runtime.get_policy(usage_id))
return self.is_proctored_enabled
module.system.render_template = Mock(return_value="<div>Test Template HTML</div>")
module = CapaFactory.create(xml=self.demand_xml)
import uuid SECRET_KEY = uuid.uuid4().hex
return self.find_css('.signatory-panel-body .signatory-title-value').first.text[0]
split_test = self.get_item_from_modulestore(self.split_test_usage_key, True) self.assertEqual(expected_number, len(split_test.children)) return split_test
pass
return self.http_get( reverse(self.view, kwargs={'course_id': course_id or self.course_id}), **headers )
self.get_selector('#certificate-exception').fill(student)
assets, count = contentstore().get_all_content_for_course(self.course.id) self.assertEqual(len(assets), 0) self.assertEqual(count, 0)
([], 'honor'),
else: self.alphas_ = np.asarray(alphas[0])
'openedx.core.djangoapps.bookmarks',
return 'self' if self.self_paced else 'instructor'
permutation = rng.permutation(n_samples) ind_test = permutation[:n_test] ind_train = permutation[n_test:(n_test + n_train)] yield ind_train, ind_test
check_estimator(AdaBoostClassifier) check_estimator(MultiTaskElasticNet)
self.assertEqual(response.status_code, 200)
return event['event_type'].startswith('edx.course.enrollment.')
self.create_programs_config()
self.path = preprocess(self.path) X, y = self._load_data()
return self.q(css=self._bounded_selector('.cohort-management-group-setup .setup-value')).first.text[0]
return store.db_connection.structures
raise NotImplementedError()
languages_data_folder = sys.argv[1] dataset = load_files(languages_data_folder)
VIDEO_CDN_URL = ENV_TOKENS.get('VIDEO_CDN_URL', {})
descriptor.raw_grader = descriptor.raw_grader
self.find_css('a.group-toggle').first.click()
for student in students[:3]: self.assertIn( GeneratedCertificate.certificate_for_student(student, self.course.id).status, CertificateStatuses.PASSED_STATUSES )
sample_weight = (sample_weight * compute_sample_weight(self.class_weight, y))
xsupi = _cg(fhess_p, fgrad, maxiter=maxinner, tol=termcond)
raise NotImplementedError()
try: return dateutil.parser.parse(datestr).replace(tzinfo=utc) except ValueError: raise DashboardError(_("Unable to parse date: ") + datestr)
google_provider = self.configure_google_provider(enabled=True) linkedin_provider = self.configure_linkedin_provider(enabled=True) self.assertEqual(len(provider.Registry.enabled()), 2)
self.certificates_section.wait_for_certificate_invalidations_section()
click_css(self, '.wrapper-mast nav.nav-actions .button-new')
file_handle.write(asbytes(length.ljust(_MAX_LEN))) file_handle.write(zlib.compress(asbytes(data), compress))
if self.value == '': self.value = 'null'
need_uniq_names = ('problem', 'sequential', 'video', 'course', 'chapter', 'videosequence', 'poll_question', 'vertical')
return meta("NewBase", bases, {})
if kl > tol or not (kl <= tol): raise AssertionError("KL divergence between two " "equivalent models should be 0 but is "+ str(kl))
return self.filter_by(data, "user", user)
profile_page.value_for_dropdown_field('language_proficiencies', 'English') profile_page.value_for_dropdown_field('country', 'United Arab Emirates') profile_page.set_value_for_textarea_field('bio', 'Nothing Special')
enrollment_mode = self.dashboard_page.get_enrollment_mode(self.course_info["display_name"]) self.assertEqual(enrollment_mode, 'verified')
return ( self.q(css="#new-url-input-field-message.has-error").visible and self.q(css="#new-url-desc-input-field-message.has-error").visible )
X = iris.data d = X.shape[1]
from lms.djangoapps.ccx.utils import get_ccx_from_ccx_locator return get_ccx_from_ccx_locator(course_id)
from __future__ import unicode_literals
super(AdvancedProblemComponentTest, self).setUp(is_staff=is_staff)
template = CourseEmailTemplate.get_template() self.assertIsNotNone(template.html_template) self.assertIsNotNone(template.plain_template)
X = x[:, np.newaxis] X_plot = x_plot[:, np.newaxis]
nonstaff, password = self.create_non_staff_user() client = AjaxEnabledTestClient() if authenticate: client.login(username=nonstaff.username, password=password) nonstaff.is_authenticated = lambda: authenticate return client, nonstaff
self.cache = caches['default']
return redirect(AUTH_DISPATCH_URLS[AUTH_ENTRY_REGISTER])
with self.assertNumQueries(1): bookmarks = api.get_bookmarks(user=self.user, course_key=course.id, serialized=False) self.assertEqual(len(bookmarks), count)
self.create_credentials_config() self.mock_credentials_api(self.user, data={'results': []}) actual = get_user_program_credentials(self.user) self.assertEqual(actual, [])
raise NotImplementedError()
self.accum.append(function(theano_args, givens=g, updates=u, mode=self.theano_function_mode, name=function_name))
AccessTestData(partition_groups={1: 1, 2: 2}, xblock_access={1: [3]}, merged_parents_list=[{1: {1}}]), AccessTestData(partition_groups={1: 1, 2: 2}, xblock_access={1: [2]}, merged_parents_list=[{1: {1}}]),
self.assertFalse(self.video.is_spinner_shown)
with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, source_course_key): component = self.store.get_item(unit.location) self.assertEqual(component.display_name, updated_display_name)
source_subs_filedata = request.FILES['transcript-file'].read().decode('utf-8-sig') source_subs_filename = request.FILES['transcript-file'].name
self.assertGreater(len(modules), 10)
plsca = PLSCanonical(n_components=2) plsca.fit(X_train, Y_train) X_train_r, Y_train_r = plsca.transform(X_train, Y_train) X_test_r, Y_test_r = plsca.transform(X_test, Y_test)
def test_split(): skip_if_no_data() n_train = 100 n_valid = 200 n_test = 300
response = self.client.get(self.courseware_url) self.assertEqual(response.status_code, 200)
res_r = int(numpy.floor(last_pool_r/rs)) + 1 res_c = int(numpy.floor(last_pool_c/cs)) + 1
aid = self.answer_ids[-1] new_cmap.set_hint_and_mode(aid, hint_text, hintmode)
self.assert_response(safe_cookie_data) self.assert_user_in_session()
return self.test_passed('.local-resource-test')
return '{}:{}'.format(self.idp_slug, remote_id)
Donation.add_to_order(self.cart, self.COST) self.cart.start_purchase() self.cart.purchase()
if support_fraction is None: n_support = int(np.ceil(0.5 * (n_samples + n_features + 1))) else: n_support = int(support_fraction * n_samples)
self._verify_xblock_info_state(xblock_info, 'has_explicit_staff_lock', expected_state, path, should_equal)
self.workd[yslice] = self.OP(self.workd[xslice])
y_true, _, probas_pred = make_prediction(binary=False)
extra = kwargs.get('extra', {})
xpath = "//div[@class='indicator-container']/span" self.assert_no_xpath(xml, xpath, self.context)
preds2 = np.zeros_like(y) for train, test in cv: est.fit(X[train], y[train]) preds2[test] = est.predict(X[test])
return self.q(css=self._discussion_selector + " " + selector)
module = CapaFactory.create(done=False)
ApiAccessConfig(enabled=False).save() response = self.client.get(self.url) self.assertEqual(response.status_code, 404)
return {ModuleStoreEnum.Type.split: self.db_connection.heartbeat()}
Z = Z.reshape(xx.shape) plt.figure() plt.pcolormesh(xx, yy, Z, cmap=cmap_light)
return student.views.index(request)
ret = line_search_wolfe2(f, fprime, xk, pk, gfk, old_fval, old_old_fval, **kwargs)
block_locator = self._map_revision_to_branch(block_locator) return super(DraftVersioningModuleStore, self).get_block_generations(block_locator)
for child in children_map[block_to_remove]: if pruned_parents_map[child]: continue for block in traverse_post_order(child, get_children=lambda block: pruned_children_map[block]): missing_blocks.append(block) pruned_children_map[block] = []
return [s.earned for s in self.get_grade_summary()['totaled_scores']['Homework']]
self.video.wait_for_position('0:05') self.video.click_player_button('do_not_show_again')
self.assertEquals(preview.latex_preview('1.618k'), r'1.618\text{k}')
discrete_estimator_errors = bdt_discrete.estimator_errors_[:n_trees_discrete] real_estimator_errors = bdt_real.estimator_errors_[:n_trees_real] discrete_estimator_weights = bdt_discrete.estimator_weights_[:n_trees_discrete]
self.__init__(**state)
self.assert_navigation_state('Test Section 1', 'Test Subsection 1,1', 0, next_enabled=True, prev_enabled=False)
ensemble.set_params(n_jobs=1) y1 = ensemble.predict_proba(X_test) ensemble.set_params(n_jobs=2) y2 = ensemble.predict_proba(X_test) assert_array_almost_equal(y1, y2)
raise NotImplementedError()
self.youtube_configuration.update({ 'time_to_response': 2.0, 'youtube_api_blocked': True, })
LOGGER.debug("Flushing the test database...") call_command('flush', interactive=False, verbosity=0) world.absorb({}, 'scenario_dict')
component = self.store.publish(xblock.location, self.user_id) self.assertFalse(self.store.has_changes(component))
self._params = []
cls.url = reverse('instructor_dashboard', kwargs={'course_id': cls.course_key.to_deprecated_string()}) cls.email_link = '<a href="" data-section="send_email">Email</a>'
resp = self.client.get_html( get_url(handler, course_key, 'course_key_string') ) self.assertEqual(resp.status_code, 200)
return self.q(css='#dashboard-search-results')
self.assertEqual( self.safe_cookie_data._compute_digest(self.user_id), self.safe_cookie_data._compute_digest(self.user_id), )
self.assertFalse(self.cohort_management_page.is_category_selected())
if self.source in self.html5_sources:
resp = self.client.get(url, HTTP_HOST=settings.MICROSITE_TEST_HOSTNAME) self.assertContains(resp, settings.MICROSITE_CONFIGURATION['test_microsite']['email_from_address'])
params = { 'photo_id_image': self.IMAGE_DATA } response = self._submit_photos(expected_status_code=400, **params) self.assertEqual(response.content, "Missing required parameter face_image")
return render_message_to_string( self.subject_template, self.message_template, self.get_email_params(), language=language )
item = self.store.get_item(item_location) html = item.visibility_view().body_html() for string in substrings: self.assertIn(string, html)
trainer = yaml_parse.load(convert_to_one_hot_yaml % {'filename': filename}) trainer.main_loop()
sorted_idx = np.argsort(predictions, axis=1)
if BulkEmailFlag.feature_enabled(course_key): sections.append(_section_send_email(course, access))
object_results = map(ordered_objects, search_queryset_pks) paged_results.object_list = object_results
status = VerificationStatus.get_user_status_at_checkpoint( self.user, self.course_key, self.reverification_location ) self.assertEqual(status, "submitted")
self.initdb(default_ms) self._create_block_hierarchy() with self.assertRaises(InvalidVersionError): self.store.revert_to_published(self.vertical_x1a, self.user_id)
'SHOW_BUMPER_PERIODICITY': 7 * 24 * 3600,
weights = np.sum(y_true_binarize, axis=0, dtype=int)
self.X_min_, self.X_max_ = np.min(X), np.max(X)
scores = cval.cross_val_score(clf, X_sparse, X) assert_array_equal(scores, clf.score(X_sparse, X))
pca = PCA(n_components=2, whiten=True, svd_solver=solver) pca.fit(X) ll2 = pca.score(X) assert_true(ll1 > ll2)
y_pred, y_pred_std = gpr.predict(X2, return_std=True) y_pred = y_mean + y_pred y_pred_norm, y_pred_std_norm = gpr_norm.predict(X2, return_std=True)
cert = GeneratedCertificate.eligible_certificates.get(user=user, course_id=course_key) self.assertEqual(cert.status, expected_status)
Y = Y.astype(np.float64) if sample_weight is not None: sample_weight = np.atleast_2d(sample_weight) Y *= check_array(sample_weight).T
return self._get_sampling_pos(model, X, Y), OrderedDict()
os.chdir(cwd)
response = self.client.get('/home') self.assertEqual(response.status_code, 200) self.assert_no_xss(response, escaping_content)
estimator_weight = self.learning_rate * ( np.log((1. - estimator_error) / estimator_error) + np.log(n_classes - 1.))
for block_key in block_structure.topological_traversal(): assert ( block_structure.get_transformer_block_field( block_key, cls, data_key, ) == cls._create_block_value(block_key, data_key) )
assert_true(init_param.default is None) continue
try: role_name = cls.ROLE REGISTERED_ACCESS_ROLES[role_name] = cls except AttributeError: log.exception(u"Unable to register Access Role with attribute 'ROLE'.") return cls
GRADES_DOWNLOAD_ROUTING_KEY = HIGH_MEM_QUEUE
super(TestPublishOverExportImport, self).setUp() self.user_id = ModuleStoreEnum.UserID.test self.export_dir = mkdtemp() self.addCleanup(rmtree, self.export_dir, ignore_errors=True)
self._iterating = False
re.compile(r'^/embargo/blocked-message/'),
varname = tokens[0][0] self.variables_used.add(varname)
with transaction.atomic(): return wrapped_func(*args, **kwargs)
if user_found_by_email_lookup and LoginFailures.is_feature_enabled(): LoginFailures.increment_lockout_counter(user_found_by_email_lookup)
minibatch_iterators = iter_minibatches(data_stream, minibatch_size) total_vect_time = 0.0
return ( 'name', 'enabled', 'backend_name', 'secondary', 'skip_registration_form', 'skip_email_verification', 'change_date', 'changed_by', 'edit_link', )
solution_element = rendered_html.find("div") self.assertEqual(solution_element.text, 'Input Template Render')
return self._tags[course_id].get(key)
super(TestSplitTestVert, self).setUp()
certs_in_queue = [call_args[0] for (call_args, __) in mock_queue.call_args_list] self.assertEqual(len(certs_in_queue), expected_num) for cert in certs_in_queue: self.assertTrue(isinstance(cert, ExampleCertificate))
problem = self.build_problem(sample_dict=sample_dict, num_samples=10, tolerance=0.01, answer="x+2*y")
choices = self.xml.xpath('choicegroup/choice') return [choice.get("name") for choice in choices]
CONTENT_GROUP_CONFIGURATION_DESCRIPTION = 'The groups in this configuration can be mapped to cohort groups in the LMS.'
y_pred = self._fit_stage(i, X, y, y_pred, sample_weight, sample_mask, random_state, X_idx_sorted, X_csc, X_csr)
__, __ = self.log_in_as_instructor()
return user[0].state
session = requests.Session() response = session.get(STUDIO_BASE_URL + "/auto_auth?staff=true")
callback = self.get_params['callback']
X = check_array(X, accept_sparse='csr') check_non_negative(X, whom) return X
for mode in ('audit', 'honor'): CourseModeFactory.create(mode_slug=mode, course_id=self.course.id)
return page_title_breadcrumbs(*args)
return AUTHOR_VIEW if has_author_view(block) else STUDENT_VIEW
return self.q(css='.CodeMirror-scroll').present
select_option_by_value( browser_query=self.settings_detail.pre_requisite_course_options, value=pre_requisite_course_id ) self.settings_detail.save_changes() self.assertEqual( 'Your changes have been saved.', self.settings_detail.alert_confirmation_title.text )
return column_or_1d(y, warn=True)
plt.xlim(0, 100) plt.legend(loc='best') plt.title('Feature selection scores - Mutual incoherence: %.1f' % mi)
theta0, thetaL, thetaU = self.theta0, self.thetaL, self.thetaU corr = self.corr verbose = self.verbose
raise SkipTest
assert_true(np.min(X.data) > 0) assert_true(np.max(X.data) < 1)
self.course.tabs = self.all_valid_tab_list
original_values_map = self.get_settings_fields_of_each_type() self.set_wrong_inputs_to_fields() self.advanced_settings.wait_for_modal_load()
self.assertEqual(problem.context['expect'], '42')
if page_refresh: self.browser.refresh() return self.q(css='{} .section-name'.format(parent_css)).text
CourseEnrollmentFactory(user=self.student, course_id=self.course.id)
clf = GradientBoostingClassifier(n_estimators=10, random_state=1)
self.split_test_module.user_partition_id = 0
url_user_invoice_preference = reverse('get_user_invoice_preference', kwargs={'course_id': self.course.id.to_deprecated_string()})
self.assert_no_setting_changed_event()
errorlog = make_error_tracker() course_descriptor = None try: course_descriptor = self.load_course(course_dir, course_ids, errorlog.tracker, target_course_id)
resp = self._get_preview(usage_key, data) self.assertEqual(resp.status_code, expected_code) if content_contains: self.assertIn(content_contains, resp.content) return resp
self.root_path = root_path if not os.path.exists(root_path): os.makedirs(root_path)
return getattr(course, 'enable_ccx', False)
X_new = assert_warns( DeprecationWarning, est.transform, X, threshold="mean") assert_less(0 < X_new.shape[1], X.shape[1])
assert_raises(ValueError, chi2_kernel, [[0, 1]], [[.2, .2, .6]])
self.assertEqual(fetched.discussion_id, discussion_item.discussion_id) self.assertEqual(fetched.discussion_id, refetched.discussion_id)
tasks = instructor_task.api.get_running_instructor_tasks(course_id)
self.profile.level_of_education = level_of_education self.profile.save()
y = 0.5 * X.ravel() + rng.randn(n_samples, 1).ravel()
return None
pass
from urllib2 import Request, build_opener
if len(results.violations) != len(rules): for violation in results.violations: print("Found violation: {}".format(violation.rule))
self.draft_store.delete_course(course.id, self.dummy_user)
pass
self.assertTrue(allowance_section.is_allowance_record_visible)
return
if not item_index_dictionary and not item.has_children: return
#html_title = None
CourseUpdateDesc = namedtuple("CourseUpdateDesc", ['date', 'content'])
dtype_orig = None
def obj_func(theta, eval_gradient=True): if eval_gradient: lml, grad = self.log_marginal_likelihood( theta, eval_gradient=True) return -lml, -grad else: return -self.log_marginal_likelihood(theta)
safe_exec("rnums = [random.randint(0, 999) for _ in xrange(100)]", g) self.assertNotEqual(g['rnums'], rnums)
clf3 = MultinomialNB() clf3.partial_fit(X, y2, classes=np.unique(y2))
alpha_grid, scores_path = lasso_stability_path(X, y, random_state=42, eps=0.05)
from __future__ import unicode_literals
EXPORTED_ASSET_FILENAME = 'assets.xml'
plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds) plt.colorbar(format='%.2f')
return self.q( css=self._bounded_selector("#cohort-management-group-add-students") ).results[0].get_attribute("value")
prefix = self.idp_slug + ":" return self.backend_name == social_auth.provider and social_auth.uid.startswith(prefix)
lim = 8
generate_cython()
coef = coef.ravel()
X, y = iris.data, iris.target y[y == 2] = 1
date = get_date(ccx, node=parent_node, date_type=date_type)
LogoutPage(self.browser).visit() self._auto_auth("STAFF_TESTER", "staff101@example.com", True) self.course_outline.visit()
for (key, value) in problemtree.items(): tree.set(key, value)
self.assertTrue(self.video.is_video_rendered('youtube'))
rng = np.random.RandomState(42) all_data, _ = make_blobs(n_samples=n_samples_max + n_queries, n_features=n_features, centers=n_centers, shuffle=True, random_state=0) queries = all_data[:n_queries] index_data = all_data[n_queries:]
clf = svm.LinearSVC(verbose=1) clf.fit(X, Y)
problem = self.build_problem( choice_type='checkbox', choices=[False, False, True, True], credit_type='halves' )
return self.q(css=self._bounded_selector('.action-delete:not(.is-disabled) .remove-user')).present
attempts = random.randint(1, 10) module = CapaFactory.create(attempts=attempts, max_attempts=attempts, force_save_button="true", done=True) self.assertFalse(module.should_show_save_button())
'ENABLE_TEAMS': True,
break
BROKER_POOL_LIMIT = 0 BROKER_CONNECTION_TIMEOUT = 1
return _get_backing_memmap(a) is not None
if user_enrollment_mode not in CourseMode.VERIFIED_MODES: return 'N/A' user_is_verified = cls.user_is_verified(user) if not user_is_verified: return 'Not ID Verified' else: return 'ID Verified'
if self.per_second: seconds = channels['training_seconds_this_epoch'].val_record seconds = np.array(seconds) seconds = seconds.cumsum() x = seconds[x]
for parent in parents: self._block_relations[parent].children.remove(usage_key)
cert = GeneratedCertificate.eligible_certificates.get(user=self.student, course_id=self.course.id) self.assertEqual(cert.status, CertificateStatuses.downloadable)
birch_models = [Birch(threshold=1.7, n_clusters=None), Birch(threshold=1.7, n_clusters=100)] final_step = ['without global clustering', 'with global clustering']
return _delete_entrance_exam(request=request, course_key=course_key)
return self.q(css='.page-content-secondary .team-country :last-child').text[0]
answered_survey = SurveyAnswer.do_survey_answers_exist(survey, user) return not answered_survey and not has_staff_access
'mode': 'r+' if memmap.mode in ('r+', 'w+') else 'r'}
self.go_to_tab_and_assert_problem(2, self.problem2_name)
self.verify_expected_team_id(new_teams[0], 'the-best-team') self.verify_expected_team_id(new_teams[1], 'the-best-team') self.assertNotEqual(new_teams[0]['id'], new_teams[1]['id'])
beta1 = sqrt_inner_product(bs)
for parent_desc_list in parents_descendants_list: if parent_desc_list is not None: parent_desc_list.items.append(unicode(block_key))
children = self.q(css='.note-group') return [EdxNotesChapterGroup(self.browser, child.get_attribute("id")) for child in children]
return library.location.library_key
_make_archive_copy(instance)
user = User() user.save() DarkLangConfig( released_languages=languages, changed_by=user, enabled=True ).save()
self.create_cohorted_discussions()
self.assertEqual(len(details['course_modes']), 3) self.assertEqual(details, cached_details)
self.page.visit()
rng = np.random.RandomState(0) n_samples, n_features = 500, 2
assert_raises(ValueError, sample_without_replacement, -1, 5) assert_raises(ValueError, sample_without_replacement, 5, -1)
for name in SPARSE_TREES: yield check_min_weight_fraction_leaf, name, "multilabel", True
X, y = check_X_y(X, y, accept_sparse=("csr", "csc"), multi_output=True, y_numeric=True)
boston = load_boston() perm = rng.permutation(boston.target.size) boston.data = boston.data[perm] boston.target = boston.target[perm]
'origin': 'git@github.com:MITx/content-mit-6002x.git',
return self._tax_deduction_msg()
subs = ''
grade_summary['raw_scores'] = raw_scores
config_course_cohorts_legacy(self.course, [], cohorted=True, auto_cohort_groups=["AutoGroup"])
response = self.send_get(client) self.assertEqual("m", response.data["gender"])
if not organizations_enabled(): return [] from organizations import api as organizations_api return organizations_api.get_organization_courses(organization_id)
self.assertTrue(access.has_ccx_coach_role(self.coach, ccx_locator))
microsite.set_by_domain(self.microsite.site.domain) self.assertTrue(microsite.is_request_in_microsite())
request = self.request_factory.get(reverse('about_course', args=[unicode(ccx_locator)])) request.user = student mako_middleware_process_request(request)
if openid_request.mode == 'checkid_immediate': return provider_respond(server, openid_request, openid_request.answer(False), {})
L = np.zeros((max_features, max_features), dtype=Gram.dtype)
LogoutPage(self.browser).visit() AutoAuthPage(self.browser, course_id=self.course_id, staff=True).visit()
self.store.publish(self.vertical.location, self.user.id) draft_container = self.store.get_item(draft_container.location) test_container_html(draft_container)
module.save()
conditions_map = {
course_key, _ = strip_ccx(course_key) return self._modulestore.check_supports(course_key, method)
selector = self.get_element_selector(CSS_CLASS_NAMES['video_spinner']) return self.q(css=selector).visible
if course_id: return cls.objects.filter(user=user, badge_class__course_id=course_id) return cls.objects.filter(user=user)
raise NotImplementedError()
fs_root = mkdtemp()
for enabled in cls._enabled_providers(): if enabled.is_active_for_pipeline(running_pipeline): return enabled
sample_weight = sample_weight / sample_weight.sum(dtype=np.float64)
np.testing.assert_array_equal(grad_x.data[grad_x.data > 0], grad_y.data[grad_y.data > 0])
name = self.cleaned_data.get("name").strip() or None
content = '<garbage tag No closing brace to force <span>error</span>' payload = {'content': content, 'date': 'January 11, 2013'}
X = X.reshape(-1, 2 * numpy.prod(self.original_image_shape))
return '{tabpanel_id} {css}'.format(tabpanel_id=getattr(self, 'tabpanel_id', ''), css=css)
self.assertEqual(requirements[2]["name"], first_block.get_credit_requirement_name()) self.assertEqual(requirements[3]["name"], second_block.get_credit_requirement_name())
return any(self._value_matches(target, test_val) for test_val in criteria['$in'])
self.verify_end_date("edX/test_end/2012_Fall", "Sep 17, 2015")
SECRET_KEY = '85920908f28904ed733fe576320db18cabd7b6cd'
LOGGER.info('Retrying task to award failed certificates to user %s', username) raise self.retry(countdown=countdown, max_retries=config.max_retries)
if sparse: decay = .01
mgmt_command = -1
certificate.course_title = course_title_override
valid_input, field_errors = get_valid_input(request.data) if field_errors: return Response( status=status.HTTP_400_BAD_REQUEST, data={ 'field_errors': field_errors } )
return etree.Element(self.tag)
return self.MODE_TO_CERT_NAME.get( cert_mode, _(u"{platform_name} Certificate for {course_name}") ).format( platform_name=microsite.get_value('platform_name', settings.PLATFORM_NAME), course_name=course_name )
self.modulestore.cache_items(self, [block_key], course_key, lazy=self.lazy) json_data = self.module_data.get(block_key) if json_data is None: raise ItemNotFoundError(block_key)
notification_msg = MIMEMultipart('related') msg_alternative = MIMEMultipart('alternative') notification_msg.attach(msg_alternative) subject = _(u'Course Credit Eligibility')
link = CourseUserGroupPartitionGroup( course_user_group=cohort, partition_id=partition_id, group_id=group_id, ) link.save() return link
from matplotlib.finance import quotes_historical_yahoo as quotes_historical_yahoo_ochl
sh(cmd( "touch", 'lms/urls.py', 'cms/urls.py', ))
CourseEnrollmentFactory( course_id=self.course.id, user=self.user, mode="verified" )
self._navigate_to_courseware_video() self.video.wait_for_video_player_render()
has_children = True field1 = String(default="something", scope=Scope.user_state) field2 = Integer(scope=Scope.user_state)
action_name = ugettext_noop('generated') task_fn = partial(upload_course_survey_report, xmodule_instance_args) return run_main_task(entry_id, task_fn, action_name)
U, V = svd_flip(U, V, u_based_decision=False)
LOGGER.info(u"Output file: {file_path}".format(file_path=file_path))
disturb_mem.disturb_mem() rng = np.random.RandomState([2012, 11, 27, 8])
#epub_uid = ''
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
from pickle import Pickler
self.assertIsNone( certs_api.get_certificate_for_user(self.student_no_cert.username, self.course_1.id) )
grid_search.score(X, y) grid_search.predict_proba(X) grid_search.decision_function(X) grid_search.transform(X)
return self.q(css='{}[data-id="{}"]'.format(self.BODY_SELECTOR, self.locator)).present
test_container_html(draft_container)
DarkLangConfig( released_languages=('es, en'), changed_by=self.user, enabled=True ).save()
store = self._verify_modulestore_support(xblock.location.course_key, 'has_changes') return store.has_changes(xblock)
return tensor.dot(inputs[1], self.wyf)
raise NotImplementedError
IN_PROGRESS = "in_progress" FAILED = "failed" SUCCEEDED = "succeeded"
X, y = make_classification(n_samples=200, n_features=100, n_informative=3, random_state=0)
tree = etree.Element(problemtree.tag) for item in problemtree: item_xhtml = self._extract_html(item) if item_xhtml is not None: tree.append(item_xhtml)
reg = RidgeClassifier(class_weight='balanced') reg.fit(X, y) assert_array_equal(reg.predict([[0.2, -1.0]]), np.array([1]))
api.set_credit_requirement_status(username, self.course_key, "grade", "grade", status="failed") self.assert_grade_requirement_status('failed', 0)
return self.oauth2_adapter.create_confidential_client( name='Test Confidential Client', user=user, client_id=client_id, redirect_uri=DUMMY_REDIRECT_URL, )
return self.def_ms.get_courses()
state = self.sample_fn(bp1, state)
return xblock._edit_info.get('published_date')
self.lc_block.max_count = 1 self.lc_block.capa_type = 'customresponse' self.lc_block.refresh_children() result = self.lc_block.validate()
self.assertFalse(form.is_valid())
assert_array_almost_equal(coef_dense, coef_sorted.toarray())
records = LoginFailures.objects.filter(user=user).order_by('-lockout_until') for extra_record in records[1:]: extra_record.delete() return records.get()
xblock = modulestore().get_item(location) xblock.display_name = display_name self.store.update_item(xblock, self.user.id)
for i in xrange(k): dists[:, i] = numpy.square((X - mu[i, :])).sum(axis=1)
state = np.random.RandomState(0) X = state.rand(10, 10) kpca = KernelPCA(random_state=state).fit(X) transformed1 = kpca.transform(X)
for (country, rule_type) in country_rules: self.assertIn( { 'country': country, 'rule_type': rule_type }, snapshot['country_rules'] )
for n_labels in range(2, 10): y_score = n_labels - (np.arange(n_labels).reshape((1, n_labels)) + 1)
raise NotImplementedError(str(type(self)) + " does not implement continue_learning.")
self.assertEquals(2, len(response_results)) self.assertEquals(True, response_max_exceeded)
for block in blocks: for field in fields: self.assertIsNone(block_structure.get_xblock_field(block.location, field))
context['duplicate_provider'] = pipeline.get_duplicate_provider(messages.get_messages(request))
try: import numpy as np except ImportError: np = None self.np = np
return sum([self.counters[key] for key in self.messages if key.startswith(prefix)])
(13, True, False, u"False"),
'CERTIFICATES_INSTRUCTOR_GENERATION': False,
self.assertEqual(len(httpretty.httpretty.latest_requests), 3)
image_url = microsite.get_value('logo_image_url') if image_url: return '{static_url}{image_url}'.format( static_url=settings.STATIC_URL, image_url=image_url )
response = render_to_response(path, context) response.mako_context = context response.mako_template = path return response
CourseEnrollmentFactory( is_active=False, mode=CourseMode.NO_ID_PROFESSIONAL_MODE, course_id=self.course.id, user=self.user )
self._source = source self._name = name
if self.status in ['correct', 'incorrect', 'partially-correct']: return False else: return True
return Response({'handouts_html': None})
linter = PythonLinter() results = FileResults('') linter.check_python_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
cost = SumOfCosts([SumOfOneHalfParamsSquared(), (0., DummyCost())]) model = DummyModel(shapes, lr_scalers=scales) dataset = ArangeDataset(1) decay = 0.95
self.assert_redirect_to_dashboard_looks_correct(actions.do_complete(
super(SplitMongoModuleStore, self)._drop_database(database, collections, connections)
raise NotImplementedError
X_filtered = np.vstack((X[y == 0][:500], X[y == 1][:100], X[y == 2][:10])) y_pred = KMeans(n_clusters=3, random_state=random_state).fit_predict(X_filtered)
#~ asList = False
X_dense[3, :] = 0.0
first_addend = random.randint(-100, 100) second_addend = 10 - first_addend
feature_names = [feature_names[i] for i in ch2.get_support(indices=True)]
self.assertEqual(response.status_code, expected_status) parsed_content = json.loads(response.content) self.assertEqual(parsed_content, expected_content)
skip_if_no_sklearn() trainer = yaml_parse.load(test_yaml) trainer.main_loop()
context_fields_to_remove = set(CONTEXT_FIELDS_TO_INCLUDE) context_fields_to_remove.add('client_id') for field in context_fields_to_remove: if field in context: del context[field]
files = request.FILES or {} error_msg = _check_files_limits(files) if error_msg: return JsonResponse({'success': error_msg}, status=413)
problem_specified = self.build_problem(answer="Second", case_sensitive=True)
y = rng.randn(n_samples) r.fit(x, y) assert_equal(r.cv_values_.shape, (n_samples, n_alphas))
default_axes = ('b', 0, 1, 'c')
AutoAuthPage(self.browser, course_id=self.course_id).visit() self._link_dummy_account() LogoutPage(self.browser).visit()
config.toggle()
plt.plot(xx, yy, 'k-') plt.plot(xx, yy_down, 'k--') plt.plot(xx, yy_up, 'k--')
self.registration = Registration() self.registration.register(self.user) self.registration.save()
def get_xml_editable_fields(self, field_data): runtime = get_test_descriptor_system() return runtime.construct_xblock_from_class( XmlDescriptor, scope_ids=Mock(), field_data=field_data, ).editable_metadata_fields
dataset = datasets.load_iris()
staff_user = User.objects.create_user('test_staff_user', 'test_staff_user@openedx.org', 'test') CourseStaffRole(self.master_course_key).add_users(staff_user)
def_ms = modulestore() course = def_ms.get_course(SlashSeparatedCourseKey('MITx', 'edx4edx', 'edx4edx')) CourseStaffRole(course.id).add_users(self.user)
return (self.small_width, self.small_height)
if valid_size < 1.0: valid_size /= 1.0 - np.true_divide(self.n_test, self.n) self.valid_size = valid_size
gmm.fit(X)
if os.path.isfile('dbm.pkl'): os.remove('dbm.pkl') control.pop_load_data()
v3.set_params(strip_accents='_gabbledegook_', preprocessor=None) assert_raises(ValueError, v3.build_preprocessor)
for key, val in params.iteritems(): self.assertEqual(self.server.config.get(key), val)
pos = logical_line.find('.has_key(') if pos > -1 and not noqa: yield pos, "W601 .has_key() is deprecated, use 'in'"
)
created_time = models.DateTimeField(auto_now_add=True)
scal_points = new_W / norms.dimshuffle('x',0)
raise
yield
if dataset in ["digits", "boston"]: n_samples = X.shape[0] // 5 X = X[:n_samples] X_sparse = X_sparse[:n_samples] y = y[:n_samples]
if 'default' in settings.MICROSITE_CONFIGURATION: self._set_microsite_config('default', subdomain, domain) return
self.set_team_configuration(None) self.verify_teams_present(False)
return BACKEND.has_override_value(val_name)
template_dir_name = None module_class = StaticTabModule
assert_equals(expected, deserialize_field(self.test_field(), arg))
result = self.get_team_detail(self.solar_team.team_id, 200, {'expand': 'user'}) self.verify_expanded_private_user(result['membership'][0]['user'])
initialize_permissions(destination_course_key, User.objects.get(id=user_id))
return _makeTags( tagStr, False )
if 'axes' not in d: d['axes'] = ['b', 0, 1, 'c'] self.__dict__.update(d)
self._enroll(course.id, "verified")
ss = cval.ShuffleSplit(10, random_state=21) assert_array_equal(list(a for a, b in ss), list(a for a, b in ss))
dictionary = dict(mako_context) return loader.render_to_string(file_name, dictionary=dictionary)
for section in self.chapter.get_children(): section.visible_to_staff_only = True self.store.update_item(section, ModuleStoreEnum.UserID.test)
return datetime.fromtimestamp(os.path.getmtime(self.path(name)))
self.track_selection_page.enroll('verified')
response = self._get_page(payment_flow, course.id, expected_status_code=302) self.assertRedirects(response, redirect_url)
def _logcosh(x, fun_args=None):
self.save() response = perform_request( 'get', url, retrieve_params, metric_action='model.retrieve', metric_tags=self._metric_tags, )
response = self.client.get(reverse("dashboard")) self.assertHttpOK(response)
filter_selected_events = lambda event: event.get('name', '') == 'edx.ui.lms.outline.selected' selected_events = self.wait_for_events(event_filter=filter_selected_events, timeout=2)
self.assert_grade(problem, 'choice_foil_4', 'incorrect') self.assert_grade(problem, 'not_a_choice', 'incorrect')
self.assertEqual(1, 1)
self.assertEqual(correct_map.get_overall_message(), "Overall message")
masked_terminal_regions = terminal_regions.copy() masked_terminal_regions[~sample_mask] = -1
verticals = self.store.get_items(course_id, qualifiers={'category': 'vertical'})
gating_api.add_prerequisite(self.course.id, self.seq1.location)
original = Microsite.objects.get(id=instance.id) _make_archive_copy(original)
user = User.objects.get(email=self.enrolled_student.email) self.assertFalse(CourseEnrollment.is_enrolled(user, self.course.id))
staff_lock = self._create_xblock_with_start_date( name + "_locked", start_date, publish, visible_to_staff_only=True ) self.assertFalse(utils.is_currently_visible_to_students(staff_lock))
VerificationDeadline.set_deadline(self.course.id, self.VERIFICATION_DEADLINE)
with self.assert_no_error_logged(): with self.assert_no_warning_logged(): yield
has_access.return_value = True response = views.all_problem_grade_distribution(self.request, 'test/test/test') self.assertEqual(json.dumps(self.simple_data), response.content)
pca = PCA(n_components=8).fit(data_train)
min_samples = X.shape[1] + 1
self.status = 'paying' self.save()
EmptyPromise( lambda: self.find_css('.actions .delete.action-icon').present, 'Certificate delete button is displayed' ).fulfill()
sample_weight = np.ones(y.shape) sample_weight[y == 1] *= 100
def test_lle_init_parameters(): X = np.random.rand(5, 3)
for train, test in kfold.split(X, y): est.fit(X[train], y[train]) expected_predictions[test] = func(X[test])
try: log.info("Course import %s: Upload complete", courselike_key) _save_request_status(request, courselike_string, 1)
pass
js_url = urljoin(self.public_service_url, self.authoring_app_js_path) css_url = urljoin(self.public_service_url, self.authoring_app_css_path) return AuthoringAppConfig(js_url=js_url, css_url=css_url)
assert len(corruptors) >= 1 self._corruptors = corruptors
return self.q(css='button.action-linkedin-profile')
monitoring_dataset = DenseDesignMatrix(X=X)
is_eligible = api.is_user_eligible_for_credit("staff", credit_course.course_key) self.assertFalse(is_eligible)
y = f(X).ravel()
n_labels = 15 n_samples = 1000 n_folds = 5
test_user = UserFactory() GeneratedCertificateFactory.create( user=test_user, course_id=course_id, mode=mode, status=status )
idx = 0 start_idx = end_idx for rd in rings: start_idx = restore_ring(img, idx, rd, dense_input, start_idx) idx += rd
self.course_outline.change_problem_release_date()
if course_data.get('name'):
self.dashboard_page.visit()
'organizations',
first_group = self.user_partition.groups[0] self.user_partition.scheme.current_group = first_group
assert_equal(len(folds), len(labels)) for i in np.unique(folds): assert_greater_equal(tolerance, abs(sum(folds == i) - ideal_n_labels_per_fold))
number_suffix = MatchFirst(Literal(k) for k in SUFFIXES.keys())
return traverse_post_order( start_node=self.root_block_usage_key, get_children=self.get_children, filter_func=filter_func, )
self.assertEqual(CourseEnrollment.objects.count(), 1) enrollment = CourseEnrollment.objects.get(course_id=course_key) self.assertEqual(enrollment.user.username, "test")
eigvals, eigvec = eigsh(XH_X, k=k, tol=tol ** 2, maxiter=maxiter, ncv=ncv, which=which, v0=v0)
scaler.fit_transform(X_2d)
with open(filename, "w") as metric_file: metric_file.write(str(metric))
@patch('xmodule.html_module.HtmlDescriptor.definition_to_xml') def test_export_import_round_trip(self, def_to_xml): def_to_xml.return_value = lxml.etree.Element('html')
def __call__(self, event): context = event.get('context', {}) course_id = context.get('course_id')
self.assertNotContains(response, "How it Works") self.assertNotContains(response, "Find courses") self.assertNotContains(response, "Schools & Partners")
alternate_course = self.create_course( org=md5(self.course.org).hexdigest() )
if not self._is_masquerading_as_student(): raise Http404('No {block_type} found with name {url_name}'.format( block_type=block_type, url_name=url_name, ))
self._make_eligible() self._purchase_credit() CourseEnrollmentAttribute.objects.all().delete()
num_drafts = self._get_draft_counts(self.course) self.assertEqual(num_drafts, 0)
proba = all_proba[0]
return self.q(css='.form-actions .action-edit-team').present
for _ in range(2): self.assertIsInstance(CourseOverview.get_from_id(course.id), CourseOverview)
self.choose_new_seed()
super(SupportViewIndexTests, self).setUp() SupportStaffRole().add_users(self.user)
for i, (X_train_text, y_train) in enumerate(minibatch_iterators):
username = data['username'] if request.user.username != username: return HttpResponseForbidden()
etree.fromstring(etree.tostring(root), self.xmlparser)
self.assertIn(self.user_name, self.certificates_section.last_certificate_exception.text) self.assertIn(notes, self.certificates_section.last_certificate_exception.text)
content = json.dumps(data, cls=i4xEncoder) super(JsonResponse, self).__init__(content, content_type='application/json; charset=utf-8')
if code in self.expected: return if self.print_filename and not self.file_errors: print(self.filename) self.file_errors += 1 self.total_errors += 1 return code
high_reg_model = ElasticNet(alpha=final_alpha * 10).fit(X, y) assert_greater(low_reg_model.n_iter_, high_reg_model.n_iter_)
kernel = RBF(length_scale=1.0)
CertificateGenerationCourseSetting.objects.create( course_key=course_key, enabled=is_enabled )
pass
user = UserFactory.create(is_staff=True) self.assert_user_has_object_permission(user, True)
return JsonError(status=404)
_OSFS_INSTANCE = {}
estimator.set_params(n_components=1)
sparse_results = sparse_classifier.score(X_test_sparse, y_test) dense_results = dense_classifier.score(X_test, y_test) assert_array_equal(sparse_results, dense_results)
clf.fit(X, y) assert_raises(ValueError, clf.partial_fit, np.hstack((X, X)), y)
unicode_text = "好 各位同学".decode('utf-8') self.assertIn(unicode_text, self.video.captions_text)
if tol > 0.0 and ewa_diff <= tol: if verbose: print('Converged (small centers change) at iteration %d/%d' % (iteration_idx + 1, n_iter)) return True
score = self.decision_function(X) decisions = self.loss_._score_to_decision(score) return self.classes_.take(decisions, axis=0)
EDX_PLATFORM_REVISION = dealer.git.Backend(path=REPO_ROOT).revision
PRIVATE_REQS = 'requirements/private.txt' if os.path.exists(PRIVATE_REQS): PYTHON_REQ_FILES.append(PRIVATE_REQS)
all_modes, unexpired_modes = CourseMode.all_and_unexpired_modes_for_courses([course_key])
classes = np.unique(y) class_weight = compute_class_weight("balanced", classes, y) class_weight_dict = dict(zip(classes, class_weight)) return class_weight_dict
world.clear_courses()
return has_studio_write_access(user, course_key)
PAYMENT_STATUS_RESPONSE = "success"
data.update({'queuekey': header['lms_key']})
config_course_cohorts_legacy( course, discussions=[], cohorted=True, auto_cohort_groups=["AutoGroup"] )
clf = PassiveAggressiveClassifier(C=0.1, n_iter=100, class_weight={1: 0.001}, random_state=100) clf.fit(X2, y2)
return regenerate_certificates( self.create_task_request(self.instructor), self.course.id, [CertificateStatuses.downloadable, CertificateStatuses.generating] )
return self.page.paginator.num_pages
self.request.user = UserFactory.create(is_staff=True) self.assertTrue(self.permission.has_permission(self.request, None))
assert_equal(_dynamic_max_trials(100, 100, 2, 0.99), 1)
self.mock_programs_api() self.mock_credentials_api(self.user, reset_url=False) actual = get_programs_credentials(self.user, category='dummy_category') expected = self.expected_credentials_display_data()
transformers = {}
test_model = CourseMetadata.fetch(self.fullcourse) self.assertIn('edxnotes', test_model)
self._fit(X) return self
fragment = Fragment( self.system.render_template(self.mako_template, self.get_context()) ) shim_xmodule_js(self, fragment) return fragment
problem_name = own_metadata(child).get('display_name', '')
I_theory = (np.log(sigma_1) + np.log(sigma_2) - 0.5 * np.log(np.linalg.det(cov)))
spca_lasso = SparsePCA(n_components=3, method='cd', random_state=0, alpha=alpha) spca_lasso.fit(Y) assert_array_almost_equal(spca_lasso.components_, spca_lars.components_)
self.attempt_login(403, return_to="http://apps.cs50.edx.or")
if relevant_verification is not None and relevant_verification.status == "approved": recent_verification_datetime = max( recent_verification_datetime if recent_verification_datetime is not None else relevant_verification.expiration_datetime, relevant_verification.expiration_datetime )
authentication_classes = []
self.dashboard_page.visit()
request.POST = request.POST.copy()
self.check_modal_shows_correct_contents(['Course Display Name']) self.advanced_settings.refresh_and_wait_for_load()
return [ self.create_student( username='student_{}'.format(index), email='student_{}@example.com'.format(index) ) for index in xrange(number_of_students) ]
runtime = SubFactory(ContainerDescriptorRuntimeFactory) children = range(3)
clf = svm.SVC() assert_raises(ValueError, clf.fit, X, Y, sample_weight=range(len(X) - 1))
substring = [ "--with-xunitmp --xunitmp-file={}".format(self.xunit_report), "--processes={}".format(self.num_processes), "--no-color --process-timeout=1200" ]
GeneratedCertificate.eligible_certificates.all().delete()
if course_mode == 'verified': self.assertIn('xseries-base-btn', response.content) else: self.assertIn('xseries-border-btn', response.content)
rel_indent[row] = expand_indent(line) - indent_level
slug = hashlib.sha256(slug).hexdigest()
segment_context = full_segment_event.get('context')
from django.conf import settings
return self.attempts > 0
return next((tab for tab in tab_list if tab.tab_id == tab_id), None)
initial_element = etree.SubElement(codeparam_element, "initial_display") initial_element.text = str(initial_display)
patched_create_thumbnail.assert_called()
v, W = self._cov_eigen(X)
is_verified = cache_values.get(enrollment_cache_key) if is_verified is None: is_verified = CourseEnrollment.is_enrolled_as_verified(user, course_key) cache.set(enrollment_cache_key, is_verified)
start = TODAY().replace(tzinfo=pytz.UTC) override_field_for_ccx(ccx_course_object, master_course_object, 'start', start) override_field_for_ccx(ccx_course_object, master_course_object, 'due', None)
for i in range(current_page, 0, -1): _check_page() if current_page > 1: page.click_on_page(current_page - 1) current_page -= 1
u_flipped, _, v_flipped = randomized_svd(mat, 3, flip_sign=True) u_based, v_based = max_loading_is_positive(u_flipped, v_flipped) assert_true(u_based) assert_false(v_based)
MODULESTORE_FIELD_OVERRIDE_PROVIDERS = ()
self.configuration = kwargs.pop('configuration', None) if not self.configuration: self.configuration = settings.ACCOUNT_VISIBILITY_CONFIGURATION
return Fragment(self.FRAG_CONTENT)
user = create_user_and_user_profile(email, username, name, country, password)
resp = self.client.get(self.url, HTTP_ACCEPT='application/json') self.assertEquals(resp.status_code, 406)
assert_raises(ValueError, next, StratifiedShuffleSplit(3, 0.2).split(X, y))
return u'<div class="{0}">{1}{2}</div>'.format(style, label_wrap, hints_wrap)
self.wait_for_element_visibility(ccx_name_selector, 'CCX name field is visible') self.q(css=ccx_name_selector).fill(ccx_name)
self.client.logout() response = getattr(self.client, method)(self.path, content_type=JSON_CONTENT_TYPE) self.assertEqual(response.status_code, 401)
violations_count_str = "Number of pep8 violations: {count}".format(count=count) print violations_count_str print violations_list
API_DATADOG_SAMPLE_RATE = 0.1
epoch_num = 2
log_prob_of = (Y * log_prob).sum(axis=1) masked = log_prob_of * drop_mask_Y assert masked.ndim == 1
X_csc_scaled = scale(X_csr.tocsc(), with_mean=False) assert_array_almost_equal(X_scaled, X_csc_scaled.toarray())
for test_index in self._iter_test_indices(): test_mask = self._empty_mask() test_mask[test_index] = True yield test_mask
for page in self.pages: page.visit()
return None
phi_aj = phi(a_j) derphi_aj = derphi(a_j)
asset_key = course.id.make_asset_key('asset', course.course_image) content_store.find(asset_key)
self.assertEqual(cached_structure, not_cached_structure)
return self.get_input_space()
power = reduce(lambda a, b: b ** a, parse_result) return power
'msg': '', 'drag_and_drop_json': json.dumps(user_input)
X1 = np.array([[-2, ], [-1, ], [-1, ], [1, ], [1, ], [2, ]], dtype='f')
signatory = certificate.signatories[0] signatory.edit()
self.q(css=".contribution-option > input").first.click() self.q(css="input[name='verified_mode']").click()
response = client.delete(self.url) self.assertEqual(expected_status, response.status_code) return response
ms = MeanShift() assert_false(hasattr(ms, "cluster_centers_")) assert_false(hasattr(ms, "labels_"))
if answer_id in self.cmap: return self.cmap[answer_id]['correctness'] == 'partially-correct' return None
iterator = SequentialSubsetIterator(10, 3, 5)
return True
old_password_hash = user.password
self.assertEqual(first_request["parameters"]["course_num"], self.course_key.course) self.assertEqual(second_request["parameters"]["course_num"], other_course_key.course)
self._test_email_address_failures(SESLocalAddressCharacterError(554, "Email address contains a bad character"))
self.client.post(url, post_args)
for key, val in data.iteritems():
call_task('pavelib.quality.run_safelint', options={"thresholds": '{"rules": {"javascript-escape": 5}}'})
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
FIELD_BLACKLIST = ['last_activity_at', 'team_size']
y1 = np.array([[0, 1, 1], [1, 0, 1]]) y2 = np.array([[0, 0, 1], [1, 0, 1]])
past_due_date_correct = CapaFactory.create(showanswer='correct_or_past_due', max_attempts="1", attempts="0", due=self.yesterday_str, correct=True) self.assertTrue(past_due_date_correct.answer_available())
return ''
order = np.lexsort((y, x)) x, y = x[order], y[order]
return not isinstance(course_access.course_id, CCXLocator)
cm = metrics.confusion_matrix(y_test, y_predicted) print(cm)
lib_key = CourseKey.from_string(self._library_key) return unicode(lib_key.make_usage_key('library', 'library'))
self.assertNotContains(resp, 'Robot_Course_Outside_Microsite')
response, _ = self._login_response('test@edx.org', 'test_password') self._assert_response(response, success=True)
grid_search.score(X, y) grid_search.predict_proba(X) grid_search.decision_function(X) grid_search.transform(X)
return self.q(css=self._bounded_selector(".check-cohort-inline-discussions:checked"))
epilog += " http://edx.readthedocs.org/projects/edx-developer-guide/en/latest/conventions/safe_templates.html#safe-template-linter\n"
modified_cohort_name = "renamed random cohort" default_cohort.name = modified_cohort_name default_cohort.save()
course_outline.visit() subsection = course_outline.section_at(0).subsection_at(0) subsection.expand_subsection() subsection.add_unit()
self.field_handlers = {} for field_name in self.DEFAULT_FIELDS + self.EXTRA_FIELDS: handler = getattr(self, "_add_{field_name}_field".format(field_name=field_name)) self.field_handlers[field_name] = handler
'django.middleware.locale.LocaleMiddleware',
self.wait_for_ajax() closed_caption_state_selector = self.get_element_selector(CSS_CLASS_NAMES['closed_captions']) return self.q(css=closed_caption_state_selector).visible
self._auto_publish_no_children(item.location, item.location.category, user_id, **kwargs)
handler404 = 'static_template_view.views.render_404' handler500 = 'static_template_view.views.render_500'
readonly_fields = ('sender',)
instructor = UserFactory.create(password="test") role = CourseInstructorRole(self.course.id) role.add_users(instructor) return instructor
key1 = user_state_key('field_a') key2 = user_state_key('field_b') new_value = 'new value' newer_value = 'newer value' return {key1: new_value, key2: newer_value}
for scaling in [2, 0.3]: assert_almost_equal( weighted_score, metric(y1, y2, sample_weight=sample_weight * scaling), err_msg="%s sample_weight is not invariant " "under scaling" % name)
newpath = (next_usage, path) queue.append((parent, newpath))
os.remove(filename)
form = CourseEmailTemplateForm(form_data) self.assertFalse(form.is_valid())
return (url_name is not None and url_name.startswith(tag) and re.search('[0-9a-fA-F]{12}$', url_name))
else: msg = _(u"Error: {msg}").format(msg=inst.message)
self.assertEqual(new_mixed_setting["default"]["ENGINE"], "xmodule.modulestore.mixed.MixedModuleStore")
termination_criterion = EpochCounter(5)
'RESTRICT_ENROLL_BY_REG_METHOD': False,
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit() attempt.approve()
self.q(css="select#allowance_type").present or self.q(css="label#timed_exam_allowance_type").present
return unicode(data)
return '__file__' in globals()
from sklearn.externals.six.moves import cStringIO as StringIO import sys
answer_given = submission[0]
PARENTAL_CONSENT_AGE_LIMIT = 13
assert_raises(ValueError, clf.partial_fit, X2[:, :-1], y2)
raised = False try: fmt.format(numpy.zeros(10, dtype='float64')) except TypeError: raised = True assert raised
RANDOM_SEED = np.random.randint(2 ** 10)
for ind, merged_parent in enumerate(merged_parents_list): converted_object = _MergedGroupAccess([], block, []) converted_object._access = merged_parent merged_parents_list[ind] = converted_object
self._auto_auth(self.cohort_default_student_username, self.cohort_default_student_email, False) self.courseware_search_page.visit()
else: raise ValueError("unrecognized mode '%s'" % mode)
self.q(css=self.PAGE_NUMBER_INPUT_CSS).results[0].send_keys(unicode(page_number), Keys.ENTER) self.wait_for_ajax()
self.assert_correct_json_response(json_response)
pass
self.assertChildren(block, self.children_for_user[user])
protocol_str = '0'
resolve('/')
clf = GradientBoostingClassifier(n_estimators=100, random_state=1)
return [provider for provider in cls.enabled() if provider.accepts_logins]
XP = np.empty((n_samples, self.n_output_features_), dtype=X.dtype)
assert_almost_equal(lrap_score([[1], [0], [1], [0]], [[0.5], [0.5], [0.5], [0.5]]), 1.)
error_msg = _('Invalid grader reply. Please contact the course staff.') oldcmap.set(self.answer_id, msg=error_msg) return oldcmap
modulestore().update_item(course, ModuleStoreEnum.UserID.test)
all_alphas = np.unique(all_alphas) stride = int(max(1, int(len(all_alphas) / float(self.max_n_alphas)))) all_alphas = all_alphas[::stride]
X = np.arange(12).reshape(3, 4)
default_grade = '-1'
TRACKING_IGNORE_URL_PATTERNS = [r'^/event', r'^/login', r'^/heartbeat', r'^/segmentio/event', r'^/performance']
'ORGANIZATIONS_APP': False,
this_sample = this_layer.sample(state_below=state_below, state_above=state_above, layer_above=layer_above, theano_rng=theano_rng)
response = self.api_response() self.assertIn("/courses/{}/".format(self.course.id), response.data['handouts_html'])
return self.q(css='.advance-modules-remove-text').visible
return self.target_type
query = self.q(css='.search-team-descriptions') if query.present: query.first.click() self.wait_for_ajax()
X0 = np.array([[10000, 9999, 9998], [1, 1, 1]]) y = [0, 1]
url = reverse( 'info', kwargs={ 'course_id': unicode(self.course.id), } ) return self.client.get(url)
self.page.modal_dialog_visible(dialog_type) self.assertIn(dialog_message, self.page.modal_dialog_text(dialog_type))
return list(reversed(course_updates.items))
return True
self.assert_has_text(xml, "//div[@class='capa_alert']", self.context['submitted_message'])
print(metrics.classification_report(y_test, y_predicted, target_names=dataset.target_names))
predictions = estimator.predict(X[:, features])
self.assertGreater(exam_score * 100, 50)
return BACKEND.is_request_in_microsite()
course_url = get_url('course_handler', destination_course_key, 'course_key_string') response = self.client.ajax_post(course_url, rerun_course_data)
self.q(css='a[data-section=send_email]').first.click() email_section = BulkEmailPage(self.browser) email_section.wait_for_page() return email_section
output_emails = [row["email"] for row in output] for email in output_emails: self.assertIn(email, output_emails)
return [profile.strip() for profile in cls.current().video_profiles.split(",") if profile]
include_dependencies = bool(request.GET.get('include-dependencies', False))
core_samples = np.asarray(n_neighbors >= min_samples, dtype=np.uint8) dbscan_inner(core_samples, neighborhoods, labels) return np.where(core_samples)[0], labels
THRESHOLDED_METRICS_WITH_AVERAGING = [ "roc_auc_score", "average_precision_score", ]
self._check_results(self.staff, set(range(len(self.parents_map))), {}, transformers)
return block_type in DETACHED_BLOCK_TYPES
course_instructors = list_with_level(course, 'instructor') course_instructors_ids = [anonymous_id_for_user(user, course_key) for user in course_instructors] course_details = CourseDetails.fetch(course_key)
xml = etree.fromstring(expr) xml = self.formulaInstance.preprocess_pmathml(xml) test = etree.tostring(xml)
world.visit('/') course_link_css = 'a.course-link' world.css_click(course_link_css) course_title_css = 'span.course-title' assert_true(world.is_css_present(course_title_css))
i18n_service = self.runtime.service(descriptor, 'i18n') self.assertIsNotNone(i18n_service) self.assertIsInstance(i18n_service, ModuleI18nService) return i18n_service
return xblock._edit_info.get('subtree_edited_on')
self.assertEqual(get_site_status_msg(None), None) self.assertEqual(get_site_status_msg(self.course_key), None)
with check_mongo_calls_range(max_finds=max_mongo_calls, min_finds=min_mongo_calls): _course_overview_2 = CourseOverview.get_from_id(course.id)
self.q(css="{} .action-close".format(self.TAB_SELECTOR)).first.click()
request.user = self.user
(['professional'], 'professional'), (['no-id-professional'], 'no-id-professional')
self.assertNotContains(response, checkbox_html, html=True)
return u"grades.MaxScores.{}___{}".format(self.cache_prefix, unicode(location))
new_course_id = self.store.make_course_key('anotherX', 'anotherToy', 'Someday') self.check_import(root_dir, content_store, new_course_id) self.assertCoursesEqual(course_id, new_course_id)
verify_date_or_time(COURSE_START_DATE_CSS, '12/20/2013') verify_date_or_time(COURSE_START_TIME_CSS, DUMMY_TIME)
microsite_template = microsite.get_template(uri) return ( microsite_template if microsite_template else super(DynamicTemplateLookup, self).get_template(uri) )
authentication_classes = (EnrollmentCrossDomainSessionAuth, OAuth2AuthenticationAllowInactiveUser) permission_classes = (IsAuthenticated,)
add_instructor(destination_course_key, request.user, request.user)
dictionary = np.array(dictionary, order='F')
if not include_first: results = results[1:]
self.assert_oauth_status(self.dot_access_token, status.HTTP_200_OK)
DEBUG_TOOLBAR_MONGO_STACKTRACES = False
clf = LinearDiscriminantAnalysis(solver="svd").fit(X, y) means_transformed = clf.transform(means)
if not hasattr(coeffs, '__iter__'): coeffs = [coeffs] * len(self.layers)
self.navigate_to_video()
root_dir = path(mkdtemp_clean()) export_course_to_xml(self.store, content_store, course_id, root_dir, 'test_roundtrip')
url( r'^courses/{course_key}/xblock/{usage_key}/view/(?P<view_name>[^/]*)$'.format( course_key=settings.COURSE_ID_PATTERN, usage_key=settings.USAGE_ID_PATTERN, ), 'courseware.module_render.xblock_view', name='xblock_view', ),
if self.kl_integrator is None: self.kl_integrator = find_integrator_for(self.prior, self.posterior)
username_placeholder = _(u"JaneDoe")
return self.get_selector('div.certificate-invalidation-container table tr:last-child td')
CIFAR_FOLDER = "./cifar-10-batches-py/" SVHN_FOLDER = "./SVHN/"
if not is_memcache_running(): msg = colorize('red', "Memcache is not running locally.") print msg sys.exit(1)
assert_array_almost_equal(K.flat[::6], [linalg.norm(x) ** 2 for x in X])
if do_oob: sample_mask = _random_sample_mask(n_samples, n_inbag, random_state) old_oob_score = loss_(y[~sample_mask], y_pred[~sample_mask], sample_weight[~sample_mask])
query = self.q(css='.browse-teams') if query.present: query.first.click() self.wait_for_ajax()
self.x_sum = numpy.zeros([self.n_dim])
cache.clear()
params_not_accepted = params.copy() params_not_accepted['decision'] = "REJECT" self.assertFalse(payment_accepted(params_not_accepted)['accepted'])
return (key.block_scope_id, key.field_name)
SOCIAL_MEDIA_FOOTER_URLS = ENV_TOKENS.get('SOCIAL_MEDIA_FOOTER_URLS', SOCIAL_MEDIA_FOOTER_URLS)
ASSET_AMOUNT_PER_TEST = (0, 1, 10, 100, 1000, 10000)
asset_md.thumbnail = 'ABC39XJUDN2' return asset_md
return (v_prime * Q ** 2).sum(axis=-1)
resp = self.client.get_html(url) self.assertEquals(resp.status_code, 404)
updated_user = User.objects.get(id=uid_int)
diabetes_X_train = diabetes_X[:-20] diabetes_X_test = diabetes_X[-20:]
test = [[1], [3], [4]] assert_array_almost_equal(clf.predict(test), [1, 3, 4], 2)
OverrideFieldData.provider_classes = None
if not (settings.FEATURES.get("ENABLE_CREDIT_ELIGIBILITY", False) and is_credit_course(course_key)): return None
with open(file_full_path, 'r') as input_file: file_contents = input_file.read() return file_contents.decode(encoding='utf-8')
vertical1_parent = self.store.get_parent_location(vertical1.location) self.assertEqual(unicode(vertical1_parent), unicode(chapter1.location))
if (algorithm == 'kd_tree' and metric not in neighbors.KDTree.valid_metrics): assert_raises(ValueError, neighbors.NearestNeighbors, algorithm=algorithm, metric=metric, metric_params=metric_params) continue
self.record_visit_outline()
predictions = cval.cross_val_predict(clf, X, y) assert_equal(predictions.shape, (10,))
self.cert.mode = 'audit' self.cert.status = status self.cert.save()
return self.client.get(url)
for j in range(n_components): w = w_init[j, :].copy() w /= np.sqrt((w ** 2).sum())
return obj["id"] in self.context["cc_requester"]["subscribed_thread_ids"]
if not hasattr(self, 'freeze_set'): self.freeze_set = set([])
estimator_error = np.mean( np.average(incorrect, weights=sample_weight, axis=0))
child_to_group = { xblock.group_id_to_child.get(unicode(group.id), None): group.id for group in partition_for_this_block.groups }
sh('find {dir} -type f -delete'.format(dir=directory))
return self.q(css=BANNER_SELECTOR)
default_response = None
request.add_header('User-Agent', 'OpenAnything/1.0') html_content = opener.open(request).read() open(html_filename, 'wb').write(html_content)
return self.make_call(reverse('topics_list'), expected_status, 'get', data, **kwargs)
total_mu = (n_new * new_mu + n_past * mu) / n_total
response_str = json.dumps( {'return_code': 0 if success else 1, 'content': message} )
yield current.node visited.add(current.node) stack.pop()
pass
self.factory().fit(X, Y, intercept_init=np.zeros((3,)))
del result['X'] del result['y']
if self.lr_schedule == 'invscaling': self.learning_rate = (float(self.learning_rate_init) / (time_step + 1) ** self.power_t)
module = CapaFactory.create(rerandomize=RANDOMIZATION.ALWAYS, show_reset_button=False, done=False) self.assertFalse(module.should_show_reset_button())
buttons = world.css_find('div.mce-widget>button')
raise NotImplementedError()
return self.q(css="#search_attempt_id").present
iris = datasets.load_iris() X = iris.data y = iris.target n_classes = np.unique(y).size
return self.get_comment_list_url(obj, endorsed=False)
self.assertEqual(response_dict, self.expected_response)
with mock_registered_transformers(self.registered_transformers): self.transformers += self.registered_transformers
"remote_id": 'remote_' + username,
unique_together = ('user', 'usage_key')
raise self.retry(exc=exc, countdown=countdown, max_retries=config.max_retries)
label_measure = metric(y_true, y_pred, average=None) assert_array_almost_equal(label_measure, [metric(y_true_binarize[:, i], y_pred_binarize[:, i]) for i in range(n_classes)])
world.trigger_event(SELECTORS['url_inputs'], event='input', index=index)
api.update_credit_request_status(request["parameters"]["request_uuid"], self.PROVIDER_ID, status)
pickled_estimator = pickle.dumps(estimator) unpickled_estimator = pickle.loads(pickled_estimator)
cohort.name = "NewName" cohort.save() self.assertFalse(mock_tracker.called)
return random.choice((True, False))
return self.get(path, data or {}, follow, HTTP_ACCEPT="text/html", **extra)
return self._field_data
limiter = BadRequestRateLimiter() if limiter.is_rate_limit_exceeded(request): AUDIT_LOG.warning("Rate limit exceeded in password_reset") return HttpResponseForbidden()
set_input_value(self, self._bounded_selector(self.NAME_INPUT_SELECTOR), new_name)
self.unit_page.xblocks[1].open_basic_tab()
get_request_dict = {CapaFactory.input_key(): '3.14'} module.check_problem(get_request_dict)
return np.memmap(filename, dtype=dtype, shape=shape, mode=mode, offset=offset, order=order)
assert_array_equal(clf.predict(T), true_result)
paver.easy.sh("exit 1")
event = self.create_segmentio_event() for field in fields: if field in event: del event[field] return event
assert all(called)
context_dict = self.response_post_params(request.user) return render_to_response("verify_student/test/fake_softwaresecure_response.html", context_dict)
authentication_classes = []
from __future__ import unicode_literals
label = world.css_html(".level-element>header>div>div>span.xblock-display-name") assert_equal(display_name, label)
UserProfileFactory(user=self.user)
multioutput = None
learn_rates = [annealed * self.learning_rates[p] for p in self.params]
)
AutoAuthPage( self.browser, username=self.student_name, email=self.student_email, course_id=self.course_id, ).visit()
module = CapaFactory.create(attempts=attempts, max_attempts=attempts) self.assertFalse(module.should_show_check_button())
if values: engine = values['ENGINE'] options = values.get('OPTIONS', {}) backends[name] = _instantiate_backend_from_name(engine, options)
store = self._get_modulestore_for_courselike(usage_key.course_key) return store.get_item(usage_key, depth, **kwargs)
transform.fit(X) assert_not_equal(transform.sample_interval_, None)
config = settings.CC_PROCESSOR.get( settings.CC_PROCESSOR_NAME, {} )
return sequence.xmodule_runtime.render( sequence, STUDENT_VIEW, { 'requested_child': requested_child, 'next_url': next_url, 'prev_url': prev_url, }, ).content
youtube_video_id = microsite.get_value('homepage_promo_video_youtube_id', "your-youtube-id") context['homepage_promo_video_youtube_id'] = youtube_video_id
_mock_counts.return_value = {'total': 0} call_task('pavelib.quality.run_safelint')
_update_course_context(request, context, course, platform_name)
self.assertFalse(CourseInstructorRole(self.course.id).has_user(nonstaff_user)) self.assertTrue(CourseStaffRole(self.course.id).has_user(nonstaff_user))
sigmas = sigma * rng.rand(n_features) + sigma / 2. X_hetero = X + rng.randn(n_samples, n_features) * sigmas
self.login(email, password) self.enroll(self.course, verify=True)
self.assertFalse(enrollment['is_active'])
nested_args = mapping.nest(theano_args) fixed_var_descr = self.cost.get_fixed_var_descr(model, nested_args) self.on_load_batch = fixed_var_descr.on_load_batch
try: imp.find_module(app_name) except ImportError: try: __import__(app_name) except ImportError: continue INSTALLED_APPS += (app_name,)
self.click(".action-publish") self.page.wait_for_ajax()
if func_code.co_flags & 0x04: name = arg_names[pos_count + keyword_only_count] annotation = annotations.get(name, _empty) parameters.append(Parameter(name, annotation=annotation, kind=_VAR_POSITIONAL))
return self.lti_consumer.consumer_key == client_key
'CUSTOM_COURSES_EDX': False,
return self.find_css("#due_date").first.attrs('value')[0]
self.assertIn( settings.MICROSITE_CONFIGURATION['test_microsite']["urls"]['ABOUT'], data['company_about_url'] )
from __future__ import unicode_literals
weight_k[in1d(y_full, list(classes_missing))] = 0.
self.assertAlmostEqual( calc.evaluator(variables, {}, "T", case_sensitive=True), 298, delta=0.2 )
enrollment_mode = self.dashboard_page.get_enrollment_mode(self.course_info["display_name"]) self.assertEqual(enrollment_mode, 'verified')
assert_almost_equal(clf.alpha_, min(clf.alphas_)) assert_equal(clf.l1_ratio_, min(clf.l1_ratio))
pass
self.parseAction += map(self._normalizeParseActionArgs, list(fns)) self.callDuringTry = self.callDuringTry or ("callDuringTry" in kwargs and kwargs["callDuringTry"]) return self
Axes3D
escaped_string_for_js = js_escaped_string(None) self.assertEquals(u"", escaped_string_for_js)
return self.children()
email_context = {'name': '', 'email': ''} email_context.update(global_email_context)
X = super(TfidfVectorizer, self).fit_transform(raw_documents) self._tfidf.fit(X) return self
return response
self.add_dropdown_to_section(vertical_1.location, 'H2P1_GROUP1', 1).location.html_id()
kvs = MongoKeyValueStore( definition_data, None, [], metadata, ) field_data = KvsFieldData(kvs) return field_data
unique_name = uuid.uuid4().hex[0:30]
request.user.is_authenticated() and is_shopping_cart_enabled() and Order.does_user_have_cart(request.user) and Order.user_cart_has_items( request.user, [PaidCourseRegistration, CourseRegCodeItem] )
asset_key = make_asset_id(course_id, asset) asset_md = AssetMetadata(asset_key) asset_md.from_xml(asset) all_assets.append(asset_md)
permutation = random_state.permutation(dim) aux = aux[permutation].T[permutation] chol += aux prec = np.dot(chol.T, chol)
self.assertEqual(mail.outbox[-1].to[0], 'finance@example.com')
actual_payment_data = checkout_with_ecommerce_service( user, 'dummy-course-key', course_mode, 'test-processor' )
if not self.has_partial_credit: return self.grade_without_partial_credit(student_answers=student_answers)
pass
warning_msg = _("The problem's state was corrupted by an invalid submission. The submission consisted of:") warning += warning_msg + '<ul>'
('subject', Pipeline([ ('selector', ItemSelector(key='subject')), ('tfidf', TfidfVectorizer(min_df=50)), ])),
return self.filter_by(data, "id", note_id)
return dict((_instantiate(k, bindings), _instantiate(v, bindings)) for k, v in six.iteritems(proxy))
self.assertEqual(context[context_key], 'test latin1 Ó é ñ'.decode('utf8'))
assert self.conv2d.get_params() == [self.filters]
self.assertOLXIsDraftOnly(block_list_publish) self.assertOLXIsDraftOnly(block_list_untouched)
app_label = "rss_proxy"
store = self._get_modulestore_for_courselike(course_key) return store.get_orphans(course_key, **kwargs)
return u"{} : {}".format(self.course_id.to_deprecated_string(), self.annotation)
def has_delete_permission(self, request, obj=None): return False
if not user: user = AnonymousUser()
language_codes = self.translations() index = language_codes.index(old_lang_code) self.select_translation_language(new_lang_code, index) self.upload_asset(transcript_name, asset_type='transcript', index=index)
Z = Z.reshape(xx.shape) plt.contourf(xx, yy, Z, cmap=plt.cm.Paired) plt.axis('off')
dx = manhattan_distances(X, Y=self.X, sum_over_features=False) f = self.regr(X) r = self.corr(self.theta_, dx).reshape(n_eval, n_samples)
def __init__(self, bulk_ops_record_type, **kwargs): super(ActiveBulkThread, self).__init__(**kwargs) self.records = defaultdict(bulk_ops_record_type)
self.assertEqual(len(self.lc_block.get_child_descriptors()), 1) self.assertEqual(len(self.lc_block.get_content_titles()), 1)
raise PermissionDenied()
full_name = UserProfile.objects.get(user=user).name
staff = UserFactory() allow_access(self.course, staff, 'staff') self.assertTrue(CourseStaffRole(self.course.id).has_user(staff))
space = CompositeSpace((self.get_input_space(), self.get_target_space())) source = (self.get_input_source(), self.get_target_source()) return (space, source)
clf = self.factory().fit(X2, Y2, intercept_init=np.zeros((3,)))
return JsonResponse( _("Successfully removed invalid due date extension (unit has no due date).") )
self.service.set_credit_requirement_status( self.user.id, self.course.id, 'grade', 'grade' )
if resp.context: self.assertEqual(resp.context['course'], self.course)
CourseTeamIndexer.engine().destroy() for team in self.test_team_name_id_map.values(): CourseTeamIndexer.index(team)
self.assertEqual(result['success'], 'correct')
self.assertEqual(course_date, expected_course_date)
'course_action_state',
best = sorted(grid_scores, key=lambda x: x.mean_validation_score, reverse=True)[0] self.best_params_ = best.parameters self.best_score_ = best.mean_validation_score
course_location_one = locator.CourseLocator('Org1', 'Course1', 'Run1') new_course_one = self._create_course(course_location_one)
vmax = arr.max(axis=0) out = np.log(np.sum(np.exp(arr - vmax), axis=0)) out += vmax return out
return self.make_theano_batch(name=name, dtype=dtype, batch_size=batch_size)
with self.assertRaises(PageNotFoundError): self.get_comment_list(thread, endorsed=True, page=2, page_size=10)
if not CreditEligibility.is_user_eligible_for_credit(course_key, username): raise UserNotEligibleException(course_key, username)
block_structure.request_xblock_fields('category')
model.threshold = 1.0 assert_greater(X_transform.shape[1], model.transform(data).shape[1])
def rval(a): return (a * self.y_cache).sum(axis=1) return rval
with self.assertRaises(SearchIndexingError): reindex_course_and_check_access(self.course.id, self.user)
self.assertFalse(api.is_user_eligible_for_credit("bob", self.course_key))
self.register_page.register(country="US", favorite_movie="Battlestar Galactica", terms_of_service=True)
content = '<ol/>' payload = get_response(content, 'January 11, 2013') self.assertHTMLEqual(content, payload['content'], "self closing ol")
for student in students[3:]: self.assertIsNone( GeneratedCertificate.certificate_for_student(student, self.course.id) )
return _absolute_url(is_secure, url_path)
course_location = self.store.make_course_key('Org1', 'Course1', 'Run1') course = self._create_course_with_access_groups(course_location, self.user)
self.assertFalse(CourseInstructorRole(self.course.id).has_user(nonstaff_user)) self.assertTrue(CourseStaffRole(self.course.id).has_user(nonstaff_user))
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
if not hasattr(view_converter, 'topo_space'): raise NotImplementedError("Not able to get a topo_space " "from this converter: %s" % view_converter)
key = "subtask-{}".format(task_id) cache.delete(key)
if message_type == 'status': self.wait_for_element_visibility(CLASS_SELECTORS[message_type], '{} message is Visible'.format(message_type.title())) return self.q(css=CLASS_SELECTORS[message_type]).text[0]
pass
for kernel in ('linear', 'poly', 'rbf'): clf = svm.SVC(kernel=kernel, gamma=2) clf.fit(X, Y)
x = np.arange(3) assert_array_equal(x[:, np.newaxis], cartesian((x,)))
assert_equals(out.count("But it is "), 1)
self.assertEqual(safe_key('test', 5, 'version'), '5:version:test')
assert_raises(ValueError, classifier.decision_function, X.T) assert_raises(ValueError, classifier.decision_function, X.T)
score = estimator.predict_proba(X)[:, 1]
if db != 'read_replica': DATABASES[db].update(get_db_overrides(db))
def __init__(self, error_message): super(SafeCookieError, self).__init__(error_message) log.error(error_message)
with mock.patch( 'openedx.core.djangoapps.content.course_overviews.models.CourseOverview.objects.get' ) as mock_getter:
context['logo_subtitle'] = _("Certificate Validation")
return
try: return cls.objects.filter(course_id=course_id, user=user, course_enrollment=course_enrollment, status='purchased').latest('id') except PaidCourseRegistration.DoesNotExist: return None
affinity = 'euclidean'
user_course_ids = random.sample(range(TOTAL_COURSES_COUNT), USER_COURSES_COUNT)
self.assertListEqual(problem.responders.values()[0].context['idset'], correct_order)
self.assertTrue(self.profile.requires_parental_consent()) self.assertTrue(self.profile.requires_parental_consent(default_requires_consent=True)) self.assertFalse(self.profile.requires_parental_consent(default_requires_consent=False))
with self.assertRaisesRegexp(CommandError, ".* requires one or more arguments.*"): call_command('reindex_library')
managed = False
for __ in range(int(num_inputs)): input_element = self.create_input_element(**kwargs) if not None == input_element: response_element.append(input_element)
'ALLOW_HIDING_DISCUSSION_TAB': False,
ModeCreationPage(self.browser, self.course_id).visit()
html_problem_semantics = [ "codeparam", "responseparam", "answer", "script", "hintgroup", "openendedparam", "openendedrubric", ]
from . import signals
except Exception: log.exception("error executing xblock handler") raise
'microsite_configuration.middleware.MicrositeSessionCookieDomainMiddleware',
n_classes = 1 labels = labels[1:]
return { field: course.fields[field] for field in CourseSummary.course_info_fields if field in course.fields }
from sklearn.externals.six.moves import cStringIO as StringIO import sys old_stdout = sys.stdout try: sys.stdout = StringIO()
return sqrt(squared_norm(x))
K = squareform(K) np.fill_diagonal(K, 1)
self.assertNotIn(malicious_code, resp.content)
with patch('capa.capa_problem.LoncapaProblem.supports_rescoring') as mock_supports_rescoring: mock_supports_rescoring.return_value = False with self.assertRaises(NotImplementedError): module.rescore_problem()
'ajax_url': '{}/xmodule_handler'.format(location.to_deprecated_string()), 'element_id': u'i4x-HarvardX-ER22x-conditional-condone', 'depends': u'i4x-HarvardX-ER22x-problem-choiceprob'
self.assertEquals( SafeSessionMiddleware.get_user_id_from_session(self.request), self.user.id )
from __future__ import unicode_literals
y = y.T
for kernel in kernels: gpr = GaussianProcessRegressor(kernel=kernel, normalize_y=True) gpr.fit(X, y)
return HttpResponseBadRequest('Requested page must be numeric')
django_settings.SOCIAL_AUTH_PROTECTED_USER_FIELDS = ['email']
actual_response = json.loads(response.content) self.assertEqual(actual_response, TEST_PAYMENT_DATA)
resources_dir = None def get_html(self): return self.studio_view(None).content
raise NotImplementedError("%s does not implement batch_size" % type(self))
self.temp_dir_1 = mkdtemp() self.temp_dir_2 = mkdtemp(dir="")
ext_user = User.objects.get(email=self.ext_user.email) self.assertFalse(auth.user_has_role(ext_user, CourseStaffRole(self.course.id)))
with check_exact_number_of_calls(store, 'refresh_cached_metadata_inheritance_tree', 28):
LIMITED_RETRY_ERRORS = ( SMTPConnectError, SMTPServerDisconnected, AWSConnectionError, )
if hasattr(self.current_request_configuration, 'cache'): return self.current_request_configuration.cache.get(key)
return [Attribute('width'), Attribute('height'), Attribute('target_shape') ]
return redirect_with_get('signin_user', request.GET)
self.video.click_player_button('fullscreen')
layer_to_updated = OrderedDict()
credit_course = CreditCourse.objects.create( course_key=self.course.id, enabled=True, )
self.payment_and_verification_flow.proceed_to_payment()
base_estimator = LinearSVC(random_state=0)
pass
"payment_url": get_purchase_endpoint(),
problem = self.build_problem(sample_dict=sample_dict, num_samples=10, tolerance=0.01, answer="x+2*y", hints=hints)
S.flat[::(n_samples + 1)] = preference
error_summary = _("An error occurred while creating your receipt.")
self.client.login(username=self.global_staff.username, password="test") self._assert_certificates_visible(False)
mongo_course1_id = self.import_and_populate_course()
unvisited_children = list( child for child in get_children(current_node) if child not in yield_results )
for choice in choices_list: choicegroup.remove(choice)
file_to_upload = 'image.jpg' self.settings_page.upload_image('#upload-course-image', file_to_upload) self.assertIn(file_to_upload, self.settings_page.get_uploaded_image_path('#course-image'))
try: return SearchEngine.get_search_engine(index=cls.INDEX_NAME) except ConnectionError as err: logging.error('Error connecting to elasticsearch: %s', err) raise ElasticSearchConnectionError
if self.subsample < 1.0: self.oob_improvement_ = np.zeros((self.n_estimators), dtype=np.float64)
res_r = int(numpy.floor(last_pool_r/rs)) + 1 res_c = int(numpy.floor(last_pool_c/cs)) + 1
self.course_outline.visit() self.course_outline.open_subsection_settings_dialog(1) self.course_outline.select_access_tab() self.course_outline.add_prerequisite_to_subsection("80")
return self.q(css=self._bounded_selector('.member-count')).map(lambda e: e.text).results
n_components = 10
BULK_EMAIL_DEFAULT_RETRY_DELAY = 30
self.assertEqual(len(actual), 2) self.assertEqual(actual, expected)
topics = self.discussion_topics return [d["id"] for d in topics.values()]
assets_by_type = defaultdict(lambda: SortedAssetList(iterable=course_assets.get(asset_type, [])))
grid = GridSearchCV(clf, refit=False, param_grid=param_grid, cv=ShuffleSplit(train_size=train_size, n_iter=250, random_state=1)) grid.fit(X, y) scores = [x[1] for x in grid.grid_scores_]
energy = dbm.energy(V = v_state, hidden = [y_state]) unnormalized_prob = T.exp(-energy) assert unnormalized_prob.ndim == 1 unnormalized_prob = unnormalized_prob[0] unnormalized_prob = function([], unnormalized_prob)
resp = self._change_enrollment('unenroll') self.assertEqual(resp.status_code, 200)
clf = self.factory().fit(X2, Y2, coef_init=np.zeros((3, 2)))
result = embargo_api.check_course_access(self.course.id, ip_address='0.0.0.0') self.assertFalse(result)
cache_values = cache.get_many([ enrollment_cache_key, has_skipped_cache_key, verification_status_cache_key ])
return course_metadata_utils.course_start_datetime_text( self.start, self.advertised_start, format_string, ugettext, strftime_localized )
raise TypeError("Unknown object type in has_access(): '{0}'" .format(type(obj)))
embargo_redirect = embargo_api.redirect_if_blocked( course.id, user=request.user, ip_address=get_ip(request), url=request.path ) if embargo_redirect is not None: return redirect(embargo_redirect)
self.assertEqual(response.status_code, 200)
self.course_key = course_key self.role = role self.user_partition_id = user_partition_id self.group_id = group_id self.user_name = user_name
response = self._search("foo")
add_user_to_cohort(second_cohort, self.student.username) self.assert_student_in_group(self.groups[1])
from .comment import Comment from .thread import Thread from .user import User from .commentable import Commentable
self._install_course_fixture() self._navigate_to_courseware_video_no_render()
return CoursewareSearchIndexer.do_course_reindex(store, self.course.id)
self.assertIn('/gitlogs/MITx/edx4edx/edx4edx', response.content)
VerificationDeadline.set_deadline(self.course.id, self.VERIFICATION_DEADLINE)
return urllib.unquote(urllib.unquote(response_str))
return [reverse(name, kwargs={'course_id': course.id.to_deprecated_string()}) for name in names]
return render_to_response('financial-assistance/financial-assistance.html', { 'header_text': FINANCIAL_ASSISTANCE_HEADER })
return settings.FEATURES.get(cls.ENABLE_SEARCH_KEY, False)
return _reduce_memmap_backed(a, m)
super(PipelineRenderTest, cls).setUpClass() call_task('pavelib.assets.update_assets', args=('lms', '--settings=test'))
X = np.array([[1, 2, 0], [0, 0, 0]], dtype=np.uint8)
import_logs = CourseImportLog.objects.all() import_logs.delete()
p = linear_response return p
assets, count = content_store.get_all_content_for_course(self.course.id) self.assertEqual(count, 1) display_name = assets[0]['displayname'] self.assertEqual(display_name, invalid_displayname)
logger.warning("no '{0}' found".format(this_check))
ii = iter_offset - 1
add_user_to_cohort(test_cohort, self.student.username) self.assert_student_in_group(None)
model.fit(X, y) n_iter_cold_start = model.n_iter_ assert_equal(n_iter_cold_start, n_iter_reference)
exam_review_policy = get_review_policy_by_exam_id(exam['id']) self.assertEqual(exam_review_policy['review_policy'], sequence.exam_review_rules)
cert = GeneratedCertificate.eligible_certificates.get(user=self.student) self.assertEqual(cert.status, CertificateStatuses.notpassing)
assert len(state) == 2 if isinstance(coeffs, str): coeffs = float(coeffs) assert isinstance(coeffs, float) _, state = state state = [state] coeffs = [coeffs]
cls.create_image(prefix, (1, 1), 'red', 'special/{}_unlock.png')
return self.n_iter
y = [3, 3, -1, -1, 3]
self.eof_index = len(string)
return self.q(css='ul.listing-courses .course-item')
return conv2d( x, self._filters, image_shape=self._img_shape, filter_shape=self._filters_shape, subsample=self._subsample, border_mode=self._border_mode, )
self._folds = stacked_blocks
assert_not_equal(X_fit_transformed.size, 0)
query_features = _task_input.get('features') student_data = get_proctored_exam_results(course_id, query_features) header, rows = format_dictlist(student_data, query_features)
#latex_use_modindex = True
delattr(tp, self.name) return result
self.refresh_cached_metadata_inheritance_tree(location.course_key)
parse_string = self._find_string_wrapping_expression(mako_template, expression) if parse_string is None: results.violations.append(ExpressionRuleViolation( Rules.mako_js_missing_quotes, expression ))
stack_data.append({ 'color': percent, 'value': count_grade, 'tooltip': tooltip, 'module_url': child.location.to_deprecated_string(), })
class Meta(object): app_label = "courseware" unique_together = (('student', 'field_name'),) student = models.ForeignKey(User, db_index=True)
return self.store.get_modulestore_type(self.course.id) == ModuleStoreEnum.Type.split
args = [func.__self__, ] + args
kf = cval.KFold(300, 3, shuffle=True, random_state=0) ind = np.arange(300)
#epub_use_index = True
return [username.strip() for username in value.split(',')]
space, source = model.get_monitoring_data_specs()
self._click_button('settings_tab')
self.assertEqual(correct_map.get_overall_message(), 'Message text')
self.assertNotIn("wsgiref.util", sys.modules) wsgiref_util = LazyModule("wsgiref.util") self.assertEqual(wsgiref_util.guess_scheme({}), "http")
return self.system.render_template('module-error.html', { 'staff_access': True, 'data': self.contents, 'error': self.error_msg, })
return reverse_course_url('course_rerun_handler', course_key)
with self.assertNumQueries(0): self.field_data_cache = FieldDataCache([mock_descriptor()], course_id, self.user) self.kvs = DjangoKeyValueStore(self.field_data_cache)
#epub_exclude_files = []
from commerce import signals
self.assertDictEqual(json.loads(response.content), data)
return item.location.version_agnostic().replace(branch=None)
key = safe_key('test', prefix, '')
return self.q(css=self._bounded_selector('.flag-role .msg-you')).present
assert_warns_message(DeprecationWarning, "class_weight='auto' heuristic is deprecated", model.fit, X, y)
'USE_CUSTOM_THEME': False,
latex_domain_indices = False
self.assertEqual(1, 1)
return staticfiles_storage.url(microsite.get_value('favicon_path', default))
ItemFactory.create( category="html", parent_location=library.location, user_id=self.user_id, publish_item=False, modulestore=self.store, data=message ) library = self.store.get_library(library.location.library_key)
'ENABLE_MAX_FAILED_LOGIN_ATTEMPTS': False,
try: set_defaults() except Exception as e: logger.exception(e)
return certificate
def __init__(self, user=None, course_id=None): super(TestCcxObject, self).__init__(user, course_id) self.coach = user
return redirect_with_get('signin_user', request.GET)
self.assertEqual(len(courses), 2)
self.assertAlmostEqual( calc.evaluator(variables, {}, '3*x-y'),
grade_summary['percent'] = round(grade_summary['percent'] * 100 + 0.05) / 100
tag = get_tag(d) try: resolver = resolvers[tag] except KeyError: reraise_as(TypeError('config does not know of any object type "'+tag+'"')) return resolver(d)
for ky in oy+N.arange(kshp[0]): for kx in ox+N.arange(kshp[1]):
X, y = check_X_y(X, y, ['csr', 'csc'])
param_grid = [param_grid]
china = load_sample_image("china.jpg")
try: output = html5lib.parseFragment(html, treebuilder='lxml', namespaceHTMLElements=False)[0] except IndexError: raise ex
self.cart = Order.get_cart_for_user(self.user) CertificateItem.add_to_order( self.cart, self.course_key, self.COST, 'verified' ) self.cart.start_purchase()
image_pair = tuple(image_pair[0, :, :, :, 0])
for i in range(X.shape[0]): assert_almost_equal(np.linalg.norm(X[0].data, 2), 1.0)
return course_metadata_utils.has_course_started(self.start)
if not user or user.is_anonymous(): return None
self.assertIn('Activate Course Enrollment', response.content)
assert np.allclose(X, np.dot(S_, A_.T) + ica.mean_)
self.assertEqual(CourseMode.can_auto_enroll(self.course_key), can_auto_enroll)
context = {
log_likelihood_gradient_dims = \ 0.5 * np.einsum("ijl,ijk->kl", tmp, K_gradient) log_likelihood_gradient = log_likelihood_gradient_dims.sum(-1)
for course_overview in [course_overview_cache_miss, course_overview_cache_hit]: course_overview_tabs = course_overview.tabs.all() course_resp_tabs = {tab.tab_id for tab in course_overview_tabs} self.assertEqual(self.COURSE_OVERVIEW_TABS, course_resp_tabs)
self.q(css="a.forgot-password").click()
settings.apply_settings(self.settings) self.assertFalse(self.settings.SOCIAL_AUTH_RAISE_EXCEPTIONS)
_, _, X_offset, _, X_scale = _preprocess_data(X, y, fit_intercept, normalize, return_mean=True) mean_dot = X_offset * np.sum(y)
Z = kmeans.predict(np.c_[xx.ravel(), yy.ravel()])
if return_distance: dist, neigh_ind = result else: neigh_ind = result
X, y = datasets.make_regression(n_targets=1) X_train, y_train = X[:50], y[:50] X_test, y_test = X[50:], y[50:]
self.assert_student_in_group(None)
return compare_with_tolerance( evaluator({}, {}, ans1), evaluator({}, {}, ans2), self.tolerance )
def context_manager_no_warning(): with ignore_warnings(): _warning_function()
try: cached_mapping = CourseStructure.objects.get(course_id=course.id).discussion_id_map if not cached_mapping: raise DiscussionIdMapIsNotCached() return cached_mapping.get(discussion_id) except CourseStructure.DoesNotExist: raise DiscussionIdMapIsNotCached()
data = dict( logo_src=branding_api.get_logo_url(), logo_url=branding_api.get_base_url(is_secure), ) return data
self._requested_xblock_fields = set()
estimator_error = np.mean( np.average(incorrect, weights=sample_weight, axis=0))
singular_ind = np.arange(n, dtype=np.float64)
valid_block_keys = set([(c.block_type, c.block_id) for c in children]) invalid_block_keys = (selected - valid_block_keys) if invalid_block_keys: selected -= invalid_block_keys
return self.alpha_
certificate = res_json['certificates'][1] self.assertEqual(certificate.get('total_issued_certificate'), 3) self.assertEqual(certificate.get('mode'), 'verified')
warnings.filterwarnings('always', category=DeprecationWarning, module='^{0}\.'.format(re.escape(__name__)))
try: user_id = int(identifier) except ValueError: return User.objects.get(email=identifier) return User.objects.get(id=user_id)
world.css_click('input[name="calculate-grades-csv"]')
context['disable_student_access'] = True
self.service.set_credit_requirement_status( self.user.id, no_credit_course.id, 'grade', 'grade' )
definition_xml.attrib.update(xml_object.attrib)
fields.update({ 'language': getattr(settings, 'DEFAULT_COURSE_LANGUAGE', 'en'), 'cert_html_view_enabled': True, })
self.q(css=self._bounded_selector(".toggle-cohort-management-discussions")).first.click() self.wait_for_element_visibility("#cohort-management-discussion-topics", "Waiting for discussions to appear")
dropout_input_mask_value = 0.
idx = np.arange(X.shape[0]) np.random.seed(13) np.random.shuffle(idx) X = X[idx] y = y[idx]
return course.id.org
class Meta(object): model = Dummy
from __future__ import unicode_literals
context = get_context(self.course, self.request, make_minimal_cs_thread(thread_data)) return CommentSerializer(comment, context=context).data
response = self.http_get_for_course(self.invalid_course_id) self.assertEqual(response.status_code, 404)
else: self.send_response(200)
try: CourseTeamIndexer.index(kwargs['instance']) except ElasticSearchConnectionError: pass
ensemble = BaggingRegressor(base_estimator=DecisionTreeRegressor(), max_samples=1.0, bootstrap=True, random_state=rng).fit(X_train, y_train)
site_configuration_history = SiteConfigurationHistory.objects.filter( site=site_configuration.site, ).all()
pass
self._login_as_non_staff_user()
self.login_student() self.submit_answer('Correct', 'Correct') self.assertEqual(self.get_progress_detail(), u'2/2')
pass
pass
FOLDER_PERMISSIONS = stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR FILE_PERMISSIONS = stat.S_IRUSR | stat.S_IWUSR
self.workd = _aligned_zeros(3 * n, self.tp) self.workl = _aligned_zeros(self.ncv * (self.ncv + 8), self.tp)
return HttpResponseBadRequest(u'Could not parse request JSON.')
response = self.client.post(self.url, { "email": "invalid@example.com", "password": self.PASSWORD, }) self.assertHttpForbidden(response)
self.assertNotEqual(initial_data["PhotoIDKey"], two_photo_reverification_data["PhotoIDKey"])
response, __ = self._get_update_response_and_expected_data(None, None) self.assertEqual(response.status_code, 200)
self.assertFalse(CourseEnrollment.is_enrolled(self.user, self.course.id))
block.edit() block.reset_field_val("Display Name") block.save_settings() self.assertEqual(block.name, name_default)
params.update(body) return params
DEBUG = True
statuses = ["approved", "denied", "pending", "must_reverify"] reverifications = reverification_info(statuses)
boston = datasets.load_boston() boston.data, boston.target = shuffle(boston.data, boston.target, random_state=rng)
self.assertEqual(len(outbox), 1)
self._verify_masquerade_for_all_groups()
return aes_decrypt(base64.urlsafe_b64decode(encoded_data), key)
raise NotImplementedError
self._assert_receipt_contains("tax purposes") self._assert_receipt_contains(self.course.display_name)
MODULESTORE = TEST_DATA_SPLIT_MODULESTORE __test__ = True url_name = 'course'
with open(state_file_path, "w") as state_file: state_file.write(expected_version)
}
from __future__ import unicode_literals
return [ credential['credential']['program_id'] for credential in get_user_credentials(student) if 'program_id' in credential['credential'] and credential['status'] == 'awarded' ]
next_offset = offset + MAX_STUDENTS_PER_PAGE_GRADE_BOOK previous_offset = offset - MAX_STUDENTS_PER_PAGE_GRADE_BOOK
mock_get.return_value.content = json.dumps({"1": 2}) self.assertRaises(EdxNotesParseError, helpers.get_notes, self.request, self.course)
course_locations = self.draft_store.get_courses_for_wiki('toy') assert_equals(len(course_locations), 0)
pass
mode = models.CharField(default=CourseMode.DEFAULT_MODE_SLUG, max_length=100)
print("Computing Spectral embedding") embedder = manifold.SpectralEmbedding(n_components=2, random_state=0, eigen_solver="arpack") t0 = time() X_se = embedder.fit_transform(X)
import theano from theano import tensor try: from theano.sparse import SparseType except ImportError: warnings.warn("Could not import theano.sparse.SparseType") from theano.compile.mode import get_default_mode
response = self.client.get(reverse("support:certificates")) self.assertContains(response, "userFilter: ''")
AUTHENTICATION_BACKENDS = ( 'ratelimitbackend.backends.RateLimitModelBackend', )
pass
microsite.set_by_domain(self.microsite.site.domain) self.assertEqual( microsite.get_all_orgs(), set(self.microsite.get_organizations()) )
raise NotImplementedError(str(type(self))+" does not implement " +\ "get_total_state_space()")
homework_1_score = 1.0 / 2 homework_2_score = (1.0 + 2.0) / 4 self.check_grade_percent(round((homework_1_score + homework_2_score) / 2, 2))
already_fixed = {}
system = -4
if created: self._ddog_increment(evt_time, 'set_many.state_created') else: self._ddog_increment(evt_time, 'set_many.state_updated')
return usage_id.replace(library_key=(usage_id.library_key.replace(version_guid=None, branch=None)))
out_file.write(', fillcolor="#C0C0C0"')
import json
tokens = [x[1:-1].decode('utf8').replace("&#39;", "'") for x in lexer]
model.tag[self._tag_key]['best_cost'] = self.best_cost
self.request.user = AnonymousUser() context = user_has_cart_context_processor(self.request) self.assertFalse(context['should_display_shopping_cart_func']())
self.assert_student_in_group(self.groups[0])
'dynamath': dynamath,
GRADES_DOWNLOAD_ROUTING_KEY = HIGH_MEM_QUEUE
boston = load_boston() X, y = boston['data'], boston['target']
email_placeholder = _(u"username@domain.com")
owner = batch.owner assert 'Subtensor' in str(owner.op) batch = owner.inputs[0]
courses_list = list(get_course_enrollments(self.student, None, [])) self.assertEqual(len(courses_list), 1) self.assertEqual(courses_list[0].course_id, course_location)
if not (has_forum_admin or has_instructor_access): return HttpResponseBadRequest( "Operation requires staff & forum admin or instructor access" )
return urlparse(self.runtime.handler_url(self.block, handler_name, suffix=suffix)).path
if mp is not None: try: _sem = mp.Semaphore()
PIPELINE_JS_COMPRESSOR = None
ASSET_XSD_FILE = 'assets.xsd'
for entry in toc: if entry['url_name'] == url_name: return entry return None
rho, _ = spearmanr(x, y) increasing_bool = rho >= 0
self.validate_xblock_info_consistency(xblock_info)
y = np.array([0.0, 1.1, 2.0, 3.0]) msg = type_of_target(y) assert_raise_message(ValueError, msg, check_classification_targets, y)
doc_topics, sstats_list = zip(*results) doc_topic_distr = np.vstack(doc_topics)
self.assertNotIn(extra_user.username, response.content)
return self.q(css='span.filter-column').visible
descriptor_filter = partial(descriptor_affects_grading, course.block_types_affecting_grading) return FieldDataCache.cache_for_descriptor_descendents( course.id, user, course, depth=None, descriptor_filter=descriptor_filter )
self._set_deadlines(course.id, upgrade_deadline=deadline, verification_deadline=deadline)
if n_components < min(n_features, n_samples): self.noise_variance_ = explained_variance_[n_components:].mean() else: self.noise_variance_ = 0.
self.add_course_to_user_cart(self.course_key) self.assertEquals(self.cart.orderitem_set.count(), 1)
asset = self.get_sample_asset(name, asset_type) response = self.client.post(self.url, {"name": name, "file": asset}) return response
self.seed = state.get('seed', seed) assert self.seed is not None, "Seed must be provided for LoncapaProblem."
with store.branch_setting(ModuleStoreEnum.Branch.draft_preferred): store.delete_item(item_location, ModuleStoreEnum.UserID.test)
cStyleComment = Regex(r"/\*(?:[^*]*\*+)+?/").setName("C style comment")
time.sleep(time_between_creation)
DEFAULT_SHOPPINGCART_MODE_SLUG = HONOR DEFAULT_SHOPPINGCART_MODE = Mode(HONOR, _('Honor'), 0, '', 'usd', None, None, None, None)
self.assertEqual(expected_message, error.exception.message)
delete_item(category='html', name='test_html')
hid_acts, filters, output_shape = inputs out, = outputs assert hid_acts[0] == filters[3] flops = (hid_acts[3] * filters[0] * hid_acts[0] * filters[1] * filters[2] * hid_acts[1] * hid_acts[2] * 2) return flops
return [ p for p in self.user_partitions if p.scheme == scheme ]
est = LogOddsEstimator() assert_raises(ValueError, est.fit, None, np.array([1]))
assert_less(0, 1) _assert_less(0, 1) assert_raises(AssertionError, assert_less, 1, 0) assert_raises(AssertionError, _assert_less, 1, 0)
self.refresh_course() return problem
self.advanced_settings.visit() self.advanced_settings.set_values({"Advanced Module List": json.dumps(block_types)})
css = {'scss': [resource_string(__name__, 'css/codemirror/codemirror.scss')]} js = {'coffee': [resource_string(__name__, 'js/src/raw/edit/xml.coffee')]} js_module_name = "XMLEditingDescriptor"
AFFILIATE_COOKIE_NAME = ENV_TOKENS.get('AFFILIATE_COOKIE_NAME', AFFILIATE_COOKIE_NAME)
FEATURES['ENFORCE_PASSWORD_POLICY'] = False FEATURES['ENABLE_MAX_FAILED_LOGIN_ATTEMPTS'] = False FEATURES['SQUELCH_PII_IN_LOGS'] = False FEATURES['PREVENT_CONCURRENT_LOGINS'] = False FEATURES['ADVANCED_SECURITY'] = False
self.user = UserFactory.create(password=self.test_password) self.teams_url = reverse('teams_dashboard', args=[self.course.id])
X = iris.data
return ('%(classname)s(dim=%(dim)s, dtype=%(dtype)s)' % dict(classname=self.__class__.__name__, dim=self.dim, dtype=self.dtype))
world.visit('/') signin_css = 'a.action-signin' assert world.is_css_present(signin_css)
train.apply_preprocessor(pipeline, can_fit=True) del train
self.assertEqual(len(h_data['course_modes']), 1) self.assertEqual(h_data['course_modes'][0]['slug'], CourseMode.HONOR)
assert_raises(ValueError, plot_partial_dependence, clf, iris.data, [0, 1], label='foobar', grid_resolution=grid_resolution)
inputs = SparseType('csr', dtype=theano.config.floatX)() return theano.function([inputs], self(inputs), name=name)
merged_access = descriptor.merged_group_access if False in merged_access.values(): log.warning("Group access check excludes all students, access will be denied.", exc_info=True) return ACCESS_DENIED
django_user_service = DjangoXBlockUserService(self.anon_user) xb_user = django_user_service.get_current_user() self.assertTrue(xb_user.is_current_user) self.assert_is_anon_xb_user(xb_user)
err = SearchIndexingError mock_index_dictionary.return_value = err
self._each_parens('[x+y]', 'x+y', '[')
self.assertOLXIsPublishedOnly(block_list_to_delete) self.delete_item(block_list_to_delete, revision=revision) self._check_for_item_deletion(block_list_to_delete, result) self.assertOLXIsDeleted(block_list_children)
self.store.delete_course(self.course.id, self.user.id)
self.iteration = sharedX(theano._asarray(0, dtype='int32'), name='iter')
return self.q(css='#course-index-tabs .programs-tab a').present
this_file = __file__ if this_file.endswith(".pyc"):
test_discussion = self.store.create_child(self.user.id, course.location, 'discussion', 'test_discussion')
stub = get_request_or_stub() expected_url = "http://{site_name}/foobar".format(site_name=settings.SITE_NAME) self.assertEqual(stub.build_absolute_uri("foobar"), expected_url)
layer_to_state = dbm.make_layer_to_state(1) v_state = layer_to_state[v] h1_state = layer_to_state[h1] h2_state = layer_to_state[h2]
if depth == 0: self.get_module.side_effect = lambda x: LeafModuleFactory(descriptor_cls=HtmlDescriptor) else: self.get_module.side_effect = lambda x: ContainerModuleFactory( descriptor_cls=VerticalBlock, depth=depth - 1 )
china = np.array(china, dtype=np.float64) / 255
self.assertFalse([ requirement for requirement in requirements if requirement['namespace'] == 'proctored_exam' ])
X = 3 * diabetes.data
self.get_selector('#add-exception').click()
return self.runtime.get_edited_by(self)
self.assertIsNone(cohorts.get_cohort(user, course.id, assign=False))
'datadog',
certs_api.set_cert_generation_enabled(self.COURSE_KEY, True) self._assert_enabled_for_course(self.COURSE_KEY, True)
assert left is not right assert left.fixed_vars is not right.fixed_vars assert left.on_load_batch is not right.on_load_batch
video_outline = self.api_response().data self.assertEqual(len(video_outline), 0)
discount = Decimal("{0:.2f}".format(Decimal(percentage_discount / 100.00) * value)) return value - discount
if not ((requester_perms & STUDIO_EDIT_ROLES) or (user.id == request.user.id)): return permissions_error_response
data_home = get_data_home(data_home=DATA_HOME) assert_true(os.path.exists(data_home))
'RUN_AS_ANALYTICS_SERVER_ENABLED': False,
course_page.set_staff_view_mode_specific_student(student_b_username) verify_expected_problem_visibility(self, course_page, [self.beta_text, self.everyone_text])
greek.append('infty')
permutation = _find_permutation(sample_id_bis, sample_id) y = y[permutation, :]
def __init__(self, developer_message, user_message=None): self.developer_message = developer_message self.user_message = user_message
self.clear_subs_content()
self._send_immediate_response(True)
return check_question_author(user, Thread(id=content["thread_id"]).to_dict())
return def_id.block_type
super(AccountSettingsPageTest, self).setUp() self.full_name = XSS_INJECTION self.username, self.user_id = self.log_in_as_unique_user(full_name=self.full_name) self.visit_account_settings_page()
pass
return None
block_start = get_field_on_block(block_structure.get_xblock(block_key), 'start') if min_all_parents_start_date is None: merged_start_value = block_start or DEFAULT_START_DATE
self._check_params(n_samples)
params = self._signed_callback_params(self.order.id, "145.00", "145.00") result = process_postpay_callback(params)
'METADATA_URL': 'https://www.googleapis.com/youtube/v3/videos/',
gp = GaussianProcessRegressor(kernel=kernel, alpha=(dy / y) ** 2, n_restarts_optimizer=10)
assert X.ndim == 2 return T.nnet.softmax(X*self.P)
class UserPreferenceFactory(DjangoModelFactory): class Meta(object): model = UserPreference
tip = resolved(joinpath(base, dirname(info.name))) return _is_bad_path(info.linkname, base=tip)
return HttpResponseBadRequest(u'Could not parse request course key.')
assert_true(set(votes[:, class_idx]).issubset(set([0., 1., 2.])))
context = { 'reorderable_items': set(), 'read_only': True } problem_html = get_preview_fragment(request, self.problem, context).content
def __init__(self, W): self.W = W super(ModelWithW, self).__init__()
self._submit_photos(expected_status_code=400) self._assert_confirmation_email(False)
user = User(username=username, email=email, is_active=False) user.set_password(password)
pass
AutoAuthPage( self.browser, username=username, email=email, password=password ).visit()
with self.assertRaises(AssertionError): Cudnn2D(filters=self.filters, batch_size=-1, input_space=self.input_space)
self.assertNotContains(response, "How it Works") self.assertNotContains(response, "Find courses") self.assertNotContains(response, "Schools & Partners")
digits = datasets.load_digits() perm = rng.permutation(digits.target.size) digits.data = digits.data[perm] digits.target = digits.target[perm]
v_sample = tensor.matrix('ais_v_sample') beta = tensor.scalar('ais_beta')
U, S, V = randomized_svd(X, n_components, random_state=random_state) W, H = np.zeros(U.shape), np.zeros(V.shape)
self.course_nav.q(css='button.check.Check').click() self.course_nav.wait_for_ajax()
input_dict = {'1_2_1': '0', '1_2_2': '42'} correct_map = problem.grade_answers(input_dict)
clf = svm.LinearSVC(penalty='l2', dual=True, random_state=0).fit(X, Y) assert_array_equal(clf.predict(T), true_result)
httpretty.register_uri( httpretty.GET, "http://localhost:4567/api/v1/threads/{id}".format(id=thread["id"]), body=json.dumps(thread), status=200 )
self.instructor_dashboard_page = InstructorDashboardPage(self.browser, self.course_id) self.instructor_dashboard_page.visit() self.cohort_management_page = self.instructor_dashboard_page.select_cohort_management() self.cohort_management_page.wait_for_page()
AccessTestData(expected_access=True), AccessTestData(xblock_access={1: None}, expected_access=True), AccessTestData(xblock_access={1: []}, expected_access=True),
final_attrs['value'] = force_text(value)
display_headers.append(enrollment_report_headers.get(header_element, header_element))
return self._is_element_visible(".add-response-btn")
mask = label_counts > 1 n_samples = np.sum(mask) label_counts = label_counts[mask] k_all = k_all[mask] c = c[mask] radius = radius[mask]
self.assertEqual(self._mock_paver_sh.call_count, 1)
enrollment_mode = self.dashboard_page.get_enrollment_mode(self.course_info["display_name"]) self.assertEqual(enrollment_mode, 'honor')
result = get_email_params(self.course, False)
if self.database.connection.alive(): return True else: raise HeartbeatFailure("Can't connect to {}".format(self.database.name), 'mongo')
ax.view_init(40, -10)
metric_tag_fields = [ 'course_id', 'group_id', 'pinned', 'closed', 'anonymous', 'anonymous_to_peers', 'endorsed', 'read' ]
return caches[alias]
n_samples = [int(1e3), int(1e4), int(1e5), int(1e6)] n_features = int(1e2) n_queries = 100 n_neighbors = 10
self.create_programs_config(enabled=False) actual = utils.get_programs(self.user) self.assertEqual(actual, [])
problem = self.store.get_item(problem_location) problem.display_name = problem_new_name self.store.update_item(problem, self.user_id)
return self.browser.execute_script("return $('{}').is(':focus')".format(selector))
queryset = (ExampleCertificate.objects).select_related('example_cert_set').filter(example_cert_set=self) for cert in queryset: yield cert
img[i, j] /= float(min(i + 1, p_h, i_h - i) * min(j + 1, p_w, i_w - j))
try:
IPFilter.objects.create( blacklist="192.168.10.20", enabled=True )
version = '0.1' release = '0.1'
return urlparse(handler_url(self.block, 'handler', query=query_string)).query
assert max(pd.max(), hd.max()) < .17
self.assertIn("2015-JULY-17", text)
pass
CONTENT_RE = re.compile(r"(?P<start>\d{1,11})-(?P<stop>\d{1,11})/(?P<end>\d{1,11})")
CoursewareSearchIndexer.do_course_reindex(store, course.id)
DEBUG = True
c=self.cols, tabsize=self.tabsize, m=self.mode, payload=self.payload, ln=self.linenumbers)
self.service.remove_credit_requirement_status( self.user.id, self.course.id, 'grade', 'grade' )
self.assertIn( "Certificate has been successfully invalidated for {user}.".format(user=self.student_name), self.certificates_section.certificate_invalidation_message.text )
import logging logging.basicConfig(filename=TEST_ROOT / "log" / "lms_acceptance.log", level=logging.ERROR)
CourseOverview.objects.filter(id=course_key).delete()
def test_course_authorized_feature_off(self): BulkEmailFlag.objects.create(enabled=False, require_course_email_auth=True) cauth = CourseAuthorization(course_id=self.course.id, email_enabled=True) cauth.save()
sequence.default_time_limit_minutes += sequence.default_time_limit_minutes self.store.update_item(sequence, self.user.id)
try: static_content_store.save(content) except Exception as err: log.exception(u'Error importing {0}, error={1}'.format( fullname_with_subpath, err ))
response_data = self.reactivation_email(self.unregisteredUser) self.assertFalse(response_data['success'])
config.toggle() self.assertFalse(config.details_warning_icon_is_present) self.assertFalse(config.details_message_is_present)
self._create_course_unit(subtitles=True) self.assertTrue(self.video.is_captions_visible())
mock_call = mock_track_function.mock_calls[-1] event = mock_call[1][2]
asset_url = '' try: template_asset = CertificateTemplateAsset.objects.get(asset_slug=asset_slug) asset_url = template_asset.asset.url except CertificateTemplateAsset.DoesNotExist: pass return asset_url
S = -euclidean_distances(X, squared=True) preference = np.median(S) * 10 cluster_centers_indices, labels = affinity_propagation( S, preference=preference)
url( r'^reverify/{course_id}/{usage_id}/$'.format( course_id=settings.COURSE_ID_PATTERN, usage_id=settings.USAGE_ID_PATTERN ), views.InCourseReverifyView.as_view(), name="verify_student_incourse_reverify" ),
estimator = clone(self.estimator) if self.verbose > 0: print("Fitting estimator with %d features." % np.sum(support_))
n_classes = 3 n_estimators = 30 plot_colors = "ryb" cmap = plt.cm.RdYlBu
if self.credit_type[0] not in graders: raise LoncapaProblemError('partial_credit attribute should be one of: ' + ','.join(graders))
self.reset_RNG()
last_mean = np.zeros(n_features) last_var = np.zeros_like(last_mean) last_n = 0
'ENABLE_MAX_SCORE_CACHE': True,
patch_extractor = sp_extract_patches(IR, IC, KR, KC, CH, RasterOrders.row_col_channel, RasterOrders.row_col_channel, subsample, border_mode, flip_patches=True).tocsc()
assert_raises(ValueError, cv.fit, K_train.tolist(), y_train)
from scipy import misc face = misc.face(gray=True)
if self.centering: self.Xt[row] -= self.x_sum / normalizer
with np.errstate(divide='ignore'): retval = 1. / dist return retval ** 2
X = [[2, 1, 2], [9, 1, 1], [6, 1, 2], [0, 1, 2]] y = [0, 1, 2, 2]
pass
self.assertEqual(content.content_type, 'application/pdf')
hash_val = ",".join([ "{0}={1}".format(key, resp_params[key]) for key in signed_fields ]) resp_params['signature'] = processor_hash(hash_val)
self.assertEqual( certs_api.get_certificates_for_user(self.student_no_cert.username), [] )
msg_format += _(" (skipping {skipped})")
assert_greater(n_iter_reference, 2)
os.environ['REQUIRE_BUILD_PROFILE_OPTIMIZE'] = 'none'
self.Xt[:self.n_eigen,:] = self.Ut
resp = self.client.put(self._url()) self.assertEqual(resp.status_code, 405)
self.assertIn(REG_STR, resp.content)
y_test = check_array(y_test, dtype=np.float64, ensure_2d=False)
y = lfw_people.target target_names = lfw_people.target_names n_classes = target_names.shape[0]
if n_local_trials is None: n_local_trials = 2 + int(np.log(n_clusters))
USER_PARTITION_SCHEME_NAMESPACE = 'openedx.user_partition_scheme'
self.assert_matching_events_were_emitted( event_filter={'name': u'edx.instructor.report.requested', 'report_type': report_type} )
return modulestore().update_item(block, ModuleStoreEnum.UserID.test)
project = 'Pylearn2' copyright = '2011-2015, LISA lab'
self.assertEqual(len(mail.outbox), 0)
AutoAuthPage(self.browser).visit() url = BASE_URL + "/course_modes/choose/" + self.course_id self.browser.get(url) self._assert_dashboard_message()
self._goto_problem_page()
self.assertEquals(22, self.response.content.count('grade_F'))
if self.is_time_limited: view_html = self._time_limited_student_view(context)
batch_inertia, centers_squared_diff = _mini_batch_step( X_valid, x_squared_norms[validation_indices], cluster_centers, counts, old_center_buffer, False, distances=None, verbose=self.verbose)
if self.n_components is None: n_components = X.shape[1] else: n_components = self.n_components
resource = {"id": self.resource_id, 'reason': ''} self.check_event_response_by_http_status(test_case['handler'], resource, test_case['status'])
CreditCourse.objects.create(course_key=course.id, enabled=True)
try: section_content = about_information.get_value(**about_context)
return self.client.patch( self.url, json.dumps(request_data), content_type="application/merge-patch+json" )
def __init__(self, course_key): detail = _('[{course_key}] is not a valid course key.').format(course_key=course_key) super(InvalidCourseKey, self).__init__(detail)
self.assertFalse(form.is_valid())
return self.enabled and self.xseries_ad_enabled
_("Expected a {expected_tag} tag; got {given_tag} instead").format( expected_tag=u"<choice>", given_tag=choice.tag, )
for group_name in groups or set():
'subscription_id': course_overview.clean_id(padding_char='_'),
self.assertEqual(resp.status_code, 200)
if cal_sstats: norm_phi = np.dot(exp_doc_topic_d, exp_topic_word_d) + EPS suff_stats[:, ids] += np.outer(exp_doc_topic_d, cnts / norm_phi)
from __future__ import unicode_literals
generate_certificates_for_students( request, params["course_key"], student_set="specific_student", specific_student_id=params["user"].id ) return HttpResponse(200)
dbm = make_random_basic_binary_dbm( rng = rng, pool_size_1 = pool_size_1,
assert_greater((X_sparse.data == 0.).sum(), 0) assert_greater((X_sparse_test.data == 0.).sum(), 0)
input_element.click() input_element.send_keys(Keys.CONTROL + 'a') input_element.send_keys(value) return input_element
self._update_staff_locks(False, False, False) self.assertIsNone(utils.find_staff_lock_source(self.vertical))
generator = np.random.RandomState(0) mat = generator.rand(100, 100) scaled = _log_normalize(mat) + 1 _do_bistochastic_test(scaled)
store.save_asset_metadata_list(md_list, ModuleStoreEnum.UserID.test)
user = User.objects.get(email=staff_email) token = default_token_generator.make_token(user) uidb36 = int_to_base36(user.id)
self._enable_cohorting() self._create_verified_cohort() self._create_named_random_cohort("Random 1") self._create_named_random_cohort("Random 2") self._enable_verified_track_cohorting()
s = (y == 2) + (y == 4) X = X[s, :] y = y[s] y = (y != 2).astype(int)
from django.test import TestCase from nose.plugins.attrib import attr
self.assertFalse(VerifiedTrackCohortedCourse.is_verified_track_cohort_enabled(course_key))
(False, True), (False, False),
laplacian, dd = graph_laplacian(sims, normed=False, return_diag=True) _, diffusion_map = eigh(laplacian) embedding_2 = diffusion_map.T[:n_components] * dd embedding_2 = _deterministic_vector_sign_flip(embedding_2).T
split_test = self._add_split_test_to_vertical(number=0, group_configuration_metadata={'user_partition_id': 0})
monitor.add_channel( name='momentum', ipt=None, val=self.momentum, data_specs=(NullSpace(), ''), dataset=monitoring_dataset)
MOCK_SEARCH_BACKING_FILE = ( TEST_ROOT / "index_file.dat" ).abspath()
EmptyPromise(lambda: self.is_captions_visible() == captions_new_state, "Transcripts are {state}".format(state=state)).fulfill()
self.q(css="li.next").click() self.wait_for_ajax()
return JsonResponse( CourseDetails.update_from_json(course_key, request.json, request.user), encoder=CourseSettingsEncoder )
self.cohort_b_student_username = "cohort_b_student" self.cohort_b_student_email = "cohort_b_student@example.com" StudioAutoAuthPage( self.browser, username=self.cohort_b_student_username, email=self.cohort_b_student_email, no_login=True ).visit()
course_locator = self._map_revision_to_branch(course_locator) return super(DraftVersioningModuleStore, self).get_course_successors( course_locator, version_history_depth=version_history_depth )
self.client.logout() super(TestUsersDefaultRole, self).tearDown()
self.assertTrue(SAMLConfiguration.is_enabled(), "SAML Provider Configuration only works if SAML is enabled.") obj = SAMLProviderConfig(**kwargs) obj.save() return obj
assert_equals('never', seq.rerandomize)
self.enrollment.update_enrollment(mode=CourseMode.VERIFIED)
with self.assertNumQueries(0): embargo_api.check_course_access(unrestricted_course.id, user=self.user, ip_address='0.0.0.0')
self.register_page.click_third_party_dummy_provider()
old_roles.add(role)
minibatch_size = 1000
modulestore().update_item(course_updates, user.id)
user_list[0].course_groups.add(non_cohort) user_list[0].course_groups.clear() self.assertFalse(mock_tracker.emit.called)
if not has_access_on_students_profiles: raise Http404 try: student = User.objects.get(id=student_id) except (ValueError, User.DoesNotExist): raise Http404
page.wait_for_component_menu() click_css(page, 'button>span.large-discussion-icon', menu_index)
self.factory(n_iter=-10000)
group = RandomUserPartitionScheme.get_group_for_user(self.MOCK_COURSE_ID, self.user, self.user_partition)
params = self._signed_callback_params(self.order.id, self.COST, self.COST, decision='REJECT') result = process_postpay_callback(params)
self.delete_item(store, self.html_unit.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
if item.has_children: for child_loc in item.children: _internal_depth_first(child_loc, False)
cls.create_and_enroll_student( courses=[cls.test_course_2], username='student_enrolled_public_profile' ) profile = cls.users['student_enrolled_public_profile'].profile profile.year_of_birth = 1970 profile.save()
urlpath = None article = None
attempt.delete() status = SoftwareSecurePhotoVerification.user_status(user) self.assertEquals(status, ('must_reverify', "No photo ID was provided."))
return self.q(css='.wrapper-alert-error.is-shown').is_present()
tsne = TSNE(n_iter=199) assert_raises_regexp(ValueError, "n_iter .*", tsne.fit_transform, np.array([[0.0]]))
buckets = 10 bucket_width = 1. / float(buckets) for i in xrange(buckets): lower_lim = i * bucket_width upper_lim = (i+1) * bucket_width
self.assertEqual(len(new_stores), len(old_stores)) for new_store in new_stores: self.assertStoreValuesEqual(new_store, old_stores[new_store['NAME']])
if not badges_enabled(): return return function(*args, **kwargs)
answers = ["Second", "Third", "Fourth"]
return urlparse.urljoin(BASE_URL, relative_path)
msg += _('Email address must end in {domain}').format(domain="@{0}".format(email_domain)) return msg
self.assertEqual(response.status_code, 405)
X_FRAME_OPTIONS = 'ALLOW'
self.assertEquals(preview.latex_preview('2^3^4'), '2^{3^{4}}')
self._assert_reg_field( no_extra_fields_setting, { "name": "password", "type": "hidden", "required": False, } )
sh("i18n_tool generate --strict")
if estimator_error <= 0: return sample_weight, 1., 0.
if not xblock.group_access: return False for partition in get_user_partition_info(xblock): if any(g["selected"] for g in partition["groups"]): return True return False
the_html2 = problem.get_html() self.assertEquals(the_html, the_html2)
self.set_logged_in_cookies(request)
self.assertIsNone(self.service.get_credit_state(self.user.id, self.course.id))
if not settings.FEATURES.get('MILESTONES_APP', False): return {} from milestones import api as milestones_api return milestones_api.get_milestone_relationship_types()
for pkg_name in ['track.contexts', 'track.middleware', 'dd.dogapi']: logging.getLogger(pkg_name).setLevel(logging.CRITICAL)
result = first.copy() result.update(second) return result
if course_org_filter: org_filter_out_set.remove(course_org_filter)
bandwidth = estimate_bandwidth(X, quantile=0.2, n_samples=500)
problem_item.display_name = 'Problem_Item1' problem_item = self.store.update_item(problem_item, self.user_id) self.assertFalse(self.store.has_published_version(problem_item))
raise NotImplementedError(str(self.__class__) + " does not implement " "log_conditional.")
self.setup_user()
self.assertFalse(runtime.user_is_beta_tester) self.assertEqual(runtime.days_early_for_beta, 5)
raise NotImplementedError(str(self.__class__) + " does not implement " "log_p_z.")
nsamples[0].set_value(x) for ii, psample in enumerate(psamples): if ii > 0: nsamples[ii].set_value(psample.get_value())
modal.policy = 'Lab' modal.save()
#html_static_path.append('source/_static')
self.transformer_data = defaultdict(dict)
X[:, :n_informative] = generator.randn(n_samples, n_informative)
if self.n_components == 0: return np.diag(1. / self.noise_variance_) if self.n_components == n_features: return linalg.inv(self.get_covariance())
self.wait_for(lambda: self.speed == expected_speed, "Video speed changed")
course_one_team.add_user(self.user)
response_dict = self._get_page_data(response) self.assertEqual(response_dict['contribution_amount'], expected_amount)
return ( CourseKey.from_string(course_key_or_id) if isinstance(course_key_or_id, basestring) else course_key_or_id )
if not ignore_missing: for field in mandatory_fields: if field not in request_data: field_errors[field] = {'error_code': 'missing_field_{0}'.format(field)} if field_errors: return valid_input, field_errors
json_result = [] for key in keys: info = block_structure.get_transformer_block_field( key, ContentLibraryTransformer, 'block_analytics_summary' ) json_result.append(info) return json_result
if rerandomize in [RANDOMIZATION.NEVER, 'false', RANDOMIZATION.PER_STUDENT]: self.assertEqual(seed, _reset_and_get_seed(module))
X_3d = X[:, :, np.newaxis] clf = MockClassifier(allow_nd=True) scores = cross_val_score(clf, X_3d, y2)
url = reverse('course_modes_choose', args=[unicode(self.course.id)]) response = self.client.get(url)
with ignore_warnings(): yield check_transformer_n_iter, name, estimator
self.assertTrue(self._has_changes(draft_xblock.location))
self.assertTrue(has_access(beta_tester, 'load', self_paced_course)) self.assertTrue(has_access(beta_tester, 'load', self_paced_section, self_paced_course.id))
link = link.replace('\\', '/')
return _reduce_memmap_backed(a, m)
layers = [self.visible_layer] + self.hidden_layers
base_estimator = LinearRegression() ransac_estimator = RANSACRegressor(base_estimator, min_samples=2, residual_threshold=0.0, random_state=0)
cc_rendered_selector = self.get_element_selector(CSS_CLASS_NAMES['closed_captions']) self.wait_for_element_invisibility(cc_rendered_selector, 'Closed captions hidden')
dec = clf.decision_function(T) res = (dec > 0).astype(np.int) + 1 assert_array_equal(res, true_result)
raise NotImplementedError('Not implemented for sparse dataset')
self.base_extauth_bypass_sending_activation_email(True)
index = rng.randint(0, len(correct_choices) - 1) correct_choice = correct_choices[index] solution_id = correct_choice.get('explanation-id')
self.new_email = email self.activation_key = uuid.uuid4().hex self.save() return self.activation_key
with self._capture_assertion_errors(): context = assertion(*args, **kwargs)
raise NotImplementedError()
return [x for sub in seq for x in sub]
response = self.send_get(client, query_parameters='view=shared') verify_fields_visible_to_all_users(response)
self.wait_for_field('image') default_links = self.q(css='.image-frame').attrs('src') return 'profiles/default' in default_links[0] if default_links else False
self._advanced_settings.update(settings)
mongo_db = { 'host': 'localhost', 'user': '', 'password': '', 'db': 'xlog', }
for k, prec in enumerate(precisions): prec = _check_precision_matrix(prec, covariance_type)
self._assert_course_verification_status(VERIFY_STATUS_MISSED_DEADLINE)
return course_mode_tuple.slug in [cls.PROFESSIONAL, cls.NO_ID_PROFESSIONAL_MODE] if course_mode_tuple else False
X_sparse_test = X_sparse_test.copy()
request = RequestFactory() request.COOKIES = {} request.META = {} request.path = '/' return request
print "Starting export" file_system = OSFS(root_dir) initial_course.runtime.export_fs = file_system.makeopendir(course_dir) root = lxml.etree.Element('root')
from sklearn.tree._tree import TREE_LEAF k = 4
context['script_code'] = all_code context['python_path'] = python_path context['extra_files'] = extra_files or None return context
draft_course_structure = self._lookup_course(draft_course_key).structure new_structure = self.version_structure(draft_course_key, draft_course_structure, user_id)
if user not in self._user_enrollments: self._user_enrollments[user] = CourseEnrollment.enrollments_for_user(user) return self._user_enrollments[user]
w = clf.coef_[0] a = -w[0] / w[1] xx = np.linspace(-5, 5) yy = a * xx - (clf.intercept_[0]) / w[1]
clf_sigmoid = CalibratedClassifierCV(clf, cv=2, method='sigmoid') clf_sigmoid.fit(X_train, y_train, sw_train) prob_pos_sigmoid = clf_sigmoid.predict_proba(X_test)[:, 1]
assert_raises(ValueError, _fast_dot, A, A[0])
course_key = course.id if view_as_ccx: course_key = CCXLocator.from_course_locator(course_key, self.ccx.id) return progress( self.request, course_id=unicode(course_key), student_id=self.student.id )
self.assertFalse(self._has_changes(parent.location)) self.assertFalse(self._has_changes(child.location))
course_module = modulestore().get_course(course_id) if course_module is None: return Response(status=status.HTTP_404_NOT_FOUND)
call_command('post_cohort_membership_fix', commit='commit')
indent_next = logical_line.endswith(':')
return User.objects.filter( courseenrollment__course_id=course_id, courseenrollment__is_active=True )
log.warning("get_all_asset_metadata request of XML modulestore - not implemented.") return []
self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))
precor = [None] * len(self.activations) for idx, val in evens_copy + odds_copy: assert precor[idx] is None precor[idx] = val assert None not in precor
elem = self.get_setting_element(label) if elem: select = Select(elem) return select.first_selected_option.text else: return None
usage_key = self._map_revision_to_branch(usage_key, revision=revision) return super(DraftVersioningModuleStore, self).has_item(usage_key)
pass
try: user_certificate = GeneratedCertificate.eligible_certificates.get( user=user, course_id=course_key, status=CertificateStatuses.downloadable ) except GeneratedCertificate.DoesNotExist: pass
self.factory(alpha=0, learning_rate="optimal")
'openedx.core.djangoapps.bookmarks',
if drop and method == 'lasso':
self.make_course(textbooks=[IMAGE_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('book', book_index=0, page='xyzzy')
self.assert_grade(problem, '42', 'correct') self.assert_grade(problem, '0', 'incorrect')
return self.db_connection.mongo_wire_version
self._assert_num_attempts(students, initial_attempts) self._test_run_with_task(reset_problem_attempts, 'reset', num_students) self._assert_num_attempts(students, 0)
super(CoursePage, self).__init__(browser) self.course_info = { 'course_org': course_org, 'course_num': course_num, 'course_run': course_run }
gmm2 = GaussianMixture(n_components=n_components, n_init=1, reg_covar=0, random_state=rng, covariance_type=covar_type).fit(X) assert_greater(gmm2.score(X), gmm1.score(X))
page_input = self.q(css="#page-number-input")[0] page_input.click() page_input.send_keys(str(number)) page_input.send_keys(Keys.RETURN) self.wait_until_ready()
return sig.replace(parameters=tuple(sig.parameters.values())[1:])
course_module = self.store.get_course(target_id)
X, y = make_blobs(n_samples=80, centers=4) brc = Birch(threshold=0.5, n_clusters=None) brc.fit(X) check_threshold(brc, 0.5)
return True
self.initialize_course( course_factory_kwargs={ 'user_partitions': [user_partition] } )
set_has_profile_image(username, False)
rng = np.random.RandomState(0) n_samples, n_features = 500, 2
if key == settings.SESSION_COOKIE_NAME: domain = microsite.get_value('SESSION_COOKIE_DOMAIN', domain)
self.socket.close()
with descriptor.runtime.export_fs.open('course/{url_name}.xml'.format(url_name=url_name)) as f: course_xml = etree.fromstring(f.read())
return self.q(css=self.auto_enroll_browse_button_selector).is_present()
forest = ExtraTreesClassifier(n_estimators=250, random_state=0)
field_overrides = current_provider.get_register_form_data( running_pipeline.get('kwargs') )
for k, v in webresponse.headers.iteritems(): http_response[k] = v
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
clf_constrained = LassoCV(n_alphas=3, eps=1e-1, max_iter=max_iter, positive=True, cv=2, n_jobs=1) clf_constrained.fit(X, y) assert_true(min(clf_constrained.coef_) >= 0)
resp = self.client.get(reverse('shoppingcart.views.show_receipt', args=[self.cart.id])) self.assertEqual(resp.status_code, 200)
self.request.user = self.user context = user_has_cart_context_processor(self.request) self.assertFalse(context['should_display_shopping_cart_func']())
self.errored_courses[course_dir] = errorlog
return self.backend_name == pipeline['backend'] and self.idp_slug == pipeline['kwargs']['response']['idp_name']
module = CapaFactory.create(max_attempts="1", attempts="2") self.assertTrue(module.closed())
#end class
self.assertEquals( self.middleware.process_response(self.request, self.response), self.response ) exit_context.assert_called_with(UserTagsEventContextMiddleware.CONTEXT_NAME) exit_context.reset_mock()
certificate_count = 3 for __ in xrange(certificate_count): self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.generating)
from random import choice from string import letters, digits, punctuation RANDOM_SHARED_SECRET = ''.join( choice(letters + digits + punctuation) for x in range(250) )
try: if os.path.exists(folder_path): shutil.rmtree(folder_path) except WindowsError: warnings.warn("Failed to clean temporary folder: %s" % folder_path)
pw = ParzenWindows(MNIST(which_set='test').X, .20) print(pw.get_ll(history))
return get_test_system(course_id=self.course.id)
return OrderedDict()
if settings.FEATURES.get("ENABLE_LTI_PROVIDER"): urlpatterns += ( url(r'^lti_provider/', include('lti_provider.urls')), )
self.assertTrue(certificate_generation_history.exists())
parent = kwargs.pop('parent', None) or store.get_item(parent_location)
if not cuda.cuda_available: convnet_available.compile_error = True _logger.debug('cuda unavailable') return False
n_classes_ = [n_classes_] classes_ = [classes_] class_prior_ = [class_prior_] constant = [constant]
b = clf.support_vectors_[0] yy_down = a * xx + (b[1] - a * b[0]) b = clf.support_vectors_[-1] yy_up = a * xx + (b[1] - a * b[0])
self._test_email_address_failures(SESDomainEndsWithDotError(554, "Email address ends with a dot"))
found_rerun = CourseRerunState.objects.find_first(course_key=self.course_key) found_rerun_state = {key: getattr(found_rerun, key) for key in self.expected_rerun_state} self.assertDictEqual(found_rerun_state, self.expected_rerun_state) return found_rerun
xblock = self.store.create_item( self.user_id, test_course.id, 'vertical', block_id='test_vertical' )
from __future__ import unicode_literals
n_min = plots.shape[1] n_min -= int(np.ceil(plots.shape[1] * self.share)) plots = plots[:, n_min:]
expected_p, expected_h = h1.mf_update( state_below = v.upward_state(v_state), state_above = h2.downward_state(h2_state), layer_above = h2)
mailing_address_label = _(u"Mailing address")
for code in [129, 500, 2 ** 8 - 1, 2 ** 16 - 1]:
self.assertTrue(has_access(self.beta_tester, 'load', self.content, self.course.id))
self.verify_content_existence(self.store, root_dir, course_id, 'about', 'about', '.html')
raise NotImplementedError()
return course_mode_tuple.slug in cls.CREDIT_MODES
redirect_to = get_next_url_for_login_page(request) if request.user.is_authenticated(): return redirect(redirect_to)
ans = False
assert world.is_css_present(sel)
resp = self.client.get_json(course_update_url) payload = json.loads(resp.content) self.assertTrue(len(payload) == 1)
link = link[3:]
attempts_left_open = CapaFactory.create(showanswer='past_due', max_attempts="1", attempts="0", due=self.tomorrow_str) self.assertFalse(attempts_left_open.answer_available())
'dark_lang.middleware.DarkLangMiddleware',
def obj_func(theta, eval_gradient=True): if eval_gradient: lml, grad = self.log_marginal_likelihood( theta, eval_gradient=True) return -lml, -grad else: return -self.log_marginal_likelihood(theta)
def fit(self, X, y): return self
stored_file_name = file_storage.save(stored_file_name, uploaded_file)
self.assertFalse( utils.is_commentable_cohorted(course.id, to_id("General")), "Course doesn't even have a 'General' topic" )
ans = commentable_id in course_cohort_settings.cohorted_discussions
self.q(css='a[data-section=special_exams]').first.click() timed_exam_section = SpecialExamsPage(self.browser) timed_exam_section.wait_for_page() return timed_exam_section
#html_last_updated_fmt = '%b %d, %Y'
with patch( 'openedx.core.lib.block_structure.transformer_registry.TransformerRegistry.get_registered_transformers' ) as mock_available_transforms: mock_available_transforms.return_value = {transformer for transformer in transformers} yield
self._verify_unit_warning( self.UnitState(is_released=False, publish_state=self.PublishState.NEVER_PUBLISHED, is_locked=True), self.STAFF_ONLY_WARNING )
if self.act_enc is None: act_enc = lambda x: x else: act_enc = self.act_enc return act_enc(self._mappings(inputs))
for option in self._find_options(inputfield): if option['choice'] == choice: return option
for tab in tab_list: if tab.type == tab_type: return True return False
user = UserFactory() allow_access(self.course, user, 'beta') self.assertTrue(CourseBetaTesterRole(self.course.id).has_user(user))
if LANGUAGE_SESSION_KEY in request.session: del request.session[LANGUAGE_SESSION_KEY]
with self.assertNumQueries(1): CountryAccessRule.check_country_access(course_id, 'NZ')
CourseEnrollment.enroll(user, course_key)
#html_copy_source = True
question_element = rendered_html.find("p") self.assertEqual(question_element.text, "Test question")
microsite.set_by_domain('unknown') self.assertIsNone(microsite.get_value('platform_name'))
random_state = self.random_state_ if random_init else None
if name: choice_element.text = str(name) choice_element.set("name", str(name))
component.display_name = 'Changed Display Name'
return self[u'name']
self.assertEqual(self.browse_teams_page.header_name, self.topic['name']) self.assertEqual(self.browse_teams_page.header_description, self.topic['description'])
if redirect: self.assertRedirects(response, reverse('dashboard')) else: self.assertEquals(response.status_code, 200)
old_center_buffer = np.zeros(n_features, np.double)
self.user.is_active = False self.user.save() verify_get_own_information(9)
def setUp(self): super(TestCase, self).setUp() self.enabled_provider = self.configure_google_provider(enabled=True)
self.setup_mongo_course() result_fragment = self.module.render(STUDENT_VIEW, context=self.default_context) self.assertIn('View Unit in Studio', result_fragment.content)
content = String(default="content", scope=Scope.content)
return self.q(css='.advance-modules-list li').text
(options, __) = parser.parse_args(arglist, values=new_options)
logger.debug( "Comment Service received PUT request {0} to path {1}" .format(json.dumps(post_dict), self.path) )
self.course_entry = CourseEnvelope(course_entry_override.course_key, self.course_entry.structure)
clf = self.factory(alpha=0.1, n_iter=1000, class_weight=[0.5]) clf.fit(X, Y)
return dict(zip(('user', 'course_key', 'course_mode', 'processor'), patched_create_order.call_args[0]))
"shareable_fields": [ 'username', 'profile_image', 'country', 'time_zone', 'language_proficiencies', 'bio', 'account_privacy', 'accomplishments_shared', ],
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
filename_extension = 'xml'
return self.list_display
self.submit_answer('Correct', 'Incorrect') self.assertEqual(self.get_progress_detail(), u'1/2')
self.logout() self.login(self.test_user.email, 'test')
assert_equal(grid_search.best_score_, 1.0) best_vectorizer = grid_search.best_estimator_.named_steps['vect'] assert_equal(best_vectorizer.ngram_range, (1, 1))
self._add_entrance_exam() self._pass_entrance_exam() self.init_course_access() self.api_response()
super(CeleryConfigTest, self).setUp() self.client = Client() self.ping_url = reverse('status.service.celery.ping')
if name in CROSS_DECOMPOSITION: for iter_ in estimator.n_iter_: assert_greater_equal(iter_, 1) else: assert_greater_equal(estimator.n_iter_, 1)
role, __ = Role.objects.get_or_create(course_id=course_id, name=FORUM_ROLE_STUDENT) user.roles.add(role)
self.click_button('handout_clear')
if asset_collection.name in asset_collection.database.collection_names():
probas_pred = probas_pred[:, 1]
self.coach = coach = AdminFactory.create(password="test") self.client.login(username=coach.username, password="test")
X, y = iris.data, iris.target y_bin = y.copy() y_bin[y_bin == 2] = 0
self.client.logout() resp = self._activate_user(self.email) self.assertEqual(resp.status_code, 200)
response = self.client.post(self.url, { "password": self.PASSWORD, }) self.assertHttpBadRequest(response)
if button == 'pause': self.wait_for(lambda: self.state != 'buffering', 'Player is Ready for Pause')
FEATURES['ENABLE_EDXNOTES'] = True
return StackedBlocks(layers)
from lxml import etree import unittest import xml.sax.saxutils as saxutils
course = self.store.create_course('org_x', 'course_y', 'run_z', self.user_id) course_key = course.id
return self._block_relations[usage_key].parents if usage_key in self else []
expiration_datetime_is_explicit = models.BooleanField(default=False)
self.assertTrue(self.creator_admin.has_change_permission(self.request)) self.request.user = self.user self.assertFalse(self.creator_admin.has_change_permission(self.request))
self.assertDictContainsSubset({'attempted': 2, 'succeeded': 2, 'failed': 0}, task_result)
non_editable_fields.extend([DiscussionDescriptor.discussion_id, DiscussionDescriptor.sort_key]) return non_editable_fields
self.q(css='a[data-section=membership]').first.click() membership_section = MembershipPage(self.browser) membership_section.wait_for_page() return membership_section
patcher = mock.patch.object(linter_class, '_is_valid_directory', return_value=True) patch_start = patcher.start() self.addCleanup(patcher.stop) return patch_start
return "{}/{}".format(self._badge_create_url, slug)
best_labels, best_inertia = \ _labels_inertia(X, x_squared_norms, best_centers, precompute_distances=precompute_distances, distances=distances)
eps = 0.8 min_samples = 10 metric = 'euclidean' core_samples, labels = dbscan(X, metric=metric, eps=eps, min_samples=min_samples)
return [ factories.UserCredential( id=1, username='test', credential=factories.ProgramCredential() ), factories.UserCredential( id=2, username='test', credential=factories.ProgramCredential() ) ]
for staged_proba in clf.staged_predict_proba(X_test): assert_equal(y_test.shape[0], staged_proba.shape[0]) assert_equal(2, staged_proba.shape[1])
fig = plt.figure() plt.subplots_adjust(hspace=-.1, wspace=.4, top=.95, bottom=.05)
url = reverse('dashboard')
fields = self.q(css='div.problem div.capa_inputtype.textline input') fields = fields.nth(input_num) if input_num is not None else fields fields.fill(text)
course_image_asset_key = StaticContent.compute_location(course.id, course.course_image) course_image_content = StaticContent(course_image_asset_key, image_name, 'image/jpeg', image_buff) contentstore().save(course_image_content)
for descriptor in items:
raise ValueError( "kd_tree algorithm does not support callable metric '%s'" % metric)
return obj.user.email
tapi, ntaps = 0, 0
split_test_module.user_partition_id = -1 [active_children, inactive_children] = split_test_module.active_and_inactive_children() self.assertEqual(active_children, []) self.assertEqual(inactive_children, children)
response = self.client.get( self._url(), HTTP_ACCEPT="text/plain", ) self.assertEqual(response.status_code, 406)
Y = np.vstack((y_diabetes, y_diabetes)).T n_features = X_diabetes.shape[1]
X = check_array(X, accept_sparse=['csc'], ensure_2d=False) if issparse(X): X.sort_indices()
gated_content = gating_api.get_gated_content(course, student)
from __future__ import unicode_literals
is_movable = True
course.position = 2 course.save()
mb_k_means = MiniBatchKMeans(init="random", n_clusters=n_clusters, random_state=42, n_init=10).fit(X_csr) _check_fitted_model(mb_k_means)
if not self.hyperparameter_length_scale.fixed: length_scale_gradient = \ 4 / self.length_scale**2 * sin_of_arg**2 * K length_scale_gradient = length_scale_gradient[:, :, np.newaxis]
TestScenario((self.demo_course,), "Empty"), TestScenario((self.html_course,), "Intro to <html>"),
random_state = check_random_state(0) y_true = random_state.randint(0, 2, size=(20, )) y_pred = random_state.randint(0, 2, size=(20, ))
new_candidates = [] for candidate in candidates: if candidate.endswith('.xml'): new_candidates.append(candidate[:-4] + '.html') return candidates + new_candidates
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
n_i = used_node[i] n_j = used_node[j] used_node[k] = n_i + n_j used_node[i] = used_node[j] = False
locator_cls = CCXBlockUsageLocator if isinstance(course_key, CCXLocator) else BlockUsageLocator return locator_cls(course_key, 'course', 'course')
#templates_path.append('source/_templates')
X_nan = np.arange(4).reshape(2, 2).astype(np.float) X_nan[0, 0] = np.nan assert_raises(ValueError, check_array, X_nan)
def __init__(self, access_key, secret_key): pass def get_bucket(self, bucket_name): return MockBucket(bucket_name)
assert_raises(ValueError, cval.KFold, 5, 1.5) assert_raises(ValueError, cval.StratifiedKFold, y, 1.5)
S = func([[1]], metric='precomputed') assert_true(isinstance(S, np.ndarray))
self.setup_mongo_course() result_fragment = self.module.render(STUDENT_VIEW, context=self.default_context) self.assertIn('View Unit in Studio', result_fragment.content)
msg_format = _("Problem {action} for {succeeded} of {attempted} students")
if self.display_organization: return self.display_organization return self.org
test_score = np.zeros((params['n_estimators'],), dtype=np.float64)
COURSE_ENROLLMENT_CACHE_KEY = u"enrollment.{}.{}.mode"
answers = ["Second", "Third", "Fourth"] problem = self.build_problem(answer="sample_answer", case_sensitive=False, additional_answers=answers)
with patch('capa.responsetypes.LoncapaResponse.evaluate_answers') as mock_evaluate_answers: mock_evaluate_answers.return_value = CorrectMap(CapaFactory.answer_key(), 'correct') result = module.rescore_problem()
X = np.array(list(product(range(N_per_side), repeat=2)))
self.visit(node)
'reverification',
return self.q(css=self.PAGINATION_HEADER_TEXT_CSS).text[0]
random_state = check_random_state(0)
clf.fit(docs_train, y_train)
with self.assertRaisesRegexp(LTIError, "Content-Type must be"): request = Mock(headers={u'Content-Type': u'Non-existent'}) self.xmodule.verify_lti_2_0_result_rest_headers(request)
return {'access_token', 'refresh_token', 'token_type', 'expires_in', 'scope'}
return {self.answer_id: self.initial_display}
if not self.q(css="input.proctored_exam").present: return False
self._auto_auth(self.USERNAME, self.EMAIL, False) self.dashboard.visit()
self.total_violations += 1 self.totals_by_rule[violation.rule.rule_id] += 1
self.client.logout() ModuleStoreTestCase.tearDown(self)
movie_reviews_data_folder = sys.argv[1] dataset = load_files(movie_reviews_data_folder, shuffle=False) print("n_samples: %d" % len(dataset.data))
resource = {"id": self.non_existing_resource_id, 'reason': ''} self.check_event_response_by_http_status(test_case, resource, 400)
self.assertIn("copyright", json_data)
return self.q(css=self._bounded_selector('.xblock-author_view'))[0].text
block = self._add_simple_content_block()
world.browser.execute_script('window.confirm = function(){return true;} ; window.alert = function(){return;}')
if noise > 0.0: y += generator.normal(scale=noise, size=y.shape)
self.submit_question_answer('p1', {'2_1': 'Incorrect'})
SECRET_KEY = '85920908f28904ed733fe576320db18cabd7b6cd'
return self.EXPORTED_COURSE_AFTER_DIR_NAME.format(unicode(uuid.uuid4())[:8])
packages_really_to_remove.append(this_package)
return self.data_specs
error_msg = _("An error occurred while deleting the score.") return HttpResponse(error_msg, status=500)
return [ tt.upper() for tt in map(_ustr,t) ]
self.assertEqual(len(httpretty.httpretty.latest_requests), count)
while top_level_logger.handlers: top_level_logger.handlers.pop()
if getattr(xblock, "in_entrance_exam", False): xblock_info["is_header_visible"] = False
module.new_lcp.assert_called_once_with(None)
self.current_video_display_name = video_display_name
self.prog_name = "{} {}".format(prog_name, subcommand) return super(TrackedCommand, self).create_parser(prog_name, subcommand)
actual_branch_setting = self.get_branch_setting() if actual_branch_setting != expected_branch_setting: raise InvalidBranchSetting( expected_setting=expected_branch_setting, actual_setting=actual_branch_setting )
self.xblock.location = Location("org", "import", "run", "category", "stubxblock")
self.assertIsNone(self.profile.age)
res = linkage_tree(X, affinity=manhattan_distances) assert_array_equal(res[0], linkage_tree(X, affinity="manhattan")[0])
from __future__ import unicode_literals
credit_course = self.add_credit_course() CreditEligibility.objects.create( course=credit_course, username="staff", deadline=datetime.datetime.now(pytz.UTC) - datetime.timedelta(days=1) )
reg = RidgeClassifierCV(class_weight={1: 0.001}, alphas=[.01, .1, 1, 10]) reg.fit(X, y)
course_id = CourseKeyField(max_length=255, db_index=True)
response = self.client.post(self.url, { "email": self.EMAIL, "password": self.PASSWORD, }) self.assertHttpOK(response)
make_asset_xml(num_assets, ASSET_XML_PATH) validate_xml(ASSET_XSD_PATH, ASSET_XML_PATH)
#html_sidebars = {}
embargo_redirect = embargo_api.redirect_if_blocked( course.id, user=request.user, ip_address=get_ip(request), url=request.path ) if embargo_redirect is not None: return redirect(embargo_redirect)
W = rng.uniform(-self.irange, self.irange, (input_dim, self.dim))
vectorizer = vec_factory(max_df=0.6, max_features=4) vectorizer.fit(ALL_FOOD_DOCS) assert_equal(set(vectorizer.vocabulary_), expected_vocabulary) assert_equal(vectorizer.stop_words_, expected_stop_words)
html_static_path = ['images']
estimator.partial_fit(X, y, np.array((0, 1))) return estimator
raise NotImplementedError()
raise ItemNotFoundError(course_locator)
problem_name, correctness = scenarios[name] problem = problems[problem_name]
versions = get_course_versions(unicode(self.course.id)) draft_version = versions['draft-branch'] published_version = versions['published-branch']
if not correct: second_addend += random.randint(1, 10)
if not len(w) > 0: raise AssertionError("No warning raised when calling %s" % func.__name__)
self.assertDeserializeEqual('"false"', '"false"') self.assertDeserializeNonString()
self.q(css='.dropdown').first.click()
'html5_sources': ['http://www.example.com/source.mp4'], 'data': ''
problem = self.build_problem(answer=u"\\\\", case_sensitive=False, regexp=True) self.assert_grade(problem, u"\\", "correct")
OverrideFieldData.provider_classes = None OverrideModulestoreFieldData.provider_classes = None
return '{}[data-locator="{}"] {}'.format( self.BODY_SELECTOR, self.locator, selector )
usage_key = UsageKey.from_string(usage_key_string) usage_key = usage_key.replace(course_key=modulestore().fill_in_run(usage_key.course_key)) return usage_key
self.course_info_page.visit() self.tab_nav.go_to_tab('Test Static Tab') self.assertTrue(self.tab_nav.is_on_tab('Test Static Tab'))
self.notes_page.go_to_page(3) self._verify_pagination_info( notes_count_on_current_page=1, header_text='Showing 26-26 out of 26 total', previous_button_enabled=True, next_button_enabled=False, current_page_number=2, total_pages=2 )
call_command('import', self.content_dir, self.good_dir) store = modulestore() self.assertIsNotNone(store.get_course(self.base_course_key))
self.client.login(username=self.global_staff.username, password="test") self._assert_certificates_visible(True)
self._set_mock_request_data(mock_request, { "threads_count": threads_count, "comments_count": comments_count, })
self.assertEqual(len(site_configuration_history), 1)
return self.q(css=self._bounded_selector('a.duplicate-button'))
self.assertTrue('success' in result and result['success'])
return self.q(css="#report-downloads-table .file-download-link>a")
self.assertEqual(actual, expected)
CREDIT_TASK_DEFAULT_RETRY_DELAY = 30
self.q(css=self.content_groups_css + " .new-button").first.click()
self.client.login(username="inactive", password=self.PASSWORD)
newrelic.agent.add_custom_parameter('seq.num_units', len(display_items))
about_base = re.sub(r"^https?://", "", about_base)
return REQUEST_CACHE.request
set_limit = numpy.ceil(numpy.divide(set_sizes, set_batch)) self.limit = map(int, set_limit)
with super(CreateCommentUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
pass
certificate_template_asset.asset = SimpleUploadedFile('picture2.jpg', 'file contents') certificate_template_asset.save()
if content.thumbnail_location is not None: try: thumbnail_content = trash.find(content.thumbnail_location) store.save(thumbnail_content) except Exception:
self.cohort_management_page.save_discussion_topics(key)
X = np.ones((5, 10))
if not overrides_disabled(): for provider in self.providers: value = provider.get(block, name, NOTSET) if value is not NOTSET: return value return NOTSET
self.support = UserFactory( username=self.SUPPORT_USERNAME, email=self.SUPPORT_EMAIL, password=self.SUPPORT_PASSWORD, ) SupportStaffRole().add_users(self.support)
from __future__ import unicode_literals
self.orderitem_set.all().delete()
topo = self.train_set.get_batch_topo(1) assert topo.ndim == 4
for section in self.course_outline_page.sections(): section.expand_subsection()
layer_to_state = dbm.make_layer_to_state(1) v_state = layer_to_state[v] h1_state = layer_to_state[h1] h2_state = layer_to_state[h2]
X_small = X[:, :4] lw = LedoitWolf() lw.fit(X_small) shrinkage_ = lw.shrinkage_
pass
html_theme_options = {'oldversion': False, 'collapsiblesidebar': True, 'google_analytics': True, 'surveybanner': False, 'sprintbanner': True}
from config_models.models import cache
profile_path = reverse('learner_profile', kwargs={'username': "no_such_user"}) response = self.client.get(path=profile_path) self.assertEqual(404, response.status_code)
sparse_results = sparse_classifier.decision_function(X_test_sparse) dense_results = dense_classifier.decision_function(X_test) assert_array_equal(sparse_results, dense_results)
request = RequestFactory().request() request.user = user all_tabs = get_course_tab_list(request, course) return any([tab.name == u'My Notes' for tab in all_tabs])
@property def score(self): raise AttributeError
return ( cls.is_restricted_course(unicode(course_id)) and cls._get_restricted_courses_from_cache().get(unicode(course_id))["disable_access_check"] )
if self.scope_ids.user_id is not None and user_id == self.scope_ids.user_id: if getattr(xmodule_runtime, 'position', None):
self.course_nav.go_to_vertical('Test Vertical-2')
self.assertEqual( res_json['message'], u"{user} does not exist in the LMS. Please check your spelling and retry.".format(user=invalid_user), )
self._verify_unit_warning( self.UnitState(is_released=True, publish_state=self.PublishState.UNPUBLISHED_CHANGES, is_locked=True), self.STAFF_ONLY_WARNING )
request.need_to_delete_cookie = True
return lxml.html.tostring(self.html, pretty_print=pretty_print)
return '{num_members} / {max_size} {members_text}'.format( num_members=num_members, max_size=max_size, members_text='Member' if num_members == max_size else 'Members' )
self._metric_base = metric_base self._sample_rate = sample_rate
rval = -(self.beta * T.dot(state, self.bias))
return self.country_access_rules(request.user, ip_address, request.path)
super(TestGenerateCourseBlocks, self).setUp() self.course_1 = CourseFactory.create() self.course_2 = CourseFactory.create() self.command = generate_course_blocks.Command()
tab_css = self._tab_css(tab_name)
with open(filename) as f: results = f.read() os.remove(filename) return results
CourseSalesAdminRole(self.course.id).add_users(instructor)
for course in courses: self.enroll(course.id)
Xy = np.empty(shape=n_features, dtype=common_dtype, order='C') np.dot(X.T, y, out=Xy)
return self.q(css='.is-active').attrs('data-url')[0]
BACKEND.set_config_by_domain(domain)
check_is_fitted(self, 'estimator_') return self.estimator_.predict(X)
transcripts = Dict(
if tree.n_outputs == 1: value = tree.value[node_id][0, :] else: value = tree.value[node_id]
response = self._get_page( 'verify_student_upgrade_and_verify', course.id, expected_status_code=302 ) self._assert_redirects_to_verify_start(response, course.id)
assert_equal( self.components_.shape, (self.n_components_, n_features), err_msg=('An error has occurred the self.components_ matrix has ' ' not the proper shape.'))
print("--- Sparse matrices")
return LibraryLocator( org=library_info['org'], library=library_info['course'], branch=branch, )
self.server.config['test_1'] = {'response': True} self.server.config['test_2'] = {'response': False}
phase_variable = 'PYLEARN2_TRAIN_PHASE' phase_value = 'phase%d' % (number + 1) os.environ[phase_variable] = phase_value
if not settings.FEATURES.get('ENABLE_CORS_HEADERS'): raise MiddlewareNotUsed()
params, response = _validate_post_params(request.POST) if response is not None: return response
for plot in self.plots: if plot.freq is None: plot.freq = self.freq
with super(ForumFormDiscussionUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
grad_shared = sharedX(zv) z_shared = sharedX(zv)
self.assertEqual(len(response.redirect_chain), 1) self.assertIn(302, response.redirect_chain[0]) self.assertEqual(len(outbox), outbox_count) if send_email:
return resolve_iterator_class(mode).uniform_batch_size
AUDIT_LOG.info("Redemption of a invalid RegistrationCode %s", registration_code) limiter.tick_bad_request_counter(request) raise Http404()
if location.category in DIRECT_ONLY_CATEGORIES: return location return location.replace(revision=MongoRevisionKey.draft)
course_page = self._goto_staff_page() course_page.set_staff_view_mode_specific_student(student_a_username) verify_expected_problem_visibility(self, course_page, [self.alpha_text, self.everyone_text])
enable_mktg_site = microsite.get_value( 'ENABLE_MKTG_SITE', settings.FEATURES.get('ENABLE_MKTG_SITE', False) ) if enable_mktg_site: return name in settings.MKTG_URLS else: return name in settings.MKTG_URL_LINK_MAP
self.assertEqual(module.attempts, 1)
css = '.group-name' return self.find_css(css).first.text[0]
return getattr(estimator, "_estimator_type", None) == "classifier"
self.assertListEqual( self.get_item_from_modulestore(self.seq2_usage_key).children, [] )
mb_k_means = MiniBatchKMeans(n_clusters=20, batch_size=201, random_state=42, init="random") mb_k_means.fit(zeroed_X) assert_greater(mb_k_means.cluster_centers_.any(axis=1).sum(), 10)
params_without_course_id = get_params_from_user_info_call(False) self.assertNotIn("group_id", params_without_course_id)
xblocks = self.course_fixture.get_nested_xblocks(category="vertical") for index in range(num_units): self._bookmark_unit(xblocks[index].locator)
return _dismiss_notification(request, action_state_id)
self.course.discussion_topics = {} self.course.save() self.discussion_num = 0 self.instructor = InstructorFactory(course_key=self.course.id)
courses_list, __ = _accessible_courses_list(self.request) self.assertEqual(len(courses_list), 1)
plt.scatter(X_test[:, 0], X_test[:, 1], s=80, facecolors='none', zorder=10)
courses_list = list(get_course_enrollments(self.student, None, [])) self.assertEqual(len(courses_list), 2)
mock_uses_shib.return_value = True
self._validate_estimator()
oa = OAS(store_precision=False) oa.fit(X) assert_almost_equal(oa.score(X), score_, 4) assert(oa.precision_ is None)
user_profile = UserFactory(username=user.username, email=user.email).profile user_profile.allow_certificate = not is_embargoed user_profile.save()
old_inertia_csr, incremental_diff_csr = _mini_batch_step( X_mb_csr, x_mb_squared_norms_csr, new_centers_csr, counts_csr, buffer_csr, 1, None, random_reassign=False) assert_greater(old_inertia_csr, 0.0)
self._test_email_address_failures(SMTPDataError(554, "Email address is blacklisted"))
dashboard_page = DashboardPage(self.browser) self._make_har_file(dashboard_page)
np.random.seed(0)
if is_prerequisite_courses_enabled(): fulfill_course_milestone(course_key, user)
return dict( self.items() )
self.navigate_to_video()
return self.q(css=self._bounded_selector('.check-discussion-category:checked')).is_present()
pass
self._fields[key.field_name] = value
return self.adjust_for_viewer(X)
plt.figure(figsize=(8, 8)) accuracy = plt.subplot(211) timescale = plt.subplot(212)
callback_url_path = reverse('certificates.views.update_example_certificate')
return "split_test"
self.assertFalse(self.cohort_management_page.is_save_button_disabled(self.inline_key))
return social_models.DjangoStorage.user.user_model().objects.get(username=username)
with restrict_course(self.course.id) as redirect_path: self.assert_access_denied(redirect_path)
self.assertFalse(result['success']) self.assertIn(u"corrupted message regarding your charge", result['error_html'])
gamma = 10. kernel = rbf_kernel(X, Y, gamma=gamma)
clf = self.factory() clf.fit(X2, Y2)
file_to_upload = 'image.jpg' self.settings_page.upload_image('#upload-video-thumbnail-image', file_to_upload) self.assertIn(file_to_upload, self.settings_page.get_uploaded_image_path('#video-thumbnail-image'))
overflow_grader = graders.AssignmentFormatGrader("Lab", 3, 2) lab_grader = graders.AssignmentFormatGrader("Lab", 7, 3)
return self.q(css='input[name=list-profiles-csv]')
ApiAccessConfig(enabled=False).save() response = self.client.post(self.url) self.assertEqual(response.status_code, 404)
return self.q(css='a.problem-button').text
return self.rows_, self.columns_
msg_format = _("Message {action} for {succeeded} of {attempted} recipients")
return page_title_breadcrumbs(*crumbs)
if self.request_cache is None: return None return self.request_cache.data.setdefault('course_cache', {}).get(course_version_guid)
return str((template_name, sorted(context.iteritems())))
raise NotImplementedError("non-square filter shape", (frows, fcols))
url = EcommerceService().payment_page_url() self.assertEqual(url, 'http://ecommerce_url/test_basket/')
simple_auth_pages = ( '/home/', )
if self.contentstore: self.contentstore.close_connections() super(ModuleStoreReadBase, self).close_connections()
assert world.is_css_present('.error_message', wait_time=0)
urlpatterns += ( url(r'^404$', 'static_template_view.views.render', {'template': '404.html'}, name="404"), )
self.field_data_cache = FieldDataCache.cache_for_descriptor_descendents( self.course_key, self.request.user, self.toy_course, depth=2 )
if node.location.to_deprecated_string() == url: return node for child in node.get_children(): found = find(child, url) if found: return found return None
return self.list_price if self.list_price else self.unit_cost
self._auto_auth({'username': 'test', 'course_id': course_id})
if self.section.default_tab: courseware_context['default_tab'] = self.section.default_tab
#if not getattr(func, "_is_xblock_handler", False):
self.assertEqual(map(str.strip, result.splitlines()), self.OVERRIDES_JS)
return urljoin(self.public_service_url, '/api/v1/')
key.set_contents_from_string( data, headers={ "Content-Encoding": content_encoding, "Content-Length": len(data), "Content-Type": content_type, } )
if a.ndim == 0: return idx
self.assertEqual(xblock_info['is_header_visible'], False) self.assertEqual(xblock_info['display_name'], 'Subsection - Entrance Exam')
if isinstance(from_space, CompositeSpace): if isinstance(to_space, Conv2DSpace): return (NotImplementedError, "CompositeSpace does not know how to format as " "Conv2DSpace")
if user_profile.requires_parental_consent() and user_profile.has_profile_image: user_profile.profile_image_uploaded_at = None
self.nfac = nfac
if get_team(commentable_id) is not None: params['context'] = ThreadContext.STANDALONE else: params['context'] = ThreadContext.COURSE
role = CourseStaffRole(self.course_key) role.add_users(self.student) self.assertGreater(len(role.users_with_role()), 0)
return ''
sw = np.ones(6) clf = GaussianNB().fit(X, y) clf_sw = GaussianNB().fit(X, y, sw)
pc_clf.fit(this_X_train, y_train + 1, sample_weight=sw_train) prob_pos_pc_clf_relabeled = pc_clf.predict_proba(this_X_test)[:, 1] assert_array_almost_equal(prob_pos_pc_clf, prob_pos_pc_clf_relabeled)
for a in args: if isinstance(a, theano.Variable): return True return False
epsilon = lr_scalers.get(param, 1.) * learning_rate scale = T.maximum(self.eps, T.sqrt(new_sum_squared_grad)) delta_x_t = (-epsilon / scale * grads[param])
fit_params = fit_params if fit_params is not None else {} fit_params = dict([(k, _index_param_value(X, v, train)) for k, v in fit_params.items()])
assert_array_almost_equal(comp_a[:9], comp_r[:9]) assert_array_almost_equal(comp_a[9:], comp_r[9:], decimal=2)
self.assertTrue(self.lc_block.has_dynamic_children())
module = CapaFactory.create(rerandomize=rerandomize, attempts=0)
distances[:] = mindist
for app in ADDL_INSTALLED_APPS: INSTALLED_APPS += (app,)
selected = block_keys['selected']
courseware_page = CoursewarePage(self.browser, self.course_id) self.publish_unit_and_verify_groups_in_lms(courseware_page, [u'Group A', u'Group B', u'Group C'])
rng = check_random_state(0) n_features = 2 n_samples = 40 n_output = 3
self.assertEqual(expected_team['name'], team_card_name) self.assertEqual(expected_team['description'], team_card_description)
if not hasattr(self, 'num_channels'): self.num_channels = self.nchannels
timed_exams = [ timed_exam for timed_exam in _timed_exams if is_item_in_course_tree(timed_exam) ]
self.cluster_centers_ = _init_centroids( X, self.n_clusters, self.init, random_state=self.random_state_, x_squared_norms=x_squared_norms, init_size=self.init_size)
scaler_incr = scaler_incr.partial_fit(chunk)
user_id = user_service.get_current_user().opt_attrs.get('edx-platform.user_id', None)
self.alpha_ = best_alpha self.cv_alphas_ = all_alphas self.cv_mse_path_ = mse_path
shared_dataset = np.random.rand(20, 19).astype(theano.config.floatX)
stack = deque([start_node])
return microsite.is_request_in_microsite()
K = rbf_kernel(np.atleast_2d(x), np.atleast_2d(y), **kwds) return K
X = faces.data[:5000] n_samples, h, w = faces.images.shape n_features = X.shape[1]
self._auto_auth(self.USERNAME, self.EMAIL, False)
import matplotlib.pyplot as plt
CourseInstructorRole(self.course_with_invalid_ee.id).add_users(self.instructor) self.client.login(username=self.instructor.username, password='test')
test_dir = path(__file__).abspath().dirname().dirname().dirname() file_path = test_dir + '/data/uploads/' + file_name
self.assert_matching_events_were_emitted( event_filter={'name': u'edx.instructor.report.downloaded', 'report_url': report_url} )
task_id = entry.task_id course_id = entry.course_id task_input = json.loads(entry.task_input)
form = RestrictedCourseForm(data={'course_key': 'not/valid'}) self._assert_course_field_error(form)
dist_matrix = np.dot(self.centroids_, subcluster.centroid_) dist_matrix *= -2. dist_matrix += self.squared_norm_ closest_index = np.argmin(dist_matrix) closest_subcluster = self.subclusters_[closest_index]
monitoring_dataset = DenseDesignMatrix(X=X)
pass
post_data = models.model_to_dict(provider1) del post_data['icon_image']
for svd_10, svd_20 in svds_10_v_20: assert_greater( svd_20.explained_variance_ratio_.sum(), svd_10.explained_variance_ratio_.sum(), )
pipe.set_params(svc__a=0.1) assert_equal(clf.a, 0.1) assert_equal(clf.b, None) repr(pipe)
np.testing.assert_almost_equal(np.diag(cm), np.ones(cm.shape[0]))
payload = json.dumps(data)
self.assertNotContains(resp, 'Robot_Super_Course')
return self.q(css='.course-number-override .certificate-value').first.text[0]
raise NotImplementedError("Unable to send refund processing emails to microsite teams.")
dis = euclidean_distances(X)
view, args, kwargs = resolve(url) response = view(request, *args, **kwargs)
return self.pacing_css + ':checked'
self.assertNotContains(resp, 'This is a Test Microsite footer')
content = 'outside <strong>inside</strong> after' payload = get_response(content, 'June 22, 2000') self.assertHTMLEqual(content, payload['content'], "text outside tag")
return self.get_selector('div.certificate-exception-container')
return html.cssselect('.course-item[data-course-key="{}"]'.format(unicode(course_key)))
course = modulestore().get_course(course_key, depth=0) if course is None: raise CourseNotFoundError return course
self.database.connection.close()
return ItemFactory.create( parent_location=parent.location, category="problem", display_name="Group {} Sees This Problem".format(group), data="<h1>No Problem Defined Yet!</h1>", )
x = np.array([1e-40] * 1000000) logx = np.log(x) assert_almost_equal(np.exp(logsumexp(logx)), x.sum())
resp_asset = post_asset_update(False, course) self.assertFalse(resp_asset['locked']) verify_asset_locked_state(False)
raise NotImplementedError()
MODULE_DOCS = __doc__
check_is_fitted(self, "coefs_") y_pred = self._decision_scores(X) if y_pred.shape[1] == 1: return y_pred.ravel() return y_pred
this_yaml = test_yaml_which_set % {'which_set': 'bogus'} try: yaml_parse.load(this_yaml) raise AssertionError except ValueError: pass
_mock_counts.return_value = {} with self.assertRaises(SystemExit): call_task('pavelib.quality.run_safelint')
self.assertEqual(element.tag, tag)
dtype = None
with self.assertRaises(CommandError): self.command.handle('not/found', all=False)
data_train = Avicenna(which_set='train', standardize=True) assert data_train.X.shape == (150205, 120)
CourseEnrollmentFactory(user=other_user, course_id=self.courses[0].id)
pca.fit(X_digits)
self.teams_page.verify_my_team_count(expected_number_of_teams)
response = self._get_page( 'verify_student_verify_now', course.id, expected_status_code=302 ) self._assert_redirects_to_dashboard(response)
return self.get_text('.message-status.error')
site_configuration = SiteConfigurationFactory.create( site=self.site, )
orig_name = orig_name[len(tag) + 1:-12]
course_key = CourseKeyField(max_length=255, db_index=True)
mock_audit_log.reset_mock()
assert_equal(3, LeavePLabelOut(n_labels=2).get_n_splits(X, y, labels)) assert_equal(3, LeaveOneLabelOut().get_n_splits(X, y, labels))
child_blocks = self.q(css=self._bounded_selector("div[data-id]")) return frozenset(child.text for child in child_blocks)
self.factory(alpha=0.01, n_iter=20).fit(X2, np.ones(9))
self._subtree_edited_on = kwargs.get('_subtree_edited_on', None) self._subtree_edited_by = kwargs.get('_subtree_edited_by', None)
check_ortho(pls_ca.x_scores_, "x scores are not orthogonal") check_ortho(pls_ca.y_scores_, "y scores are not orthogonal")
if self.backward: return self.check_string_backward(expected, given)
config.save() self.assertEqual(config.mode, 'edit') self.assertEqual(message, config.validation_message)
field_dictionary, filter_dictionary, _ = LmsSearchFilterGenerator.generate_field_filters() self.assertTrue('start_date' in filter_dictionary) self.assertEqual(0, len(field_dictionary['course']))
np.random.seed(42)
return int((datetime_value - datetime(1970, 1, 1, tzinfo=UTC)).total_seconds())
return self.page.q(css=self.get_selector(css=selector))
delete_comment(request, comment_id) return Response(status=204)
if 'topo_space' not in self.__dict__: self._update_topo_space()
return { 'id': user.id, 'username': user.username, 'email': user.email, 'role': role }
httpretty.register_uri(httpretty.POST, urljoin(ZENDESK_URL, '/api/v2/tickets.json'), status=status, body='{}', content_type=JSON)
Coupon.objects.create( code=code, description='testing code', course_id=course_key, percentage_discount=self.percentage_discount, created_by=self.user, is_active=is_active )
estimators = [ ('Eigenfaces - RandomizedPCA', decomposition.RandomizedPCA(n_components=n_components, whiten=True), True),
template_name = 'api_admin/terms_of_service.html'
return wrapper
xpath = "//div[@class='indicator-container']/span" self.assert_no_xpath(xml, xpath, self.context)
with mock.patch.dict('django.conf.settings.FEATURES', {'ENABLE_MKTG_SITE': True}): self.assertEquals(self.get_about_page_link(), None)
AFFILIATE_COOKIE_NAME = 'affiliate_id'
return ensure_csrf_cookie(func)(*args, **kwargs)
self.cohort_name = "OnlyCohort" self.setup_cohort_config(self.course_fixture) self.cohort_id = self.add_manual_cohort(self.course_fixture, self.cohort_name)
return self.q(css=selector)[0].text
return username in [user.username for user in cohort.users.all()]
url_path = "tabs" def is_browser_on_page(self): return self.q(css='body.view-static-pages').present
tflat = _flatten(t.asList()) rep << And( [ Literal(tt) for tt in tflat ] )
cache.delete(VerificationDeadline.ALL_DEADLINES_CACHE_KEY)
CertificateGenerationConfiguration.objects.create(enabled=True)
self.q(css=".filterable-column .nav-item").click()
self.set_user_module_score(user, None, None)
X = np.vstack(data_chunks) X_lil = sp.lil_matrix(X) X_csr = sp.csr_matrix(X_lil) X_csc = sp.csc_matrix(X_lil)
missing = index - len(self) + 1 if missing > 0: self.extend([None] * missing) list.__setitem__(self, index, value)
if xblock_name is None: xblock_name = TestCrowdsourceHinter.XBLOCK_NAMES[0] resp = self.call_event(handler, resource, xblock_name) self.assertEqual(resp[resp_key], resp_val) self.assert_request_status_code(200, self.course_url)
self.assertEqual(len(cache), 1) cache_exc_msg, cache_globals = cache.values()[0] self.assertIn("ZeroDivisionError", cache_exc_msg)
expected_grades = [self._format_user_grade(header_row, **grade) for grade in user_grades] self.verify_rows_in_csv(expected_grades)
self.assertEqual(self.settings_detail.course_pacing, 'Instructor-Paced')
self.lc_block.max_count = 1 self.lc_block.capa_type = 'multiplechoiceresponse' self.lc_block.refresh_children() self.assertTrue(self.lc_block.validate())
self._navigate_to_course_unit_page() self.assertTrue(self.video.is_controls_visible())
super(LearnerProfilePage, self).__init__(browser) self.username = username
return None
loss, grad = _logistic_loss_and_grad(w, X, y, alpha=1.) grad_2, hess = _logistic_grad_hess(w, X, y, alpha=1.) assert_array_almost_equal(grad, grad_2)
if 'permutation' not in event_info: event_info['permutation'] = {} event_info['permutation'][response.answer_id] = (permutation_option, response.unmask_order())
listen_for_course_publish(self, self.course.id)
self._make_eligible() self._purchase_credit()
else: for str_group_id, usage_key in self.group_id_to_child.items():
for X, y in classification_datasets: X_train = X[:150] y_train = y[:150] X_test = X[150:]
CourseEnrollmentFactory( user=self.user_2, course_id=self.course.id, is_active=True, mode='audit' ) CertificateWhitelistFactory(course_id=self.course.id, user=self.user_2)
assert_greater_equal(w[0], 0)
assert_almost_equal(np.std(y - np.dot(X, c)), 1.0, decimal=1)
if not isinstance(course_id, basestring): raise ValueError('course_id must be a string. {} is not acceptable.'.format(type(course_id)))
self.create_xblock(parent_usage_key=self.chapter_usage_key, category='sequential2')
self.assertRegexpMatches( without_new_lines, r'<targetedfeedbackset.*?>.*?explanation-id="feedback1".*?</targetedfeedbackset>.*' + r'<targetedfeedbackset.*?>\s*</targetedfeedbackset>' )
choose_track_url = reverse('course_modes_choose', args=[unicode(self.course.id)]) response = self.client.post(choose_track_url, self.POST_PARAMS_FOR_COURSE_MODE['unsupported'])
self.class_names = [array[0].encode('utf-8') for array in test['class_names'][0]]
self.assertFalse(CourseMode.objects.filter(id=self.course_mode.id).exists())
FEATURES['ENABLE_PAYMENT_FAKE'] = True
raise NotImplementedError
ranks = {'leaves': []} colors = {'bounds': None}
self = layer
webresponse = server.encodeResponse(response) http_response = HttpResponse(webresponse.body) http_response.status_code = webresponse.code
indices = np.arange(10, 13)
fake_data_api.add_course(self.COURSE_ID, course_modes=course_modes) api.add_enrollment(self.USERNAME, self.COURSE_ID)
course5 = CourseFactory.create(org='otherorg', number='999') course5_key = course5.id
if settings.LMS_SEGMENT_KEY: analytics.write_key = settings.LMS_SEGMENT_KEY
self.assertEqual(certificate_statuses.count(CertificateStatuses.generating), 8) self.assertEqual(certificate_statuses.count(CertificateStatuses.unavailable), 2)
return False
data = dict(self.data.items()) self.cleaned_data['confirmed'] = data['confirmed'] = 'true' self.data = data is_valid = False
response = self.client.get('/?preview-lang=fa-ir') self.assert_tag_has_attr(response.content, "html", "lang", "fa-ir")
bin_sizes = defaultdict(int) for point in X: binned_point = np.round(point / bin_size) bin_sizes[tuple(binned_point)] += 1
for certificate in certificates: is_active = certificate.get('is_active', False) break
return settings.FEATURES['ENABLE_MAX_FAILED_LOGIN_ATTEMPTS']
for tree, dataset in product(REG_TREES, ["boston", "reg_small"]): if tree in SPARSE_TREES: yield (check_sparse_input, tree, dataset, 2)
self.cohort_management_page.select_discussion_topic(self.inline_key)
self.asset_collection.insert(dest_assets)
Xs.append(np.array([[1, 0.0003817754041], [2, 0.0003817753750]], dtype=np.float32))
ItemFactory.create( parent_location=self.course.location, category="discussion", discussion_id=topic_id, discussion_category=category, discussion_target=subcategory, **kwargs )
request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.user.username) self.assertEqual(request['parameters']['user_mailing_address'], '')
if settings.FEATURES["USE_CUSTOM_THEME"]: template = "theme-" + template
block_structure = BlockStructureModulestoreData(root_block_usage_key=0) for block in blocks: block_structure._add_xblock(block.location, block)
if not is_credit_course(course_key): return
self.assertEqual(response.status_code, 204)
ApiAccessConfig(enabled=False).save() response = self.client.get(self.url) self.assertEqual(response.status_code, 404)
view = super(AtomicMixin, cls).as_view(**initkwargs) return cls.create_atomic_wrapper(view)
message = "Error while calling " + str(type(self)) + ".expr" reraise_as(TypeError(message))
output = StringIO.StringIO() import_log_handler = logging.StreamHandler(output) import_log_handler.setLevel(logging.DEBUG)
post_save.connect(invalidate_country_rule_cache, sender=CountryAccessRule) post_save.connect(invalidate_country_rule_cache, sender=RestrictedCourse) post_delete.connect(invalidate_country_rule_cache, sender=CountryAccessRule) post_delete.connect(invalidate_country_rule_cache, sender=RestrictedCourse)
X, y = hastie_X, hastie_y ForestEstimator = FOREST_ESTIMATORS[name] clf = ForestEstimator(n_estimators=15, max_depth=3, warm_start=False, random_state=1, bootstrap=True, oob_score=True) clf.fit(X, y)
if not(len(users) == 1 and caller == users[0]): _check_caller_authority(caller, role) role.remove_users(*users)
window_height = window_width * ((num_rows * 1.8) / num_columns) figure, all_axes = pyplot.subplots(num_rows, num_columns, squeeze=False, figsize=(window_width, window_height))
problem = new_loncapa_problem(xml_str)
self.assertEqual(result['success'], 'correct') self.assertEqual(module.attempts, num_attempts + 1)
choice.text = "choice_{0}".format(ind) input_element.append(choice)
if not request.user.is_staff: raise Http404 cilset = CourseImportLog.objects.order_by('-created')
X_trans = maxabs_scale(X) assert_array_almost_equal(X_trans, X_expected)
with patch('student.models.cc.User.save'): uname = 'student' email = 'student@edx.org' password = 'test'
return (self.get_input_space(), self.get_input_source())
assert_equals(attempt_2, SoftwareSecurePhotoVerification.active_for_user(user))
self.set_state_from_lcp() return response
connectivity = np.eye(5)
self.wait_for_element_presence(self.upload_image_popup_window_selector, 'upload dialog is present')
self.provider.enable_integration = True self.provider.save()
('ALIGN', (5, 0), (5, 0), 'RIGHT'),
self._create_courses_and_enrollments( ("MyOrg", True), ("myorg", True) )
'limits': { 'CPU': 1, },
previous_offset = None
with patch('capa.responsetypes.LoncapaResponse.evaluate_answers') as mock_evaluate_answers: mock_evaluate_answers.return_value = CorrectMap(CapaFactory.answer_key(), 'incorrect') result = module.rescore_problem()
return zlib.compress(pickle.dumps(data, pickle.HIGHEST_PROTOCOL))
return self.cleaned_data.get("order_direction") or "desc"
return self.q(css='.page-header .breadcrumbs')[0].text
dict(safe_zip(range(2), (0.8, 1.3))))
y = np.linspace(0, resolution - 1, resolution) first_quarter = y < resolution / 4 y[first_quarter] = 3. y[np.logical_not(first_quarter)] = -1.
self._test_readonly_field('username', 'Username', self.username)
self.subcluster_labels_ = clusterer.fit_predict( self.subcluster_centers_)
assert len(str(e))
self.progress_page.visit() self.tab_nav.go_to_tab('Home')
from student.views import login_user return shim_student_view(login_user, check_logged_in=True)(request)
raise NotImplementedError()
np.testing.assert_allclose(f([[1]], [[0]]), [20, 20 / np.sqrt(2)])
return self.get_text('.certificate-id .certificate-value')
message = message.strip()
module = CapaFactory.create(due=self.yesterday_str, done=True) self.assertFalse(module.should_show_save_button())
if not settings.FEATURES.get('CUSTOM_COURSES_EDX'): filtered_list.append('enable_ccx') filtered_list.append('ccx_connector')
self.assert_logged_in_cookie_redirect(actions.do_complete(
scikit_classifier_results = [] scikit_regressor_results = []
self.course_dir = self.create_course_xml(self.content_dir, self.truncated_key)
def __init__(self, *args, **kwargs): super(CourseTeamSerializerWithoutMembership, self).__init__(*args, **kwargs) del self.fields['membership']
skip_if_no_sklearn() mapping = {'dataset_iterator': 'StratifiedDatasetShuffleSplit'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
if self.lcp.is_queued(): prev_submit_time = self.lcp.get_recentmost_queuetime()
return response
votes = np.zeros((n_samples, n_classes))
self.cursor = position
LogoutPage(self.browser).visit() self._login_as_a_verified_user() self.courseware_page.visit()
p_idx = rng.randint(num_p)
test_invalid_token("AAAAAAAAAAAAAAAAAAAAACpyUxTGIrUjnpuUsNi7mAY=", "username")
return ( auth.user_has_role(user, CourseBetaTesterRole(descriptor.id)) or _has_staff_access_to_descriptor(user, descriptor, descriptor.id) or _is_descriptor_mobile_available(descriptor) )
CreditRequirementStatus.objects.create( username=username, requirement=requirement, status='satisfied', reason={'final_grade': final_grade} )
self._verify_unit_warning( self.UnitState(is_released=False, publish_state=self.PublishState.UNPUBLISHED_CHANGES, is_locked=True), self.STAFF_ONLY_WARNING )
log.exception( 'Failed to handle marketing opt-in flag: user="%s", course="%s"', user.username, course_key )
real_cov = np.dot(coloring_matrix.T, coloring_matrix) emp_cov = empirical_covariance(X_train) loglik_real = -log_likelihood(emp_cov, linalg.inv(real_cov))
try: CourseUserGroup.objects.get(id=group_id) kwargs['group_id'] = group_id except CourseUserGroup.DoesNotExist: pass
block_id = BlockKey.from_usage_key(parent_usage_key) if block_id not in new_structure['blocks']: raise ItemNotFoundError(parent_usage_key)
return get_url("PRIVACY")
attribute = getattr(module, attribute_name) setattr(attribute_replacement, __BACKUP_ATTRIBUTE_NAME, attribute) setattr(module, attribute_name, attribute_replacement) return is_patched(module, attribute_name)
outcomes, __ = OutcomeService.objects.get_or_create( lis_outcome_service_url=result_service, lti_consumer=lti_consumer )
super(BinomialSampler, self).__init__(0, *args, **kwargs)
self.payment_and_verification_flow.proceed_to_payment()
block_structure.remove_block_if( lambda block_key: block_key.block_type == 'split_test', keep_descendants=True, )
self.assertTrue(all_gradesets[student1]) self.assertTrue(all_gradesets[student2]) self.assertTrue(all_gradesets[student5])
if versions_dict is None or master_branch not in versions_dict: definition_id = self.create_definition_from_data(locator, definition_fields, root_category, user_id).definition_id
aside2 = AsideBar(scope_ids=ScopeIds('user', block_type2, def_id, usage_id), runtime=self.runtime) aside2.field21 = 'new_value21'
LOGGER.info( u"Retrieving data for courses: {courses}".format( courses=", ".join([unicode(course) for course in courses]) ) )
BROKER_POOL_LIMIT = 0 BROKER_CONNECTION_TIMEOUT = 1
url = '{base}/course_modes/create_mode/{course_id}/'.format( base=BASE_URL, course_id=self._course_id ) query_string = urllib.urlencode(self._parameters) if query_string: url += '?' + query_string return url
params["username"] = "invalid username" assert_username_error("Usernames must contain only letters, numbers, underscores (_), and hyphens (-).")
self.assertTrue(res_json['success']) self.assertEqual( res_json['message'], u"Certificate generation started for white listed students." )
field_data_cache = FieldDataCache.cache_for_descriptor_descendents(course_id, student, module_descriptor) student_data = KvsFieldData(DjangoKeyValueStore(field_data_cache))
chapter_css = '.course-navigation .chapter .group-heading' return self.q(css=chapter_css).map(lambda el: el.text.strip()).results
convergence_context = {}
self.attempt_upload_file_and_verify_result(test_case, 'upload_screenshot')
os.remove(tmp.name)
)
config.delete() self.assertEqual(len(self.page.experiment_group_configurations), 1)
for iter_ in range(self.n_iter):
max_depth = node_indicator.sum(axis=1).max() assert_less_equal(est.tree_.max_depth, max_depth)
expected = '<video url_name="SampleProblem" download_video="false"/>\n' self.assertEquals(expected, etree.tostring(xml, pretty_print=True))
self.q(css="#verify_later_button").click() DashboardPage(self.browser).wait_for_page()
pass
url(r'^api/enrollment/v1/', include('enrollment.urls')),
cache.clear() CertificateGenerationConfiguration.objects.create(enabled=True)
result = self.service.delete_student_attempt( 'bad_student', unicode(self.course.id), 'foo/bar/baz', requesting_user=self.student, ) self.assertIsNone(result)
X = check_array(X, accept_sparse=['csr', 'csc']) n_samples = X.shape[0]
patcher = mock.patch('terrain.stubs.xqueue.Timer') timer = patcher.start() timer.side_effect = FakeTimer self.addCleanup(patcher.stop)
graph = image.img_to_graph(img, mask=mask)
result = get_email_params( self.course, True, course_key=self.course_key, display_name=self.ccx.display_name )
classifier = OneVsRestClassifier(svm.SVC(kernel='linear', probability=True, random_state=random_state)) y_score = classifier.fit(X_train, y_train).decision_function(X_test)
assert_array_equal(np.argmin(samme_proba, axis=1), [2, 0, 0, 2]) assert_array_equal(np.argmax(samme_proba, axis=1), [0, 1, 1, 1])
class_priority = ['video', 'problem']
from courseware.views.views import render_xblock return render_xblock(request, unicode(usage_key), check_if_enrolled=False)
BULK_EMAIL_ROUTING_KEY = HIGH_PRIORITY_QUEUE
columns = [col[astype(mask, bool, copy=False)] for col, mask in zip(columns_all, mask_valids)]
try: return self._config.get_setting(name) except KeyError: return self.strategy.setting(name, default)
return self.get_block_keys()
self.is_proctored_enabled = value
assert_almost_equal(s2, s3)
prior = DiagonalGaussianPrior() vae = DummyVAE() prior.set_vae(vae) prior.initialize_parameters(nhid=5)
hidden_layer_sizes = self.hidden_layer_sizes if not hasattr(hidden_layer_sizes, "__iter__"): hidden_layer_sizes = [hidden_layer_sizes] hidden_layer_sizes = list(hidden_layer_sizes)
self.assertIn('<div class="courses no-course-discovery"', response.content)
self.module_store = modulestore()._get_modulestore_by_type(ModuleStoreEnum.Type.mongo)
assert_almost_equal((3.0 * RBF(2.0))(X), (RBF(2.0) * 3.0)(X))
main(args=[])
import numpy import theano from pylearn2.datasets.utlc import load_ndarray_dataset, load_sparse_dataset from pylearn2.utils import subdict, sharedX
estimators = [c for c in estimators if not is_abstract(c[1])]
GENERAL_ASSET_TYPE = 'asset'
params, response = _validate_post_params(request.POST) if response is not None: return response
if include_default_option: field_dict["options"].append({ "value": "", "name": "--", "default": True })
self.assertEqual(unicode(self.annotation), u'{} : {}'.format(self.course_key.to_deprecated_string(), self.TEST_ANNOTATION))
try: final_grade = CreditRequirementStatus.objects.get( username=username, requirement__namespace="grade", requirement__name="grade", requirement__course__course_key=course_key, status="satisfied" ).reason["final_grade"]
conditional_page = ConditionalPage(self.browser) conditional_page.fill_in_poll() self.courseware_page.visit() self.assertTrue(conditional_page.is_content_visible())
raise NotImplementedError()
verified, _ = self.create_mode('verified', 'Verified', min_price=5) self.assertTrue(CourseMode.has_payment_options(self.course_key))
user_list[0].course_groups.add(*cohort_list) assert_events("added", user_list[:1], cohort_list) mock_tracker.reset_mock()
MONGO_PORT_NUM = int(os.environ.get('EDXAPP_TEST_MONGO_PORT', '27017')) MONGO_HOST = os.environ.get('EDXAPP_TEST_MONGO_HOST', 'localhost')
n_samples, self.n_features_ = X.shape y = self._validate_y(y)
query = queries[[rng.randint(0, n_queries)]]
start_time = time.time() yield execution_time = time.time() - start_time LOGGER.info(u"Execution time: {time} seconds".format(time=execution_time))
with store.branch_setting(ModuleStoreEnum.Branch.draft_preferred): store.publish(item_location, ModuleStoreEnum.UserID.test)
return self.q(css=self._bounded_selector('.xblock-student_view'))[0].text
self.payment_and_verification_flow.immediate_verification()
db_alias = ( 'read_replica' if 'read_replica' in settings.DATABASES else 'default' ) return connections[db_alias].cursor()
return self.q(css='.conditional-wrapper').visible
return etree.Element("imageresponse")
return self._decision_function(X)
try: problem.grade_answers({'1_2_1': '42'})
module.location = Mock(module.location) module.location.to_deprecated_string.return_value = 'i4x://edX/capa_test/problem/meh'
location = course_key.make_usage_key('course', 'test') link = utils.get_lms_link_for_item(location) self.assertEquals(link, "//localhost:8000/courses/mitX/101/test/jump_to/i4x://mitX/101/course/test")
return normalize_key_for_search(structure_key)
if not all(parent in yield_results for parent in parents): continue
sum_square_grad = sharedX(param.get_value() * 0.)
REQUEST_CONTEXT.request = None return response
clf = svm.SVR(kernel=lambda x, y: np.array([[1.0]])) clf.fit(X, y) assert_raises(ValueError, clf.predict, X)
exams = get_all_exams_for_course(unicode(self.course.id)) self.assertEqual(len(exams), expected_count)
data = { "indexed_count": indexed_count, 'category': category, } tracker.emit( event_name, data )
if 'download_track' not in field_data and track is not None: field_data['download_track'] = True
filepath = SettingsPage.get_asset_path(file_to_upload) self.q(css=self.upload_image_browse_button_selector).results[0].send_keys(filepath) self.q(css=self.upload_image_upload_button_selector).results[0].click()
self.assertCoursesEqual(source_library1_key, source_library2_key)
self.load_data()
self.q(css=TEAMS_LINK_CSS).filter( text='View Teams in the {topic_name} Topic'.format(topic_name=topic_name) )[0].click() self.wait_for_ajax()
auth.add_users(request.user, role, user) role_added = True
mako_middleware_process_request(self.request) return views.progress(self.request, course_id=unicode(course.id), student_id=self.user.id).content
y = [5, 0, 5] for X in ([[5, 0], [0, 5], [10, 10]],
rng = np.random.RandomState(0) n_topics, X = _build_sparse_mtx() lda = LatentDirichletAllocation(n_topics=n_topics, evaluate_every=1, learning_method='batch', random_state=rng) lda.fit(X)
details.update(self._course_details)
vectors = vectors / np.sqrt((vectors ** 2).sum(axis=1))[:, np.newaxis]
if not settings.FEATURES['ADVANCED_SECURITY']: return False min_days_between_reset = settings.ADVANCED_SECURITY_CONFIG.get( 'MIN_DAYS_FOR_STAFF_ACCOUNTS_PASSWORD_RESETS' ) return min_days_between_reset
self.assertEqual(user_info["username"], self.user.username) self.assertEqual(user_info["email"], self.user.email)
for section in self.course_outline_page.sections(): self.assertEqual(collapsed, section.is_collapsed)
image_length = 96 if which_norb == 'small' else 108
test = SVHN('test', path=local_path) check_dtype(test) test.apply_preprocessor(pipeline, can_fit=False)
return self.q(css='.program-card').present
from safe_lxml import defuse_xml_libs defuse_xml_libs()
self.library_fixture.create_xblock(self.library_fixture.library_location, XBlockFixtureDesc("html", "Html4"))
self.q(css='.button-preview').first.click() self._switch_to_lms()
signs = np.sign(X) signs = signs.view(dtype='|S{0}'.format(signs.strides[0])) unique_signs, cluster_index = np.unique(signs, return_inverse=True)
self.assertEqual(old_email, response.data["email"]) self.assertEqual("change my email", response.data["goals"])
if not hasattr(coeffs, '__iter__'): coeffs = [coeffs] * len(self.layers)
'CMS_SEGMENT_KEY': None,
self.xblock.location = Location("org", "import", "run", "category", "stubxblock")
is_done = page.browser.execute_script("return $({!r}).data('initialized')".format(xblock_css)) return (is_done, is_done)
except (AttributeError, ValueError): violations['total'] = None return violations
self.answer_problem(correct=False) self.problem_page.click_check() self.wait_for_status('incorrect')
problem = self.store.get_item(problem_location) self.assertEquals(problem.display_name, expected_display_name)
return False
parent_map = [[] for _ in children_map] for parent, children in enumerate(children_map): for child in children: parent_map[child].append(parent) return parent_map
last_objective_value = ncut_value rotation = np.dot(Vh.T, U.T)
if self.include_arguments: return sum(self._stacks[stack].values()) else: return self._stacks[stack]
self._assert_credit_status("pending")
self.assertEqual( response['content-disposition'], 'attachment' ) rows = response.content.strip().split('\r') headers = rows[0]
self.course_fixture = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
draggables = world.css_find(css_class + ' .drag-handle') source = draggables.first target = draggables.last
f = lambda *args: 0 assert_raises(ValueError, make_scorer, f, needs_threshold=True, needs_proba=True)
for resource, xblock_name in itertools.product(self.test_recommendations.values(), self.XBLOCK_NAMES): self.call_event('add_resource', resource, xblock_name)
self.asset_collection.update( {'_id': course_assets.doc_id}, {'$set': updates_by_type} ) return True
return u"{checkpoint} in {course}".format( checkpoint=self.checkpoint_name, course=self.course_id )
del context_mock.context self.assertIn("We're having trouble rendering your component", render_to_string("html_error.html", None))
y_true, _, probas_pred = make_prediction(binary=True) fpr, tpr, thresholds = roc_curve(y_true, probas_pred)
self.assertEqual(self.video.speed, '0.50x')
try: imp.find_module(app_name) except ImportError: try: __import__(app_name) except ImportError: continue INSTALLED_APPS += (app_name,)
'error': _("Problem is closed."),
brc_partial.set_params(n_clusters=3) brc_partial.partial_fit(None) assert_array_equal(brc_partial.subcluster_labels_, brc.subcluster_labels_)
add_period = lambda x: '.' + x return map(add_period, cls.current().excluded_extensions.split())
noise = rng.randn(*X.shape) / 100 X_reembedded = clf.transform(X + noise) assert_less(linalg.norm(X_reembedded - clf.embedding_), tol)
return self.q(css=".submission-success h4").text
assert_greater(np.mean(labels == true_labels), .3)
scaler_batch = MaxAbsScaler().fit(X)
try: delattr(_MovedItems, name) except AttributeError: try: del moves.__dict__[name] except KeyError: raise AttributeError("no such move, %r" % (name,))
EmptyPromise( lambda: cohort_name == cohort_management_page.get_selected_cohort(), "Waiting for new cohort" ).fulfill() cohort_management_page.add_students_to_selected_cohort([student])
X = g.sample(n_samples=100) g = self.model(n_components=self.n_components, covariance_type=self.covariance_type, random_state=rng, min_covar=1e-1, n_iter=1, init_params=params) g.fit(X)
mock_course_module = MagicMock(id=self.course.id, position=None) mock_course_module.get_display_items.return_value = [MagicMock()] self.assertIsNone(helpers.get_course_position(mock_course_module))
context.update(course.cert_html_view_overrides)
return None
S = func(np.array([[1]], dtype='int'), metric='precomputed') assert_equal('f', S.dtype.kind)
def __init__( self, expr ): super(Group,self).__init__( expr ) self.saveAsList = True def postParse( self, instring, loc, tokenlist ): return [ tokenlist ]
predictions = cross_val_predict(clf, X_sparse, multioutput_y) assert_array_equal(predictions.shape, (150, 2))
if relevant_course_mode.sku: processors = ecommerce_api_client(request.user).payment.processors.get() else: processors = [settings.CC_PROCESSOR_NAME]
super(MultinomialSampler, self).__init__(0, *args, **kwargs)
return ''
return dict( sorted( dict_obj.items(), key=lambda x: x[1], reverse=True )[:amount] )
self.addCleanup(self._mock_paver_needs.stop)
course = store.get_course(course.id, depth=1)
self.settings_page.visit()
if draft_only: revision = MongoRevisionKey.draft else: revision = ModuleStoreEnum.RevisionOption.all
return self.q(css=self._bounded_selector('.user-username')).text[0]
self.q(css=self._bounded_selector('a.action-view')).first.click()
assert_raises(ValueError, enc.fit, [[0], [-1]])
cauth = CourseAuthorization(course_id=course_id, email_enabled=False) cauth.save()
return self.get_displayable_field_names() + ['edit_link']
if X is not None: X = check_array(X, accept_sparse='csr') n_samples1 = X.shape[0] else: n_samples1 = self._fit_X.shape[0]
COURSE_SCOPE = 'course'
return models.Application.objects.create( name=name, user=user, client_id=client_id, client_type=models.Application.CLIENT_PUBLIC, authorization_grant_type=models.Application.GRANT_PASSWORD, redirect_uris=redirect_uri, )
assert_greater(brier_score_loss(y_test, prob_pos_clf), brier_score_loss(y_test, prob_pos_pc_clf))
self.process_requirements()
assert not isinstance(x, theano.gof.Variable) return 1. / (1. + np.exp(-x))
try: result = super(StringOrDate, self).from_json(value) except ValueError: return value if result is None: return value else: return result
y[::5] += 3 * (0.5 - np.random.rand(8))
raise SyntaxError("unknown encoding: " + encoding)
_, y_true = make_multilabel_classification(n_features=1, n_classes=n_classes, random_state=0, allow_unlabeled=True, n_samples=n_samples) _, y_pred = make_multilabel_classification(n_features=1, n_classes=n_classes, random_state=1, allow_unlabeled=True, n_samples=n_samples)
with mock.patch('requests.post', side_effect=Timeout) as mock_post: self.call_create_zendesk_ticket() self.assertTrue(mock_post.called)
self.save() orderitems = OrderItem.objects.filter(order=self).select_subclasses() site_name = microsite.get_value('SITE_NAME', settings.SITE_NAME)
OUTPUT_FIELD_NAMES = [ "email", "full_name", "course_id", "is_opted_in_for_email", "preference_set_datetime" ]
return xblock._edit_info.get('published_by')
self.assert_no_setting_changed_event()
sh( "diff-cover {xml_report_str} --compare-branch={compare_branch} " "--html-report {diff_html_path}".format( xml_report_str=xml_report_str, compare_branch=compare_branch, diff_html_path=diff_html_path, ) )
shim.remove_shim_context(event)
still_in_grace = CapaFactory.create(showanswer='closed', max_attempts="1", attempts="0", due=self.yesterday_str, graceperiod=self.two_day_delta_str) self.assertFalse(still_in_grace.answer_available())
super(BaseTeamsPage, self).__init__(browser, course_id) self.topic = topic
f_init = compile_f_init() cc = self._compiled_cache self._compiled_cache = (state, indices, f_init, cc[3]) return self._compiled_cache[2:]
return HttpResponse(get_edxnotes_id_token(request.user), content_type='text/plain')
#add_module_names = True
ir = IsotonicRegression(increasing='auto', out_of_bounds="clip") ir.fit(x, y)
self.assertFalse(result['success']) self.assertIn(u"did not accept your payment", result['error_html']) self.assert_dump_recorded(result['order'])
self.assertTrue(modal.has_release_date()) self.assertFalse(modal.has_due_date()) self.assertFalse(modal.has_policy())
from __future__ import unicode_literals
return self._batch_size
urlpatterns += ( url(r'^404$', handler404), url(r'^500$', handler500), )
CourseEnrollment.enroll(user, course_id, "honor") self.assert_no_events_were_emitted()
self.verify_show_answer_present(False)
n_iter_search = 20 random_search = RandomizedSearchCV(clf, param_distributions=param_dist, n_iter=n_iter_search)
self.assertEqual(CourseEnrollment.objects.count(), 1) enrollment = CourseEnrollment.objects.get(course_id=course_key) self.assertEqual(enrollment.user.username, "test")
assert isinstance(value, UsageKey) self.scope_ids = self.scope_ids._replace( def_id=value, usage_id=value, )
if self.shuffle: rng = check_random_state(self.random_state) else: rng = self.random_state
return self.q(css="body.discussion .forum-nav-sort-control").present
y = [3, 3, -1, -1, 2]
self._run_command()
render_args, _ = module.system.render_template.call_args self.assertEqual(len(render_args), 2)
from __future__ import unicode_literals
user2 = UserFactory() with self.assertRaises(PermissionDenied): reindex_course_and_check_access(self.course.id, user2)
section_css = '.course-navigation .chapter:nth-of-type({0})'.format(sec_index + 1) self.q(css=section_css).first.click()
rxml = etree.fromstring(req.text)
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
continue
assert max(pd.max(), hd.max()) < .17
try: deadline = cls.objects.get(course_key=course_key) return deadline.deadline except cls.DoesNotExist: return None
pred = mb_k_means.predict(X) assert_array_equal(mb_k_means.predict(X), mb_k_means.labels_)
action_name = ugettext_noop('emailed') visit_fcn = perform_delegate_email_batches return run_main_task(entry_id, visit_fcn, action_name)
LIBRARY_LABEL = "Library" COUNT_LABEL = "Count" SCORED_LABEL = "Scored" PROBLEM_TYPE_LABEL = "Problem Type"
self._reset() return self.partial_fit(X, y)
'ADDITIONAL_OPTIONS': { 'trashcan': { 'bucket': 'trash_fs' } }
depths = [_find_longest_prefix_match(tree, tree_queries, MAX_HASH_SIZE, self._left_mask, self._right_mask) for tree, tree_queries in zip(self.trees_, np.rollaxis(bin_queries, 1))]
root_dir = path(mkdtemp_clean()) export_course_to_xml(self.store, content_store, course_id, root_dir, 'test_roundtrip')
return self.__dict__
braces = '}' * num_braces rval = basic_setup + \ setup_nv_hid_acts + \ setup_nv_filters + \ setup_nv_targets + \ do_convolution + \ braces rval = rval % locals() return rval
self.extra = extra
for field_name in InheritanceMixin.fields: record_filter['metadata.{0}'.format(field_name)] = 1
self.find_css('.action-secondary').first.click()
LETTUCE_SERVER_PORT = 8003 XQUEUE_PORT = 8040 YOUTUBE_PORT = 8031 LTI_PORT = 8765 VIDEO_SOURCE_PORT = 8777
exception_classes = [StudentInputError, LoncapaProblemError, ResponseError] for exception_class in exception_classes:
layer_below = self.dbm.hidden_layers[i-1]
add_openid_simple_registration(request, response, data) add_openid_attribute_exchange(request, response, data)
super(TestLibraryContentModuleWithSearchIndex, self).setUp() search_index_mock.search = Mock(side_effect=self._get_search_response)
dataset_sources="sources.lst" dataset_web="http://www.stevenpigeon.org/secret" dataset_conf_path="" dataset_data_path="" root_conf_path=None root_data_path=None user_conf_path=None user_data_path=None super_powers=False
self.request.backend = social_utils.load_backend(self.request.social_strategy, self.BACKEND, redirect_uri)
clf = AdaBoostRegressor(random_state=0) clf.fit(boston.data, boston.target) score = clf.score(boston.data, boston.target) assert score > 0.85
return self.lcp.get_score()
self.fit(X) return self.labels_
sample_problem_xml = textwrap.dedent(xml)
return xblock._edit_info.get('edited_by')
if make_new: self.filters = tables.Filters(complib='blosc', complevel=5) self.make_data(which_set, path)
group.full_clean()
self._assert_cert_status(phantom_course, self.user, CertificateStatuses.error)
install_package(package,temp_filename,dataset_data_path) update_installed_list("i",package)
node.attrib.pop('xblock-family', None)
block = modulestore().get_item(block_location) block.user_partitions = partitions modulestore().update_item(block, 1)
with self.assertRaises(UnsupportedRevisionError): self.store.has_item(self.fake_location, revision=ModuleStoreEnum.RevisionOption.draft_preferred)
log.exception( u'Unable to emit {event} event for user {user} and order {order}'.format( event=event_name, user=self.user.id, order=self.id) )
xblock, fields = (None, block.__dict__)
MSE[MSE < 0.] = 0.
eigvals = np.maximum(eigvals.real, 0)
obj.is_active = False obj.save()
resource = {"id": self.non_existing_resource_id, 'event': test_case['event']} self.check_event_response_by_http_status('handle_vote', resource, 400)
try: validate_email(eamap.external_email) context['ask_for_email'] = False except ValidationError: context['ask_for_email'] = True
def course_id(course_num): return world.scenario_dict['COURSE'].id.replace(course=course_num)
if Y is not None: H_hat[-1] = Y
self.assert_bookmark_data_is_valid(bookmarks[-1], bookmarks_data[0], check_optional_fields=check_all_fields) self.assert_bookmark_data_is_valid(bookmarks[0], bookmarks_data[-1], check_optional_fields=check_all_fields)
images_grad, filters_grad = grad(cost, [images, filters]) reference_cost = (cost_weights * output_conv2d).sum() images_conv2d_grad, filters_conv2d_grad = grad(reference_cost, [images, filters])
if options['course']: try: course_key = CourseKey.from_string(options['course']) except InvalidKeyError: course_key = SlashSeparatedCourseKey.from_deprecated_string(options['course'])
usage_id = unicode(usage_key) bookmarks_cache = self._bookmarks_cache(usage_key.course_key, fetch=True) for bookmark in bookmarks_cache: if bookmark['usage_id'] == usage_id: return True return False
y = np.array([3, 3, -1, -1, 2])
call_command('import', self.content_dir, self.course_dir) self.assertIsNotNone(store.get_course(self.truncated_key))
blocks = _get_course_date_summary_blocks(course, user) return '\n'.join( b.render() for b in blocks )
try: do_email_change_request(user, email, activation_key) except ValueError as err: return err.message
greek += [x.capitalize() for x in greek]
bulk_ops_record.dirty = False
check_node(child.location, after_create, after_edit, editing_user, after_create, after_edit, editing_user)
'ENABLE_LTI_PROVIDER': False,
dense_results = BaggingRegressor( base_estimator=CustomSVR(), random_state=1, **params ).fit(X_train, y_train).predict(X_test)
for i in range(3):
return image.resize((side_length, side_length), Image.ANTIALIAS)
X, y = make_circles(factor=0.5, random_state=0, noise=0.05)
if task_progress.attempted % status_interval == 0: task_progress.update_task_state(extra_meta=current_step) task_progress.attempted += 1
rng = np.random.RandomState(0) X = rng.randn(97, 149) Y = rng.randn(111, 149)
user_preference = kwargs["instance"] emit_setting_changed_event( user_preference.user, sender._meta.db_table, user_preference.key, user_preference._old_value, user_preference.value ) user_preference._old_value = None
store = self._get_modulestore_for_courselike(asset_key.course_key) return store.find_asset_metadata(asset_key, **kwargs)
return self.descriptor.runtime.modulestore.get_course(self.course_id)
assert_equal(clf.fit(x, y).score(x, y), 1.0, 'using covariance: %s' % solver)
num_braces = 0
if __name__ == '__main__': main()
d = load_linnerud() X = d.data Y = d.target
if not base.startswith(resolved(settings.DATA_DIR)): raise SuspiciousOperation("Attempted to import course outside of data dir")
about_base = marketing_urls.get('ROOT', None)
if not err_msg: err_msg = u"Unknown error" error_rows.append(student_fields + [err_msg]) task_progress.failed += 1 continue
return cls.objects.filter(invoice__isnull=False, course_id=course_id)
self._conv_op = GpuDnnConv() self._desc = GpuDnnConvDesc(border_mode=border_mode, subsample=self._subsample, conv_mode='conv')
url = AUTH_BASE_URL + "/auto_auth" query_str = urllib.urlencode(self._params) if query_str: url += "?" + query_str return url
task_input = {'statuses_to_regenerate': [CertificateStatuses.downloadable, CertificateStatuses.error]}
try: record = cls.objects.get(course_id=course_id) return record.embargoed except cls.DoesNotExist: return False
'rule': Rules.python_interpolate_html
TASK_LOG.error(u"Task (%s) has no InstructorTask object for id %s", task_id, entry_id)
try: user = User.objects.get(id=user_id) except ObjectDoesNotExist: return None
url = BASE_URL + '/dashboard/programs/123/program-name/' def is_browser_on_page(self): return self.q(css='.js-program-details-wrapper').present
assets, __ = store.get_all_content_for_course(course_loc) for asset in assets: print "Deleting {0}...".format(asset) store.delete(asset['_id'])
est = DummyRegressor() est.fit(X_learn, y_learn) y_pred_learn = est.predict(X_learn) y_pred_test = est.predict(X_test)
super(BaseVisitor, self).__init__() self.file_contents = file_contents self.lines = StringLines(self.file_contents) self.results = results
self.course_nav.q(css='input[id^=input_][id$=_2_1]').fill('A*x^2 + sqrt(y)')
self.assertEqual(len([r for r in httpretty.httpretty.latest_requests if r.method == 'POST']), 0)
self.assertEqual(len(courses), 1) self.verify_course(courses[0])
X, y = make_classification(n_samples=200, n_features=20, n_informative=3, n_redundant=2, n_repeated=0, n_classes=8, n_clusters_per_class=1, flip_y=0.0, class_sep=10, shuffle=False, random_state=0)
self.verify_success_on_file_content( 'email,cohort\nfoo_email,bar_cohort', mock_store_upload, mock_cohort_task )
self.student = UserFactory(username=uname, password=password, email=email)
BODY_SELECTOR = "#tags-panel" TAB_SELECTOR = ".tab#view-tags" CHILD_SELECTOR = ".note-group" CHILD_CLASS = EdxNotesTagsGroup
if step_score: self.scores_.append(step_score(self.estimator_, features)) self.n_features_ = support_.sum() self.support_ = support_ self.ranking_ = ranking_
return self.q(css="div.proctored-exam.completed").visible
response = self.session.post( STUDIO_BASE_URL + '/xblock/' + loc, data=xblock_desc.serialize(), headers=self.headers, )
self.xmodule.is_condition_satisfied = lambda: True self.xmodule.descriptor.get_children = lambda: []
self.mods = set(sys.modules)
self.course_enrollment.change_mode(self.mode) self.course_enrollment.activate()
s = data[:, 11] == 1 data = np.c_[data[s, :11], data[s, 12:]] target = target[s]
response = self._add_edx4edx() self.assertRegexpMatches(response.content, table_re)
self.assertIn(self.split_test_module.child_descriptor.url_name, ['split_test_cond0', 'split_test_cond1'])
img = circle1 + circle2 + circle3 + circle4
add_lookup('main', '', package=__name__) self.assertEqual(utils.render_mustache('test.mustache', {}), 'Testing 1 2 3.\n')
return '<div>{0}</div>'.format(saxutils.escape(repr(context)))
clf = ensemble.RandomForestClassifier(n_estimators=100, random_state=0)
source_course_key = CourseKey.from_string(source_course_key_string) destination_course_key = CourseKey.from_string(destination_course_key_string) fields = deserialize_fields(fields) if fields else None
return self._mapping.keys()
response = requests.post(self.url, data={"test_param": 2}) self.assertEqual(response.status_code, 200)
offset += m.offset
selector = self.get_element_selector(VIDEO_MENUS[menu_name]) return self.q(css=selector).present
return mini_batch
if exif is None: image.save(string_io, format='JPEG') else: image.save(string_io, format='JPEG', exif=exif)
if self.estimators_ is None or len(self.estimators_) == 0: raise NotFittedError("Estimator not fitted, call `fit`" " before making predictions`.")
if self.negative_class_index is None: y = T.eq(y, self.positive_class_index)
self.client.login(username=self.user.username, password='test')
resp = self.client.post( '/shoppingcart/payment_fake', dict(post_params) )
super(HtmlStringVisitor, self).__init__(file_contents, results) self.skip_wrapped_html = skip_wrapped_html self.unsafe_html_string_nodes = [] self.over_escaped_entity_string_nodes = [] self.has_text_or_html_call = False
self.course = CourseFactory.create( org=org, number=course_number, run=course_run )
course_fixture = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
base = np.memmap(filename, dtype=dtype, shape=total_buffer_len, mode=mode, offset=offset, order=order) return as_strided(base, shape=shape, strides=strides)
modes = CourseMode.modes_for_course(self.course_key) self.assertEqual([CourseMode.DEFAULT_MODE], modes)
with mock_basket_order(basket_id=1, exception=exceptions.HttpNotFoundError): response = self.client.get(self.path) self.assertEqual(response.status_code, 404)
rng = np.random.RandomState(42) old_centers = centers + rng.normal(size=centers.shape)
user = User.objects.get(email=self.notenrolled_student.email) self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))
del configure_custom
self.assertNotIn('course', course_xml.attrib) self.assertNotIn('org', course_xml.attrib)
with self.assertRaises(RequestAlreadyCompleted): api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO['username'])
return self._folds[0].get_output_space()
installed_date=installed_packages_list[this_package].timestamp
return self._folds[0][0].get_input_space()
redirect_url = "{login_url}?next={original_url}".format( login_url=reverse("signin_user"), original_url=url, ) self.assertRedirects(response, redirect_url)
return os.path.dirname(self._get_module_path(module))
from __future__ import unicode_literals
signed_fields = post_params.get('signed_field_names').split(',')
child_descriptor = self.descriptor.get_child(usage_id) child_block = None if child_descriptor is not None: child_block = self.system.get_module(child_descriptor)
self.unit_page.xblocks[1].open_advanced_tab()
n_components = 150
self._update_feature_log_prob() self._update_class_log_prior(class_prior=class_prior) return self
for child in children_map[block_to_remove]: for parent in parents_map[block_to_remove]: removed_children_map[parent].append(child)
if code.ndim == 1: code = code[np.newaxis, :] return code
raise NotImplementedError("Applications must monkey-patch this function before using local_resource_url for studio_view")
iris = datasets.load_iris()
microsite = Microsite.get_microsite_for_domain(domain)
return self.q(css='.wrapper-notification-error.is-shown')
config.add_subpackage('tests')
y_predicted = grid_search.predict(docs_test)
os.remove(layer0_filename) os.remove(layer1_filename)
self.assertNotIn('contents', result)
block = self._add_simple_content_block() with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
assert_page_correct( page=1, page_size=4, expected_start=0, expected_stop=4, expected_next=2, expected_prev=None )
from __future__ import unicode_literals
assert_equal(name, world.browser.find_by_css('.problem-header').text)
test_score -= test_score[0] test_best_iter = x[np.argmin(test_score)]
if db != 'read_replica': DATABASES[db].update(get_db_overrides(db))
ForestClassifier = FOREST_CLASSIFIERS[name] _y = np.vstack((y, np.array(y) * 2)).T
self.previous_version = edit_info.get('previous_version', None)
assert_raises(ValueError, binarizer.transform, sparse.csc_matrix(X))
with check_mongo_calls(chapter_queries_1): self.client.get(outline_url, HTTP_ACCEPT='application/json')
assert_raises(ValueError, svm.SVC(C=-1).fit, X, Y)
'ENABLE_EDXNOTES': False,
assert isinstance(model.hidden_layers[-1], Softmax)
from .overrides import get_override_for_ccx return get_override_for_ccx(self, self.course, 'due')
return AppVersionConfig.last_supported_date(platform_name, platform_version) or self.NO_LAST_SUPPORTED_DATE
ps_diff_cache = self._create_service(username, {})
n_connected_components, _ = connected_components(graph) return n_connected_components == 1
mode = 'r+'
clf = svm.OneClassSVM() rnd = check_random_state(2)
from lms.envs.test import ( WIKI_ENABLED, PLATFORM_NAME, SITE_NAME, DEFAULT_FILE_STORAGE, MEDIA_ROOT, MEDIA_URL, )
for msg in messages.get_messages(request): if msg.extra_tags.split()[0] == "social-auth":
if namespace in NAMESPACE_CHOICES.values(): if namespace == 'entrance_exams': return '{}.{}'.format(unicode(course_key), NAMESPACE_CHOICES['ENTRANCE_EXAM'])
self._change_enrollment('enroll', email_opt_in=email_opt_in)
self.assertEqual(len(paths[milestone_key]), 0)
num_rows = max_num_channels // num_columns if num_rows * num_columns < max_num_channels: num_rows += 1
'ENABLE_THIRD_PARTY_AUTH': False,
features = np.arange(n_features)[support_] self.estimator_ = clone(self.estimator) self.estimator_.fit(X[:, features], y)
self.set_date('due_date', "#due_date", date)
cert_set = ExampleCertificateSet.objects.create(course_key=self.COURSE_KEY) return ExampleCertificate.objects.create( example_cert_set=cert_set, description=self.DESCRIPTION, template=self.TEMPLATE )
return self._hidden_activation(inputs)
deleted = [] valid = [] for enrollment in enrollments: if enrollment.get("course_details") is not None: valid.append(enrollment) else: deleted.append(enrollment)
validated_data["modes"] = self._new_course_mode_models(validated_data["modes"]) instance.update(validated_data) instance.save() return instance
def frombuffer_empty(buf, dtype): if len(buf) == 0: return np.empty(0, dtype=dtype) else: return np.frombuffer(buf, dtype=dtype)
self._captions_visibility(True)
colors_hue = np.arange(n_colors) colors_hue = as_floatX(colors_hue) colors_hue *= 1./n_colors
mask[np.argsort(scores, kind="mergesort")[-self.k:]] = 1 return mask
for name in ["", "a"]: params["name"] = name assert_name_error("Your legal name must be a minimum of two characters long")
assert len(state) == 2 if isinstance(coeffs, str): coeffs = float(coeffs) assert isinstance(coeffs, float) _, state = state state = [state] coeffs = [coeffs]
return self._require_oauth_field("access_token")
SSL_AUTH_EMAIL_DOMAIN = ENV_TOKENS.get("SSL_AUTH_EMAIL_DOMAIN", "MIT.EDU") SSL_AUTH_DN_FORMAT_STRING = ENV_TOKENS.get("SSL_AUTH_DN_FORMAT_STRING", "/C=US/ST=Massachusetts/O=Massachusetts Institute of Technology/OU=Client CA v1/CN={0}/emailAddress={1}")
config = CourseOverviewImageConfig.current() course_overview = CourseOverview.get_from_id(course.id) image_urls = course_overview.image_urls
with patch_edxnotes_api_settings("http://example.com"): self.assertEqual("http://example.com/", get_endpoint_function())
gpr = GaussianProcessRegressor(kernel=kernel) gpr.fit(X, y_norm) gpr_norm = GaussianProcessRegressor(kernel=kernel, normalize_y=True) gpr_norm.fit(X, y)
self.client.logout() self.assertEqual(403, self._post_to_view().status_code)
self.q(css='div.csh_rate_hint').click() self.wait_for_ajax()
problem_page.fill_answer("4") problem_page.click_check() self.assertFalse(problem_page.is_correct())
gs = GridSearchCV(clf, [{'parameter': [0, 1, 2]}], scoring='accuracy', refit=False, error_score='raise')
mock_get.return_value.content = "Error" self.assertRaises(EdxNotesParseError, helpers.get_notes, self.request, self.course)
self.course.grading_policy = grading_policy self.update_course(self.course, self.student_user.id) self.refresh_course()
'enrollment',
self.assertNotIn(REG_STR, resp.content)
pass
self.q(css='.nav-item .new-button').click()
self.assertEqual( first_request["parameters"]["request_uuid"], second_request["parameters"]["request_uuid"] )
report_dir = (Env.REPORT_DIR / system).makedirs_p()
global cuda if cuda is None: from theano.sandbox import cuda return cuda.mem_info()[0]/1024./1024
return self.q(css='.signatory-title-value').first.html[0]
macro_measure = metric(y_true, y_pred, average="macro") assert_almost_equal(macro_measure, np.mean(label_measure))
assert_equal(_barnes_hut_tsne.test_index2offset(), 1) assert_equal(_barnes_hut_tsne.test_index_offset(), 1)
return self.q(css='.wrapper-status').visible
self.socket.close()
sigmoid = CalibratedClassifierCV(est, cv=2, method='sigmoid')
optioninput_element = etree.Element("optioninput")
if self.structure: ordered_blocks = OrderedDict() self._traverse_tree(self.structure['root'], self.structure['blocks'], ordered_blocks) return ordered_blocks
def setUp(self): super(TestRenderXBlockSelfPaced, self).setUp() SelfPacedConfiguration(enabled=True).save() def course_options(self): return {'self_paced': True}
resp = self.client.get(self.url_unlocked) self.assertEqual(resp.status_code, 200) self.assertEquals('Origin', resp['Vary'])
backend = self.select_backend(request) view = self.get_view_for_backend(backend) return view(request, *args, **kwargs)
clf = GaussianNB(priors=np.array([-1., 2.])) assert_raises(ValueError, clf.fit, X, y)
return self.children(CourseOutlineChild)
for _ in xrange(0, max_iters): last_d = doc_topic_d
for child_location in xblock.children: child = block_structure.get_xblock(child_location) group = child_to_group.get(child_location, None) child.group_access[partition_for_this_block.id] = [group] if group else []
n_topics, X = _build_sparse_mtx() lda = LatentDirichletAllocation(n_topics=n_topics, max_iter=10, random_state=0) distr = lda.fit_transform(X) perplexity_1 = lda.perplexity(X, distr, sub_sampling=False)
if parent_url is not None and index is not None: course_key = descriptor.location.course_key parent_location = course_key.make_usage_key_from_deprecated_string(parent_url)
if is_caller_html_or_text is False: self.results.violations.append(ExpressionRuleViolation( Rules.python_requires_html_or_text, self.node_to_expression(node.func) ))
email_instructions = _(u"The email address you used to register with {platform_name}").format( platform_name=settings.PLATFORM_NAME )
transform = AdditiveChi2Sampler(sample_steps=sample_steps) assert_equal(transform.sample_interval, None)
self.assertEqual(pq(response.content)(".sts-enrollment").length, 0)
raise NotImplementedError( "%s does not implement definition_to_xml" % self.__class__.__name__)
with patch('openedx.core.djangoapps.safe_sessions.middleware.log.error') as mock_log: yield self.assertFalse(mock_log.called)
if not isinstance(self.course_id, CourseLocator): return response
total_amount_paid = InvoiceTransaction.get_total_amount_of_paid_course_invoices(self.course_key) self.assertEqual(float(total_amount_paid), 0)
date = master_date.strftime('%Y-%m-%d %H:%M')
coach_user = User.objects.create_user('test_coach_user', 'test_coach_user@openedx.org', 'test') CourseCcxCoachRole(self.master_course_key).add_users(coach_user)
'shoppingcart.context_processor.user_has_cart_context_processor',
return self.backend_name == pipeline['backend']
select_option_by_text(language_selector, 'English') self.account_settings.wait_for_ajax() self.assertEqual(self.account_settings.value_for_dropdown_field('pref-lang'), u'English')
idx = mapping if isinstance(flat, CompositeSpace): assert 0 <= idx < len(flat.components) return flat.components[idx] else: assert idx == 0 return flat
num_labels_by_type = (len(_categories),
img[:, ring_w:ring_w + inner_h, ring_w:ring_w + inner_w] = inner_img
subject = render_to_string(subject_template, param_dict) message = render_to_string(message_template, param_dict) return subject, message
if not settings.FEATURES.get('MILESTONES_APP', False): return None from milestones import api as milestones_api return milestones_api.add_course_content_milestone(course_id, content_id, relationship, milestone)
y_true = rng.randint(0, 3, size=10) assert_raise_message(ValueError, "multiclass format is not supported", roc_auc_score, y_true, y_pred)
v3 = CountVectorizer(vocabulary=None) assert_raises(ValueError, v3.transform, train_data)
self.browser.refresh()
query = X[rng.randint(0, n_samples)].reshape(1, -1)
if check_pickle: pickle.dumps(function)
rng = np.random.RandomState(42) S = rng.standard_t(1.5, size=(20000, 2)) S[:, 0] *= 2.
user = kwargs['user'] updated_state = kwargs['state'] update_course_creator_group(kwargs['caller'], user, updated_state == CourseCreator.GRANTED)
source_version = block.edit_info.source_version return source_version if source_version is not None else block.edit_info.update_version
cv = list(check_cv(cv, X, y, classifier=is_classifier(estimator))) scorer = check_scoring(estimator, scoring=scoring)
__import__(name) return sys.modules[name]
data_dict = get_executive_report(course_id) data_dict.update( { 'total_enrollments': true_enrollment_count, 'report_generation_date': report_generation_date.strftime("%Y-%m-%d"), } )
self.assertTrue(self.certificates_section.pending_tasks_section.visible)
if kwargs.get('params', {}).get('course_id'): data.update({ "threads_count": 1, "comments_count": 2 })
task_id = str(uuid4())
code_prolog = CODE_PROLOG % random_seed
EMAIL_OPTIN_MINIMUM_AGE = PARENTAL_CONSENT_AGE_LIMIT
return [mock.call(self.store, self._get_lib_key(lib)) for lib in libraries]
if view_name == 'ccx_manage_student' and not is_email(identifier): self.assertContains(response, 'Could not find a user with name or email ', status_code=200)
import ipdb ipdb.set_trace() assert True
idx = np.arange(n_train) np.random.seed(13) np.random.shuffle(idx) X_train = X_train[idx] y_train = y_train[idx]
return self.q(css=self._bounded_selector(self.OPTION_SELECTOR)).results
if ApiAccessRequest.api_access_status(request.user) is not None: return redirect(reverse('api_admin:api-status')) return super(ApiRequestView, self).get(request)
def custom_score(y_true, y_pred): return (((y_true == y_pred).sum() - (y_true != y_pred).sum()) / y_true.shape[0])
confirm_prompt(self, cancel=True)
'rule': None
os.chmod(fn, st_mode | read_all)
input_dict = {'1_2_1': '42'} correct_map = problem.grade_answers(input_dict)
rbm.learning_rate = 0.06 rbm.n_iter = 20 rbm.n_components = 100 logistic.C = 6000.0
for field in self.CONTENT_FIELDS + self.SETTINGS_FIELDS + self.CHILDREN_FIELDS: self.assertTrue(new_version.fields[field].is_set_on(new_version))
elif self.algorithm == 'l-bfgs': self._fit_lbfgs(X, y, activations, deltas, coef_grads, intercept_grads, layer_units) return self
if not self.blank and value is self.Empty: raise ValidationError(self.error_messages['blank']) else: return super(OpaqueKeyField, self).validate(value, model_instance)
inter_clust_dists = np.inf * intra_clust_dists
def __init__(self, collection, page, num_pages, thread_count=0, corrected_text=None): self.collection = collection self.page = page self.num_pages = num_pages self.thread_count = thread_count self.corrected_text = corrected_text
return self.q(css='#upload_error').text[0]
if max_leaf_nodes < 0: builder = DepthFirstTreeBuilder(splitter, min_samples_split, min_samples_leaf, min_weight_leaf, max_depth) else: builder = BestFirstTreeBuilder(splitter, min_samples_split, min_samples_leaf, min_weight_leaf, max_depth, max_leaf_nodes)
def fit(self, X, y): return self def score(self, X, y): return 1.0
_exprArgCache = {} def resetCache(): ParserElement._exprArgCache.clear() resetCache = staticmethod(resetCache)
resp = self.client.get_html('/home/') self.assertEqual(resp.status_code, 302)
LogoutPage(self.browser).visit()
return self.page.num_pages
return _transform_selected(X, self._fit_transform, self.categorical_features, copy=True)
pca = PCA(svd_solver='full') pca.fit(X) assert_almost_equal(pca.explained_variance_ratio_.sum(), 1.0, 3)
self.assertEqual(processor_hash('test'), 'GqNJWF7X7L07nEhqMAZ+OVyks1Y=') self.assertEqual(processor_hash('edx '), '/KowheysqM2PFYuxVKg0P8Flfk4=')
return
module.runtime = inner_system inner_system.xmodule_instance = module
return None
response = self._get_page("verify_student_verify_now", course.id) self.assertNotContains(response, "Verification is no longer available")
from .celery import APP as CELERY_APP
X, y = datasets.make_hastie_10_2(n_samples=100, random_state=1) for Cls in [GradientBoostingRegressor, GradientBoostingClassifier]: est = Cls(n_estimators=200, max_depth=1) est.fit(X, y)
self.clear_child_cache()
KEY_EXPIRATION_IN_SECONDS = 86400
self.store.create_child( self.user_id, self.course.location, 'static_tab' )
sw = np.sqrt(np.atleast_1d(sample_weight)) y = y * sw[:, np.newaxis] K *= np.outer(sw, sw)
iris = datasets.load_iris() perm = rng.permutation(iris.target.size) iris.data, iris.target = shuffle(iris.data, iris.target, random_state=rng)
return etree.Element('truefalseresponse')
#self.debug(msg)
user = UserFactory.create() CourseEnrollment.objects.create( user=user, course_id=self.course.id, mode=enrollment_type, is_active=True ) return user
for this_X in (X, X_csr): mb_k_means = MiniBatchKMeans(n_clusters=n_clusters, batch_size=100, random_state=42) mb_k_means.fit(this_X)
def _warning_function(): warnings.warn("deprecation warning", DeprecationWarning)
p = T.tanh(linear_response) return p
CourseEnrollment.unenroll_by_email("not_jack@fake.edx.org", course_id) self.assert_no_events_were_emitted()
multi_db = True
TEST_DIR = REPO_ROOT / ".testids"
assert_raises(Exception, metric, y1, y2, sample_weight=np.hstack([sample_weight, sample_weight]))
configuration = self.get_configuration() return configuration.get(val_name, default)
return self._decision_function(X)
filepath = filename
trees = ExtraTreesClassifier(max_depth=3, n_estimators=10, random_state=0) trees.fit(X, y)
Xs.append(np.array([[0.0003817754041, 1.0], [0.0003817753750, 2.0]], dtype=np.float32))
sample_weight, estimator_weight, estimator_error = self._boost( iboost, X, y, sample_weight)
self.assertTrue('Activate Course Enrollment' in response.content)
self.assertTrue(CourseEnrollment.is_enrolled(self.global_staff, self.course.id))
for course in _COURSES: if course_id == course['course_id']: return course
return { 'user': user or self.user, 'usage_key': block.location, 'course_key': block.location.course_key, 'display_name': block.display_name, }
try: mod = import_module(app + '.startup') except ImportError: continue
new_mean_square_dx = ( self.decay * mean_square_dx + (1 - self.decay) * T.sqr(delta_x_t) )
self.assertTrue(filesystem.exists(exported_asset_name)) self.assertEqual(len(exported_static_files), 1)
recipient_list.append(finance_email)
problem = new_loncapa_problem(xml_str)
course_details.license = getattr(course_descriptor, "license", "all-rights-reserved")
self.assertTrue(self._has_changes(locations['grandparent'])) self.assertTrue(self._has_changes(locations['parent']))
theme_root = settings.ENV_ROOT / "themes" / settings.THEME_NAME
self.find_css('.signatory-title-input').first.fill(value)
return self.find_css("#start_time").first.attrs('value')[0]
self.assertTrue(self.store.has_item(course.id.make_usage_key('html', 'multi_parent_html')))
self.copy_from_server_to_local(remote_name, local_name) log.info(common_msg + "File %s has been locally cached to %s" % (remote_name, local_name))
for num, item in enumerate(extra_data, start=1): key = u"merchant_defined_data{num}".format(num=num) params[key] = item
train_composite = Train(dataset_composite, mlp_composite, SGD(0.0001, batch_size=20)) train_composite.algorithm.termination_criterion = EpochCounter(1) train_composite.main_loop()
link_href = self._find_within(".post-body p a").attrs('href') return link_href[0] if link_href else None
self.assertEqual(own_metadata(course1_item), own_metadata(course2_item))
for i in range(self.n_layers_ - 1): n_fan_in, n_fan_out = layer_units[i], layer_units[i + 1]
self.page.create_experiment_group_configuration() config = self.page.experiment_group_configurations[0] config.description = "Description of the group configuration."
SignalHandler.course_published.connect(listen_for_course_publish)
serializer_ctx["request"] = request
if self.multi_class == 'multinomial': scores = multi_scores coefs_paths = multi_coefs_paths
pos_switch = pos_label == 0 if pos_switch: pos_label = -neg_label
with outer_atomic(): entry = InstructorTask.objects.get(pk=entry_id) entry.task_state = PROGRESS entry.save_now()
if power_iteration_normalizer == 'auto': if n_iter <= 2: power_iteration_normalizer = 'none' else: power_iteration_normalizer = 'LU'
data[:, 3] /= data[:, 5]
self.assertNotIn("enrollment_action", self.captured_request.POST) self.assertNotIn("course_id", self.captured_request.POST)
self.q(css=self.auto_enroll_upload_button_selector).click()
self.assertTrue(self.store.has_changes(parent))
validators = ( traverse_tree, )
definition_guid = course_key.as_object_id(definition_guid) return self.db_connection.get_definition(definition_guid, course_key)
est.fit(data, y) threshold = 0.5 * np.mean(est.feature_importances_) mask = est.feature_importances_ > threshold assert_array_equal(X_transform, data[:, mask])
self.settings_patcher.stop() super(GatingTestCase, self).tearDown()
from .aws import * import os from django.core.exceptions import ImproperlyConfigured
col_names = [str(descr[0]) for descr in matlab_dict['mldata_descr_ordering'][0]]
target = (iris.target > 0).astype(np.intp) target = np.array(["setosa", "not-setosa"])[target]
return strip_key_collection(retval)
if not parent_location: return xblock
response = None log.exception("Outcome Service: Error when sending result.")
with self.assertRaises(PermissionDenied): add_user_with_status_granted(self.user, self.user) with self.assertRaises(PermissionDenied): update_course_creator_group(self.user, self.user, True)
accuracy_scorer = make_scorer(accuracy_score) f1_scorer = make_scorer(f1_score)
self.user.is_staff = True
dest_id = self.store.make_course_key(courselike_key.org, courselike_key.course, courselike_key.run)
course2.certificates_display_behavior = 'early_no_info' cert_status = {'status': 'unavailable'} self.assertEqual(_cert_info(user, course2, cert_status, course_mode), {})
data = fetch_olivetti_faces() X = data.images.reshape((len(data.images), -1)) y = data.target
resp = self.client.post( reverse('submit_answers', args=['NonExisting']), self.student_answers ) self.assertEquals(resp.status_code, 404)
(False, "en", "lms-footer.css"), (False, "ar", "lms-footer-rtl.css"),
assert_raises(ValueError, _fast_dot, A, A)
ir = IsotonicRegression() copy.copy(ir)
return self.q(css=ERROR_ITEM_CONTENT_SELECTOR).text
EmptyPromise( lambda: self.find_css('.signatory-panel-body .signatory-name-input').present, 'On signatory edit view' ).fulfill()
centers[center_idx] += np.sum(X[center_mask], axis=0)
db_table = 'django_comment_client_role'
all_lists = np.all([not hasattr(v, "rvs") for v in self.param_distributions.values()]) rnd = check_random_state(self.random_state)
AWS_QUERYSTRING_AUTH = AUTH_TOKENS.get('AWS_QUERYSTRING_AUTH', True) AWS_S3_CUSTOM_DOMAIN = AUTH_TOKENS.get('AWS_S3_CUSTOM_DOMAIN', 'edxuploads.s3.amazonaws.com')
self.client.logout() self._verify_response(403)
list_check = lambda x: isinstance(x, list) clf = CheckingClassifier(check_X=list_check) predictions = cval.cross_val_predict(clf, X.tolist(), y.tolist())
print cmd, logfile run_background_process(cmd, out_log=logfile, err_log=logfile, cwd=cwd)
pca = PCA(n_components=50) pca.fit(X) pca_test = PCA(n_components=50, svd_solver='full') pca_test.fit(X) assert_array_almost_equal(pca.components_, pca_test.components_)
for CourseState in self.course_actions_displayable_states + self.courses_with_state3_non_displayable: action_class.objects.update_state( CourseState.course_key, CourseState.state, should_display=CourseState.should_display, allow_not_found=True )
for dummy in range(6): BadgeAssertionFactory.create()
resources = find_release_resources() sh("i18n_tool transifex pull " + " ".join(resources))
certificate_id = content.pop("id") return certificate_id
USERNAME_MIN_LENGTH = 2 USERNAME_MAX_LENGTH = 30
pass
v, W = v[::-1], W[:, ::-1] return v, W
scheme_extensions = None
with open(os.path.abspath(path), 'w') as cur_file: cur_file.write(text)
pass
call_command('flush', verbosity=0, interactive=False, load_initial_data=False)
if hasattr(searchindex, 'decode'): searchindex = searchindex.decode('UTF-8')
self.assertIn(draft_html.location, public_vertical.children)
assert self.n_unique_specs == 1
LOGGER.debug('Starting service on port {0}'.format(self.port))
y_pred = base_estimator.predict(X)
for n_comp in np.arange(1, d): pca = PCA(n_components=n_comp, svd_solver='arpack', random_state=0)
descriptor = descriptor.get_children()[0] self.course_descriptor_no_inheritance_check(descriptor)
try: ranges.last.value = 'Failure' except InvalidElementStateException:
course_mode = CourseMode.DEFAULT_SHOPPINGCART_MODE
structure_json = models.TextField(verbose_name='Structure JSON', blank=True, null=True)
return serializer.data
md5er = hashlib.md5() update_hash(md5er, obj) return md5er.hexdigest()
self._find_within(".discussion-show").first.click() EmptyPromise( self.is_discussion_expanded, "Discussion expanded" ).fulfill()
cet = CourseEmailTemplate.objects.get(name=None) self.assertIsNotNone(cet)
pass
X_train = np.vstack([shifted_gaussian, stretched_gaussian])
if self.default and CourseCompleteImageConfiguration.objects.filter(default=True).exclude(id=self.id): raise ValidationError(_(u"There can be only one default image."))
VIDEO_SOURCE_DIR = REPO_ROOT / "test_root" / "data" / "video"
try: new_configuration = GroupConfiguration(request.body, course).get_user_partition() except GroupConfigurationsValidationError as err: return JsonResponse({"error": err.message}, status=400)
remove_master_course_staff_from_ccx( self.course, self.ccx_locator, self.ccx.display_name, send_email=True ) self.assertEqual(len(outbox), len(list_staff_master_course) + len(list_instructor_master_course))
self.store.publish(self.course.location, self.user_id)
overrides = overrides.copy() if overrides else {} overrides.setdefault("course_id", unicode(self.course.id)) return make_minimal_cs_thread(overrides)
time_isoformat.split('+')[0], "%Y-%m-%dT%H:%M:%S.%f"
yield check_estimators_unfitted if 'class_weight' in Classifier().get_params().keys(): yield check_class_weight_classifiers
regression.fit(x, y, sample_weight=w)
if dtype is None: dtype = theano.config.floatX return theano.shared(theano._asarray(value, dtype=dtype), name=name, borrow=borrow)
self.assertEqual(response.status_code, 403)
call_command("loaddata", "course_email_template.json")
super(BadImplementationAbstractEnrollmentReportProvider, self).get_enrollment_info(user, course_id)
certificate_count = 3 for __ in xrange(certificate_count): self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)
pred = km.predict(km.cluster_centers_) assert_array_equal(pred, np.arange(n_clusters))
super(TestGenerateCourseOverview, self).setUp() self.course_key_1 = CourseFactory.create().id self.course_key_2 = CourseFactory.create().id self.command = generate_course_overview.Command()
try: verify_format_docstrings() except SkipTest as e: import traceback traceback.print_exc(e) raise AssertionError( "Some file raised SkipTest on import, and inadvertently" " canceled the documentation testing." )
top_level_export_dir = 'exported_source_course_with_asides' export_course_to_xml( self.store, contentstore, dest_course_key, self.export_dir, top_level_export_dir, )
valid = SVHN('valid', path=local_path) check_dtype(valid) valid.apply_preprocessor(pipeline, can_fit=False)
X_features = combined_features.fit(X, y).transform(X)
assert world.is_css_not_present(ASSET_NAMES_CSS)
pass
resp = self.client.get('/') self.assertEquals(resp['X-Frame-Options'], 'DENY')
checkpoint = VerificationCheckpoint(course_id=self.course_key, checkpoint_location=self.reverification_location) checkpoint.save()
_ = lambda text: text
errstring = "Error: too few arguments" with self.assertRaisesRegexp(CommandError, errstring): call_command('export')
tab_ids[num_orig_tabs - 1], tab_ids[num_orig_tabs - 2] = tab_ids[num_orig_tabs - 2], tab_ids[num_orig_tabs - 1]
assignments = outcomes.get_assignments_for_problem( problem_descriptor, user_id, course_key ) for assignment in assignments: assignment.version_number += 1 assignment.save() return assignments
return 'latex' not in template['template_id'] or course.use_latex_compiler
p_up = dict(self.sgd_updates(self.params, gradients, learn_rates))
from __future__ import unicode_literals
world.wait_for( lambda _: len(world.browser.windows) == 2, timeout=5, timeout_msg="Timed out waiting for the LTI window to appear." )
self.user = UserFactory.create()
return self._decision_function(X)
self.clear() self.get_collected()
self.assertEqual( reverification_service.get_status(self.user.id, unicode(self.course_id), self.final_checkpoint_location), 'skipped' )
for idx, text in enumerate(text_options): if text == POLL_ANSWER: self.q(css=text_selector).nth(idx).click()
self.q(css=self.active_problem_selector('.annotation-return')).click()
inherited_settings = {}
self._check_underscore_expressions(underscore_template, results) results.prepare_results(underscore_template)
LogoutPage(self.browser).visit() self._make_har_file(login_page)
with self.assertNumQueries(3): self._assert_group_assignment(user, VerificationPartitionScheme.DENY)
for length in [248, 249, 250, 251, 252]:
if isinstance(block, XModuleDescriptor):
return self
ModeCreationPage( self.browser, self.course_id, mode_slug=u'verified', mode_display_name=u'Verified Certificate', min_price=10, suggested_prices='10,20' ).visit()
assert_array_equal(mb_k_means.predict(X_csr), mb_k_means.labels_)
from setuptools import setup setup( name="safe_lxml", version="1.0", packages=["safe_lxml"], install_requires=[ "lxml", "defusedxml" ], )
self.verify_pdf_certificate()
from course_modes.models import CourseMode
LmsAutoAuthPage(self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id).visit()
for i in range(3):
new_indexed_count = self.index_recent_changes(store, before_time) self.assertEqual(new_indexed_count, 5)
nn.set_params(algorithm='kd_tree')
iris = load_iris() scaler = StandardScaler() km = KMeans(random_state=0)
return self._is_element_visible(".response_{} .action-show-comments".format(response_id))
user_list[0].course_groups.remove(*cohort_list) assert_events("removed", user_list[:1], cohort_list) mock_tracker.reset_mock()
simultaneous_sort(dist, ind)
set_course_cohort_settings(course_key=self.course.id, is_cohorted=False) check_cohorted(False)
rng = np.random.RandomState(0) n_samples = 100 n_features = 80 n_components = 30 rank = 50
if did_validate: updated_data = cls.update_from_dict(key_values, descriptor, user, save=False)
self._capture_basic_metrics()
self.strategy.session_setdefault('auth_entry', 'login')
cv = list(super(ValidationKFold, self).__iter__()) for train, valid, test in get_k_fold_splits(cv): yield train, valid, test
return advertised_start is None and start == DEFAULT_START_DATE
_ = lambda text: text
self.assertNotIn('Search for a course', response.content) self.assertNotIn('<aside aria-label="Refine Your Search" class="search-facets phone-menu">', response.content)
self.course_outline.select_advanced_tab()
for student in students[:2]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=status, )
return get_members(mailchimp, list_id, 'unsubscribed')
result = self.client.login(username=self.USERNAME, password=self.NEW_PASSWORD) self.assertTrue(result)
from __future__ import unicode_literals
self.estimators_ = []
return _load_output(self._output_dir, _get_func_fullname(self.func), timestamp=self.timestamp, metadata=self.metadata, mmap_mode=self.mmap_mode, verbose=self.verbose)
with self.assertRaises(NotImplementedError): self.client.ajax_post( self.url, data={'invalid_request': None}, )
self.cmap = dict() self.items = self.cmap.items self.keys = self.cmap.keys self.overall_message = "" self.set(*args, **kwargs)
if not consumer: consumer = LtiConsumer.objects.get( consumer_key=consumer_key, )
data[s].ndim = len(data[s].shape)
from ..preprocessing import LabelEncoder
'provider', 'provider.oauth2', 'edx_oauth2_provider',
response = self.client.get_json(LIBRARY_REST_URL) self.assertEqual(response.status_code, 404)
response = self.client.post(reverse('admin:course_modes_coursemode_add'), data=data) self.assertRedirects(response, reverse('admin:course_modes_coursemode_changelist'))
self.wait_for_element_visibility('#password-reset-email', 'Email field is shown') self.q(css="#password-reset-email").fill(email)
super(BadImplementationAbstractEnrollmentReportProvider, self).get_payment_info(user, course_id)
for class_path in settings.AUTHENTICATION_BACKENDS: auth_class = module_member(class_path) if issubclass(auth_class, base_class): yield auth_class
disable_jquery_animations(page) disable_css_animations(page)
delete_item(category='sequential', name='test_sequence')
return [ self._load_item( course_key, item, data_cache, using_descriptor_system=using_descriptor_system, apply_cached_metadata=self._should_apply_cached_metadata(item, depth), for_parent=for_parent, ) for item in items ]
pass
assert_equal(neighbors.shape[1], n_neighbors)
upload_csv_to_report_store(rows, 'proctored_exam_results_report', course_id, start_date)
try: records = _fixed_getframes(etb, context, tb_offset) except: raise print('\nUnfortunately, your original traceback can not be ' 'constructed.\n') return ''
return '{}[data-locator="{}"] {}'.format( self.BODY_SELECTOR, self.locator, selector )
FOOTER_ORGANIZATION_IMAGE = "images/logo.png"
from _dummy_thread import get_ident as _get_ident
super(ThirdPartyAuthApiPermissionTest, self).setUp() client = self.configure_oauth_client() self.configure_api_permission(client, PROVIDER_ID_TESTSHIB)
new_block = self.store.get_item(new_block.location)
report_name = u"ORA_data" self.data_download_section.generate_ora2_response_report_button.click() self.data_download_section.wait_for_available_report() self.verify_report_download(report_name)
clf = svm.NuSVC(nu=0.0) assert_raises(ValueError, clf.fit, X_sp, Y)
bool_dict = [True, "True", "true", "T", "t", "1"] return value in bool_dict
return [parse_path_data(path) for path in self._paths] if self._paths else self._paths
return
return np.sum(self.score_samples(X))
_ = lambda text: text
user_partition_id = self.user_partition.id groups = self.user_partition.groups self.user_partition.scheme.current_group = groups[0]
requirements = CreditRequirement.objects.filter(course__course_key=course_key, active=True)
with remove_ccx(dest_key) as (dest_key, restore): return restore(self._modulestore.copy_from_template( source_keys, dest_key, user_id, **kwargs ))
print("Computing t-SNE embedding") tsne = manifold.TSNE(n_components=2, init='pca', random_state=0) t0 = time() X_tsne = tsne.fit_transform(X)
xml_obj = self.split_test_module.definition_to_xml(MemoryFS())
self.course = CourseFactory.create(emit_signals=True)
expiration_datetime_custom.short_description = "Upgrade Deadline"
n_ranked_above = sum(rank[r] <= rank[label] for r in relevant)
course = modulestore().get_item(block_map['course'].location) course.children.remove(block_key) block_map['course'] = update_block(course)
X, y = datasets.make_classification(n_samples=1000, n_features=100, n_informative=20, random_state=1234)
stochastic = None
data = np.asarray(data[skip:skip+trials])[:, 0, :, :]
self._verify_editable(self._get_course_details_response(False))
self.problem_section = ItemFactory.create(parent_location=chapter.location, category='sequential', metadata={'graded': True, 'format': 'Homework'}, display_name=self.TEST_SECTION_NAME)
resp = self.client.get('/') self.assertEquals(resp['X-Frame-Options'], 'ALLOW')
module = CapaFactory.create(max_attempts="2", attempts="1") self.assertFalse(module.closed())
submissions_score_set_handler(None, **SUBMISSION_SET_KWARGS) self.get_user_mock.assert_called_once_with('anonymous_id')
message = self.textbook_page.get_element_text('.wrapper-content .no-textbook-content') self.assertIn("You haven't added any textbooks", message)
def set( self, answer_id=None, correctness=None, npoints=None, msg='', hint='', hintmode=None, queuestate=None,
for frac in np.linspace(0, 0.5, 6): est = ForestEstimator(min_weight_fraction_leaf=frac, n_estimators=1, random_state=0) if "RandomForest" in name: est.bootstrap = False
if not hasattr(draft_node.module, 'xml_attributes'): draft_node.module.xml_attributes = {}
self.q(css='a.action-export').click()
indexed_count = self.reindex_course(store) self.assertEqual(indexed_count, 7)
alphas /= alphas[0] alphas = alphas[::-1] coefs = coefs[:, ::-1] mask = alphas >= eps mask[0] = True alphas = alphas[mask] coefs = coefs[:, mask] return alphas, coefs
if not filter_tabs: filtered_list.remove("tabs")
self.assertEqual(store, modulestore()._get_modulestore_for_courselike(new_key).get_modulestore_type())
self.assertAcceptEquals( 'rel;q=1.0, rel;q=0.5', self.process_request(accept='rel-ter;q=1.0, rel;q=0.5') )
return module.get_explicitly_set_fields_by_scope(Scope.settings)
dashboard_url = reverse('dashboard') self._test_change_session_hash(dashboard_url, reverse('signin_user') + '?next=' + dashboard_url)
__, count = self.contentstore.get_all_content_for_course(self.course2_key) self.assertEqual(count, len(self.course2_files))
wb = trials - len(self.aes) if wb <= 0: return 0 else: return wb
with self.assertRaisesRegexp(GitExportError, unicode(GitExportError.XML_EXPORT_FAIL)): git_export_utils.export_to_git( course_key, 'file://{0}'.format(self.bare_repo_dir))
return {'default_impl': True}
user = User.objects.get(email=email) user.is_active = True user.save()
default_grade = '-1'
self.client.get( pipeline.get_login_url(self.provider.provider_id, pipeline.AUTH_ENTRY_LOGIN))
n_features = X.shape[1] if self.n_features_to_select is None: n_features_to_select = n_features // 2 else: n_features_to_select = self.n_features_to_select
PER_STUDENT_ANONYMIZED_DESCRIPTORS = set( class_ for (name, class_) in XModuleDescriptor.load_classes() if not issubclass(class_, PER_COURSE_ANONYMIZED_DESCRIPTORS) )
unvisited_children = list(get_children(current_node))
field_object = self._cache.get(self._cache_key_for_kvs_key(kvs_key)) if field_object is None: return None else: return field_object.modified
tolW = max(0.001, tol) * np.sqrt(init_grad) tolH = tolW
for line in self.get_statistics(prefix): print(line)
tabs = [] expected_tabs = [u'LTI | Test Section | {0} Courseware | edX'.format(TEST_COURSE_NAME), u'TEST TITLE']
raise NotImplementedError
STATUS_MESSAGE_PATH = ENV_ROOT / "status_message.json"
outliers = abs_linear_loss[outliers_mask] num_outliers = np.count_nonzero(outliers_mask) n_non_outliers = X.shape[0] - num_outliers
return numpy.arccos(1. / val)
params, response = self._validate_parameters(request, bool(initial_verification)) if response is not None: return response
resp = self.client.get(self.get_url(self.student.username)) self.assertEqual(resp.status_code, status.HTTP_401_UNAUTHORIZED)
y_seq_of_seqs = [[], [1, 2], [3], [0, 1, 3], [2]] assert_raises(ValueError, LabelBinarizer().fit_transform, y_seq_of_seqs)
cov = ShrunkCovariance(shrinkage=0.5, store_precision=False) cov.fit(X) assert(cov.precision_ is None)
upload_csv_to_report_store(rows, 'grade_report', course_id, start_date)
self.workd = _aligned_zeros(3 * n, self.tp) self.workl = _aligned_zeros(3 * self.ncv * (self.ncv + 2), self.tp)
msg = "does not match the number of clusters" assert_raises_regex(ValueError, msg, MiniBatchKMeans(init=test_init, random_state=42).fit, X_csr)
self.certificates_section.wait_for_certificate_exceptions_section()
return view(request, course, ccx)
data_test, targets_test = data[n_samples / 2:], digits.target[n_samples / 2:] #data_test = scaler.transform(data_test)
XML_IMPORT_ARGS = inspect.getargspec(XmlImportData.__init__).args
assert len(state) == 2 assert isinstance(coeffs, float) _, state = state state = [state] coeffs = [coeffs]
self._send_handler_response("POST")
raise NotImplementedError()
cls.course_commentable_id = "course_level_commentable"
super(BaseComponentEditorView, self).__init__(browser) self.locator = locator
self.assertIn("Payment Form", resp.content)
result = self.enroll(self.course) self.assertFalse(result)
message = _('This student (%s) is already allowed to skip the entrance exam.') % self.student.email self.assertContains(response, message)
for index in [i for i, x in enumerate(found) if x]:
self.login_staff() self.assertEqual(self.get_progress_detail(), u'0/2')
resp = self.client.get(reverse('dashboard')) self.assertEquals(resp.status_code, 200)
sampling_algorithm["numpy-permutation"] = \ lambda n_population, n_sample: \ np.random.permutation(n_population)[:n_sample]
modulestore().get_item(usage_key)
if sp.isspmatrix_csr(X): return bincount(X.indices, minlength=X.shape[1]) else: return np.diff(sp.csc_matrix(X, copy=False).indptr)
self.assertFalse(library_container.has_validation_error) self.assertFalse(library_container.has_validation_warning)
self.assertFalse(user(email).is_active)
try: sec_index = self._section_titles().index(section_title) except ValueError: self.warning("Could not find section '{0}'".format(section_title)) return
CourseModeFactory.create(course_id=self.COURSE_KEY, mode_slug=CourseMode.HONOR) data = certs_api.get_certificate_header_context(is_secure=True)
self.find_css('.action-secondary').first.click()
if self.cert_status is not None: return { 'status': self.cert_status, 'can_unenroll': self.cert_status not in DISABLE_UNENROLL_CERT_STATES } else: return {}
response = getattr(self.client, method)(self.path, content_type=JSON_CONTENT_TYPE) self.assertEqual(response.status_code, 403)
return handle_node(self.tree)
return False
self.attempt_upload_file_and_verify_result(test_case, 'upload_screenshot')
msg = u"Error in xml '{x}': {err} ".format( x=etree.tostring(xml), err=err.message) raise Exception, msg, sys.exc_info()[2]
status_code = 400 default_detail = "The course key provided was invalid."
xx = np.linspace(-1, 5, 10) yy = np.linspace(-1, 5, 10)
return html.cssselect('.courses-processing li[data-course-key="{}"]'.format(unicode(course_key)))
return (self.expiration_date - timedelta(days=1)).strftime("%B %d, %Y") if self.expiration_date else None
xpath = "//div[@class='block']/p/b" self.assert_has_text(xml, xpath, 'prompt HTML')
scores = [x[1] for x in grid.grid_scores_] scores = np.array(scores).reshape(len(C_range), len(gamma_range))
if isinstance(dtype, tuple): return tuple(replace_none_dtypes(d, fallback_dtype) for d in dtype) else: return fallback_dtype if dtype is None else dtype
(error, msg) = self._send_to_queue(header, body, files_to_upload)
sqrt_n = np.sqrt(len(x)) return (sqrt_n - np.linalg.norm(x, 1) / norm(x)) / (sqrt_n - 1)
clf = DecisionTreeClassifier() clf.feature_importances_
return self.get_selected_option_text(self.LIBRARY_LABEL)
self.validate_preview_html(self.vertical, self.container_view) self.validate_preview_html(self.child_container, self.container_view) self.validate_preview_html(self.child_vertical, self.reorderable_child_view)
return User.objects.get(email=email)
resp = self.client.patch(self.detail_url, data, format='json', HTTP_AUTHORIZATION=self.auth) self.expect_error_fields(expected_errors, resp)
published_video = self.store.publish(self.video.location, self.user.id) self.validate_preview_html(self.video, STUDENT_VIEW, can_add=False)
self.courseware_page.visit() staff_page = StaffPage(self.browser, self.course_id) self.assertEqual(staff_page.staff_view_mode, 'Staff') return staff_page
response = self.http_get_for_course(course_id=unicode(self.empty_course.id), HTTP_AUTHORIZATION=auth_header) self.assertEqual(response.status_code, 404)
policy_str = '{}'
csv_file = open(path, 'r')
with MongoContentstoreBuilder().build() as self.contentstore: with modulestore_builder.build(contentstore=self.contentstore) as self.store: self._create_course(self.store) yield
assert_is_none(SoftwareSecurePhotoVerification.active_for_user(user))
from __future__ import division
if closest_subcluster.child_ is not None: split_child = closest_subcluster.child_.insert_cf_subcluster( subcluster)
if xblock_name is None: xblock_name = TestRecommender.XBLOCK_NAMES[0] url = self.get_handler_url(handler, xblock_name) return self.client.post(url, json.dumps(resource), '')
return ItemFactory.create( parent_location=parent_location, category=category, display_name=display_name, publish_item=False, user_id=self.user.id, **kwargs )
assert_page_correct( page=2, page_size=4, expected_start=4, expected_stop=8, expected_next=3, expected_prev=1 )
self._find_within("#comment_{} .wmd-input".format(comment_id)).fill(new_body)
use_svd = (n_neighbors > d_in)
response_content = {'test_response': 'test_content'} self.server.config['default'] = response_content
url = reverse('instructor_dashboard', kwargs={'course_id': self.course.id.to_deprecated_string()}) response = self.client.get(url)
self.db_connection.close_connections()
kwargs['w'] = 1
sel = np.zeros(self.num_examples, dtype=bool) sel[next_index] = True next_index = sel
self._create_courses_and_enrollments((self.TEST_ORG, True)) self._set_opt_in_pref(self.user, self.TEST_ORG, opt_in_pref)
self.assert_no_xpath(xml, "//label[@class='choicegroup_incorrect']", self.context)
CourseOverviewImageConfig.objects.all().delete() CourseOverviewImageConfig.objects.create( enabled=enabled, small_width=200, small_height=100, large_width=400, large_height=200 )
params[u'oauth_signature'] = urllib.unquote(params[u'oauth_signature']).decode('utf8')
X /= np.sqrt(np.sum(X ** 2, axis=0))
self.dashboard_page = DashboardPage(self.browser)
subsection_css = 'a[href*="Test_Subsection_2/"]' world.css_click(subsection_css)
result = VerificationStatus.objects.filter(checkpoint=self.first_checkpoint)[0] self.assertEqual(result.status, status) self.assertEqual(result.user, self.user)
self.assertEqual( actual_url, 'http://example-storage.com/profile-images/{name}_{size}.jpg?v={version}'.format( name=expected_name, size=expected_pixels, version=expected_version ) )
self._update_no_improvement_count(early_stopping, X_val, y_val)
if generate_translation: old_langs = set(old_metadata.get('transcripts', {})) if old_metadata else set() new_langs = set(item.transcripts)
return lambda course, reverse_url_func: reverse_url_func(reverse_name, args=[course.id.to_deprecated_string()])
del input_payload['current_time']
disable_animations(self) self.find_css('.action-primary').first.click() self.wait_for_ajax()
asides2 = published_xblock2.runtime.get_asides(published_xblock2) self.assertEquals(asides2[0].field11, 'aside1_default_value1') self.assertEquals(asides2[0].field12, 'aside1_default_value2')
idx = np.arange(X.shape[0]) np.random.seed(RANDOM_SEED) np.random.shuffle(idx) X = X[idx] y = y[idx]
return numpy.clip(X * 2. - 1., -1., 1.)
return open(file_name)
parser.add_argument('repository_url') parser.add_argument('--directory_path', action='store') parser.add_argument('--repository_branch', action='store')
n, p = 10, 5 rng = np.random.RandomState(0)
return int(self.get_setting_element(self.COUNT_LABEL).get_attribute('value'))
attempt2 = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt2.mark_ready() attempt2.submit() attempt2.approve() attempt2.save()
hasher = RandomTreesEmbedding(n_estimators=10, random_state=0, max_depth=3) X_transformed = hasher.fit_transform(X)
if not settings.FEATURES.get("ENABLE_CREDIT_ELIGIBILITY"): return {}
user = User.objects.get(email=EMAIL) self.assertEqual(user.username, EDX_USER_ID)
return course_metadata_utils.may_certify_for_course( self.certificates_display_behavior, self.certificates_show_before_end, self.has_ended() )
return self.list_display
return registration.activation_key
modulestore().get_item(usage_key)
courses = [course for course in courses if course.id != course_key] if courses: courses = _remove_in_process_courses(courses, in_process_course_actions) settings_context.update({'possible_pre_requisite_courses': courses})
if 'custom_checking' in self.text_customization: return self.text_customization.get('custom_checking')
cart = Order.get_cart_for_user(user=student) CertificateItem.add_to_order(cart, course_id, 50, 'verified') cart.purchase()
pass
version_history = modulestore().get_block_generations(updated_problem.location) self.assertEqual(version_history.locator.version_guid, first_problem.location.version_guid)
cursor.execute(query, [module_id.to_deprecated_string()])
self.store.unpublish(item_location, self.user_id) item = self.store.get_item(item_location) self.assertFalse(self.store.has_published_version(item))
model = CourseRegistrationCodeInvoiceItem extra = 0 can_delete = False readonly_fields = ( 'qty', 'unit_price', 'currency', 'course_id', ) def has_add_permission(self, request): return False
'html5_sources': ['http://www.example.com/source.mp4'], 'data': '',
return self.default_answer_map
trigger_time = datetime.now(UTC) return CoursewareSearchIndexer.index( store, self.course.id, triggered_at=trigger_time, reindex_age=(trigger_time - since_time) )
merged_group_ids = _MergedGroupAccess._intersection(xblock_partition_access, merged_parent_group_ids)
raise NotImplementedError
for subs_id in youtube_subs.values(): self.clear_sub_content(subs_id)
knn_mo = neighbors.KNeighborsClassifier(weights=weights, algorithm=algorithm) knn_mo.fit(X_train, y_train) y_pred_mo = knn_mo.predict(X_test)
if isinstance(exceptions, tuple): names = " or ".join(e.__name__ for e in exceptions) else: names = exceptions.__name__
self.course_id = course_id self.load_error_modules = load_error_modules self.modulestore = xmlstore
for i in range(self.n_eigen + self.minibatch_size): self.G[i,i] += self.regularizer
with assert_raises(TypeError): StudioValidation("id").set_summary("foo")
if not config.is_certification_enabled: LOGGER.warning( 'Task award_program_certificates cannot be executed when program certification is disabled in API config', ) raise self.retry(countdown=countdown, max_retries=config.max_retries)
with self.assertRaises(AttributeError): getattr(self.profile, '_changed_fields')
seed = module.seed self.assertTrue(seed is not None)
parent = None
call_command("loaddata", "course_email_template.json")
return
assert_equal(type(X_transformed), np.ndarray)
key = UsageKey.from_string(ref_string) return key.replace(run=self.modulestore.fill_in_run(key.course_key).run)
HIDDEN_SIZE = 1000 SALT_PEPPER_NOISE = 0.4 GAUSSIAN_NOISE = 0.5
course_key = courselike.id
if mappings: for key in mappings.iterkeys(): if re.match(key, hostname): return mappings[key]
self._original = None
self.len_indices_pos[curr_len] += curr_batch_size self.len_curr_counts[curr_len] -= curr_batch_size self.total_curr_counts -= curr_batch_size return curr_indices
CREDIT_MODES = [CREDIT_MODE]
if xblock.location in blocks_visited: return
remove_master_course_staff_from_ccx(self.course, self.ccx_locator, self.ccx.display_name) self.assertEqual(len(outbox), len(list_staff_master_course) + len(list_instructor_master_course))
self.filter(id=entry_id).delete()
if all_options_selected and not has_option: all_options_selected = False return all_options_selected
self.check_val('True', True)
for app in ENV_TOKENS.get('ADDL_INSTALLED_APPS', []): INSTALLED_APPS += (app,)
neigh_ind = neigh_ind[ sample_range, np.argsort(dist[sample_range, neigh_ind])]
MESSAGE = _('The specified remote branch is not available.')
self.course_fixture._update_xblock(component.locator, {'metadata': metadata}) self.browser.refresh() self.container_page.wait_for_page()
METRIC_UNDEFINED_BINARY = [ "samples_f0.5_score", "samples_f1_score", "samples_f2_score", "samples_precision_score", "samples_recall_score", "coverage_error",
FEATURES['ENABLE_CSMH_EXTENDED'] = True INSTALLED_APPS += ('coursewarehistoryextended',)
self.client.logout() self._test_return_login()
self.assertChildren(block, self.all_children)
self.testing_course.enrollment_start = self.tomorrow self.testing_course.enrollment_end = self.nextday self.testing_course = self.update_course(self.testing_course, self.user.id)
email_label = _(u"Email")
try: access_group = Group.objects.get(name=settings.PAYMENT_REPORT_GENERATOR_GROUP) except Group.DoesNotExist: return False return access_group in user.groups.all()
self.assertEqual(response.status_code, 200)
clf1 = LogisticRegressionCV(cv=precomputed_folds) target_copy = target.copy() target_copy[target_copy == 0] = 1 clf1.fit(train, target_copy)
self.assertEqual( utils.get_discussion_category_map(self.course, requesting_user or self.user), expected )
n_samples = X.shape[0] X_train, y_train = X[:n_samples / 2], y[:n_samples / 2] X_test, y_test = X[n_samples / 2:], y[n_samples / 2:]
self.client.logout()
self.q(css=self._bounded_selector(".annotator-close")).first.click() self.wait_for_notes_invisibility("Note is canceled.") return self
return self.posterior.encode_conditional_params(X)
world.wait_for(lambda _: world.css_text('#data-student-profiles-table') not in [u'', u'Loading'])
s = cPickle.dumps(obj, get_pickle_protocol()) return cPickle.loads(s)
super(DashboardSearchTest, self).tearDown() os.remove(self.TEST_INDEX_FILENAME)
self.assertFalse(self.advanced_settings.is_validation_modal_present())
certs_api.set_cert_generation_enabled(self.COURSE_KEY, True) self._assert_enabled_for_course(self.COURSE_KEY, True)
course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
evaluate_prerequisite(self.course, self.prob1.location, self.user.id) self.assertFalse(mock_module_score.called)
return self.course_overview
return next((tab for tab in tab_list if tab.get('url_slug') == url_slug), None)
self.course.display_coursenumber = None updated_course = self.update_course(self.course, self.user.id)
init_space, source = self.data_specs X_space, init_y_space = init_space.components new_y_space = VectorSpace(dim=num_classes) new_space = CompositeSpace((X_space, new_y_space)) self.data_specs = (new_space, source)
LOGGER.debug(self._format_msg(format_str, *args))
if hasattr(settings, 'DEPRECATED_ADVANCED_COMPONENT_TYPES'): xblock_types.extend( xblock_type for xblock_type in settings.DEPRECATED_ADVANCED_COMPONENT_TYPES if xblock_type not in xblock_types )
raise NotImplementedError()
'openedx.core.djangoapps.coursetalk',
try: course_key = CourseKey.from_string(course_id) user = User.objects.get(id=user_id) course = modulestore().get_course(course_key)
visible_serialized_account = {} for field_name in field_whitelist: visible_serialized_account[field_name] = serialized_account.get(field_name, None) return visible_serialized_account
TEST_PROFILE_IMAGE_BACKEND = deepcopy(settings.PROFILE_IMAGE_BACKEND) TEST_PROFILE_IMAGE_BACKEND['options']['base_url'] = '/profile-images/'
block = modulestore().get_item(block_location) block.group_access = access_dict modulestore().update_item(block, 1)
plot_batch_errors(all_errors, n_components, batch_sizes, data)
self._W = W
movie_reviews_data_folder = sys.argv[1] dataset = load_files(movie_reviews_data_folder, shuffle=False) print("n_samples: %d" % len(dataset.data))
MODULESTORE = convert_module_store_setting_if_needed(MODULESTORE)
clf = svm.OneClassSVM() clf.fit(X) pred = clf.predict(T)
acond = anorm * sqrt(ddnorm) res1 = phibar**2 res2 = res2 + psi**2 rnorm = sqrt(res1 + res2) arnorm = alfa * abs(tau)
solver = 'svd'
elif isinstance(proxy, six.string_types): return preprocess(proxy) else: return proxy
location = self.problem_location(problem_url_name) modx_url = self.modx_url(location, "problem_get") resp = self.client.get(modx_url) return resp
'ENABLE_MKTG_SITE': False,
_DELETED_SENTINEL = object()
iris = load_iris() perm = rng.permutation(iris.target.size) iris.data = iris.data[perm] iris.target = iris.target[perm]
url_to_enroll = reverse(course_about, args=[course_id]) if settings.FEATURES.get('ENABLE_MKTG_SITE'): url_to_enroll = marketing_link('COURSES')
return _can_enroll_courselike(user, courselike)
if math_expr.strip() == "": return ""
self.certificates_section.remove_first_certificate_exception() self.assertNotIn(self.user_name, self.certificates_section.last_certificate_exception.text) self.assertNotIn(notes, self.certificates_section.last_certificate_exception.text)
skip_entrance_exam = models.BooleanField(default=True)
response = self.client.post(self.visibility_url) self.assertEqual(response.status_code, 404)
self.assertTrue(self.advanced_settings.is_validation_modal_present())
user_groups = _get_user_partition_groups( self.course.id, [self.split_test_user_partition], self.user ) self.assertEquals(len(user_groups), 1)
assert_raises(ValueError, sel.transform, np.array([[1], [2]]))
queryset = cls.objects.filter( course_id=course_id, module_type='problem', grade__isnull=False ) if "read_replica" in settings.DATABASES: return queryset.using("read_replica") else: return queryset
self.page.visit() self.page.wait_until_no_loading_indicator()
if any(relative_path.lower().endswith(excluded_ext.lower()) for excluded_ext in excluded_exts): serve_from_cdn = False
command.handle(output_path, *org_list, courses=only_courses)
images = np.zeros((3,) + face.shape) images[0] = face images[1] = face + 1 images[2] = face + 2 return images
return len(self.q(css='div.wrapper-note-excerpts').results)
if field_name == 'children': continue
self.defaults = block_data.get('defaults', {})
cc_rendered_selector = self.get_element_selector(CSS_CLASS_NAMES['closed_captions']) self.wait_for_element_visibility(cc_rendered_selector, 'Closed captions rendered')
assert mlp_composite.get_input_space() == fl.get_input_space()
self.user.is_active = False self.user.save()
self.users = [ UserFactory.create() for dummy0 in range(self.USER_COUNT) ]
labels = np.array(labels, copy=True) unique_labels = np.unique(labels) for i in unique_labels: yield labels == i
self.children_for_user = { user: [ ItemFactory(category=child_type, parent=self.parent).scope_ids.usage_id for child_type in BLOCK_TYPES ] for user in self.users.itervalues() }
self.password = 'test' self.user = UserFactory.create(password=self.password) self.staff = UserFactory.create(password=self.password, is_staff=True)
multi_db = True
self.wait_for_field('image') return self.q(css='.u-field-upload-button').visible
items_in_tree = self.store.get_items(course_key, include_orphans=False)
enrollment.deactivate() self.assertFalse(CourseEnrollment.is_enrolled(user, course_id)) self.assert_no_events_were_emitted()
return [{'username': username, 'remote_id': 'remote_' + username} for username in usernames]
n_estimators_values = [1, 5, 10, 20, 30, 40, 50] accuracies_trees = np.zeros(len(n_estimators_values), dtype=float)
logreg.fit(X, Y)
pass
self.violations = [v for v in self.violations if not self._is_commented(v, line_comment_delim)]
return (self.get_input_space(), self.get_input_source())
if slug_is_numerical(slug): slug = slug + "_"
year = datetime.date.today().year age_limit = settings.PARENTAL_CONSENT_AGE_LIMIT profile.year_of_birth = (year - age_limit) - 1 profile.save()
return descriptor_global_local_resource_url(block, uri)
log.warning("Send-email task %s for email %s: being retried", current_task_id, email_id)
self._set_opt_in_pref(self.user, "MyOrg", True) self._set_opt_in_pref(self.user, "myorg", False)
X -= self.x_mean_ X /= self.x_std_ Ypred = np.dot(X, self.coef_) return Ypred + self.y_mean_
self.send_delete(self.client) self.send_get(self.client, expected_status=404)
rng = np.random.RandomState(0)
topics = self.setup_topics(teams_per_topic=0) self.assert_serializer_output(topics, num_teams_per_topic=0, num_queries=1)
metric_str = metric if name in METRICS_WITH_POS_LABEL: metric_str = partial(metric_str, pos_label=pos_label_str)
self.assertTrue( self.thread_page_1.check_threads_rendered_successfully(thread_count=self.thread_count) )
api.set_credit_requirement_status("bob", self.course_key, "grade", "grade")
self._check_staff(self.course) self._check_staff(self.test_course)
return self.database.connection.max_wire_version
deadline_is_explicit = models.BooleanField(default=False)
blocks_visited.add(xblock.location)
self.enrollment = CourseEnrollmentFactory( user=self.user, course_id=self.course.id, mode="verified" )
X = -np.ones((5, 10)) lda = LatentDirichletAllocation() regex = r"^Negative values in data passed" assert_raises_regexp(ValueError, regex, lda.fit, X)
return self.find_css('.actions .delete').present
self.course.user_partitions = partitions self.course = self.store.update_item(self.course, ModuleStoreEnum.UserID.test)
vars().update(ENV_TOKENS)
for user in users: CourseEnrollment.enroll(user, course_key)
index = world.get_setting_entry_index(DISPLAY_NAME) world.set_field_value(index, "<script>alert('test')</script>") verify_modified_display_name_with_html() world.save_component()
return cls(xblock_wrapper.browser, xblock_wrapper.locator)
MICROSITE_BACKEND = ENV_TOKENS.get("MICROSITE_BACKEND", MICROSITE_BACKEND) MICROSITE_TEMPLATE_BACKEND = ENV_TOKENS.get("MICROSITE_TEMPLATE_BACKEND", MICROSITE_TEMPLATE_BACKEND) MICROSITE_DATABASE_TEMPLATE_CACHE_TTL = ENV_TOKENS.get( "MICROSITE_DATABASE_TEMPLATE_CACHE_TTL", MICROSITE_DATABASE_TEMPLATE_CACHE_TTL )
centers = km.cluster_centers_ assert_equal(centers.shape, (n_clusters, n_features))
if os.getenv('DISPLAY') is None: try: import matplotlib matplotlib.use('Agg') except: pass
message = "np.nan is an invalid document, expected byte or unicode string." exception = ValueError
self.assertEquals( preview.latex_preview('2*3/4/5'), r'\frac{2\cdot 3}{4\cdot 5}' )
RestrictedCourse.objects.create(course_key=self.course.id)
call_command('delete_orphans', unicode(published_branch), '--commit')
#html_title = None
return
from collections import namedtuple import datetime BlockInfo = namedtuple('BlockInfo', 'block_id, category, fields, sub_tree')
self.lc_block = self._add_library_content_block(self.course, self.lib_key)
short_name = '.'.join(parts[:(i + 1)]) break
assert_raises(ValueError, e.fit, X_zero_samples, [])
self.user = UserFactory.create() self.client.login(username=self.user.username, password='test') CourseEnrollmentFactory.create(user=self.user, course_id=self.course_key)
return datetime.datetime.utcnow().replace(tzinfo=utc)
self.client.login(username=self.audit_course_instructor.username, password='test')
importances = est.feature_importances_ est.set_params(n_jobs=2) importances_parrallel = est.feature_importances_ assert_array_almost_equal(importances, importances_parrallel)
read_only_fields = set(update.keys()).intersection( AccountUserSerializer.get_read_only_fields() + AccountLegacyProfileSerializer.get_read_only_fields() )
response = self.client.post(reverse('commerce:checkout_receipt'), params={'basket_id': 1}, data=post_data) self.assertEqual(response.status_code, 200) return response
self.xmodule_runtime.xmodule_instance = None
return np.tanh(X, out=X)
xblocks = get_course_blocks(course_key, category) return xblocks
with override_settings(CREDIT_PROVIDER_SECRET_KEYS={}): response = self._credit_provider_callback(request_uuid, 'approved', keys={}) self.assertEqual(response.status_code, 403)
backward_reduce_ndarray = ArrayMemmapReducer( None, pool_folder, mmap_mode, verbose) backward_reducers[np.ndarray] = backward_reduce_ndarray backward_reducers[np.memmap] = reduce_memmap
from __future__ import unicode_literals
request = RequestFactory().request() request.user = self.user all_tabs = get_course_tab_list(request, course) return any(tab.type == 'ccx_coach' for tab in all_tabs)
DEFAULT_ASSET_COLLECTION_NAME = 'assetstore'
if isinstance(value, datetime.timedelta) or value is None: return value return self.from_json(value)
raise NotImplementedError()
if keep_descendants: for child in children: for parent in parents: self._add_relation(parent, child)
self.assertEqual( StudentModule.objects.filter( student=self.module_to_reset.student, course_id=self.course.id, module_state_key=self.module_to_reset.module_state_key, ).count(), 1 )
elif request.method == 'DELETE': return delete_entrance_exam(request, course_key)
super(CustomSVR, self).fit(X, y, sample_weight=sample_weight) self.data_type_ = type(X) return self
log.exception( "Indexing error encountered, courseware index may be out of date %s - %r", structure_key, err ) error_list.append(_('General indexing error occurred'))
yyy = np.column_stack([y, y, y])
pass
p = T.nnet.sigmoid(linear_response) return p
return course_metadata_utils.course_end_datetime_text( self.end, format_string, strftime_localized )
if average is not None: return np.average(score, weights=average_weight) else: return score
for certificate in certificates: certificate['is_active'] = is_active break
visibility_editor = self.edit_component_visibility(component) self.verify_selected_labels(visibility_editor, expected_labels) visibility_editor.save()
CLASS_PRIORITY = ['video', 'problem']
return check_mongo_calls_range(max_finds=calls)
do_init = not(self.warm_start and hasattr(self, 'converged_')) n_init = self.n_init if do_init else 1
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
self.client = AjaxEnabledTestClient()
self.user.password = u'new password' with self.assertRaises(IntegrityError): self.user.save() self.assert_no_events_were_emitted()
students = self._create_students(10)
assert_raises(ValueError, cval.StratifiedShuffleSplit, y, 3, 2) assert_raises(ValueError, cval.StratifiedShuffleSplit, y, 3, 3, 2)
patcher = patch( 'social.backends.twitter.TwitterOAuth.unauthorized_token', create=True, return_value="unauth_token" ) patcher.start() self.addCleanup(patcher.stop)
self.assertEqual([], course_detail_json['pre_requisite_courses'])
self.provider = Registry.get(provider_id) if not self.provider: raise Http404
cmap = CorrectMap() for answer_id in answer_ids: cmap.update(CorrectMap(answer_id=answer_id, queuestate=None)) self.problem.correct_map.update(cmap)
if not hasattr(self, 'sampling_procedure') or \ self.sampling_procedure is None: self.sampling_procedure = GibbsEvenOdd() self.sampling_procedure.set_dbm(self)
FOOTER_BROWSER_CACHE_MAX_AGE = 5 * 60
course = get_course_by_id(SlashSeparatedCourseKey.from_deprecated_string(course_id)) unit = find_unit(course, request.GET.get('url')) return JsonResponse(dump_module_extensions(course, unit))
pass
org_access_role(lib_key_pacific.org).add_users(self.non_staff_user)
user = models.ForeignKey(User, db_index=True, null=True) course_id = CourseKeyField(max_length=255, db_index=True)
response = self.client.get(self.url) self.assertTrue(self.email_modal_link in response.content)
target = [-1] * len(JUNK_FOOD_DOCS) + [1] * len(NOTJUNK_FOOD_DOCS)
return np.dot(np.dot(u * (1. / np.sqrt(s)), u.T), W)
self.vert1 = ItemFactory.create( parent_location=self.seq1.location, category='vertical', display_name='untitled vertical 1' )
from __future__ import unicode_literals
self.browser.refresh() return self.components
self.assertFalse(SignatureValidator(self.lti_consumer).check_nonce(nonce))
raise NotImplementedError()
backends = self._reload_backends() self.assertEqual(len(backends), 1) tracker.send({}) self.assertEqual(backends.values()[0].count, 1)
self.assertEqual(module.attempts, 1)
users = self.get_json(USER_LIST_URI)["results"] for user in users: if user["id"] == target_user.id: return user["url"] self.fail()
vocabulary = dict(vocabulary) if not vocabulary: raise ValueError("empty vocabulary; perhaps the documents only" " contain stop words")
self.assertEquals(preview.latex_preview('log10(3)'), r'\log_{10}(3)')
from optparse import make_option from django.core.management.base import BaseCommand, CommandError from .prompt import query_yes_no
prob /= prob.sum(axis=1).reshape((prob.shape[0], -1)) return prob
instance._state.adding = False
RateLimitConfiguration = apps.get_model("util", "RateLimitConfiguration") objects = RateLimitConfiguration.objects if not objects.exists(): objects.create(enabled=True)
_bulk_ops_record_type = BulkOpsRecord
clf = svm.SVC(kernel='linear', C=1.0) clf.fit(X, y)
return '{name}_{size}.{file_extension}'.format(name=name, size=size, file_extension=file_extension)
axes = self.input_space.axes assert len(axes) == 4
problem = new_loncapa_problem(xml_str, capa_system=the_system) rendered_html = etree.XML(problem.get_html())
self.wait_for_ajax() return self._is_element_visible(".response_{} .response-body".format(comment_id))
self.assertSetEqual( set(course_action_state.course_key for course_action_state in expected), set(course_action_state.course_key for course_action_state in found))
'expect': self.expect,
labels = np.zeros_like(mean) labels[np.arange(labels.shape[0]), am] = 1.0
self.assertFalse(_can_download_report(self.user))
if api_response.data is not None and api_response.data != '': content = json.dumps(api_response.data)
sequential = get_and_verify_publish_state('sequential', self.SEQUENTIAL, True) self.assertFalse(getattr(sequential, "is_draft", False))
view_html = proctoring_service.get_student_view( user_id=user_id, course_id=course_id, content_id=content_id, context=context, user_role=user_role_in_course )
self.assertTrue(self.video.is_video_rendered('youtube'))
return sel
#html_short_title = None
ext_user = User.objects.get(email=self.ext_user.email) self.assertTrue(auth.user_has_role(ext_user, CourseStaffRole(self.course.id)))
pass
update_subtask_status(entry_id, task_id, subtask_status)
self.navigate_to_video()
alternate_course = self.create_course(course='mobile', mobile_available=True)
getattr(delegator, method)(delegator_data.fit_args[0])
from uuid import uuid4
msg = colorize('green', "Confirming servers are running...") print msg bokchoy_utils.start_servers(self.default_store, self.coveragerc)
PYTHON_LIB_ZIP = "python_lib.zip"
expected = digits.target[n_samples / 2:] predicted = classifier.predict(data[n_samples / 2:])
regex = re.compile('^' + answer + '$', flags=flags | re.UNICODE) return re.search(regex, given)
return self.q(css='.form-create.create-user .user-email-input').visible
y = np.array([3, 7, 5, 9, 8, 7, 10]) x = np.arange(len(y))
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course_key): assertProblemNameEquals(problem_original_name)
try: return cls.objects.get(user=student, course_id=course_id) except cls.DoesNotExist: pass return None
_("There was a problem with the staff answer to this problem: complex boundary.")
precs_chol_diag = 1. / np.sqrt(covars_diag) log_prob = _estimate_log_gaussian_prob_diag(X, means, precs_chol_diag) assert_array_almost_equal(log_prob, log_prob_naive)
course_names = self.dashboard_page.wait_for_page().available_courses self.assertIn(self.course_info["display_name"], course_names)
if draft_node.parent_location is None: continue
self.assertEqual(resp.status_code, 200)
log.exception("Error in get_module") return None
self.mu = sharedX(bias, name = 'mu')
Env.METRICS_DIR.makedirs_p()
self.assertContains(resp, "super-ugly") self.assertContains(resp, "This file is only for demonstration, and is horrendous!")
account_settings.switch_account_settings_tabs('accounts-tab')
GraphLassoCV(alphas=[0.8, 0.5], tol=1e-1, n_jobs=1).fit(X)
Vi = V[i, :, n_neighbors - s_i:] alpha_i = np.linalg.norm(Vi.sum(0)) / np.sqrt(s_i)
link = utils.get_lms_link_for_item(location, True) self.assertEquals( link, "//preview.localhost/courses/mitX/101/test/jump_to/i4x://mitX/101/vertical/contacting_us" )
self.courseware_page.click_next_button_on_top() self.assert_navigation_state('Test Section 1', 'Test Subsection 1,1', 1, next_enabled=True, prev_enabled=True)
from pylearn2.datasets import vector_spaces_dataset
assert_equal(lshf._fit_X.shape[0], n_samples + n_samples_partial_fit) assert_equal(len(lshf.original_indices_[0]), n_samples + n_samples_partial_fit) assert_equal(len(lshf.trees_[1]), n_samples + n_samples_partial_fit)
ifp = self.capa_system.filestore.open(filename)
JOBLIB_SPAWNED_PROCESS = "__JOBLIB_SPAWNED_PARALLEL__"
if instance.state == CourseCreator.DENIED or granted_state_change: send_user_notification.send( sender=sender, user=instance.user, state=instance.state )
Y /= Y.sum(axis=1)[:, np.newaxis] loss = -(T * np.log(Y)).sum(axis=1)
return self.prior.log_p_z(z)
self.check_caches("mstc_cache_test_key")
try: export_dir = mkdtemp() yield export_dir finally: rmtree(export_dir, ignore_errors=True)
colors_ = cycle(colors.cnames.keys())
response = self.client.post(self.url, data) self.assertHttpBadRequest(response)
retval = func(field_decorator=strip_key_collection, *args, **kwargs)
suff_stats = np.zeros(self.components_.shape) for sstats in sstats_list: suff_stats += sstats suff_stats *= self.exp_dirichlet_component_
backend = "multiprocessing"
days_good_for = settings.VERIFY_STUDENT["DAYS_GOOD_FOR"] return self.created_at + timedelta(days=days_good_for)
face_image_url = models.URLField(blank=True, max_length=255) photo_id_image_url = models.URLField(blank=True, max_length=255)
with self.assertRaises(ValueError): mock_strftime_localized(test_datetime, 'BAD_FORMAT_SPECIFIER')
courses_list[course_key] = course
return ProfileImageView().post(request, username)
log_msg = ( 'remove_credit_requirement_status was called with ' 'user_id={user_id}, course_key_or_id={course_key_or_id} ' 'req_namespace={req_namespace}, req_name={req_name}, '.format( user_id=user_id, course_key_or_id=course_key_or_id, req_namespace=req_namespace, req_name=req_name ) ) log.info(log_msg)
with self.assertRaises(Exception): self.check_group('invalid', 'choice', 'checkbox')
def test_user_role(): return 'staff'
batch = _undo_op(batch, 'Cast')
MAX_MEMORY = np.int(2e9)
return
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
self._check_linkedin_visibility(True)
if 'parent_url' in value: del value['parent_url'] if 'parent_sequential_url' in value: del value['parent_sequential_url']
from logging import getLogger
def __init__(self, location, content): self.location = location self.content = content def get_id(self): return self.location.to_deprecated_son()
self.user = random.getrandbits(32) self.new_course = modulestore().create_course( 'org', 'course', 'test_run', self.user, BRANCH_NAME_DRAFT, )
if branch_setting != ModuleStoreEnum.Branch.published_only: raise ValueError(u"Cannot set branch setting to {} on a ReadOnly store".format(branch_setting)) yield
try: get_course_overview_with_access(request.user, 'load', course_id) return redirect("/courses/{course_id}/wiki/{path}".format(course_id=course_id.to_deprecated_string(), path=wiki_path)) except Http404: pass
rng = np.random.RandomState(0)
organizations = microsite_object.get_organizations()
with self.assertRaisesRegexp(CommandError, unicode(GitExportError.BAD_COURSE)): call_command('git_export', 'foo/bar:baz', 'silly', stderr=StringIO.StringIO())
return self._folds[k]
self.q(css='{} .section-name'.format(parent_css)).first.click()
EmptyPromise(lambda: self.is_closed_captions_visible() == closed_captions_new_state, "Closed captions are {state}".format(state=state)).fulfill()
if obj.get("parent") is None: data["parent"] = None
os.mkdir(path) self.addCleanup(shutil.rmtree, path)
from pylearn2.gui.patch_viewer import PatchViewer
msg = "No module {loc} for student {student}--access denied?".format( loc=usage_key, student=student ) TASK_LOG.debug(msg) raise UpdateProblemModuleStateError(msg)
se = SpectralEmbedding(n_components=1, affinity="precomputed", random_state=np.random.RandomState(seed), eigen_solver="<unknown>") assert_raises(ValueError, se.fit, S)
if settings.ROOT_URLCONF == 'lms.urls': url_pattern = '/info' else: url_pattern = '/course/{}'.format(unicode(course_key))
knn.fit(X, y_str) y_pred = knn.predict(X[:n_test_pts] + epsilon) assert_array_equal(y_pred, y_str[:n_test_pts])
self._choose_algorithm(self.algorithm, self.metric)
pass
isotonic = CalibratedClassifierCV(est, cv=2, method='isotonic')
create_account(self.USERNAME, self.USERNAME, self.EMAIL)
self.page = IndexPage(self.browser)
encoder=CourseSettingsEncoder
if not username: username = request.user.username if username != request.user.username and not has_api_key_permissions: return Response(status=status.HTTP_404_NOT_FOUND)
assert_equal(np.size(sample_without_replacement(0, 0)), 0)
course = self.store.get_course(course.id)
'edxmako.shortcuts.microsite_footer_context_processor',
if user is None: user = self.user if user not in self.session_data: self.session_data[user] = {} request = Mock(user=user, session=self.session_data[user]) _load_preview_module(request, descriptor)
url(r'^press/([_a-zA-Z0-9-]+)$', 'static_template_view.views.render_press_release', name='press_release'),
self._assertOLXBase(block_list, draft=True, published=True)
problem = new_loncapa_problem(xml_str) rendered_html = etree.XML(problem.get_html())
ref_inlier_mask = np.ones_like(ransac_estimator.inlier_mask_ ).astype(np.bool_) ref_inlier_mask[outliers] = False
return add_enrollment(student_id, course_id, mode=mode, is_active=is_active)
add_instructor(new_course.id, user, user)
kwargs[param_name] = arg
backend_name = forms.ChoiceField(choices=((name, name) for name in _PSA_SAML_BACKENDS))
response = self.client.post(reverse('admin:student_courseaccessrole_add'), data=data) self.assertRedirects(response, reverse('admin:student_courseaccessrole_changelist'))
split_modulestore = modulestore()._get_modulestore_by_type(ModuleStoreEnum.Type.split) active_version_collection = split_modulestore.db_connection.course_index structure_collection = split_modulestore.db_connection.structures
import uuid SECRET_KEY = uuid.uuid4().hex
to_js['base_image'] = Attribute('img').parse_from_xml(self.xml)
self.assertNotContains(resp, 'Explore free courses from')
self._verify_and_return_staff_page().set_staff_view_mode('Student') self._verify_components_visible(expected_components)
self.youtube_configuration['time_to_response'] = 0.4 self.metadata = self.metadata_for_mode('youtube_html5')
cls = args[0] if cls.search_is_enabled(): return f(*args, **kwargs)
return u'{cat}/{name}'.format(cat=location.category, name=location.name)
request = build_launch_request() del request.POST[missing_param] return views.lti_launch(request, None, None)
FILE_UPLOAD_STORAGE_BUCKET_NAME = ENV_TOKENS.get('FILE_UPLOAD_STORAGE_BUCKET_NAME', FILE_UPLOAD_STORAGE_BUCKET_NAME) FILE_UPLOAD_STORAGE_PREFIX = ENV_TOKENS.get('FILE_UPLOAD_STORAGE_PREFIX', FILE_UPLOAD_STORAGE_PREFIX)
module.lcp.get_html = Mock(side_effect=Exception("Test"))
url = reverse('activate', kwargs={'key': activation_key}) self.assert_request_status_code(200, url) self.assertTrue(User.objects.get(email=email).is_active)
return self.q(css='.annotatable-title').text[0]
response = self.client.post(set_course_price_url, data) self.assertTrue("Please Enter the numeric value for the course price" in response.content)
self.cohort_management_page.select_cohort_some_inline_discussion()
num_queries = 1
section = get_current_child(chapter, min_depth=1) if section is None: log.debug("No section found when loading current position in course") return None
LTI_USER_EMAIL_DOMAIN = 'lti.example.com'
for enrollment in manual_enrollments: self.assertEqual(enrollment.enrollment.mode, CourseMode.AUDIT)
CREDIT_TASK_DEFAULT_RETRY_DELAY = 30
current_time = datetime.datetime.now(UTC()) if override_time is not False: current_time = override_time
settings.TRACKING_BACKENDS.update({'second': None}) backends = self._reload_backends() self.assertEqual(len(backends), 1)
old_definition = self.get_definition(course_key, definition_locator.definition_id) if old_definition is None: raise ItemNotFoundError(definition_locator)
return self.q(css='.wrapper-release .title').first.text[0]
self.provider_id = provider_id
digits = datasets.load_digits()
super(ExportTestCase, self).setUp() self.url = reverse_course_url('export_handler', self.course.id)
X = np.arange(200)[:, np.newaxis] y = np.zeros(200) y[50:100] = 1 y[100:200] = 2 X[100:200, 0] = 200
self._auto_auth({'username': 'test', 'course_id': course_id})
self._assert_requirements_displayed(response, [ PayAndVerifyView.PHOTO_ID_REQ, PayAndVerifyView.WEBCAM_REQ, ])
assert_array_equal(children_unstructured, children_structured)
if bulk_ops_record.is_root: self._start_outermost_bulk_operation(bulk_ops_record, course_key)
settings.DEFAULT_TEMPLATE_ENGINE['DIRS'] = [ path for path in settings.DEFAULT_TEMPLATE_ENGINE['DIRS'] if path != settings.MICROSITE_ROOT_DIR ]
return self.find_courses(data['user'], CourseInstructorRole.ROLE, data.get('values'))
root_usage_key = self._create_vertical()
X = np.cast['float32'](X) X = X.reshape(-1, 2 * 96 * 96)
self.assertIn(map_key(actual_item_location), actual_item_map.keys())
X_train, X_train_lr, y_train, y_train_lr = train_test_split(X_train, y_train, test_size=0.5)
if sp.issparse(X): centers[c] = X[best_candidate].toarray() else: centers[c] = X[best_candidate] current_pot = best_pot closest_dist_sq = best_dist_sq
import logging import os import inspect import zipfile from tempfile import TemporaryFile
actual_enabled = certs_api.cert_generation_enabled(course_key) self.assertEqual(expect_enabled, actual_enabled)
export_extra_content( export_fs, self.modulestore, self.courselike_key, xml_centric_courselike_key, 'course_info', 'info', '.html' )
self.load_extra_content( system, course_descriptor, 'static_tab', self.data_dir / course_dir / 'tabs', course_dir, url_name )
result = embargo_api.check_course_access(self.course.id, ip_address='0.0.0.0') self.assertTrue(result)
transcripts_utils.download_youtube_subs(good_youtube_sub, self.course, settings)
self.assertIn( settings.MICROSITE_CONFIGURATION['test_microsite']["urls"]['PRIVACY'], data['company_privacy_url'] )
response = requests.post(self.launch_uri, data=self.payload) self.assertIn('Wrong LTI signature', response.content)
def __init__(self, message, status=HTTP_200_OK): data = {'detail': message} super(DetailResponse, self).__init__(resp_obj=data, status=status)
cachedir = self.cachedir[:-7] if self.cachedir is not None else None return (self.__class__, (cachedir, self.mmap_mode, self.compress, self._verbose))
self.assertEquals( preview.latex_preview('(2+3)/(4+5)'), r'\frac{2+3}{4+5}' )
cea = CourseEnrollmentAllowed(email='robot-allowed@robot.org', course_id=self.course.id) cea.save() self.allowed_email = 'robot-allowed@robot.org'
np_ver = [int(x) for x in unpickler.np.__version__.split('.', 2)[:2]]
tab_ids[0], tab_ids[1] = tab_ids[1], tab_ids[0]
yield check_clustering yield check_estimators_partial_fit_n_features
if pointval: choice_element.set("point_value", str(pointval))
assert_array_equal(votes[0, :], 1) assert_array_equal(np.argmax(votes[1:], axis=1), ovo_prediction[1:]) assert_equal(ovo_prediction[0], normalized_confidences[0].argmax())
n_jobs, n_estimators, starts = _partition_estimators( self.n_estimators, self.n_jobs)
pass
p_shared = sharedX(zv[:, 0:rows:pool_rows, 0:cols:pool_cols, :]) h_shared = sharedX(zv) z_shared = sharedX(zv)
save_course_update_items(location, course_updates, course_update_items, user) return _get_visible_update(course_update_items)
order_history_list = order_history(user, course_org_filter=course_org_filter, org_filter_out_set=org_filter_out_set)
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'proj.settings')
modes = cls.modes_for_course(course_id) return min(mode.min_price for mode in modes if mode.currency.lower() == currency.lower())
update_entrance_exam(request, self.course.id, {})
n, p = 10, 5 rng = np.random.RandomState(0)
if role is not None: role().add_users(user)
raise ValueError("The constant target value must be " "present in training data")
X = np.array([[0, 1], [1.01, 1.], [2, 0]])
LOGGER.error(self._format_msg(format_str, *args))
if role: role(self.course.id).add_users(self.user)
registration_codes = CourseRegistrationCode.order_generated_registration_codes(self.course_key) self.assertEqual(registration_codes.count(), item.qty)
self.store.publish(item_location, self.user_id) item = self.store.get_item(item_location) self.assertTrue(self.store.has_published_version(item)) _check_asides(item)
monitoring_train = DenseDesignMatrix(X=X) monitoring_test = DenseDesignMatrix(X=Y)
params = get_required_parameters(request.POST) if not params: return HttpResponseBadRequest() params.update(get_optional_parameters(request.POST))
queue = [course] while len(queue) > 0: node = queue.pop() queue.extend(node.get_children()) return True
self.course_outline_page.visit() section = self.course_outline_page.section_at(0) section.subsection_at(0).set_staff_lock(True) self.assertFalse(section.has_staff_lock_warning)
url = endpoint + urlquote(user.username) response = openid_request.answer(True, None, url)
assert_greater(np.mean(pred == iris.target), .9)
try: mask = importances >= threshold except TypeError: raise ValueError("Invalid threshold: all features are discarded.")
bulk_ops_record.nest()
self.get_selector('#invalidate-certificate').click()
from ratelimitbackend import admin
epoch_num = 15 termination_criterion = EpochCounter(epoch_num)
rng = np.random.RandomState(0) n_samples, n_features = 10, 5
return _get_block_structure_manager(course_key).get_collected()
self.wait_for_element_visibility( '#pre-requisite-course', 'Prerequisite course element is available' ) return self.get_elements('#pre-requisite-course')
lshf = LSHForest(min_hash_match=32) ignore_warnings(lshf.fit)(X_train)
if amount_value < mode_info.min_price: error_msg = _("No selected price or selected price is too low.") return self.get(request, course_id, error=error_msg)
self.course_info_page.visit() self.tab_nav.go_to_tab('Wiki') self.assertTrue(self.tab_nav.is_on_tab('Wiki'))
with self.assertRaises(InvalidVersionError): self.store.convert_to_draft(self.chapter_loc, self.user.id)
thread_author = getattr(self, thread_author) self._setup_mock(
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course_key): assertProblemNameEquals(problem_new_name)
pass
try: with open(env_path) as env_file: return json.load(env_file)
X = check_array(X, accept_sparse=['csr', 'csc'])
import pylearn2.config.yaml_parse
def __init__(self, func): self.func = func
if enrollment.is_active and enrollment.created > time_delta
if user is None: user = self.user return Mock( user_id=user.id, commentable_id=self.DISCUSSION_TOPIC_ID, context=context, **{'thread.user_id': self.user.id} )
request_info = xmodule_instance_args.get('request_info', {}) if xmodule_instance_args is not None else {} task_info = {"student": student.username, "task_id": _get_task_id_from_xmodule_args(xmodule_instance_args)}
if scope != Scope.user_state: raise ValueError("Only Scope.user_state is supported") raise NotImplementedError()
with self.assertRaises(SearchIndexingError): CoursewareSearchIndexer.do_course_reindex(modulestore(), self.course.id)
return iter(getattr(d, _itervalues)(**kw))
proba = sum(all_proba) / self.n_estimators
inlier_mask_subset = residuals_subset < residual_threshold n_inliers_subset = np.sum(inlier_mask_subset)
self.assertFalse(self._has_changes(locations['grandparent'])) self.assertFalse(self._has_changes(locations['parent']))
with store.branch_setting(ModuleStoreEnum.Branch.draft_preferred): store.update_item(item, ModuleStoreEnum.UserID.test)
certificates.update( status=CertificateStatuses.unavailable, verify_uuid='', download_uuid='', download_url='', grade='', )
assert_equal(cv_repr, repr(cv))
resultset = self.collection.find(query, record_filter)
self.set_group_access(self.vertical, {1: []}) self.set_group_access(self.problem, {2: [3, 4]})
EmptyPromise( lambda: self.q(css='.signatory-panel-delete').present, 'Delete icon is displayed' ).fulfill()
super(ForgotPasswordPageTest, self).setUp() self.user_info = self._create_user() self.reset_password_page = ResetPasswordPage(self.browser)
full_name = UserProfile.objects.get(user=user).name
self.assertTrue(CourseStructure.objects.filter(course_id=self.course.id).exists()) response = self.http_get_for_course() self.assertEqual(response.status_code, 200)
try: open(libcuda_convnet_so).close() return True except IOError: return False
_strip_value(value, lookup)
self.registration.activate() self.assertTrue(self.user.is_active) mock_segment_identify.assert_called_with( self.user.id, expected_segment_payload, expected_segment_mailchimp_list )
grid_search.scoring = 'sklearn' assert_raises(ValueError, grid_search.fit, X, y)
survey = SurveyForm.get(course_descriptor.course_survey_name)
if gated_content and unicode(section.location) in gated_content: continue if section.hide_from_toc: continue
'transcript': 'http://video.google.com/timedtext?lang=en&v=OEoXaMPEzfM',
pass
MESSAGE_STORAGE = 'django.contrib.messages.storage.session.SessionStorage'
width = self.ext.config['bliptv_width'][0] height = self.ext.config['bliptv_height'][0] return flash_object(url, width, height)
access_role(library2_key).add_users(self.non_staff_user)
return course_metadata_utils.clean_course_key(self.location.course_key, padding_char)
return datetime.now(UTC()) > end_date if end_date is not None else False
with self.assertNumQueries(18): self.client.get(self.teams_url)
enrollment_mode = self.dashboard_page.get_enrollment_mode(self.course_info["display_name"]) self.assertEqual(enrollment_mode, 'verified')
from abc import ABCMeta, abstractmethod
resp = self.client.get(reverse('dashboard'), HTTP_HOST=settings.MICROSITE_TEST_HOSTNAME) self.assertContains(resp, 'Robot_Super_Course') self.assertNotContains(resp, 'Robot_Course_Outside_Microsite')
self.mean_square_grads[param.name] = mean_square_grad
self.assertEquals(course.entrance_exam_minimum_score_pct, .5)
request.session = {} gradeset = grade(student, request, course, keep_raw_scores) yield student, gradeset, ""
del params["terms_of_service"] assert_terms_of_service_error("You must accept the terms of service.")
CourseEnrollment.enroll(student, ccx_locator)
patcher = mock.patch('terrain.stubs.xqueue.post') self.post = patcher.start() self.addCleanup(patcher.stop)
course_organization = get_course_organizations(course_key) if course_organization: org_id = course_organization[0]['id']
released_languages = [ Language(tuple[0], tuple[1]) for tuple in settings.LANGUAGES if tuple[0] in released_language_codes ]
missing_courses = set(course_id_list) - set(modes_by_course.keys()) for course_id in missing_courses: modes_by_course[course_id] = [cls.DEFAULT_MODE]
response = self._load_dashboard() self.assertContains(response, "credit-request-rejected-msg")
if isinstance(batch, np.ndarray): return batch.shape else: return tuple(get_shape(b) for b in batch)
StudioAutoAuthPage( self.browser, username=self.staff_user["username"], email=self.staff_user["email"] ).visit()
depth = len(b_list)
staff = UserFactory() allow_access(self.course, staff, 'staff') self.assertTrue(CourseStaffRole(self.course.id).has_user(staff))
assert np.all((ps == 0) + (ps == 1)) assert np.all((hs == 0) + (hs == 1))
self._update_cutoff()
url = reverse("verify_student_reverify") return self.client.get(url)
'ENABLE_OPENBADGES': False,
try: self.url = reverse('login_post') except NoReverseMatch: self.url = reverse('login')
self.assertTrue(self.certificates_section.certificate_exceptions_section.visible)
vertical = get_and_verify_publish_state('vertical', self.TEST_VERTICAL, True) for child in vertical.get_children(): verify_item_publish_state(child, True)
responsetype_cls = responsetypes.registry.get_class_for_tag(response.tag) responder = responsetype_cls(response, inputfields, self.context, self.capa_system, self.capa_module) self.responders[response] = responder
with MongoContentstoreBuilder().build() as contentstore: with self.build_with_contentstore(contentstore) as modulestore: yield contentstore, modulestore
#self.assertIn("4 matching components", library_block.author_content)
loss_l = self.loss.lower()
usage_key = usage_key.replace(course_key=store.fill_in_run(usage_key.course_key))
return self.course_locations[string].course_key
self.assertEqual(module.attempts, 2)
return _makeTags( tagStr, True )
self.setup_mongo_course(course_edit_method='XML') result_fragment = self.module.render(STUDENT_VIEW, context=self.default_context) self.assertNotIn('View Unit in Studio', result_fragment.content)
DONATION_TYPES = ( ("general", "A general donation"), ("course", "A donation to a particular course") )
with self.assertRaises(KeyError): data.get('block', 'foo')
source = utils.find_staff_lock_source(item) self.assertEqual(source.location, expected_source.location) self.assertTrue(source.visible_to_staff_only)
return self.q(css=self._bounded_selector('h3.card-title')).map(lambda e: e.text).results
students = 'all_whitelisted'
self.wait_for_ajax() return self._get_element_text(".response-count")
clf_base_regressor = CalibratedClassifierCV(Ridge()) clf_base_regressor.fit(X_train, y_train) clf_base_regressor.predict(X_test)
pca = PCA(n_components=3)
init = cls.__init__
beta = 5 eps = 1e-6 graph.data = np.exp(-beta * graph.data / graph.data.std()) + eps
def astype(array, dtype, copy=True): if not copy and array.dtype == dtype: return array return array.astype(dtype)
fake_data_api.add_course(self.COURSE_ID, course_modes=['honor', 'verified', 'audit'])
original_course = self.source_modulestore.get_course(source_course_key, **kwargs) if original_course is None: raise ItemNotFoundError(unicode(source_course_key))
self.q(css=BUTTON_SELECTORS[button_name]).nth(index).click() if require_notification: wait_for_notification(self) self.wait_for_ajax()
return self.q(css='div.discussion-module').attrs('data-discussion-id')[0]
rng = check_random_state(0)
assert self.local.get_params() == [self.filters]
module = CapaFactory.create(attempts=1)
if not string.islower(): raise ValidationError(_(u"This value must be all lowercase."))
with check_mongo_calls(mongo_calls): _accessible_courses_summary_list(self.request)
return tab.is_enabled(course, user=user)
if X.flags.c_contiguous: return check_array(X.T, copy=False, order='F'), True else: return check_array(X, copy=False, order='F'), False
return page.q(css='.wrapper-notification-mini.is-hiding').present
self.assertIn("2013-SEPTEMBER-16", text)
if sp_version >= (0, 12): solvers.append('lbfgs')
'parent_url', module.xml_attributes.get('parent_sequential_url')
self.q(css=BROWSE_BUTTON_CSS).click()
self._assert_user_name(self.FULL_NAME)
mock_get.return_value.content = json.dumps(NOTES_API_EMPTY_RESPONSE) self.assertItemsEqual( NOTES_VIEW_EMPTY_RESPONSE, helpers.get_notes(self.request, self.course) )
MOBILE_APP_USER_AGENT_REGEXES = [ r'edX/org.edx.mobile', ]
"callback_url": callback_url,
return self.redirect_uri
E = np.random.uniform(0, 0.1, size=(len(iris.data), 20))
empty_asset_trashcan([self.course.id])
certificates = course.certificates.get('certificates', []) if only_active: certificates = [certificate for certificate in certificates if certificate.get('is_active', False)] return certificates
for mode in [CourseMode.DEFAULT_MODE_SLUG, CourseMode.VERIFIED]: CourseModeFactory.create( course_id=self.course.id, mode_slug=mode, mode_display_name=mode, )
manager = self.__manager self.__manager = None yield
cipher = aes_cipher_from_key(key) padded_data = cipher.decrypt(encrypted_data) return unpad(padded_data)
self.assertIn(html, html_encapsulated)
if getattr(xblock, 'is_draft', False): published_xblock_location = as_published(xblock.location) try: xblock.runtime.lookup_item(published_xblock_location) except ItemNotFoundError: return False return True
md5 = hashlib.md5() for data in resource: md5.update(repr(data)) return md5.hexdigest()
buckets = 10 bucket_width = 1. / float(buckets) for i in xrange(buckets): lower_lim = i * bucket_width upper_lim = (i+1) * bucket_width
user = User.objects.get(email=self.notenrolled_student.email) self.assertTrue(CourseEnrollment.is_enrolled(user, self.course.id))
batch0 = slice(0, chunk_size) scaler_batch = MaxAbsScaler().fit(X[batch0]) scaler_incr = MaxAbsScaler().partial_fit(X[batch0])
X_0 = X[y == 0, :] y_0 = y[y == 0]
return mixed_setting["default"]["OPTIONS"]["stores"]
if self.corruption_level < 1e-5: return x
if is_advanced_problem: advanced_tab = page.q(css='.problem-type-tabs a').filter(text='Advanced').first advanced_tab.click()
n_targets = y.shape[1] Xy = np.empty(shape=(n_features, n_targets), dtype=common_dtype, order='F') np.dot(y.T, X, out=Xy.T)
multi_db = True
self.assertFalse(res_json['success'])
assert_raises(ValueError, plot_partial_dependence, clf, X, [100])
self.assertEquals(imported_word_cloud.data, '')
return self.enabled and self.enable_learner_issuance
X = 5 * rng.rand(10000, 1) y = np.sin(X).ravel()
self.rwork = _aligned_zeros(self.ncv, self.tp.lower())
return '%s.%s:%d' % ( model._meta.app_label, model._meta.model_name, getattr(instance_or_pk, 'pk', instance_or_pk), )
from __future__ import unicode_literals
import os from os.path import join
assert False
assert False
node = Element(self.category) super(XmlDescriptor, self).add_xml_to_node(node) return etree.tostring(node)
xblock_info = self._get_xblock_info(chapter.location) self._verify_visibility_state(xblock_info, VisibilityState.ready) self.assertFalse(course.self_paced)
if max_iter is None: max_iter = 1000
meta_dict = json.loads(profile.meta) if profile.meta else {} for meta_feature, meta_key in meta_features: student_dict[meta_feature] = meta_dict.get(meta_key)
y_pred = - clf.decision_function(X_test)
response = self.client.get(self.ping_url)
url( r'^u/(?P<username>[\w.@+-]+)$', 'student_profile.views.learner_profile', name='learner_profile', ),
self.assertEquals(resp.status_code, 200) self.assertTrue(resp.get('Content-Disposition').startswith('attachment'))
return not self.q(css=self._bounded_selector('.wrapper-xblock article')).present
window = tensor.alloc(0.0, batch, channel, res_r, res_c, pr, pc) window.name = 'unravlled_winodows_' + name
self.assertFalse(self.store.has_changes(self.store.get_item(self.course.location)))
course_overview_before.image_set.small_url = broken_small_url course_overview_before.image_set.large_url = broken_large_url course_overview_before.image_set.save()
return self.modulestores[0]
clf_isotonic = CalibratedClassifierCV(clf, cv=2, method='isotonic') clf_isotonic.fit(X_train, y_train, sw_train) prob_pos_isotonic = clf_isotonic.predict_proba(X_test)[:, 1]
get_request_dict = {CapaFactory.input_key(): '3.14'} result = module.check_problem(get_request_dict)
return self.get_text('.course-title-override .certificate-value')
skip_if_no_data() data = stl10.STL10(which_set='train') data = stl10.STL10(which_set='test')
X = np.asmatrix(X)
filters_regex = re.compile(r'\|([.,\w\s]*)\}') filters_match = filters_regex.search(expression.expression)
CourseEnrollmentFactory.create(user=self.user, course_id=self.course.id) self.client.login(username=self.user.username, password=self.test_password)
self.client.logout() super(TestLibraryAccess, self).tearDown()
if rolename == FORUM_ROLE_ADMINISTRATOR and not has_instructor_access: return HttpResponseBadRequest("Operation requires instructor access.")
scores = as_float_array(scores, copy=True) scores[np.isnan(scores)] = np.finfo(scores.dtype).min return scores
n_trials = 10000
score += _loglikelihood(doc_topic_prior, doc_topic_distr, dirichlet_doc_topic, self.n_topics)
test_course = self.store.create_course('testx', 'GreekHero', 'test_run', self.user_id) self.assertTrue(self.store.has_published_version(test_course))
if not self._whiten and can_fit: assert proc_var[0] > orig_var.max()
self.q(css='div.problem .clarification:nth-child({index}) i[data-tooltip]'.format(index=index + 1)).click()
plot_calibration_curve(GaussianNB(), "Naive Bayes", 1)
url = BASE_URL + "/logout" def is_browser_on_page(self): return self.q(css='.btn-login').present
assert_almost_equal(errors, errors3) assert_almost_equal(values, values3)
return x * (x > 0)
super(PythonLinter, self).__init__() self._skip_python_dirs = SKIP_DIRS + ('tests', 'test/acceptance')
counts[to_reassign] = np.min(counts[~to_reassign])
rng = check_random_state(13) X = rng.rand(100, 2) sample_weight = np.ones(100) reg_y = rng.rand(100)
self.auto_enroll_section.upload_correct_csv_file() self.assertTrue(self.auto_enroll_section.is_notification_displayed(section_type=self.auto_enroll_section.NOTIFICATION_SUCCESS))
format = ugettext("LONG_DATE_FORMAT") if format == "LONG_DATE_FORMAT": format = DEFAULT_LONG_DATE_FORMAT
version_guids = [] id_version_map = defaultdict(list) for course_index in matching_indexes: version_guid = course_index['versions'][branch] version_guids.append(version_guid) id_version_map[version_guid].append(course_index) return version_guids, id_version_map
if value is self.Empty: return return super(OpaqueKeyField, self).run_validators(value)
#texinfo_domain_indices = True
return [Attribute('file'), Attribute('missing', None)]
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
from django.conf import settings from django.contrib.auth.models import User from django.db import models, migrations
errstring = "Invalid course_key: 'InvalidCourseID'." with self.assertRaisesRegexp(CommandError, errstring): call_command('export', "InvalidCourseID", self.temp_dir_1)
remove_steps |= set([self.INTRO_STEP])
bulk_ops_record.nest()
assert_equal(7, counts_1.max()) assert_equal(7, counts_3.max()) assert_equal(7, counts_None.max())
self.context['return_to_annotation'] = False xml = self.render_to_xml(self.context) self.assert_no_xpath(xml, xpath, self.context)
#add_function_parentheses = True
config.groups[2].name = "Second Group"
if numpy.size(imgshp)==2: imgshp = (1,)+imgshp
if use_svd: U = svd(Gi, full_matrices=0)[0] else: Ci = np.dot(Gi, Gi.T) U = eigh(Ci)[1][:, ::-1]
rng = np.random.RandomState(0) rand_data = RandomData(rng) n_features = rand_data.n_features n_components = rand_data.n_components
assert_array_equal(lfw_people.target, [2, 0, 1, 0, 2, 0, 2, 1, 1, 2])
if script: script_element = etree.SubElement(root, "script") script_element.set("type", "loncapa/python") script_element.text = str(script)
lc_block = self._refresh_children(lc_block) check()
self.assertIn('Welcome to edX.', self.video.captions_text)
task_type = 'rescore_problem' task_class = rescore_problem task_input, task_key = encode_entrance_exam_and_student_input(usage_key, student) return submit_task(request, task_type, task_class, usage_key.course_key, task_input, task_key)
self.service.set_credit_requirement_status( self.user.id, unicode(self.course.id), 'grade', 'grade' )
'openedx.core.djangoapps.site_configuration',
logger.error("'{0}' not found " "but mandatory".format(this_check)) return False
X, y = datasets.make_friedman3(n_samples=1200, random_state=random_state) X_train, y_train = X[:200], y[:200] X_test, y_test = X[200:], y[200:]
slices = gen_even_slices(10, -1) assert_raises_regex(ValueError, "gen_even_slices got n_packs=-1, must be" " >=1", next, slices)
md5 = hashlib.md5() md5.update(repr(resource)) return md5.hexdigest()
hastie_X, hastie_y = datasets.make_hastie_10_2(n_samples=20, random_state=1) hastie_X = hastie_X.astype(np.float32)
dog_stats_api.start(**options)
return student_complex == instructor_complex
completion_date = get_last_exam_completion_date(course_key, username)
disable_animations(page) page.q(css=css).filter(_is_visible).nth(source_index).click()
return (self.get_input_space(), self.get_input_source())
return self.page_num > 1
embargoed = models.BooleanField(default=False)
assert_not_equal(id(attr_value), id(attr_value_cloned))
return self._get_course_info(request, course)
self.validate_xblock_info_consistency(xblock_info, has_child_info=has_child_info, course_outline=course_outline)
X = FeatureHasher().transform([{'foo': 0}]) assert_equal(X.data.shape, (0,))
self.course_id = course_id self._doc_id = doc_id self.asset_md = asset_md
user_enroll = get_enrollment(self.username, self.course_id) self.assertTrue(user_enroll['is_active'])
split_test = self.get_item_from_modulestore(self.split_test_usage_key, verify_is_draft=True) self.assertEqual(partition_id, split_test.user_partition_id) return split_test
if not child_class: child_class = self.CHILD_CLASS return self.children(child_class)[index]
w = clf.coef_[0] a = -w[0] / w[1] xx = np.linspace(-5, 5) yy = a * xx - (clf.intercept_[0]) / w[1]
query = self.q(css='.u-field-{}'.format(field_id)) return query.text[0] if query.present else None
self.assertEqual(context['currency_symbol'], '$') self.assertEqual(context['currency'], 'usd')
'ENABLE_DISABLING_XBLOCK_TYPES': True,
X = self.estimators_[0]._validate_X_predict(X, check_input=True) n_samples = X.shape[0]
assertion, args = assertion_tuple[0], assertion_tuple[1:] getattr(self, assertion)(*args)
<script type="{}"> ${{x | n, dump_js_escaped_json}} </script>
bulk_write_record.index = copy.deepcopy(bulk_write_record.initial_index) bulk_write_record.course_key = course_key
('svc', SVC(kernel='linear')),
from smtplib import SMTPException
username = email.split("@")[0] try: email = people[username]['email'] except KeyError: pass
self.assertTrue(self.video.is_aligned(False))
out = np.empty(len(list_of_arrays), dtype=object) out[:] = list_of_arrays return out
FEATURES['AUTOMATIC_AUTH_FOR_TESTING'] = True
show_openedx_logo = bool(request.GET.get('show-openedx-logo', False))
CourseEnrollmentFactory.create(user=self.user, course_id=self.course.id, is_active=True)
this_yaml = test_yaml_which_set % {'which_set': ['train', 'test']} trainer = yaml_parse.load(this_yaml) trainer.main_loop()
self.rows = shape[0] self.cols = shape[1]
self.lc_block.max_count = 1 self._create_capa_problems() self.lc_block.refresh_children() self.assertTrue(self.lc_block.validate())
return course_metadata_utils.has_course_ended(self.end)
if isinstance(course_descriptor, ErrorDescriptor): return course_descriptor
'AUTOPLAY_VIDEOS': False,
return super(XmlDescriptor, cls).parse_xml( etree.fromstring(xml_data), system,
OAUTH_OIDC_ISSUER = ENV_TOKENS['OAUTH_OIDC_ISSUER']
ApiAccessRequestFactory(user=self.user) response = self.client.get(self.url) self.assertRedirects(response, reverse('api_admin:api-status'))
self.assert_enrollment_status(as_server=True, mode='professional')
authentication_classes = (OAuth2Authentication, SessionAuthentication,) permission_classes = (IsAuthenticated,) serializer_class = CourseSerializer pagination_class = None def get_queryset(self): return list(Course.iterator())
unrestricted_course = CourseFactory.create() with self.assertNumQueries(1): embargo_api.check_course_access(unrestricted_course.id, user=self.user, ip_address='0.0.0.0')
score = MagicMock() score.possible = possible score.earned = earned return score
eps = 0.8 min_samples = 10
self.user = User.objects.get(pk=self.user.pk)
response = self.ajax_request('No', {})
self.assertIs(descriptor._unwrapped_field_data, original_field_data) self.assertIsNot(descriptor._unwrapped_field_data, descriptor._field_data)
return has_studio_read_access(self._user, course_key)
idx = np.where(land_reference > -9999) coverages_land = data.coverages[:, idx[0], idx[1]].T
X = [[2, 1], [3, 1], [1, 3], [2, 3]] y = [0, 0, 1, 1]
#html_favicon = None
sources = xml_element.get('sources') if sources: return [location.strip() for location in sources.split(';')]
self.q(css=self.search_bar_selector + ' [type="submit"]').click() self.wait_for_element_visibility('.search-info', 'Search results are shown')
course = CourseFactory.create(default_store=modulestore_type, run="TestRun", **course_kwargs) self.check_course_overview_against_course(course)
courseware_page = CoursewarePage(self.browser, self.course_id) self._make_har_file(courseware_page)
COURSE_CATALOG_VISIBILITY_PERMISSION = 'see_exists'
ORA2_FILE_PREFIX = None
self.store.publish(item_location, self.user_id) item = self.store.get_item(item_location) self.assertTrue(self.store.has_published_version(item))
self.factory(loss="foobar")
temp_poll_answers = self.poll_answers temp_poll_answers[dispatch] += 1 self.poll_answers = temp_poll_answers
self._cleanup_index_file() super(StudioLibraryContainerTest, self).tearDown()
self.check_assertion_structure(assertion, response['results'][0])
if not has_course_author_access(user, course_key): raise PermissionDenied() return CoursewareSearchIndexer.do_course_reindex(modulestore(), course_key)
course = self.store.create_course('org_x', 'course_y', 'run_z', self.user_id) signal_handler.send.assert_called_with('course_published', course_key=course.id)
username = request.data.get('username') if not username: raise ValidationError({'detail': 'A username must be specified.'})
r = FOREST_REGRESSORS[name](random_state=0) assert_false(hasattr(r, "classes_")) assert_false(hasattr(r, "n_classes_"))
self.assertTrue('Activate Course Enrollment' in response.content)
self.q(css=self._bounded_selector(".annotator-item textarea")).first.fill(value)
for honor_code in ["", "false", "not_boolean"]: params["honor_code"] = honor_code assert_honor_code_error("To enroll, you must follow the honor code.")
pass
bulk_sku = models.CharField( max_length=255, null=True, blank=True,
self.assertTrue(config.id)
plt.figure() plt.legend(legend_rects, legend_labels, loc='upper left')
httpretty.register_uri( httpretty.GET, "http://localhost:4567/api/v1/comments/{id}".format(id=comment_id), body="", status=status_code )
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 4)
from django.core.cache import cache from django.test.utils import override_settings from lang_pref import LANGUAGE_KEY
protocol = (pickle.DEFAULT_PROTOCOL if PY3_OR_LATER else pickle.HIGHEST_PROTOCOL) Pickler.__init__(self, self.stream, protocol=protocol) self._hash = hashlib.new(hash_name)
self.course_db.update( { (block_type, block_id): _make_course_db_entry( parent_type, parent_id, block_id, idx, child_type, child_base ) } )
'openedx.core.djangoapps.programs',
#today = '' #today_fmt = '%B %d, %Y'
X, y = 3 * diabetes.data, diabetes.target G = np.dot(X.T, X) Xy = np.dot(X.T, y)
loss[i] = np.dot(true_at_reversed_rank.cumsum(), false_at_reversed_rank)
'dark_lang.middleware.DarkLangMiddleware',
self.assertNotContains(resp, '<section class="university-partners university-partners2x6">')
order = 'C'
assert_raises(ValueError, getattr(nbrs_D, method), X)
sites.models.SITE_CACHE.clear()
msg = "Error in problem xml include: %s" % ( etree.tostring(next_include, pretty_print=True)) system.error_tracker(msg)
st = os.statvfs(path) total = st.f_blocks * st.f_frsize used = (st.f_blocks - st.f_bfree) * st.f_frsize return total, used
self.check('[50,40]', 35, 25)
coef = np.zeros(n_features) coef[:n_relevant_features] = coef_min + rng.rand(n_relevant_features)
train(os.path.join( pylearn2.__path__[0], 'train_extensions/tests/live_monitor_test.yaml' ))
response = client2.post(self.url, creds) self._assert_response(response, success=True)
self.wait_for_ajax() return self.q(css='#u-field-message-account_privacy').visible
SERVICE_VARIANT = os.environ.get('SERVICE_VARIANT', None)
trainer.main_loop(time_budget) return trainer
draft_problem = self.store.get_item(self.problem.location) self.assertTrue(getattr(draft_problem, 'is_draft', False))
P *= self.early_exaggeration
if is_comment_too_deep(parent=cc.Comment(comment_id)): return JsonError(_("Comment level too deep")) return _create_comment(request, CourseKey.from_string(course_id), parent_id=comment_id)
log.warn('Error in conditional module: \ required module {module} has no {module_attr}'.format(module=module, module_attr=attr_name)) return False
user = User(username="rusty", email="rusty@fake.edx.org") course_id = SlashSeparatedCourseKey("edX", "Test101", "2013")
self.fs_files.database.connection.close()
contentstore().delete(content.get_id()) del_cached_content(content.location)
if not self.value and self.xml.text: self.value = self.xml.text.strip()
#html_use_opensearch = ''
latex = fname + inner return LatexRendered(latex, tall=children[1].tall)
LogoutPage(self.browser).visit() AutoAuthPage(self.browser, username=username, email=email, staff=staff).visit()
self.assertIs(VerificationDeadline.deadline_for_course(self.course.id), None)
modulestore().delete_course(destination_course_key, user_id)
FINANCIAL_REPORTS = ENV_TOKENS.get("FINANCIAL_REPORTS", FINANCIAL_REPORTS)
blend_arr = copy(patch_arr) blend_arr[mask_arr] = frgd_arr[mask_arr]
response = self.client.post( reverse('change_enrollment'), { 'course_id': course.id.to_deprecated_string(), 'enrollment_action': 'enroll' } ) return response
return cache_and_return(None)
message = msg_format.format( action=action_name, succeeded=num_succeeded, attempted=num_attempted, total=num_total, skipped=num_skipped, student=student ) return (succeeded, message)
return self.oauth2_adapter.create_public_client( name='Test Public Client', user=user, client_id=client_id, redirect_uri=DUMMY_REDIRECT_URL, )
return any(is_marketing_link_set(name) for name in names)
log.debug("configuration error in split test module: no such child") return []
self.case_sensitive = False
X = X.tocsr()
assert start >= 0 assert stop > start assert stop <= X.shape[0] X = X[start:stop, :] y = y[start:stop, :] assert X.shape[0] == y.shape[0]
os.remove(filename)
if os.path.isdir(SCIKIT_LEARN_DATA): shutil.rmtree(SCIKIT_LEARN_DATA) if os.path.isdir(SCIKIT_LEARN_EMPTY_DATA): shutil.rmtree(SCIKIT_LEARN_EMPTY_DATA)
inpaint_cost = 0.5 * inpaint_cost + 0.5 * new_inpaint_cost
actual_status = certs_api.example_certificates_status(self.COURSE_KEY) self.assertEqual(list(expected_statuses), actual_status)
params = {'amount': donation_amount} if course_id is not None: params['course_id'] = course_id
'openedx.core.djangoapps.self_paced',
sources, duration = self.video.sources[0], self.video.duration self.assert_bumper_payload_contains_ids(load_video_event, sources, duration)
return self.q(css='.components-list li>a').text
SUBSCRIBE_BATCH_SIZE = 1000
if access_key != settings.VERIFY_STUDENT["SOFTWARE_SECURE"]["API_ACCESS_KEY"]: return HttpResponseBadRequest("Access key invalid")
old_value = tab[key] new_value = 'New Value' tab[key] = new_value self.assertEquals(tab[key], new_value) tab[key] = old_value self.assertEquals(tab[key], old_value)
if self._sample_switch: self._apply_corruption(activations, self._layer_samplers, idx_iter) return activations
self.chap_1_handle = 0 self.chap_1_seq_1_handle = 1
show_min_grade_warning = False if course_module.minimum_grade_credit > 0 else True settings_context.update( { 'is_credit_course': True, 'credit_requirements': paired_requirements, 'show_min_grade_warning': show_min_grade_warning, } )
max_squared_sum = row_norms(X, squared=True).max()
del params["username"] assert_username_error("Username must be minimum of two characters long")
stable_x = (x.T - x.max(axis=1)).T numer = np.exp(stable_x) return (numer.T / numer.sum(axis=1)).T
if PY3_OR_LATER: dispatch[pickle.BUILD[0]] = load_build else: dispatch[pickle.BUILD] = load_build
self.q(css='.button-view').first.click() self._switch_to_lms()
return self._get_xblocks(".is-active ")
return False
cls.objects.create(checkpoint=checkpoint, user=user, status=status)
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit()
icrv_status_emails = IcrvStatusEmailsConfiguration.current() if icrv_status_emails.enabled and checkpoints: user_id = attempt.user.id course_key = checkpoints[0].course_id related_assessment_location = checkpoints[0].checkpoint_location
client = DjangoTestClient() response1 = client.get(path='/shib-login/', data={}, follow=False, **identity) postvars = {'email': u'post_email@stanford.edu',
response = self.assert_enrollment_status( as_server=True, mode=new_mode, is_active=new_is_active, expected_status=expected_status, )
courses_list, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(len(courses_list), 1) self.assertNotIn( ccx_course_key, [course.id for course in courses_list] )
data = "Some data" ItemFactory.create( parent_location=self.library.location, category="html", display_name="Html Content 3", data=data, modulestore=store, publish_item=False, )
return 'all_users' if self.q(css=PROFILE_VISIBILITY_SELECTOR.format('all_users')).selected else 'private'
assert_greater(gpr.log_marginal_likelihood(gpr.kernel_.theta), gpr.log_marginal_likelihood(gpr.kernel.theta))
self.assertFalse(user.is_staff)
course_badge_check(user, course_key)
ItemFactory.create( parent_location=self.course.location, category="discussion", discussion_id="Topic_A", discussion_category="Chapter", discussion_target="Discussion", start=now )
css = self.certficate_css + ' .wrapper-collection' return [CertificateSectionPage(self, self.certficate_css, index) for index in xrange(len(self.q(css=css)))]
for item in REPORT_TYPES: if report_type in item: return item[1](start_date, end_date, start_letter, end_letter) raise ReportTypeDoesNotExistException
fulfill_course_milestone(pre_requisite_course.id, user) self.assertTrue(access._has_access_course(user, 'view_courseware_with_prerequisites', course))
if params.get('decision') == u'DECLINE': raise CCProcessorUserDeclined()
dtype_numeric = dtype == "numeric"
terminal_regions = tree.apply(X)
self.find_css('.collection-name-input').first.fill(value)
with remove_ccx(location) as (location, restore): return restore( self._modulestore.publish(location, user_id, **kwargs) )
create_xblock( parent_locator=unicode(created_block.location), user=request.user, category='sequential', display_name=_('Entrance Exam - Subsection') ) add_entrance_exam_milestone(course.id, created_block)
self.assert_requirement_status(grade, due_date, 'satisfied')
response = self._load_dashboard() self.assertContains(response, "credit-error-msg")
return self._on_user_authentication_failed(request)
non_outliers = linear_loss[~outliers_mask] weighted_non_outliers = sample_weight[~outliers_mask] * non_outliers weighted_loss = np.dot(weighted_non_outliers.T, non_outliers) squared_loss = weighted_loss / sigma
sparse_classifier = BaggingClassifier( base_estimator=CustomSVC(decision_function_shape='ovr'), random_state=1, **params ).fit(X_train_sparse, y_train) sparse_results = getattr(sparse_classifier, f)(X_test_sparse)
face = sp.misc.imresize(face, 0.10) / 255.
return etree.Element("annotationresponse")
mock_request = Mock() mock_request.GET = mock_request.POST = {'task_id': task_id} response = instructor_task_status(mock_request) status = json.loads(response.content) return status
FEATURES['ENABLE_EXPORT_GIT'] = True GIT_REPO_EXPORT_DIR = TEST_ROOT / "export_course_repos"
self.assertEqual(req_status[1]["status"], None) self.assertEqual(req_status[1]["order"], 1)
return self.find_courses_by_search_target('wiki_slug', wiki_slug)
if not settings.FEATURES['ADVANCED_SECURITY']: return False min_days_between_reset = settings.ADVANCED_SECURITY_CONFIG.get( 'MIN_TIME_IN_DAYS_BETWEEN_ALLOWED_RESETS' ) return min_days_between_reset
should_yield_node = filter_func(current_node) if should_yield_node: yield current_node
'sources': [u'example.mp4', u'example.webm'] + [video['url'] for video in encoded_videos],
FIELD_OVERRIDE_PROVIDERS = ()
if name in answers: raise ValueError(u"Key {name} already exists in answers dict".format(name=name)) else: answers[name] = val
if key not in fields: return False, None field = fields[key] if xblock is not None: return field.is_set_on(block), getattr(xblock, key) else: return True, field
world.retry_on_exception( _click_advanced, ignored_exceptions=AssertionError, )
tmp = X - X.max(axis=1)[:, np.newaxis] np.exp(tmp, out=X) X /= X.sum(axis=1)[:, np.newaxis] return X
self._verify_response(200)
ransac_estimator0.fit(X, y) assert_warns(DeprecationWarning, ransac_estimator2.fit, X, y) assert_array_almost_equal(ransac_estimator0.predict(X), ransac_estimator2.predict(X))
query = self.q(css='.page-content-secondary > .team-user-membership-status') return query.text[0] if query.present else ''
self.assert_enrollment_status(as_server=True, mode=CourseMode.VERIFIED)
return u"Invalid user preference key '{preference_key}'.".format(preference_key=preference_key)
self.assertIn("Password Reset Email Sent", self.reset_password_page.get_success_message())
resp = self.client.get(self.list_url_master_course, {}, HTTP_AUTHORIZATION=self.auth)
CREDIT_PROVIDER_TIMESTAMP_EXPIRATION = 15 * 60
PaymentFakeView.PAYMENT_STATUS_RESPONSE = "success"
still_in_grace = CapaFactory.create(showanswer='finished', max_attempts="1", attempts="1", due=self.yesterday_str, graceperiod=self.two_day_delta_str) self.assertTrue(still_in_grace.answer_available())
announcement, start, now = sorting_dates(start, advertised_start, announcement)
warm_low_reg_model = deepcopy(high_reg_model) warm_low_reg_model.set_params(warm_start=True, alpha=final_alpha) warm_low_reg_model.fit(X, y) assert_greater(low_reg_model.n_iter_, warm_low_reg_model.n_iter_)
self.certificates_section.wait_for_certificate_exceptions_section()
microsite.set_by_domain(self.microsite_subdomain) self.assertTrue(microsite.has_override_value('platform_name'))
loc_str = unicode(location) if self._max_scores_cache.get(loc_str) != max_score: self._max_scores_updates[loc_str] = max_score
return OAuth2Client.objects.create(client_type=constants.CONFIDENTIAL)
query = self._course_key_to_son(location.course_key) query['definition.children'] = location.to_deprecated_string()
captions_rendered_selector = self.get_element_selector(CSS_CLASS_NAMES['captions_rendered']) self.wait_for_element_presence(captions_rendered_selector, 'Captions Rendered')
if hasattr(modulestore, '_drop_database'):
core_samples, labels = dbscan(X, algorithm=algorithm, eps=1, min_samples=3) assert_array_equal(core_samples, [2]) assert_array_equal(labels, [-1, 0, 0, 0, -1, -1, -1])
return self.q(css='.components-list-heading-text').text[0]
if group == 'multilabel-indicator' and issparse(example): sparse_assert_, sparse_exp = assert_true, 'True' else: sparse_assert_, sparse_exp = assert_false, 'False'
from cPickle import loads from cPickle import dumps
with patch('lms.djangoapps.verify_student.models.requests.post', new=mock_software_secure_post_error): attempt = self.create_and_submit() assert_equals(attempt.status, "must_retry")
tasks = instructor_task.api.get_instructor_task_history(course_id, task_type=task_type)
try: instance.handle_ajax(dispatch, data) instance.save() except: log.exception("error processing ajax call") raise
BlockCountsTransformer(['problem', 'chapter']).transform(usage_info=None, block_structure=self.block_structure)
self.case_sensitive = False
self.create_reverification_xblock()
cache.clear() CertificateGenerationConfiguration.objects.create(enabled=True) self.client.login(username=self.global_staff.username, password='test')
import logging import sys
X = diabetes.data Y = np.vstack([diabetes.target, diabetes.target ** 2]).T n_targets = Y.shape[1]
max_scores_cache = MaxScoresCache("test_max_scores_cache") max_scores_cache.fetch_from_remote(self.locations)
locked=getattr(content, 'locked', False)) as fp:
FEATURES['ENABLE_CSMH_EXTENDED'] = True INSTALLED_APPS += ('coursewarehistoryextended',)
if not given: return False
self.check_caches("smstc_cache_test_key")
if not get_override_for_user(student, unit, 'due'): raise DashboardError(_("No due date extension is set for that student and unit."))
split_test = self._update_partition_id(0) self.assertEqual(2, len(split_test.children)) initial_vertical_0_location = split_test.children[0] initial_vertical_1_location = split_test.children[1]
for cls in [BernoulliNB, MultinomialNB, GaussianNB]: assert_raises(ValueError, cls().fit, X2, y2[:-1])
self.strategy.clean_partial_pipeline()
verify_date_or_time(COURSE_START_TIME_CSS, DUMMY_TIME)
N_REGIONS = 25
assert_raises(ValueError, svm.SVC(C=-1).fit, X, Y)
target_source = self.add_mask_source(self.get_target_space(), 'targets') return target_source
try: return content and not content['closed'] except KeyError: return False
if 'asides' in kwargs: kwargs['asides'] = prepare_asides_to_store(kwargs['asides']) return func(*args, **kwargs)
self.estimators_[i, k] = tree
draft = self.get_item_from_modulestore(self.problem_usage_key, verify_is_draft=True) self.assertNotEqual(draft.data, published.data)
SORT_REVISION_FAVOR_DRAFT = ('_id.revision', pymongo.DESCENDING)
IPFilter.objects.create( blacklist=", ".join(blacklist), whitelist=", ".join(whitelist), enabled=is_enabled )
if email_students: send_beta_role_email(action, user, email_params) if auto_enroll: if not CourseEnrollment.is_enrolled(user, course_id): CourseEnrollment.enroll(user, course_id)
X = np.dot(h, W) + noise
opt_args['objective_error'] = objective_error opt_args['kwargs']['angle'] = self.angle opt_args['kwargs']['verbose'] = self.verbose
block_structure.remove_block_if( check_child_removal )
solution_tags = ['solution']
default_headers = { 'HTTP_AUTHORIZATION': 'Bearer ' + self.access_token } default_headers.update(headers) response = self.client.get(uri, follow=True, **default_headers) return response
self.settings_detail.visit() self.assertTrue(self.settings_detail.is_browser_on_page())
X = [[0, 1, 0], [0, -1, -1], [0, .5, .5]] y = [1, 0, 1]
'gating.apps.GatingConfig',
pass
('cart', 'cart'),
AutoAuthPage(self.browser, username=username, email=email, course_id=self.course_id, staff=staff).visit()
EmptyPromise( lambda: self.q(css='.assetupload-modal .action-upload').present, 'Signature image upload dialog opened' ).fulfill()
for i, hyperparameter in enumerate(kernel.hyperparameters): assert_equal(theta[i], np.log(getattr(kernel, hyperparameter.name)))
return ItemFactory.create( category="html", parent_location=self.library.location, user_id=self.user.id, publish_item=False )
'description',
precision = tp / T.maximum(1., tp + fp) return precision
return EmptyPromise( lambda: self._is_on_tab(tab_name), "{0} is the current tab".format(tab_name) )
self.assertEquals(len(self.backend.events), 0)
self.login(self.email, self.pw)
SECRET_KEY = '85920908f28904ed733fe576320db18cabd7b6cd'
([[10, 10, 8], [9, 8, 1], [9, 7, 4]], 18 ),
if GlobalStaff().has_user(caller): return
self.assert_redirect_to_provider_looks_correct(self.client.get( pipeline.get_login_url(self.provider.provider_id, pipeline.AUTH_ENTRY_LOGIN)))
scaler = MinMaxScaler(feature_range=(2, 1)) assert_raises(ValueError, scaler.fit, X)
def render_to_template_mock(*args): pass
def from_json(self, values): return [UserPartition.from_json(v) for v in values] def to_json(self, values): return [user_partition.to_json() for user_partition in values]
X, y = datasets.make_classification(n_samples=100000, n_features=20, n_informative=2, n_redundant=10, random_state=42)
return login_required(inner)
X, y = make_classification(n_samples=1000, n_features=10, n_informative=3, n_redundant=0, n_repeated=0, n_classes=2, random_state=0, shuffle=False)
self.save_course() self.url_nonexist = self.get_details_url("1=20")
from .overrides import get_override_for_ccx return get_override_for_ccx(self, self.course, 'start')
xT_A = self.lmul(self.transpose_left(x, True)) rval = self.transpose_right(xT_A, True) return rval
for choice in subset_choices: choicegroup.append(choice)
self.assertTrue(api.is_user_eligible_for_credit("bob", self.course_key))
try: return self._client.get( self.user.username, kvs_key.block_scope_id, fields=[kvs_key.field_name], ).updated except self._client.DoesNotExist: return None
return hasattr(self, method)
CONTACT_MAILING_ADDRESS = ''
default=None
return reverse('social:complete', kwargs={'backend': self.PROVIDER_BACKEND})
rnd = np.random.RandomState(37) X = rnd.uniform(size=(10, 4))
ScopeIds(None, block_type, location, location), dbmodel, for_parent=kwargs.get('for_parent'),
self.client.login(username="jack", password="test")
html_encapsulated = module.get_problem_html(encapsulate=True)
self.assertNotIn(self.vert_loc, course.system.module_data)
iris = datasets.load_iris()
rng = check_random_state(0) X_train, X_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state=rng)
lookup_value = '[^/.]+'
with self.assertNumQueries(0): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
return (None, None)
raise NotImplementedError
y_true = np.zeros((1, n_labels)) assert_equal(lrap_score(y_true, y_score), 1.) assert_equal(lrap_score(y_true, y_score_ties), 1.)
store = self._verify_modulestore_support(dest_key.course_key, 'copy_from_template') return store.copy_from_template(source_keys, dest_key, user_id)
return self._block_relations.iterkeys()
multi_db = True
for field_name in remove_fields: self.fields.pop(field_name)
def has_permission(self, request, view): if request.user.is_staff: return True return super(IsUserInUrlOrStaff, self).has_permission(request, view)
tab_id = models.CharField(max_length=50) course_overview = models.ForeignKey(CourseOverview, db_index=True, related_name="tabs")
return models.Application.objects.create( name=name, user=user, client_id=client_id, client_type=models.Application.CLIENT_CONFIDENTIAL, authorization_grant_type=authorization_grant_type, redirect_uris=redirect_uri, )
actual_explicitly_set_fields = block.get_explicitly_set_fields_by_scope(scope=scope) assertion = self.assertIn if should_be_set else self.assertNotIn for field in expected_explicitly_set_fields: assertion(field, actual_explicitly_set_fields)
config_course_cohorts( course, is_cohorted=True, auto_cohorts=[] )
X = [[0., 1., +0.5], [0., 1., -0.1], [0., 1., +1.1]]
store = self._verify_modulestore_support(xblock.location.course_key, 'update_item') return store.update_item(xblock, user_id, allow_not_found, **kwargs)
AccessTestData(partition_groups={1: 3, 2: 3}, xblock_access={1: [1, 2], 2: [1, 2]}),
params = self._signed_callback_params(self.order.id, self.COST, "abcd") result = process_postpay_callback(params)
if course_key.org is None or course_key.course is None or course_key.run is None: return self._active_bulk_ops.records[ course_key.replace(org=None, course=None, run=None, branch=None) ]
fake_course_key = CourseKey.from_string('course-v1:FakeOrg+CN1+CR-FALLNEVER1') self.assertEqual(utils.get_course_chapters(fake_course_key), None)
assert_raises(ValueError, auc, [0.0, 0.5, 1.0], [0.1, 0.2])
return a
self.assertEqual(info['blocks'], [])
([[400, 150, 400], [400, 450, 600], [300, 225, 300]],
(['honor', 'verified', 'audit'], 'honor'),
self._submit_photos(face_image=self.IMAGE_DATA + "1112") reverification_data = self._get_post_data()
for block in blocks: for field in fields: self.assertEquals( block_structure.get_xblock_field(block.location, field), block.field_map.get(field), )
return self.dop_adapter.create_confidential_client( name='test_app', user=user, client_id=client_id, redirect_uri=DUMMY_REDIRECT_URL )
config.cancel()
log_likelihoods, responsibilities = self.score_samples(X) current_log_likelihood = log_likelihoods.mean()
is_increasing = assert_warns_message(UserWarning, "interval", check_increasing, x, y)
return (self.close_date is not None and datetime.datetime.now(UTC()) > self.close_date)
elif user_groups[partition_id].id in allowed_group_ids: continue
lw = LedoitWolf(store_precision=False, assume_centered=True) lw.fit(X_centered) assert_almost_equal(lw.score(X_centered), score_, 4) assert(lw.precision_ is None)
template = self.cleaned_data["plain_template"] self._validate_template(template) return template
import_course_from_xml(self.store, self.user.id, root_dir) imported_word_cloud = self.store.get_item(course_id.make_usage_key('word_cloud', 'untitled'))
monitoring_dataset = DenseDesignMatrix(X=X)
learn_more = model.train_batch(dataset, batch_size) model.monitor.report_batch(batch_size) if not learn_more: break
logging.getLogger().setLevel(logging.ERROR)
assert_raises(ValueError, _inverse_binarize_thresholding, y=csr_matrix([[1, 2], [2, 1]]), output_type="foo", classes=[1, 2, 3], threshold=0)
dbkey['run'] = location.run content_id = unicode(location.for_branch(None))
course_group.users.remove(user) user.course_groups.remove(course_group)
self.assertFalse(self.done.inprogress()) self.assertFalse(self.not_started.inprogress())
return StudioLibraryContainerXBlockWrapper.from_xblock_wrapper(xblock)
pass
pre_requisite_courses = get_prerequisite_courses_display(course)
self.browser.refresh() profile_page.wait_for_page() self.verify_profile_page_is_private(profile_page)
if row_max[-1] == 0: y_i_all_argmax = np.append(y_i_all_argmax, [len(y.data)])
"spec", "spec_helpers",
self.q(css='.wrapper-create-course .new-course-save').first.click() self.wait_for_ajax()
'ENABLE_TEAMS': True,
url = BASE_URL + "/signup" def is_browser_on_page(self): return self.q(css='body.view-signup').present
leaf_weights = node_weights[node_weights != 0] assert_greater_equal( np.min(leaf_weights), total_weight * est.min_weight_fraction_leaf, "Failed with {0} " "min_weight_fraction_leaf={1}".format( name, est.min_weight_fraction_leaf))
raise NotImplementedError(str(type(self)) + " does not implement " + "get_batch")
answer = 'Option 2' if correct else 'Option 3' selector_element = self.problem_page.q( css='.problem .option-input select') select_option_by_text(selector_element, answer)
train_data = iter(ALL_FOOD_DOCS[:-1]) tv = TfidfVectorizer(norm='l1')
self._click_button('basic_tab')
sample_steps_available = [1, 2, 3] for sample_steps in sample_steps_available:
AutoAuthPage(self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id, staff=True).visit()
pipeline.items.append( preprocessing.ExtractPatches(patch_shape=(8, 8), num_patches=150000) )
self._npy_counter = 1 if protocol is None: protocol = (pickle.DEFAULT_PROTOCOL if PY3_OR_LATER else pickle.HIGHEST_PROTOCOL)
c_int32 = astype(a_int32, dtype=np.int32, copy=False) assert_true(c_int32 is a_int32)
vertical1.children.append(html.location) self.store.update_item(vertical1, self.user.id)
USE_I18N = True
resp = self.client.get(self._receipt_url) self.assertContains(resp, expected_text)
assert_equal(len(lars.alphas_), 7)
choice = random.SystemRandom().choice return ''.join([choice(chars) for _i in range(length)])
col_mean, col_var, n_total_samples = \ _incremental_mean_and_var(X, last_mean=self.mean_, last_variance=self.var_, last_sample_count=self.n_samples_seen_)
element = etree.fromstring(xml_str) state = {'value': 'H2OYeah', } self.the_input = lookup_tag('chemicalequationinput')(test_capa_system(), element, state)
(2, 2.0, classification_cost)
self.item.youtube_id_1_0 = None with self.assertRaises(ValueError): self.item.get_transcript(transcripts)
launch_mcd_on_dataset(1700, 5, 800, 0.1, 0.1, 870)
with patch('lms.djangoapps.verify_student.models.requests.post', new=mock_software_secure_post_unavailable): attempt = self.create_and_submit() assert_equals(attempt.status, "must_retry")
try: connection.commit() except DatabaseError: try: connection.rollback() except Error: connection.close() raise
rt = RandomTreesEmbedding(max_depth=3, n_estimators=n_estimator, random_state=0)
task_entry = self._create_input_entry() with self.assertRaises(ValueError): task_class(task_entry.id, self._get_xmodule_instance_args())
return self.q(css='.bit-publishing .wrapper-visibility .copy .inherited-from').visible
#html_split_index = False
action_name = 'generating_exec_summary_report' task_fn = partial(upload_exec_summary_report, xmodule_instance_args) return run_main_task(entry_id, task_fn, action_name)
phase_data = self.run_data.setdefault(test_phase, {}) amount_data = phase_data.setdefault(amount_md, {}) __ = amount_data.setdefault(modulestores, time_taken)
if value: wait_for(lambda _: css_value(css_selector, index=index))
requested_format = request.GET.get('_accept', request.META.get('HTTP_ACCEPT', 'text/html'))
correct_map = CorrectMap() if 'correct_map' in state_dict: correct_map.set_dict(state_dict['correct_map'])
if merged_group_ids is not None: self._access[partition.id] = merged_group_ids
with make_uploaded_file( dimensions=(1, 1), extension=".png", content_type="image/png", force_size=upload_size ) as uploaded_file: self.check_validation_result(uploaded_file, expected_failure_message)
SECRET_KEY = 'dev key'
self.assertFalse(self._has_changes(locations['grandparent'])) self.assertFalse(self._has_changes(locations['parent']))
return '.cohort-management {}'.format(selector)
return self.list_display
for student in students[:2]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.downloadable, mode='honor' )
assert_raises(ValueError, _inverse_binarize_thresholding, y=csr_matrix([[1, 2], [2, 1]]), output_type="foo", classes=[1, 2], threshold=0)
return self.q(css=CARD_TITLE_CSS).map(lambda e: e.text).results
super(Conv2DSpace, self)._validate_impl(is_numeric, batch)
else: response.content = msg
self.course.edxnotes = True self.assertTrue(has_notes_tab(self.user, self.course))
for norb in (SmallNORB('train', stop=1000), NORB(which_norb='small', which_set='train')): test_impl(norb)
CCX_MAX_STUDENTS_ALLOWED = 200
return self.q(css=".field-hide-after-due").visible
if file_access_rights(local_dst,os.W_OK,check_above=True):
return self.q(css="div.modal div.modal-header").present and self._are_all_assets_present()
remove_users(self.admin, CourseCreatorRole(), self.user) self.assertTrue(user_has_role(self.user, CourseCreatorRole()))
self.course_info_page.visit() self.tab_nav.go_to_tab('Course') acid_block = AcidView(self.browser, '.xblock-student_view[data-block-type=acid]') self.validate_acid_block_view(acid_block)
self.q(css='.remove-action').filter(lambda el: language_code == el.get_attribute('data-lang')).click()
if issubclass(Estimator, ProjectedGradientNMF): with ignore_warnings(): yield check_get_params_invariance, name, Estimator else: yield check_get_params_invariance, name, Estimator
try: email = CourseEmail.create( course_id, request.user, targets, subject, message, template_name=template_name, from_addr=from_addr ) except ValueError as err: return HttpResponseBadRequest(repr(err))
self.test_create_account()
validated_lti_params = self.get_validated_lti_params(self.strategy)
return Env.BOK_CHOY_CACHE.set('test', 'test')
return etree.Element("schematic")
energy = dbm.energy(V = v_state, hidden = [y_state]) unnormalized_prob = T.exp(-energy) assert unnormalized_prob.ndim == 1 unnormalized_prob = unnormalized_prob[0] unnormalized_prob = function([], unnormalized_prob)
log.warning("_find_course_asset request of XML modulestore - not implemented.") return (None, None)
self.content_store.find(location)
return event['event_type'] in ('load_video', 'play_video', 'pause_video')
for name in keyword_only: default = _empty if kwdefaults is not None: default = kwdefaults.get(name, _empty)
for sel in PROBLEM_DICT[problem_type][correctness]: if bool(isnt_marked):
col = np.argmax(self.marked[row] == 2) if self.marked[row, col] != 2: col = -1 return col
mi = mutual_info_classif(X, y, discrete_features=True) assert_array_equal(np.argsort(-mi), np.array([0, 2, 1]))
if N.size(imgshp)==2: imgshp = (1,)+imgshp
os.remove(filename)
overview_v10 = CourseOverview.get_from_id(course.id) self.assertEqual(overview_v10.version, 10)
arnorm = alfa * beta if arnorm == 0: print(msg[0]) return x, istop, itn, r1norm, r2norm, anorm, acond, arnorm, xnorm, var
from __future__ import unicode_literals
if norm(grad * np.logical_or(grad < 0, H > 0)) < tol: break
problem_vertical = ItemFactory.create( parent_location=self.problem_section.location, category='vertical', display_name='Problem Unit' )
SSL_AUTH_EMAIL_DOMAIN = "MIT.EDU" SSL_AUTH_DN_FORMAT_STRING = "/C=US/ST=Massachusetts/O=Massachusetts Institute of Technology/OU=Client CA v1/CN={0}/emailAddress={1}"
with open(CONFIG_ROOT / CONFIG_PREFIX + "env.json") as env_file: ENV_TOKENS = json.load(env_file)
student_choices = set(choices) required_selected = len(self.correct_choices - student_choices) == 0 no_extra_selected = len(student_choices - self.correct_choices) == 0 correct = required_selected and no_extra_selected return correct
modulestore().get_item(usage_key)
'API': 'https://www.youtube.com/iframe_api',
description = "A CourseKey object, saved to the DB in the form of a string" KEY_CLASS = CourseKey
clf_random = ElasticNet(selection='invalid') assert_raises(ValueError, clf_random.fit, X, y)
indices = np.argsort(n_samples_per_label)[::-1] n_samples_per_label = n_samples_per_label[indices]
from django.core import management
mean_square_grad = sharedX(param.get_value() * 0.) mean_square_dx = sharedX(param.get_value() * 0.)
@functools.wraps(func) def capture(*args, **kwargs): stacks.capture_stack(args, kwargs) return func(*args, **kwargs)
if metric == 'precomputed' and sparse.issparse(X): neighborhoods = np.empty(X.shape[0], dtype=object)
assert_equal(len(folds), len(labels)) for i in np.unique(folds): assert_greater_equal(tolerance, abs(sum(folds == i) - ideal_n_labels_per_fold))
self.assertFalse(self.has_notes_tab(self.course, self.user))
clf = self.factory(alpha=0.1, n_iter=1000, fit_intercept=False) clf.fit(X, Y, sample_weight=np.arange(7))
yield check_estimators_overwrite_params
face = sp.misc.imresize(face, 0.10) / 255.
fs_root = mkdtemp()
'e3b0b940318df9c14be59acb08e78af5', self._get_anonymous_id(SlashSeparatedCourseKey('MITx', '6.00x', '2012_Fall'), descriptor_class)
return {'ok': False, 'msg': msg}
return ['sub']
from __future__ import unicode_literals
expected_X_norm = (np.sqrt(X.shape[0]) * np.mean((X - expected_X_mean) ** 2, axis=0) ** .5)
assert_array_almost_equal(clf.scores_[2], clf1.scores_[2]) assert_array_almost_equal(clf.intercept_[2:], clf1.intercept_) assert_array_almost_equal(clf.coef_[2][np.newaxis, :], clf1.coef_)
all_parents = [] published_parents = 0 for parent in parents: if parent['_id']['revision'] is None: published_parents += 1 all_parents.append(parent)
return self.q(css="#prereq").visible
Options.FORWARD_PROPERTIES = {'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields', '_forward_fields_map'}
y = 0.5 * X.ravel()
return 1
return CourseLocator( org=course_info['org'], course=course_info['course'], run=course_info['run'], branch=branch, )
'ENABLE_SOFTWARE_SECURE_FAKE': False,
self.test_cleanup()
Z = Z.reshape(xx.shape) plt.pcolormesh(xx, yy, Z, cmap=plt.cm.Paired)
inherited_metadata_filter_list = list(filtered_metadata.keys()) inherited_metadata_filter_list.extend(INHERITED_FILTER_LIST)
if n_features > 1: X = np.hstack([X, np.random.randn(n_samples, n_features - 1)]) return X, y
sigma_1 = 1 sigma_2 = 10 corr = 0.5 cov = np.array([ [sigma_1**2, corr * sigma_1 * sigma_2], [corr * sigma_1 * sigma_2, sigma_2**2] ])
SEARCH_ENGINE = None ELASTIC_FIELD_MAPPINGS = { "start_date": { "type": "date" } }
context['client'] = dict(segment_context) context['agent'] = segment_context.get('userAgent', '')
selector = self.get_element_selector(VIDEO_BUTTONS['quality']) return self.q(css=selector).visible
self.assertFalse(has_access(self.non_staff_user, 'load', self_paced_course))
assert np.isfinite(data_x).all() assert np.isfinite(data_y).all() assert data_x.shape[0] == data_y.shape[0]
indices, indptr, spmat_shape, sptype, outshp = \ convolution_indices.conv_eval(imgshp, maxpoolshp, maxpoolshp, mode='valid')
X, y, X_offset, y_offset, X_scale = _preprocess_data( X, y, fit_intercept=fit_intercept, normalize=normalize, copy=copy)
has_force_batch_size = getattr(model, "force_batch_size", False) train_dataset_is_uneven = \ dataset.get_num_examples() % self.batch_size != 0
if policy == {}:
start = DateTimeField(null=True) end = DateTimeField(null=True) advertised_start = TextField(null=True) announcement = DateTimeField(null=True)
from __future__ import unicode_literals
self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course_key)) delete_course_and_groups(self.course_key, self.user.id)
return self
catalog_visibility = TextField(null=True) short_description = TextField(null=True) course_video_url = TextField(null=True) effort = TextField(null=True) self_paced = BooleanField(default=False)
is_from_cdn = StaticContentServer.is_cdn_request(request) newrelic.agent.add_custom_parameter('contentserver.from_cdn', is_from_cdn)
self.prev_floatX = config.floatX config.floatX = 'float64'
X = [[1, 1, 5], [1, 1, 0]] t3.fit(X) X_incompt = [[1, 3], [1, 3]] assert_raises(ValueError, t3.transform, X_incompt)
discussion_id_map_json = CompressedTextField(verbose_name='Discussion ID Map JSON', blank=True, null=True)
current_cohort = get_cohort(user, course_key) verified_cohort = get_cohort_by_name(course_key, verified_cohort_name)
from __future__ import unicode_literals
EmptyPromise( lambda: self.q(css=create_ccx_button).present, "Create a new Custom Course for edX" ).fulfill() self.q(css=create_ccx_button).click()
i = np.argsort(dist2, axis=1) row_ind = np.arange(n_rows)[:, None] dist2 = dist2[row_ind, i] ind2 = ind2[row_ind, i]
self.assert_account_settings_context_looks_correct(account_settings_context(request), user, linked=True) self.assert_social_auth_exists_for_user(request.user, strategy)
current_cost = 0.5 * residuals + alpha * np.sum(np.abs(code)) errors.append(current_cost)
raise
return (self.role, self.org, self.course_id, self.user_id)
toy_course = store.get_course(SlashSeparatedCourseKey('edX', 'toy', '2012_Fall')) toy_course.wiki_slug = 'simple'
total_n_estimators = self.n_estimators if total_n_estimators < self.estimators_.shape[0]: raise ValueError('resize with smaller n_estimators %d < %d' % (total_n_estimators, self.estimators_[0]))
self._load_data(which_set, context_len, data_mode)
U *= sqrt(X.shape[0])
self.assertEqual(response.status_code, 200)
errs = {} for store in self.modulestores: errs.update(store.get_errored_courses()) return errs
if not fragment.js_init_fn: fragment.initialize_js('XBlockToXModuleShim') fragment.json_init_args = {'xmodule-type': block.js_module_name}
X_list = [1., 3., 5., 0.] X_arr = np.array(X_list)
return self.status == CertificateStatuses.downloadable
with self.assertNumQueries(6): override_field_for_ccx(self.ccx, chapter, 'start', ccx_start)
resp = self.create_xblock(parent_usage_key=self.usage_key, category='chapter') self.chapter_usage_key = self.response_usage_key(resp)
pos = logical_line.find('`') if pos > -1: yield pos, "W604 backticks are deprecated, use 'repr()'"
ddm = get_rnd_design_matrix() folds = ddm.split_dataset_nfolds(10) assert folds[0].shape[0] == np.ceil(ddm.get_num_examples() / 10)
if enrollment_mode is not None: CourseEnrollmentFactory( is_active=is_active, mode=enrollment_mode, course_id=self.course.id, user=self.user )
return output_scores
self.hw1_names = ['h1p1', 'h1p2'] self.hw2_names = ['h2p1', 'h2p2'] self.hw3_names = ['h3p1', 'h3p2']
def single_fdr(alpha, n_informative, random_state): X, y = make_regression(n_samples=150, n_features=20, n_informative=n_informative, shuffle=False, random_state=random_state, noise=10)
blocks_stack.extend(children)
self.collection.database.connection.close()
assert_true(world.css_has_value(css, date_or_time))
a = '\xe0\xe1\xe2\xe3\xe4\xe5\xe7\xe8\xe9\xea\xeb' expected = 'aaaaaaceeee' assert_equal(strip_accents_unicode(a), expected)
log.warning("find_asset_metadata request of XML modulestore - not implemented.") return None
self._auto_auth({'username': 'test', 'course_id': course_id})
roles = get_role_ids(course_id) for role in roles: if user.id in roles[role]: return True return False
#texinfo_show_urls = 'footnote'
actual_enabled = certs_api.cert_generation_enabled(self.course.id) self.assertEqual(is_enabled, actual_enabled)
self.dismiss_ui_and_verify(rerun)
self.assertContains(response, "Explore courses")
X = check_array(X, accept_sparse='csr') return safe_sparse_dot(X, self.components_.T)
restore_asset_from_trashcan(unicode(asset_key))
assert_raises(ValueError, cval.StratifiedShuffleSplit, y, 3, 0.2)
mathjax_container = self.q(css="div.problem div.problem-hint .MathJax_SVG") return mathjax_container.visible and mathjax_container.present
store = modulestore() with store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course.id): store.publish(course.location, ModuleStoreEnum.UserID.test)
template = Template(filename=file_path, module_directory=self.module_directory, input_encoding='utf-8', output_encoding='utf-8', default_filters=['decode.utf8'], encoding_errors='replace', uri=template_name) return template, None
legacy_profile = UserProfile.objects.get(id=self.user.id) name_change_info = legacy_profile.get_meta()["old_names"] self.assertEqual(expected_entries, len(name_change_info)) return name_change_info
has_access.return_value = True response = views.section_problem_grade_distrib(self.request, 'test/test/test', '1') self.assertEqual(json.dumps(self.simple_data), response.content)
self.assertFalse(result['success']) self.assertIn(u"did not return a required parameter", result['error_html'])
user = kwargs['instance'] user._changed_fields = get_changed_fields_dict(user, sender)
BlockCountsTransformer.collect(self.block_structure) self.block_structure._collect_requested_xblock_fields()
W = rng.randn(n_components, n_features) h = rng.randn(n_samples, n_components) noise = rng.gamma(1, size=n_features) * rng.randn(n_samples, n_features)
self.assert_no_xpath(xml, "//div[@class='capa_alert']", self.context)
self.assertEqual(initial_data["PhotoIDKey"], reverification_data["PhotoIDKey"])
indices = np.empty(X.shape[0], dtype=np.intp) values = np.empty(X.shape[0]) values.fill(np.infty)
if is_feature_enabled(): BACKEND.enable_microsites_pre_startup(log)
self._unenroll() self.assertEqual(DEFAULT_VERIFIED_COHORT_NAME, get_cohort(self.user, self.course.id, assign=False).name)
name_placeholder = _(u"Jane Doe")
buf = buf[offset:offset+size+1][:-1] data = np.ndarray(shape, dtype, buf, order=order) data.fill(0) return data
X = check_array(X, accept_sparse="csc", dtype=DTYPE) y = check_array(y, accept_sparse='csc', ensure_2d=False, dtype=None) if issparse(X): X.sort_indices()
content = StaticContent('loc', 'name', 'content_type', 'data', None, None, None) self.assertIsNone(content.thumbnail_location)
svd = TruncatedSVD(opts.n_components) normalizer = Normalizer(copy=False) lsa = make_pipeline(svd, normalizer)
field_data[attr] = deserialize_field(cls.fields[attr], value)
simplefilter('ignore')
pass
self.refresh_course() return section
self.assertEqual(len(mail.outbox), 2)
else: new_subcluster1, new_subcluster2 = _split_node( closest_subcluster.child_, threshold, branching_factor) self.update_split_subclusters( closest_subcluster, new_subcluster1, new_subcluster2)
mlp_second_part = MLP( layers=[ second_indep_layer ], input_space=VectorSpace(features_in_second_mlp), input_source=('features1') )
self.register_get_threads_response([], page=3, num_pages=3) with self.assertRaises(PageNotFoundError): get_thread_list(self.request, self.course.id, page=4, page_size=10)
source_suffix = '.rst'
STATIC_ROOT_BASE = ENV_TOKENS.get('STATIC_ROOT_BASE', None) if STATIC_ROOT_BASE: STATIC_ROOT = path(STATIC_ROOT_BASE)
from pylearn2.costs.mlp import L1WeightDecay as _L1WD from pylearn2.costs.mlp import WeightDecay as _WD
width = self.ext.config['veoh_width'][0] height = self.ext.config['veoh_height'][0] return flash_object(url, width, height)
sequential = self.store.create_child( self.user_id, chapter.location, 'sequential', block_id='subsection_one' ) self.store.publish(sequential.location, self.user_id)
score = self._init_decision_function(X) predict_stages(self.estimators_, X, self.learning_rate, score) return score
student = UserFactory.create() CourseEnrollmentFactory.create(user=student, course_id=self.course.id) self.client.login(username=student.username, password="test")
super(AdminCourseModeFormTest, self).setUp() self.course = CourseFactory.create()
return all([not xblock.is_placeholder() for xblock in self.xblocks])
component = self.store.publish(xblock.location, self.user_id) self.assertFalse(self.store.has_changes(component))
return spanify(render_expression(left))
raise NotImplementedError()
assert_equal(X.indptr.shape[0], 7) assert_equal(X.shape[0], 6) assert_equal(X.shape[1], 21) assert_equal(y.shape[0], 6)
def __call__(self, est, X, y): return 1
re.compile(r'^Advanced Settings \|'): [ "jquery", "js/base", "js/models/course", "js/models/settings/advanced", "js/views/settings/advanced", "codemirror"],
with patch.object(XQueueCertInterface, 'add_example_cert') as mock_queue: yield mock_queue
self.click(".action-save") self.page.wait_for_ajax()
clf = NearestCentroid() clf.fit(X_csr, y) assert_array_equal(clf.predict(T), true_result)
self.bookmarks_page.click_bookmarks_button() self.assertTrue(self.bookmarks_page.results_present()) self.assertEqual(self.bookmarks_page.results_header_text(), 'My Bookmarks')
self.xblock.test_content_field = "Explicitly set" self.xblock.test_settings_field = "Explicitly set" self.xblock.save()
self.assert_redirect_to_register_looks_correct(actions.do_complete(request.backend, social_views._do_login))
self._create_courses_and_enrollments( (self.TEST_ORG, True), ("other_org", True) )
if not isinstance(answers, (list, tuple)): answers = [answers]
student_complex = complex(student_complex) instructor_complex = complex(instructor_complex)
_do_scale_test(scaled) assert_almost_equal(scaled.sum(axis=0).mean(), scaled.sum(axis=1).mean(), decimal=1)
subject = render_to_string('emails/activation_email_subject.txt', context) subject = ''.join(subject.splitlines()) message = render_to_string('emails/activation_email.txt', context)
problem = self.build_problem(answer='[1j, 5]') input_dict = {'1_2_1': '3'} with self.assertRaises(StudentInputError): problem.grade_answers(input_dict)
upload_csv_to_report_store(rows, 'enrollment_report', course_id, start_date, config_name='FINANCIAL_REPORTS')
n_samples = 500
self.store.publish(problem_location, self.user_id)
assert_almost_equal(entropy(y), sum(importances)) assert_less(np.abs(true_importances - importances).mean(), 0.01)
return self.q(css='.new-library-button').present
return ACCESS_GRANTED if course.catalog_visibility == visibility_type else ACCESS_DENIED
class Meta(ConfigurationModel.Meta): app_label = "shoppingcart"
if course_id in course_summaries: log.warning( u"Modulestore %s have duplicate courses %s; skipping from result.", store, course_id ) else: course_summaries[course_id] = course_summary
_NEUPD_WHICH = ['LM', 'SM', 'LR', 'SR', 'LI', 'SI']
STATIC_ROOT = (TEST_ROOT / "staticfiles" / "lms").abspath()
response = self.client.get(self.url) self.assert_tag_has_attr(response.content, "html", "lang", self.site_lang)
return CompositeSpace((CompositeSpace((image_space,) * 2), VectorSpace(dim=1)))
dummy_v = T.tensor4() sqfilt = T.square(self._filters)
self.wait_for_ajax()
self.assertTrue(self.client.login(username=requesting_user.username, password=TEST_PASSWORD)) if make_inactive: requesting_user.is_active = False requesting_user.save()
url = reverse('verify_student_verify_now', kwargs=course_kwargs)
self.assertFalse(auth.user_has_role(self.user, CourseCreatorRole()))
return JsonResponse({'return_code': 0})
tmp *= 1 - damping A *= damping A -= tmp
parser.add_argument( '--all', action='store_true', dest='all', default=False, help='Generate course overview for all courses.', )
pass
EDX_API_KEY = AUTH_TOKENS.get("EDX_API_KEY")
ApiResponse = collections.namedtuple('ApiResponse', ['http_response', 'data'])
reset_student_attempts( self.course_key, user, problem_location, requesting_user=user, delete_module=True, )
assert all([len(arg) == len(args[0]) for arg in args]) return izip(*args)
user_exam_summary = get_attempt_status_summary( usage_info.user.id, unicode(block_key.course_key), unicode(block_key), ) return user_exam_summary and user_exam_summary['status'] != ProctoredExamStudentAttemptStatus.declined
self.assertEqual(course.course_image, 'images_course_image.jpg')
return check_sum_of_calls(object_with_method, [method_name], maximum_calls, minimum_calls)
added_to_index = self.reindex_course(store) self.assertEqual(added_to_index, 3) response = self.search() self.assertEqual(response["total"], 3)
#epub_language = ''
org = models.CharField(max_length=64, db_index=True, blank=True) course_id = CourseKeyField(max_length=255, db_index=True, blank=True) role = models.CharField(max_length=64, db_index=True)
response.remove_headers = headers
return self.page_num + 1
logistic = linear_model.LogisticRegression() rbm = BernoulliRBM(random_state=0, verbose=True)
CONFIG_ROOT = path(os.environ.get('CONFIG_ROOT', ENV_ROOT))
self.assertEqual(context['currency'], 'usd') self.assertEqual(context['currency_symbol'], '$')
return _has_instructor_access_to_location(user, descriptor.location, course_key)
self.assertEqual(k_args, tuple()) self.assertEqual( k_kwargs.get('url'), urlparse.urljoin(self.course.ccx_connector, ccxconapi.CCXCON_COURSEXS_URL) )
pca = PCA(n_components=n_digits).fit(data) bench_k_means(KMeans(init=pca.components_, n_clusters=n_digits, n_init=1), name="PCA-based", data=data) print(79 * '_')
self.assertEqual( res_json['message'], u"Certificate Invalidation does not exist, Please refresh the page and try again.", )
parents = block_structure.get_parents(block_key)
y_multirf = regr_multirf.predict(X_test) y_rf = regr_rf.predict(X_test)
course_with_disabled_forums = CourseFactory.create() CourseEnrollmentFactory.create(user=user, course_id=course_with_disabled_forums.id) _remove_discussion_tab(course_with_disabled_forums, user.id) return course_with_disabled_forums
if self.max_attempts is not None and self.attempts >= self.max_attempts: return True if self.is_past_due(): return True return False
courses = sorted( courses, key=lambda course: (course.has_ended(), course.start is None, course.start), reverse=False ) return courses
'default': { 'BACKEND': 'django.core.cache.backends.dummy.DummyCache', },
if self.n_classes_ > 1: max_features = max(1, int(np.sqrt(self.n_features))) else: max_features = self.n_features
CSRF_COOKIE_AGE = 60 * 60 * 24 * 7 * 52 CSRF_COOKIE_SECURE = False
published_xblock = self.store.create_item( self.user_id, self.course.id, 'vertical', block_id='test_vertical', asides=[aside1, aside2] )
self.assertEquals( value, request.META.get('HTTP_ACCEPT_LANGUAGE', UNSET) )
self.user.profile.year_of_birth = 1980 self.user.profile.profile_image_uploaded_at = TEST_PROFILE_IMAGE_UPLOAD_DT self.user.profile.save()
logger.info(this_package) packages_really_to_upgrade.append(this_package)
cache.clear() self.course_key = CourseLocator(org='TestOrg', course='TestCourse', run='TestRun')
self.randomize_datasets(randomize_now)
backend_name = forms.ChoiceField(choices=((name, name) for name in _PSA_OAUTH2_BACKENDS))
if instance.module_type in StudentModuleHistoryExtended.HISTORY_SAVING_TYPES: history_entry = StudentModuleHistoryExtended(student_module=instance, version=None, created=instance.modified, state=instance.state, grade=instance.grade, max_grade=instance.max_grade) history_entry.save()
return next( video for video in self.previous_uploads if video["edx_video_id"] == edx_video_id )
'start': course_overview.start, 'start_display': course_overview.start_display, 'start_type': course_overview.start_type, 'end': course_overview.end,
css = prefix + ' .wrapper-collection' return [GroupConfiguration(self, prefix, index) for index in xrange(len(self.q(css=css)))]
return self.q(css="div.problem section.inputtype div.correct span.status").is_present()
expr_s = re.sub( r'script([a-zA-Z0-9]+)', '\\mathcal{\\1}', expr_s )
lars = Lars(fit_intercept=False, verbose=verbose, normalize=False, precompute=gram, n_nonzero_coefs=int(regularization), fit_path=False) lars.fit(dictionary.T, X.T, Xy=cov) new_code = lars.coef_
self._init_state()
X = csr_matrix(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
context = {'payment_support_email': microsite.get_value('payment_support_email', settings.PAYMENT_SUPPORT_EMAIL)} return render_to_response("commerce/checkout_error.html", context)
task_type = 'cohort_students' task_class = cohort_students task_input = {'file_name': file_name} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
ngrams_nnz = X.nnz assert_true(ngrams_nnz > token_nnz) assert_true(ngrams_nnz < 2 * token_nnz)
n_samples_per_center = 100 grid_size = 3 scale = 0.1 n_clusters = grid_size ** 2
cov = pca.get_covariance() precision = pca.get_precision() assert_array_almost_equal(np.dot(cov, precision), np.eye(X.shape[1]), 12)
return 0
if self.name in self.name_to_event_type_map: super(VideoEventTransformer, self).transform()
attempt.mark_ready() attempt.submit(copy_id_photo_from=initial_verification)
patch_stack = patches.reshape((B*OR*OC, KR*KC*CH))
self.q(css='.prompt.error .action-primary').click()
num_enrollments = len(enrollments) self.assertDictContainsSubset({'attempted': num_enrollments, 'succeeded': num_enrollments, 'failed': 0}, result)
raise NotImplementedError()
if user is not None and has_course_author_access(user, course_key): return True
return self._extra_fields_setting.get(field_name) in ["required", "optional"]
wiki_courses = self.store.get_courses_for_wiki('999') self.assertIn(
for course_key, deadline in deadlines.iteritems(): VerificationDeadline.objects.create( course_key=course_key, deadline=deadline, )
X = check_array(X) n_samples, n_features = X.shape
sample_ids = [0, 1] common_nodes = (node_indicator.toarray()[sample_ids].sum(axis=0) == len(sample_ids))
e = np.zeros((n_samples, convergence_iter))
super(MyFetcher, self).__init__() self.client = client
from xmodule.modulestore.mongo.draft import DraftModuleStore as DraftMongoModuleStore
#latex_show_pagerefs = False
g.precisions_init = precisions_not_positive[covar_type] assert_raise_message(ValueError, "'%s precision' should be %s" % (covar_type, not_positive_errors[covar_type]), g.fit, X)
dispatch[type(len)] = save_global dispatch[type(object)] = save_global dispatch[type(Pickler)] = save_global dispatch[type(pickle.dump)] = save_global
try: return getattr(self._module_system, name) except AttributeError: return getattr(self._descriptor_system, name)
pred = km.predict(X) assert_array_equal(pred, km.labels_)
use = zipped[:1]
return unicode(self.course_key)
self.students = [UserFactory() for _ in xrange(STUDENT_COUNT)] for student in self.students: CourseEnrollmentFactory.create(user=student, course_id=self.course.id)
self.start_time = datetime.now(UTC) - timedelta(seconds=1)
ModuleStoreNoSettings.modulestore = class_(
_enroll_user_in_pending_courses(regs[0].user)
i18n_service = self.runtime.service(self.mock_block, 'i18n') self.assertIsNotNone(i18n_service) self.assertIsInstance(i18n_service, ModuleI18nService)
for node in range(len(children_map)): self.assertIn(node, block_structure) self.assertNotIn(len(children_map) + 1, block_structure)
pipe.set_params(svc__C=0.1) assert_equal(clf.C, 0.1) repr(pipe)
return Response(status=status.HTTP_204_NO_CONTENT)
$ ./manage.py lms resubmit_error_certificates -c edX/DemoX/Fall_2015 -c edX/DemoX/Spring_2016
path = path.replace(os.sep, '/') if path.startswith('./'): path = path[2:] return path
for field_name in self.DEFAULT_FIELDS: self.field_handlers[field_name](form_desc, required=True)
context['last_accessed_courseware_url'] = None if SelfPacedConfiguration.current().enable_course_home_improvements: context['last_accessed_courseware_url'] = get_last_accessed_courseware(course, request, user)
output = tensor.dot(patch_stack, kerns.flatten(2).T).reshape((B, OR, OC, K))
if microsite.has_override_value('SESSION_COOKIE_DOMAIN'):
multi_db = True
CourseEnrollmentFactory.create( user=self.user, course_id=course_key, mode=mode )
super(TeamManagementPage, self).__init__(browser, course_id) self.topic = topic self.url_path = "teams/#topics/{topic_id}/create-team".format(topic_id=self.topic['id'])
submitted = self._unpack(student_answer) option_ids = submitted['options_value'] if len(option_ids) == 1: return option_ids[0] return None
return etree.Element("choicetextresponse")
return None
unlink_cohort_partition_group(test_cohort) link_cohort_to_partition_group( test_cohort, self.user_partition.id, self.groups[1].id, ) self.assert_student_in_group(self.groups[1])
problem_location = task_input.get('problem_location') student_data = list_problem_responses(course_id, problem_location) features = ['username', 'state'] header, rows = format_dictlist(student_data, features)
self.elapsed = time.time() - self._start_time
VERIFY_STUDENT["SOFTWARE_SECURE"] = { "API_ACCESS_KEY": "BBBBBBBBBBBBBBBBBBBB", "API_SECRET_KEY": "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC", }
self._block_relations = pruned_block_relations
config = VerifiedTrackCohortedCourse.objects.create(course_key=course_key, enabled=True) config.save() self.assertTrue(VerifiedTrackCohortedCourse.is_verified_track_cohort_enabled(course_key))
model_channels = model.get_monitoring_channels(nested_ipt[-1]) channels = {} for name in model_channels: channels[name] = (model_channels[name], nested_ipt[-1], (spaces[-1], sources[-1])) custom_channels.update(channels)
assignment = GradedAssignment( user=self.user, course_key=self.course.id, usage_key=desc.location, outcome_service=outcome_service, lis_result_sourcedid=result_id, version_number=0 ) assignment.save() return assignment
self.answer_problem(correct=True) self.problem_page.click_check() self.wait_for_status('correct')
X = [[0], [0]] Y = [[1], [2]] D = paired_manhattan_distances(X, Y) assert_array_almost_equal(D, [1., 2.])
return iter(getattr(d, _iteritems)(**kw))
return self.q(css='.warning-heading-text').text[0]
return CreditCourse.is_credit_course(course_key=course_key)
self.dashboard_page.visit() self.assertTrue(self.dashboard_page.has_course( org=new_org, number=self.course_number, run=self.course_run ))
is_redeemed = RegistrationCodeRedemption.objects.filter( registration_code=reg_code ).exists() self.assertFalse(is_redeemed)
url = self._reverse_urls(['courseware'], course)[0] self.assert_request_status_code(302, url)
last_name_label = _(u"Last Name")
if not self.user_can_access_course(user, course): raise Http404
REQUIRE_DEBUG = False
return _get_array_element('scale change', label, (0.78, 1.0))
self.import_static(data_path, dest_id)
msg = 'Error inserting to MongoDB event tracker backend' log.exception(msg)
return self.q(css='.new-course-button')
'answers': student_answers,
wtf_numpy = np.zeros((n_classes,)) for i in xrange(n_classes): wtf_numpy[i] = probs[i] probs = wtf_numpy
mock_get.return_value = Mock(status_code=200, text=response_success, content=response_success) transcript_name = transcripts_utils.youtube_video_transcript_name(youtube_text_api) self.assertIsNone(transcript_name)
verified.delete() self.assertFalse(CourseMode.has_payment_options(self.course_key))
invoice_copy_preference = True invoice_preference_value = get_user_preference(request.user, INVOICE_KEY) if invoice_preference_value is not None: invoice_copy_preference = invoice_preference_value == 'True' return JsonResponse({ 'invoice_copy': invoice_copy_preference })
import datetime
self.q(css=self._bounded_selector(self.NAME_INPUT_SELECTOR)).results[0].send_keys(Keys.ENTER) self.wait_for_ajax()
import functools import operator
ir.fit(x, y) ir.out_of_bounds = "xyz" assert_raises(ValueError, ir.transform, x)
def rval(): X, y = self.dataset.get_batch_design(self.batch_size, include_labels=True) self.y_cache = y return X return rval
PAYLOAD_EXTRA_FIELDS = 'payload_extra_fields'
xml = self.xml cxml = xml.xpath('//*[@id=$id]//choice', id=xml.get('id'))
is_verified, has_skipped, has_completed = _get_user_statuses(user, course_key, checkpoint)
W = rng.uniform(-self.irange, self.irange, (input_dim, self.dim * 4))
certificate_type = context.get('certificate_type')
all_modes = CourseMode.modes_for_course_dict(self.course_key, only_selectable=False) self.assertItemsEqual(all_modes.keys(), available_modes)
course_cohort_settings = get_course_cohort_settings(course_key) if not course_cohort_settings.is_cohorted: return request_cache.data.setdefault(cache_key, None)
label = _(u"I agree to the {platform_name} {terms_of_service}.").format( platform_name=get_themed_value("PLATFORM_NAME", settings.PLATFORM_NAME), terms_of_service=terms_link )
vect = CountVectorizer(analyzer='char', max_df=1.0, binary=True, dtype=np.float32) X_sparse = vect.fit_transform(test_data) assert_equal(X_sparse.dtype, np.float32)
return super(AdaBoostClassifier, self).fit(X, y, sample_weight)
return key.field_name
log.error("Unable to add Credit requirement status for user with id %d", attempt.user.id)
else: merged = closest_subcluster.merge_subcluster( subcluster, self.threshold) if merged: self.init_centroids_[closest_index] = \ closest_subcluster.centroid_ self.init_sq_norm_[closest_index] = \ closest_subcluster.sq_norm_ return False
def left_op(imgs): return self.op(imgs, self.s_filters)
if domain and 'edge.edx.org' in domain: return redirect(reverse("signin_user"))
for parent, children in enumerate(children_map): self.assertSetEqual(set(block_structure.get_children(parent)), set(children))
self.normalize = bool(self.normalize)
activations = [X]
except ValueError: pass
('subjectbody', SubjectBodyExtractor()),
def render_to_template_mock(*args): pass
assert_raises(ValueError, model.fit, mat) continue
certs_enabled = CertificateGenerationConfiguration.current().enabled if certs_enabled and access['admin']: sections.append(_section_certificates(course))
self.fields = block_data.get('fields', {})
self.send_get(self.anonymous_client, expected_status=401) self.send_patch(self.anonymous_client, {}, expected_status=401)
fit_params = fit_params if fit_params is not None else {} fit_params = dict([(k, _index_param_value(X, v, train)) for k, v in fit_params.items()])
err = SearchIndexingError mock_index_dictionary.return_value = err
train = cifar10.CIFAR10(which_set="train")
data = { "email": self.EMAIL, "password": self.PASSWORD, }
return dict([(pref.key, pref.value) for pref in user.preferences.all()])
X = np.array([[1, 2], [2, 1], [-2, 1], [-2, -1]]) y_ref = np.array([2, 0, 1, 2])
del results[-1] max_exceeded = True
return self._estimate_log_prob(X) + self._estimate_log_weights()
if answer_script: answer_element = etree.SubElement(response_element, "answer") answer_element.set("type", "loncapa/python") answer_element.text = str(answer_script)
#html_static_path = add_base(['_static'])
if None in distribution:
overview_v10.version = 9 overview_v10.save()
DATADOG = AUTH_TOKENS.get("DATADOG", {}) DATADOG.update(ENV_TOKENS.get("DATADOG", {}))
params[field] = "" assert_extra_field_error()
return "{}/assertions".format(self._badge_url(slug))
message_cache_key = ( 'embargo.message_url_path.courseware.{course_key}' ).format(course_key=self.course.id) cache.delete(message_cache_key)
anon_user = Client() resp = anon_user.get(self.view_url) self.assertEquals(resp.status_code, 302)
course_mode_info = { enrollment.course_id: complete_course_mode_info( enrollment.course_id, enrollment, modes=course_modes_by_course[enrollment.course_id] ) for enrollment in course_enrollments }
self.assertFalse(zendesk_mock_class.return_value.mock_calls) self.assertFalse(datadog_mock.mock_calls)
self.assertTrue(self.user.roles.filter(name="Student", course_id=self.course_key))
#html_show_sourcelink = True
self.check_components_on_page( ADVANCED_COMPONENT_TYPES, ['Word cloud', 'Annotation', 'Text Annotation', 'Video Annotation', 'Image Annotation', 'split_test'], )
CreditCourse.objects.create( course_key=self.course.id, enabled=True, )
return int(self.position.split(':')[1])
modulestore = XMLModuleStore( DATA_DIR, course_ids=course_ids, default_class='xmodule.hidden_module.HiddenDescriptor', xblock_mixins=XBLOCK_MIXINS, ) yield modulestore
self.generated_certificate.invalidate()
face_compressed = np.choose(labels, values) face_compressed.shape = face.shape
assert_raises(ValueError, unique_labels)
if self.current_user != username: self.logout() user_email = User.objects.get(username=username).email self.login(user_email, "test") self.current_user = username
if match is not None: return True
log.warning( "Error while previewing formula", exc_info=True ) result['error'] = _("Error while rendering preview")
CELERY_ALWAYS_EAGER = True
try: certificate_exception, student = parse_request_data_and_get_user(request, course_key) except ValueError as error: return JsonResponse({'success': False, 'message': error.message}, status=400)
self.assertEqual(self.video.speed, '2.0x')
raise NotImplementedError
course_key = ccx_key.to_course_locator() return _has_access_course_key(user, action, course_key)
choices = [(short, full) for (short, full) in raw_choices] + [('no_data', 'No Data')]
'ENABLE_SPECIAL_EXAMS': False,
self.course_hierarchy = self.get_course_hierarchy() self.blocks = self.build_course(self.course_hierarchy) self.course = self.blocks['course']
allowance_section.submit_allowance_form('10', self.USERNAME)
if category == "static_tab": dog_stats_api.increment( DEPRECATION_VSCOMPAT_EVENT, tags=( "location:xml_load_extra_content_static_tab", u"course_dir:{}".format(course_dir), ) )
if not date_time: msg = '[{}] is not a valid timestamp'.format(value) log.warning(msg) raise serializers.ValidationError(msg)
for problem in problem_set: stack_data = []
EmptyPromise(self.is_error_modal_showing, 'Error Modal Displayed', timeout=30).fulfill()
uid = self.provider.get_social_auth_uid('uid') if uid is not 'uid': query_set = query_set.filter(uid__startswith=uid[:-3])
yield check_estimators_pickle
self.assert_grade(problem, "Other String", "incorrect")
try: course = get_course_with_access(request.user, 'load', course_key, check_if_enrolled=check_if_enrolled) except UserNotEnrolled: raise Http404("Course not found.")
num_braces = 0
X_pca = pca.transform(X) assert_array_almost_equal(pca.explained_variance_, np.var(X_pca, axis=0))
return modulestore.get_course(structure_key, depth=None)
if n_components == X.shape[1]: assert_array_almost_equal(X, X2)
err_count = 0 while True: try: shutil.rmtree(fullname, False, None) break except os.error: if err_count > 0: raise err_count += 1 time.sleep(RM_SUBDIRS_RETRY_TIME)
return ContainerPage(self.browser, self.locator).visit()
entrance_exam_minimum_score_pct = _get_default_entrance_exam_minimum_pct() if ee_min_score != '' and ee_min_score is not None: entrance_exam_minimum_score_pct = float(ee_min_score) return create_entrance_exam(request, course_key, entrance_exam_minimum_score_pct)
custom_parameters = {}
from nose.plugins.skip import SkipTest import theano.sandbox.cuda as cuda_ndarray if cuda_ndarray.cuda_available == False: raise SkipTest('Optional package cuda disabled')
bootstrap=bootstrap, bootstrap_features=False, n_estimators=n_estimators, max_samples=max_samples, max_features=max_features, n_jobs=n_jobs, random_state=random_state, verbose=verbose)
distribution['no_data'] = profiles.filter( **{feature: None} ).count()
for key, value in settings.MKTG_URL_LINK_MAP.items(): if value is None: continue
return ( self.enabled and self.enable_studio_tab and bool(self.authoring_app_js_path) and bool(self.authoring_app_css_path) )
self.find_css('p.group-configuration-usage-text a').first.click()
xpath = "//div[@class='drag_and_drop_problem_json']/p/b" self.assert_has_text(xml, xpath, 'HTML')
self._create_courses_and_enrollments( (self.TEST_ORG, True), (self.TEST_ORG, True), (self.TEST_ORG, True), ("org_alias", True) )
log_func = log.debug if request.user.id is None else log.warning log_func(
math_interpreter.check_variables(all_variables, all_functions)
time_step = 5 rval = np.zeros((time_step, batch_size), dtype=dtype) rval[:3, :1] = 1 rval[:4, 1:] = 1 return rval
LogoutPage(self.browser).visit() StudioAutoAuthPage(self.browser, username=username, email=email, course_id=self.course_id, staff=staff).visit()
result = self.store.get_library(LibraryLocator("non", "existent")) self.assertEqual(result, None)
if self.axis == 1: X = check_array(X, accept_sparse='csr', dtype=FLOAT_DTYPES, force_all_finite=False, copy=self.copy)
with self.assertNumQueries(2): embargo_api.message_url_path(self.course.id, "enrollment")
w = [e for e in w if e.category is not np.VisibleDeprecationWarning]
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
key = signature.get_shared_secret_key("asu") sig = signature.signature({}, key) self.assertEqual(sig, "7d70a26b834d9881cc14466eceac8d39188fc5ef5ffad9ab281a8327c2c0d093")
assert_greater(np.abs(s[:k] - sa).max(), 0.1)
distances = paired_distances(X[connectivity.row], X[connectivity.col], metric=affinity)
total_pages = int(math.ceil(float(total_students) / MAX_STUDENTS_PER_PAGE_GRADE_BOOK)) or 1
self.verify_success_on_file_content( 'username,email,cohort\nfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task )
Z, (pi, W_sr, L, b, a) = \ self._posterior_mode(K, return_temporaries=True)
mlp_first_part = MLP( layers=[ first_indep_layer ], input_space=VectorSpace(features_in_first_mlp), input_source=('features0') )
self.assertEqual(len(mail.outbox), 1)
self.assertFalse(are_permissions_roles_seeded(self.base_course_key)) call_command('import', self.content_dir, self.good_dir) self.assertTrue(are_permissions_roles_seeded(self.base_course_key))
self._auto_auth(self.USERNAME, self.EMAIL, False)
self.video.show_captions()
clf = DecisionTreeClassifier(max_depth=3, min_samples_split=2, criterion="gini", random_state=2) clf.fit(X, y)
return render_body(obj["body"])
pl2_path, = pylearn2.__path__ file_list = _list_files(pl2_path, suffix) return file_list
with open(CONFIG_ROOT / CONFIG_PREFIX + "auth.json") as auth_file: AUTH_TOKENS = json.load(auth_file)
self.covariance_ = covariance if self.store_precision: self.precision_ = pinvh(covariance) else: self.precision_ = None
v3.set_params(strip_accents='ascii', lowercase=False) assert_equal(v3.build_preprocessor(), strip_accents_ascii)
continue
batch_names = ['monitoring_%s' % s for s in self._flat_data_specs[1]] theano_args = self._flat_data_specs[0].make_theano_batch(batch_names)
y = zca_dataset.mapback_for_viewer(zca_dataset.X) z = x/np.abs(x).max(axis=0) assert_allclose(z[start:stop], y, rtol=1e-2)
api_call = lambda: generate_certificates_for_students( self.create_task_request(self.instructor), self.course.id ) self._test_resubmission(api_call)
if per_example is None: return None
pass
rng = np.random.RandomState(0)
update_wrapper(self, fn)
new_user_partition = UserPartition(
self.assertIsNone(SurveyForm.get(self.test_survey_name, throw_if_not_found=False))
user = self.create_user_and_enroll('verified') self.add_verification_status(user, VerificationStatus.DENIED_STATUS)
assert_raises(VerificationException, attempt.submit)
expected_url = _third_party_login_url( backend_name, "login", redirect_url=_finish_auth_url(params), ) self.assertContains(response, expected_url)
self.selector = prefix + ' .certificates-list-item-{}'.format(index) self.index = index super(CertificateSectionPage, self).__init__(container.browser, **container.course_info)
self.section = modulestore().get_item(self.section.location, depth=None) self.field_data_cache.add_descriptor_descendents(self.section, depth=None)
values = [arg_val] values.extend(arg_vals) arguments[param.name] = tuple(values) break
x = np.array([0, 1, 1, 0, 0]) y = np.array([1, 0, 0, 0, 1])
w = rng.uniform(size=n_samples) w[5:8] = 0 regression.fit(x, y, sample_weight=w)
try: connection.rollback() except Error: connection.close()
ps = precision_score(y_true, y_pred, pos_label=1, average='micro') assert_array_almost_equal(ps, 0.53, 2)
reraise_as(IOError("Cannot open " + path + " but can open " + parent + "."))
spmatrix = spmatrix.copy()
pil_from_ndarray(ndarray).save(filepath)
if url is not None:
affiliate_id = request.COOKIES.get(settings.AFFILIATE_COOKIE_NAME) if user is not None and affiliate_id is not None: UserAttribute.set_user_attribute(user, settings.AFFILIATE_COOKIE_NAME, affiliate_id)
command = resubmit_error_certificates
self._verify_unit_warning( self.UnitState(is_released=True, publish_state=self.PublishState.NEVER_PUBLISHED, is_locked=False), self.NEVER_PUBLISHED_WARNING )
USE_I18N = True
course = xml.CourseFactory.build() sequence = xml.SequenceFactory.build(parent=course) split_test = SplitTestModuleFactory( parent=sequence, attribs={ 'user_partition_id': '0',
child_pids = p1_group.get_children(recursive=True)
return traverse_topologically( start_node=self.root_block_usage_key, get_parents=self.get_parents, get_children=self.get_children, filter_func=filter_func, yield_descendants_of_unyielded=yield_descendants_of_unyielded, )
return ', '.join([', '.join(IMAGE_TYPES[ft].extensions) for ft in IMAGE_TYPES.keys()])
ave = kl(Y, Y_hat, 1)
request = self.create_request( data=self.create_segmentio_event_json(**kwargs), content_type='application/json' ) segmentio.track_segmentio_event(request)
self.assert_response_with_delete_cookie()
MULTILABELS_METRICS = [ "accuracy_score", "unnormalized_accuracy_score", "hamming_loss", "jaccard_similarity_score", "unnormalized_jaccard_similarity_score", "zero_one_loss", "unnormalized_zero_one_loss",
self.assert_field_type(load_video_event, 'time', datetime.datetime) del load_video_event['time']
return cls.current().cdn_user_agents
return self.q(css='.item-progresspoint-success-date').visible
CourseEnrollment.enroll(self.user, course_id or self.course.id)
'MAX_NOTE_LIMIT': 1000,
assert isinstance(num_steps, py_integer_types) assert num_steps > 0
self.assertEqual(str(results[0].time), '2013-01-01 17:01:00+00:00')
asset_filename = subs_filename(subs_id, lang) if not filename else filename return Transcript.get_asset(location, asset_filename)
self.first_checkpoint.add_verification_attempt(SoftwareSecurePhotoVerification.objects.create(user=self.user))
if validation.empty: validation.set_summary(summary)
return { child_descriptor.location: child_descriptor, source_location: source_descriptor }.get(usage_id)
product = partial(reduce, operator.mul) return sum(product(len(v) for v in p.values()) if p else 1 for p in self.param_grid)
return bool(STUDIO_VIEW_CONTENT & get_user_permissions(user, course_key))
param_grid = ParameterGrid(self.param_distributions) grid_size = len(param_grid)
redirect_url = embargo_api.redirect_if_blocked( course_key, user=request.user, ip_address=get_ip(request), url=request.path ) if redirect_url: return redirect(redirect_url)
self.assertEqual(first_cohort.users.get(), course_user)
def utcoffset(self, _dt): return None
unique_together = (('user', 'name',), )
index = counter[chosen] minibatch = self.dataset[chosen][ index * self.batch_size:(index + 1) * self.batch_size ] counter[chosen] = (counter[chosen] + 1) % self.limit[chosen] yield minibatch
n_samples = 500
super(VectorSpace, self)._validate_impl(is_numeric, batch)
clf = cls().fit(X2, y2) assert_raises(ValueError, clf.predict, X2[:, :-1])
students = self._create_students(10)
app.connect('build-finished', embed_code_links)
student = UserFactory.create() CourseEnrollmentFactory.create( user=student, course_id=SlashSeparatedCourseKey.from_deprecated_string(self.course_name) ) self.client.login(username=student.username, password="test")
unit = self.go_to_unit_page() test_block = unit.xblocks[1] title_on_unit_page = test_block.name container = test_block.go_to_container() self.assertEqual(container.name, title_on_unit_page)
with patch('openedx.core.djangoapps.safe_sessions.middleware.log.warning') as mock_log: yield self.assertFalse(mock_log.called)
query = "UPDATE auth_userprofile SET country = NULL WHERE id = %s" connection.cursor().execute(query, [str(self.user.profile.id)])
cls.num += 1 return cls.num
return self.q(css=self._bounded_selector('.remove-admin-role')).text[0]
print 'Not logged in' for page in auth_pages: print "Checking '{0}'".format(page) self.check_page_get(page, expected=302)
attempt2 = SoftwareSecurePhotoVerification(user=user) attempt2.status = 'denied' attempt2.error_msg = '[{"photoIdReasons": ["Not provided"]}]' attempt2.save()
return student.views.index(request, user=request.user)
for label in np.unique(labels): assert_equal(len(np.unique(folds[labels == label])), 1)
levels = np.linspace(0, Z.max(), 25) plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)
X = np.c_[X, E]
html = module.render(STUDENT_VIEW).content
#source_encoding = 'utf-8'
NEVER = lambda x: False ALWAYS = lambda x: True
self.test_tab = ItemFactory.create( parent_location=self.course.location, category="static_tab", display_name="Static_1" ) self.reload_course()
self._set_gender(gender_enum) self.assertEqual(self.profile.gender_display, display_gender)
kern_data_minor = kern_data.transpose([0,2,3,1]).copy() img_data_minor = img_data.transpose([0,2,3,1]).copy()
self._create_video_component() self.edit_component() self.assertTrue(self.video.verify_settings())
X = X_2d n = X.shape[0]
SignalHandler.pre_publish.disconnect(receiver=on_pre_publish) self.addCleanup(SignalHandler.pre_publish.connect, receiver=on_pre_publish)
clean_warning_registry() with warnings.catch_warnings(): warnings.simplefilter("ignore", self.category) return fn(*args, **kwargs)
self.client.logout() super(TestCourseListing, self).tearDown()
varname = ur"{a}_{{{b}}}".format( a=enrich_varname(first), b=enrich_varname(second) )
exception = Exception("failure in rerunning") try: raise exception except: CourseRerunState.objects.failed(course_key=self.course_key)
if case_sensitive: casify = lambda x: x else:
for mode, min_price in course_modes: CourseModeFactory.create(mode_slug=mode, course_id=self.course.id, min_price=min_price)
key = RSA.importKey(rsa_pub_key_str) cipher = PKCS1_OAEP.new(key) encrypted_data = cipher.encrypt(data) return encrypted_data
frgd_img = to_img(blend_arr, os)
raise NotImplementedError
'courseware', 'student',
X, y = make_regression( n_samples=n_samples, n_features=n_features, random_state=0, noise=0.05)
CourseModeFactory.create(course_id=self.COURSE_KEY, mode_slug=CourseMode.HONOR) with self._mock_xqueue() as mock_queue: certs_api.generate_example_certificates(self.COURSE_KEY)
for t in cls.tags: self._mapping[t] = cls
self.assertIn('<span class="important-dates-item-text">$10</span>', resp.content)
ais_nodata('mnistvh.mat', do_exact=do_exact, betas=betas)
selector = self.get_element_selector(CSS_CLASS_NAMES['error_message']) return self.q(css=selector).text[0]
bnorm = beta1 n_params = len(bs)
def test_email_flag_false_mongo_true(self): BulkEmailFlag.objects.create(enabled=False) response = self.client.get(self.url) self.assertFalse(self.email_link in response.content)
n_samples = len(y) n_classes = float(len(np.unique(y)))
from __future__ import unicode_literals
"decision": decision, "req_reference_number": str(order_id), "req_amount": order_amount, "auth_amount": paid_amount, "req_card_number": card_number,
dlogz = log_mean(log_ais_w)
assert_equal(train.union(test), set(range(n_samples)))
distances.flat[::distances.shape[0] + 1] = 0.0
course_outline_page.q(css='.outline-item.outline-subsection.is-collapsed .ui-toggle-expansion').first.click()
entry_needs_saving = True log.warning("background task (%s) revoked.", task_id) task_output = InstructorTask.create_output_for_revoked()
cm = metrics.confusion_matrix(y_test, y_predicted) print(cm)
section_titles = [t.split('\n')[0] for t in section_titles]
return self.q(css='#view-updated-button').visible
d_Z = np.empty(theta.shape[0])
sampling_algorithm["python-core-sample"] = \ lambda n_population, n_sample: \ random.sample(xrange(n_population), n_sample)
cmp_mode = 'equal'
assert_true(hasattr(InheritanceMixin, attribute))
return self._get_cohort_messages("confirmations", wait_for_messages)
assert_raises(ValueError, lshf.partial_fit, np.random.randn(n_samples_partial_fit, n_features - 1))
from __future__ import unicode_literals
for vertical in verticals: self.assertEqual(course.xqa_key, vertical.xqa_key) self.assertEqual(course.start, vertical.start)
user.masquerade_settings = { self.course_key: CourseMasquerade(self.course_key, role=role) }
return self.get_text('.group-configuration-description')
if case_sensitive: casify = lambda x: x else:
'openedx.core.djangoapps.credit',
self.execute_check_function(idset, submission)
X_blobs, y_blobs = make_blobs(n_samples=100, centers=10, random_state=0) X_blobs = sparse.csr_matrix(X_blobs)
mid = int(np.floor(kernel_shape/ 2.)) centered_X = X - convout[:,:,mid:-mid,mid:-mid]
y_pred3 = clf.fit(X, y3).predict(X) assert_true(np.any(y_pred3 != y3), 'solver %s' % solver)
exclude_dirs = ['images', 'scripts', 'sandbox']
self.cohort_management_page.select_cohort(cohort_name) self.assertEquals(self.cohort_management_page.get_selected_cohort(), cohort_name) self.assertIn(expected_description, self.cohort_management_page.get_cohort_group_setup())
self.assertTrue(all(isinstance(course, CourseSummary) for course in course_summaries))
self.enrollment = CourseEnrollment.enroll(self.user, self.course_id, mode=CourseMode.VERIFIED)
with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
X, y = make_regression(n_samples=200, n_features=20, n_informative=5, shuffle=False, random_state=0)
raise NotImplementedError
if org_target: if record.index['org'] != org_target: continue
self.client.post( url_course2, data=json.dumps(self.certificate_exception), content_type='application/json' )
from urllib.request import urlopen from urllib.error import HTTPError
request.grant_type = grant_type request.user = user
self.assertIsInstance(descriptor._field_data, LmsFieldData)
except StopIteration: log.info("Extension requested training halt.") continue_learning = False
nav_dict = dict()
statobj = inputtypes.Status('queued', func) self.assertEqual(statobj.display_name, u'PROCESSING')
self.assertIn( 'oauth_body_hash="00hq6RNueFa8QiEjhep5cJRHWAI%3D"', prepped_req.headers['Authorization'] )
for fname, dirpath in get_all_files(directory): if fname == filename: return dirpath return None
config = DonationConfiguration.current() config.enabled = True config.save()
event_info = dict() event_info['module_id'] = self.capa_module.location.to_deprecated_string() event_info['problem_part_id'] = self.id
X -= X.min() with warnings.catch_warnings(record=True): estimator = Estimator()
return self.translations.get(msgid, msgid)
with with_edx_domain_context(is_edx_domain): response = self.client.get(reverse(url_name), params)
X_FRAME_OPTIONS = 'ALLOW'
dense_classifier = IsolationForest( n_estimators=10, random_state=1, **params).fit(X_train) dense_results = dense_classifier.predict(X_test)
z,zz = 0,0
world.ItemFactory.create( parent_location=parent_location, category='problem', display_name=display_name, data=problem_xml )
items = list(items) return (items[i:i + chunk_size] for i in xrange(0, len(items), chunk_size))
with override_settings(REGISTRATION_EXTRA_FIELDS={"country": "required"}): response = self.client.get(self.url) self.assertHttpOK(response)
copy = copy if copy is not None else self.copy return binarize(X, threshold=self.threshold, copy=copy)
msg = 'Error occurred while evaluating CustomResponse' log.warning(msg, exc_info=True)
self.page = _Page(page_num, num_pages) self.base_url = request.build_absolute_uri() self.count = result_count super(DiscussionAPIPagination, self).__init__()
super(TestCourseVerificationStatus, self).setUp()
paid_course = CourseMode.is_white_label(self.course_id) if paid_course or CourseMode.is_professional_slug(self.mode): return True return False
previous_count = len(selected) block_keys = LibraryContentModule.make_selection(selected, library_children, max_count, mode) selected = block_keys['selected']
different = (mbk_means_labels == 4) ax = fig.add_subplot(1, 3, 3)
#html_sidebars = {}
if self.status == "approved": return
return Response(data=token)
missing_course_key = CourseKey.from_string('course-v1:FakeOrganization+CN999+CR-FALL99') self.assertIsNone(ccxconapi.course_info_to_ccxcon(missing_course_key)) self.assertEqual(mock_post.call_count, 0)
top_level_logger.setLevel(logging.NOTSET)
resp_asset = post_asset_update(True, course) self.assertTrue(resp_asset['locked']) verify_asset_locked_state(True)
self.assertEqual(block.edited_by, "testassist@edx.org") self.assertDictEqual( block.grade_cutoffs, {"Pass": 0.45}, )
face_image = decode_image_data(face_data)
updates[mean_square_grad] = new_mean_squared_grad updates[param] = param + delta_x_t
'ENABLE_FEEDBACK_SUBMISSION': False,
clf = GaussianNB()
self.settings_page.a11y_audit.config.set_rules({ "ignore": [
with closing(uploaded_file):
_, X = self._count_vocab(raw_documents, fixed_vocab=True) if self.binary: X.data.fill(1) return X
return self.best_estimator_.transform(X)
url( r'^(?P<certificate_uuid>[0-9a-f]{32})$', views.render_cert_by_uuid, name='render_cert_by_uuid' ),
return self.q(css='div.instructor-dashboard-wrapper-2').present
self.assertNotIn('<span class="important-dates-item-text">$10</span>', resp.content)
return self.q(css=".courses-listing-item")
return T.sum(T.mean(T.sqr(Y-Y_hat), axis=batch_axis))
svc = SVC(kernel="linear") rfecv = RFECV(estimator=svc, step=1, cv=StratifiedKFold(2), scoring='accuracy') rfecv.fit(X, y)
return u'%b %d, %Y'
return self.modulestore.get_library(self.courselike_key, depth=None, lazy=False)
estimators = [] estimators_samples = [] estimators_features = []
RestrictedCourse.objects.get(course_key=self.course.id).delete()
GeneratedCertificate.eligible_certificates.create( user=user, course_id=course_key, status=status )
for _ in xrange(len(self.aes) + walkback): steps.append(self._update(self.activations, clamped=clamped))
lexer = shlex.shlex(options[1:-1].encode('utf8')) lexer.quotes = "'" lexer.whitespace = ", "
if self.hintmode == 'always': self.msg = self.hint + ('<br/>' if self.msg else '') + self.msg
data_dir = string_utils.preprocess('${PYLEARN2_DATA_PATH}') info['filename'] = os.path.join(data_dir, info['filename'])
raise NotImplementedError()
eps = 0.8 min_samples = 10 metric = distance.euclidean core_samples, labels = dbscan(X, metric=metric, eps=eps, min_samples=min_samples, algorithm='ball_tree')
raise NotImplementedError( str(type(self)) + " does not implement fprop.")
self.assertEqual( self.client.session.get_expire_at_browser_close(), expire_at_browser_close )
return location.name
for tab_type in CourseTabPluginManager.get_tab_types(): if not tab_type.is_dynamic and tab_type.is_default: tab_enabled = tab_type.is_enabled(course_module, user=request.user) update_tab(course_tabs, tab_type, tab_enabled)
return self.header_description.startswith(u"Showing results for")
self.cart.purchase() resp = self.client.get(instructor_dashboard) self.assertEqual(resp.status_code, 200)
assert_raises(ValueError, clf.fit, X6, y4)
X[0, 2] *= 2 assert_equal(X[0, 2], 5)
all_proba = Parallel(n_jobs=n_jobs, verbose=self.verbose, backend="threading")( delayed(parallel_helper)(e, 'predict_proba', X, check_input=False) for e in self.estimators_)
try: return _render_to_html(_get_final_tree(ex)) except ParseException: return err(ex)
negative_chains.show_negative_chains('dbm.pkl')
self.parents = []
return combined
def _get_course_name(el): return el.text return self.q(css='h3.course-title > a').map(_get_course_name).results
from __future__ import unicode_literals
if problem_url: usage_key = course_id.make_usage_key_from_deprecated_string(problem_url) usage_keys.append(usage_key)
course = CourseFactory.create(static_asset_path="foo") self.assertEquals( course_image_url(course), '/static/foo/images/course_image.jpg' )
response = self._get_page(payment_flow, course.id) self._assert_steps_displayed( response, PayAndVerifyView.PAYMENT_STEPS, PayAndVerifyView.MAKE_PAYMENT_STEP ) self._assert_requirements_displayed(response, [])
resp = self.client.post('/courses/def/generate_user_cert') self.assertEqual(resp.status_code, 404)
bandwidth = estimate_bandwidth(X, n_samples=200) assert_true(0.9 <= bandwidth <= 1.5)
self.assertFalse(CourseMode.is_professional_mode(None))
self._closed_captions_visibility(True)
self.q(css=".payment-button").click() FakePaymentPage(self.browser, self._course_id).wait_for_page()
self._assert_cert_status({ 'description': 'honor', 'status': 'started' })
obj = (klass, ('HASHED', obj.dtype, obj.shape, obj.strides))
all_checks_points = cls.objects.filter( user_id=user_id, checkpoint__course_id=course_key ) check_points = {} for check in all_checks_points: check_points[check.checkpoint.checkpoint_location] = check.status return check_points
new_deadline = (self.VERIFICATION_DEADLINE + timedelta(days=1)).replace(microsecond=0) self._set_form_verification_deadline(form, new_deadline) form.save()
self.store.create_child( self.user_id, locations['parent'], 'vertical', block_id='new_child', )
self.assertEqual(csv.replace('\r\n', '\n').strip(), self.CORRECT_REFUND_REPORT_CSV.strip())
courses = modulestore().get_courses(branch=BRANCH_NAME_DRAFT) self.assertEqual(len(courses), 3)
text_items = self.q(css='section#my-courses').text if len(text_items) > 0: return text_items[0] else: return ""
discussion_topics = { "Topic B": {"id": "Topic B"}, }
context.update(app_context)
unlock_content = cls.create_image(prefix, (32, 32), 'blue', '{}_unlock.png')
for item in structure.get_children(): prepare_item_index(item, groups_usage_info=groups_usage_info) searcher.index(cls.DOCUMENT_TYPE, items_index) cls.remove_deleted_items(searcher, structure_key, indexed_items)
mock_response = mock.Mock() mock_citc.return_value = mock_response course_id = u'course-v1:OrgFoo+CN199+CR-FALL01' tasks.update_ccxcon.delay(course_id) mock_citc.assert_called_once_with(CourseKey.from_string(course_id))
pipeline.items.append(preprocessing.ZCA())
clf = QuadraticDiscriminantAnalysis(store_covariances=True).fit(X6, y6) assert_true(hasattr(clf, 'covariances_'))
else: if self.n_outputs_ == 1: return proba[:, 0]
methods = ['standard', 'ltsa', 'hessian', 'modified'] labels = ['LLE', 'LTSA', 'Hessian LLE', 'Modified LLE']
est = DummyRegressor(strategy="quantile", quantile=0.8) est.fit(X_learn, y_learn) y_pred_learn = est.predict(X_learn) y_pred_test = est.predict(X_test)
self.assertRaises( ValidationError, BadgeClass( slug='test', issuing_component='test2', criteria='test3', description='test4', image=get_image('unbalanced') ).full_clean )
"Test for Annotation Xmodule functional logic."
self.create_programs_config(program_details_enabled=False) response = self.client.get(self.details_page) self.assertEquals(response.status_code, 404)
result = super(NORB, self).get_topological_view(mat)
return self.name_to_event_type_map[self.name]
course = self.store.get_course(self.store.make_course_key( 'test_org', 'import_draft_order', 'import_draft_order' )) self.assertIsNotNone(course)
if hasattr(self, "classes_") and self.n_outputs_ == 1: self.n_classes_ = self.n_classes_[0] self.classes_ = self.classes_[0]
return os.getcwd()
CourseFactory.create(emit_signals=True)
return [(t, t) for t in tokens]
self.wait_for_field('image') self.wait_for_ajax() return self.q(css='.message-banner p').text[0]
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit()
return self.q(css='p.card-description').map(lambda e: e.text).results
self.assertEqual(len(team_membership), 1) member = team_membership[0]['user'] self.assertEqual(member['username'], creator)
self.edited_on = edit_info.get('edited_on', None) self.edited_by = edit_info.get('edited_by', None)
if not course_org_filter: org_filter_out_set = microsite.get_all_orgs() if org_filter_out_set: exclude_dictionary['org'] = list(org_filter_out_set)
EmptyPromise( lambda: self.q(css=self.certficate_css + " .action-add").present, 'Add certificate button is displayed' ).fulfill()
self.assertEqual(response.status_code, 200)
EmptyPromise(lambda: self.q(css='.bookmark-button').visible, "Bookmark button visible").fulfill() return True
for child in xblock.get_children():
form_desc.override_field_properties( "password", default="", field_type="hidden", required=False, label="", instructions="", restrictions={} )
self._assert_course_verification_status(None)
shutil.rmtree(folder_path)
if instance.state == CourseCreator.PENDING: send_admin_notification.send( sender=sender, user=instance.user )
self.assertEqual(mail.outbox[0].subject, expected_subject)
user = serializers.PrimaryKeyRelatedField(queryset=User.objects.all()) class Meta(object): model = UserPreference depth = 1
theme_root = settings.ENV_ROOT / "themes" / settings.THEME_NAME
adder['tail_text'] = elt.tail if elt.tail else '' components.append(adder)
self._samples = samples self._sigma = sigma
alert = get_modal_alert(self.student_admin_section.browser) alert.dismiss()
return urlparse(self.runtime.handler_url(self.block, 'handler', query=query_string)).query
components = sp.csr_matrix((data, indices, indptr), shape=(n_components, n_features))
train.algorithm.termination_criterion = EpochCounter(max_epochs=1) train.extensions.pop(0) train.save_freq = 0 train.main_loop()
assert_equal(train.union(test), set(range(n_samples)))
y = np.array([3, 7, 5, 9, 8, 7, 10]) x = np.arange(len(y))
if query_interval is not None: command.QUERY_INTERVAL = query_interval
"public_fields": [ 'username', 'profile_image', 'account_privacy', ],
('refunded', 'refunded'),
random_state = np.random.RandomState(0) n_samples, n_features = X.shape X = np.c_[X, random_state.randn(n_samples, 200 * n_features)]
if re.match(pattern, path): return False
AutoAuthPage(self.browser, username=username, email=email, course_id=self.course_id, staff=staff).visit()
for item_type in item_types: if cart.has_items(item_type): return True
for student in students[:2]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.downloadable, mode='honor' )
CourseEnrollment.unenroll(user, course_id) self.assertFalse(CourseEnrollment.is_enrolled(user, course_id)) self.assertFalse(CourseEnrollment.is_enrolled_by_partial(user, course_id_partial)) self.assert_no_events_were_emitted()
STATUS_STARTED = 'started' STATUS_SUCCESS = 'success' STATUS_ERROR = 'error'
assert V is orig_V assert drop_mask is orig_drop_mask
if not hasattr(self, 'detector_normalization'): self.detector_normalization = None
super(StudioCourseTest, self).setUp() self.test_xss = test_xss self.install_course_fixture(is_staff)
self.course = CourseFactory.create(default_store=store) self.course.course_image = '' url = course_image_url(self.course) self.assertEqual('static/test.png', url)
response = self.the_input.handle_ajax("obviously_not_real", {}) self.assertEqual(response, {})
self.settings_detail.visit() self.settings_detail.require_entrance_exam(required=False) self.settings_detail.save_changes()
self.assertIsInstance(result_dict['task_id'], unicode) self.assertIsInstance(result_dict['time'], float) self.assertTrue(result_dict['time'] > 0.0)
choice = 0 if correct else 1 input_value = "8" if correct else "5" self._select_choice(choice) self._fill_input_text(input_value, choice)
if completed: return 'is-complete', "'{}' is marked complete" else: return 'is-not-started', "'{}' is in not-yet-started status"
self.assertDeserializeEqual(False, 'false') self.assertDeserializeEqual(True, 'true') self.assertDeserializeEqual(-2.78, '-2.78')
block_type = 'vertical' for idx in xrange(0, 8): block_id = _make_block_id(block_type, idx) self.all_verticals.append((block_type, block_id))
email_msg = EmailMultiAlternatives( course_email.subject, plaintext_msg, from_addr, [email], connection=connection ) email_msg.attach_alternative(html_msg, 'text/html')
response = self.client.get_json(LIBRARY_REST_URL) self.assertEqual(response.status_code, 200) return parse_json(response)
if user is not None and password is not None: mongo_conn.authenticate(user, password)
model = CountryAccessRule extra = 1 def has_delete_permission(self, request, obj=None): return True
notification_url = reverse_course_url('course_notifications_handler', self.course.id, kwargs={ 'action_state_id': 1, })
#'preamble': '',
self.answer_ids = [x.get('id') for x in self.inputfields] if self.max_inputfields == 1: self.answer_id = self.answer_ids[0]
container = self.go_to_nested_container_page() self.modify_display_name_and_verify(container)
for name, Tree in CLF_TREES.items(): clf = Tree(random_state=0)
self.publish_unit_and_verify_groups_in_lms( courseware_page, [u'Group A', u'Group B', u'Group ID 2 (inactive)'], publish=False )
self.assertEqual(modal.release_date, u'1/1/1970')
EmptyPromise( lambda: self.q(css=".action-upload-signature").first.present, 'Signature image upload button available' ).fulfill()
set_credit_requirements(self.course.id, requirements)
self.refresh_course()
parsed_html = lxml.html.fromstring(response.content) return parsed_html.find_class('course-status')[0].find_class('status-release-value')[0].text_content()
is_increasing = assert_no_warnings(check_increasing, x, y) assert_true(is_increasing)
config_course_cohorts(course, is_cohorted=True, discussion_topics=["General", "Feedback"])
cm = confusion_matrix(y_test, y_pred) np.set_printoptions(precision=2) print('Confusion matrix, without normalization') print(cm) plt.figure() plot_confusion_matrix(cm)
enrollment.activate() self.assertTrue(CourseEnrollment.is_enrolled(user, course_id)) self.assert_enrollment_event_was_emitted(user, course_id)
clf = mixture.GaussianMixture(n_components=2, covariance_type='full') clf.fit(X_train)
if not timestamp: return False try: parse_datetime(timestamp) except ValueError: return False else: return True
filtered_visible_ids = None
return nt_uri[SHORTNAME_SLICE]
user = UserFactory.create(is_staff=True, is_superuser=True) user.save() self.client.login(username=user.username, password='test')
return _click_edit(self, '.visibility-button', '.xblock-visibility_view', self._bounded_selector)
ACCOUNT_VISIBILITY_CONFIGURATION = { "default_visibility": "all_users",
return set([p.id for p in course.user_partitions])
self.course.user_partitions.append(self.random_user_partition) self.assertIsNone(get_cohorted_user_partition(self.course))
orphan = course_key.make_usage_key('chapter', 'OrphanChapter') self.store.create_item(self.user_id, orphan.course_key, orphan.block_type, block_id=orphan.block_id)
self._examples_seen += num_examples self._num_batches_seen += 1
#man_show_urls = False
self.dashboard_page.visit()
pattern = klass(re) pattern.md = md pattern.ext = self md.inlinePatterns.add(name, pattern, "<reference")
module = CapaFactory.create(attempts=attempts - 2, max_attempts=attempts) self.assertEqual(module.check_button_name(), "Check")
self.assertRedirects(response, reverse('dashboard'))
frgd_arr = to_array(frgd_img) mask_arr = frgd_arr > 0.1
active_reg_button = not(registered or is_course_full or not can_enroll)
scalar_label = int(scalar_label) assert scalar_label >= 0 assert scalar_label < 9 return 30 + 5 * scalar_label
return self.q(css='{} .request-response-error'.format(self.EE_CONTAINER)).first
success = convnet_compile() if success: convnet_available.compiled = True else: convnet_available.compile_error = False _logger.debug('compilation success: %s', success)
dynamath = [student_answers.get(k + '_dynamath', None) for k in idset]
sample_weight = np.empty(X.shape[0], dtype=np.float64) sample_weight[:] = 1. / X.shape[0]
if not isinstance(course_key, CCXLocator): send_ccx_course_published.delay(unicode(course_key))
response = self.client.post(self.url, {})
return self.q(css='.wrapper-xblock.level-page .studio-xblock-wrapper').filter( lambda el: el.get_attribute('data-locator') == xblock_id )
pass
'dark_lang',
self.assertEqual(unicode(course.location.course_key), unicode(course.children[0].course_key))
def test_get_missing_template(self): with self.assertRaises(CourseEmailTemplate.DoesNotExist): CourseEmailTemplate.get_template()
self.sigma_[:, :] -= epsilon
ROLE = "support" def __init__(self, *args, **kwargs): super(SupportStaffRole, self).__init__(self.ROLE, *args, **kwargs)
return self.backend.events[idx]
self.assertEquals(course.tabs[2], {'type': 'discussion', 'name': 'Discussion'})
self.assertIn("ufeff", filedata) self.ufeff_srt_file.write(filedata) self.ufeff_srt_file.seek(0)
self.show_question_answer('p1')
u'{user}@example.com'.format( user=(u'e' * (EMAIL_MAX_LENGTH - 11)) )
course_mode = CourseMode( course_id=course.id, mode_slug=CourseMode.DEFAULT_MODE_SLUG, mode_display_name=CourseMode.DEFAULT_MODE_SLUG, min_price=10, ) course_mode.save()
assert_raises(ValueError, cval.StratifiedShuffleSplit, y, train_size=2) assert_raises(ValueError, cval.StratifiedShuffleSplit, y, test_size=2)
cookies[settings.SESSION_COOKIE_NAME] = unicode(safe_cookie_data)
super(SymbolicResponse, self).setup_response()
xblock = modulestore().get_item(location) xblock.start = start self.store.update_item(xblock, self.user.id)
grid_search.scoring = 'sklearn' assert_raises(ValueError, grid_search.fit, X, y)
if obj: return self.readonly_fields + ('status', 'checkpoint', 'user', 'response', 'error') return self.readonly_fields
self.assertNotIn('url_name', course_xml.attrib)
return event['event_type'] == self.USER_SETTINGS_CHANGED_EVENT_NAME
credit_api.update_credit_request_status(uuid, self.PROVIDER_ID, status)
student_count_percent = 0 if total_student_count.get(child.location, 0) > 0: student_count_percent = count_grade * 100 / total_student_count[child.location]
self.save_and_verify_discussion_topics(key=self.inline_key)
url = reverse('team_membership_detail', args=[team_id, username]) + '?admin=true' return self.make_call(url, expected_status, 'delete', **kwargs)
log.warning("Asset's course {} does not match other assets for course {} - not saved.".format( asset_md.asset_id.course_key, course_key )) continue
raise NotImplementedError
self._export_import_course_round_trip( self.store, contentstore, source_course_key, self.export_dir )
store = self._get_modulestore_for_courselike(asset_key.course_key) return store.delete_asset_metadata(asset_key, user_id)
with self.assertRaises(UserOrgTag.DoesNotExist): UserOrgTag.objects.get(user=self.user, org=self.course.id.org, key="email-optin")
course_locator = self._map_revision_to_branch(course_locator, revision=revision) return super(DraftVersioningModuleStore, self).get_items(course_locator, **kwargs)
return remote_id
return self.q(css='section.banner-user')
with mock.patch('requests.post') as mock_post: self.call_create_zendesk_ticket() self.assertFalse(mock_post.called)
for mode in (CourseMode.DEFAULT_MODE_SLUG, 'verified'): CourseModeFactory.create(mode_slug=mode, course_id=self.course.id)
ip_blacklist_url = reverse( 'embargo_blocked_message', kwargs={ 'access_point': 'courseware', 'message_key': 'embargo' } ) return redirect(ip_blacklist_url)
from __future__ import unicode_literals
estimator = RandomForestRegressor(random_state=0, n_estimators=100) score = cross_val_score(estimator, X_full, y_full).mean() print("Score with the complete dataset = %.2f" % score)
if self._aborting: return
def __init__(self, estimator): raise RuntimeError("sklearn not available.")
return '{}[data-id="{}"] {}'.format( self.BODY_SELECTOR, self.locator, selector )
self.assertEqual(set(subtree_roots_urls), set(expected_roots_urls))
return self.runtime.service(self, "request_cache")
X, y = datasets.make_hastie_10_2(n_samples=100, random_state=1)
activations = [X] activations.extend(np.empty((batch_size, n_fan_out)) for n_fan_out in layer_units[1:]) deltas = [np.empty_like(a_layer) for a_layer in activations]
self.q(css=self.PREVIOUS_PAGE_BUTTON_CSS).click() self.wait_for_ajax()
self.assert_account_settings_context_looks_correct(account_settings_context(request), user, linked=False) self.assert_social_auth_does_not_exist_for_user(user, strategy)
self.n_classes = 1
self.freeze_set = self.freeze_set.union(parameter_set)
CommitOnSuccessManager.ENABLED = True OuterAtomic.ALLOW_NESTED = False OuterAtomic.atomic_for_testcase_calls -= 1 return wrapped_func(*args, **kwargs)
'submissions', 'openassessment', 'openassessment.assessment', 'openassessment.fileupload', 'openassessment.workflow', 'openassessment.xblock',
y = np.dot(X, w)
scov = np.cov(X, rowvar=0., bias=1.)
response = self.client.get(self.programs_path) self.assertRedirects( response, '{login_url}?next={programs}'.format( login_url=settings.LOGIN_URL, programs=self.programs_path ) )
module_class = RandomizeModule resources_dir = None
warnings.warn("non-uniform sample weights unsupported for svd, " "forcing usage of eigen") gcv_mode = 'eigen'
n_neighbors = 10 n_samples = 1000
return expected_prefix + '-' + team['discussion_topic_id']
username = user.username if user else ""
past_due_date = CapaFactory.create(showanswer='finished', max_attempts="1", attempts="0", due=self.yesterday_str) self.assertTrue(past_due_date.answer_available())
return cls.populate(modulestore().get_course(course_key))
braces = '}' * num_braces + "\n" rval = (basic_setup + setup_nv_images + setup_nv_targets + setup_nv_denoms + do_normalize + braces) rval = rval % locals() return rval
'packages': ('openassessment',),
mock_val_api.ValVideoNotFoundError = _MockValVideoNotFoundError mock_val_api.export_to_xml = Mock(side_effect=mock_val_api.ValVideoNotFoundError) self.descriptor.edx_video_id = 'test_edx_video_id'
classifier.set_params(class_weight='balanced') coef_balanced = classifier.fit(X, y).coef_.copy()
if not CourseEnrollment.is_enrolled(user, self.course_id): raise NotEnrolledInCourseForTeam if CourseTeamMembership.user_in_team_for_course(user, self.course_id): raise AlreadyOnTeamInCourse return CourseTeamMembership.objects.create( user=user, team=self )
world.xqueue.config['default'] = response_dict
mode, is_active = CourseEnrollment.enrollment_mode_for_user(self.user, self.course.id) self.assertEqual(mode, CourseMode.DEFAULT_MODE_SLUG) self.assertEqual(is_active, True)
sparse_matrix_params = { "n_components": opts.n_components, "random_state": opts.random_seed, "density": opts.density, "eps": opts.eps, }
time_fit = collections.defaultdict(list) time_transform = collections.defaultdict(list)
type = ''
assert_almost_equal(dists[1], 1 - np.cos(np.pi / 4))
'SQUELCH_PII_IN_LOGS': False,
PROCESSOR_MODULE = __import__( 'shoppingcart.processors.' + settings.CC_PROCESSOR_NAME, fromlist=[ 'render_purchase_form_html', 'process_postpay_callback', 'get_purchase_endpoint', 'get_signed_purchase_params', ] )
store.save_asset_metadata_list(md_list, ModuleStoreEnum.UserID.test)
raise ValueError( 'ignore_lst must be a list of parameters to ignore ' '%s (type %s) was given' % (ignore_lst, type(ignore_lst)))
ccx_ids_to_delete.append(get_override_for_ccx(ccx, block, 'due_id')) clear_ccx_field_info_from_ccx_map(ccx, block, 'due')
for extension in self.cv_extensions: extension.on_save(self.trainers)
invalidate_generated_certificates(course_id, students_to_generate_certs_for, statuses_to_regenerate)
return self.page.paginator.count
'rule': None
target_users = [user for user in self.users if user.email == email] assert len(target_users) == 1 return target_users[0]
link = world.retry_on_exception( lambda: _find_matching_button(category, component_type), ignored_exceptions=AssertionError )
data_home = get_data_home(data_home=DATA_HOME) assert_equal(data_home, DATA_HOME) assert_true(os.path.exists(data_home))
grid_search_no_score = GridSearchCV(clf_no_score, {'C': Cs}) assert_raise_message(TypeError, "no scoring", grid_search_no_score.fit, [[1]])
self.course_nav.go_to_vertical('Test Vertical-0')
course = CourseFactory.create(course_image='', default_store=default_store) self.assertEquals( 'static/test.png', course_image_url(course), )
youtube_id = videos.get('youtube', None) if youtube_id: transcripts_presence['is_youtube_mode'] = True
self._assert_requirements_displayed(response, [ PayAndVerifyView.PHOTO_ID_REQ, PayAndVerifyView.WEBCAM_REQ, ])
print("Compute structured hierarchical clustering...") st = time.time()
hasher = RandomTreesEmbedding(n_estimators=10, sparse_output=False) X, y = datasets.make_circles(factor=0.5) X_transformed = hasher.fit_transform(X)
self.submit_question_answer('H1P1', {'2_1': 'Correct', '2_2': 'Correct'}) self.check_grade_percent(0.25)
mean = layer.mf_update( state_below=T.alloc(0., 1, 1), state_above=None, layer_above=None)
assert_array_equal(unique_labels(np.array([[0, 0, 1], [1, 0, 1], [0, 0, 0]])), np.arange(3))
selected_sort = self.sort_page.get_selected_sort_preference() self.assertEqual(selected_sort, "activity")
self.assertIn(str(verified_course_audit_track), response.content) for course in ( non_verified_course, verified_course_verified_track, verified_course_deadline_passed, unenrolled_course ): self.assertNotIn(str(course), response.content)
self._submit_photos( face_image=self.IMAGE_DATA + "9999", photo_id_image=self.IMAGE_DATA + "1111", ) two_photo_reverification_data = self._get_post_data()
self.pdf.drawString( horizontal_padding_from_border, y_pos, _(u'Date: {date}').format(date=self.date) )
try: return self.matches[state] except IndexError: return None
world.wait_for_ajax_complete()
all_assets, __ = contentstore('trashcan').get_all_content_for_course(self.course.id) self.assertGreater(len(all_assets), 0)
else: terms_text = _(u"Terms of Service and Honor Code")
if self.contentstore: self.contentstore.delete_all_course_assets(course_key) super(ModuleStoreWriteBase, self).delete_course(course_key, user_id)
y_pred = KMeans(n_clusters=2, random_state=random_state).fit_predict(X)
self.dbs[db].remove()
return word.strip().lower()
created_courses = [] for course_number in course_numbers: created_courses.append(CourseFactory.create(number=course_number))
([], []),
self._verify_xblock_info_state(xblock_info, 'staff_only_message', expected_state, path)
self.check_toggle_tab_visiblity('wiki', True) self.check_toggle_tab_visiblity('wiki', False)
raise ValueError("No point was within bandwidth=%f of any seed." " Try a different seeding strategy \ or increase the bandwidth." % bandwidth)
if data and data not in self.COUNTRY_CODES: raise serializers.ValidationError( u"{code} is not a valid country code".format(code=data) ) return data
TOKEN_RESPONSE_DATA = None
clf = GradientBoostingClassifier(loss=loss, n_estimators=10, random_state=1, presort=presort)
with self.settings(OPENID_SSO_SERVER_URL=abs_provider_url):
usage_key = self.course.id.make_usage_key('vertical', None)
code_redemption = RegistrationCodeRedemption(registration_code=course_reg_code, redeemed_by=user) code_redemption.save() return code_redemption
self.setup_groups_partitions() self.user_partition = self.user_partitions[0]
return self.q(css='.problem-header').text[0]
return self.context["group_ids_to_names"].get(obj["group_id"])
self._assert_output(output)
pv = get_weights_report.get_weights_report(model_path=model_path, rescale=rescale, border=border) if out is None: pv.show() else: pv.save(out)
precompute = False
dataset = datasets.load_iris()
assert_almost_equal(mcc, 0.)
for key, matrix in matrices.items(): del result[key]
refetched = self.store.get_item(discussion_item.location)
optima = [self._constrained_optimization(obj_func, self.kernel_.theta, self.kernel_.bounds)]
import logging
self.store.publish(vertical.location, self.user_id) self.assertFalse(self._has_changes(vertical.location))
return iter(getattr(d, _iterkeys)(**kw))
assert_true(modulestore.has_course(locator, ignore_case))
super(AboutWithCappedEnrollmentsTestCase, self).setUp()
items_index = []
return reverse_course_url( 'group_configurations_detail_handler', self.course.id, kwargs={'group_configuration_id': cid}, )
try: from mpl_toolkits.basemap import Basemap basemap = True except ImportError: basemap = False
if len(violation_list_for_line) == 4: num_violations_report += 1
PLATFORM_NAME = "Your Platform Name Here" CC_MERCHANT_NAME = PLATFORM_NAME COPYRIGHT_YEAR = "2015"
ax.plot_surface(X, Y, Z.T, cstride=1, rstride=1, color=c, alpha=0.8)
print "======== Roundtrip diff: ========="
rerun_state = CourseRerunState.objects.update_state( course_key=self.course.id, new_state=state, allow_not_found=True ) CourseRerunState.objects.update_should_display( entry_id=rerun_state.id, user=UserFactory(), should_display=should_display )
z = np.zeros((X.shape[0], self.n_components))
if not record.exc_text: record.exc_text = self.formatException(record.exc_info)
self.assertTrue(microsite.BACKEND.has_configuration_set()) Microsite.objects.all().delete() self.assertFalse(microsite.BACKEND.has_configuration_set())
with open(report_file) as f: violations_list = f.readlines() num_lines = len(violations_list) return num_lines, violations_list
self._assert_course_verification_status(VERIFY_STATUS_APPROVED)
resp = self.client.ajax_post( self.url, data={'tabs': [{'tab_id': tab_id} for tab_id in invalid_tab_ids]}, ) self.check_invalid_tab_id_response(resp)
with self.assertRaises(ResponseError): problem.grade_answers({'1_2_1': '42'})
index = self.get_course_index(course_key)
self.assertTrue('Activate Course Enrollment' in response.content)
return self.provider.provider_id + '_unlink_form'
clf = NearestCentroid() clf.fit(X_csr, y) assert_array_equal(clf.predict(T_csr), true_result)
chapter_index = self._chapter_index(chapter) if chapter_index is None: return None
X = np.ascontiguousarray(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
sample_silhouette_values = silhouette_samples(X, cluster_labels)
result = list_files('.py') for path in result: logger.info(path)
COURSE_EMAIL_MESSAGE_BODY_TAG = '{{message_body}}'
corr_rank = np.bincount(rank, minlength=n_ranks + 1).cumsum() rank = corr_rank[rank]
self.assertFalse(zendesk_mock_class.mock_calls) self.assertFalse(datadog_mock.mock_calls)
return self._validation_paragraph('error').present
mean_square_grad = sharedX(param.get_value() * 0.)
warnings.warn("Do you really want to regularize the detector units to be more active than the pooling units?")
self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + H2 -> 2H2O2'))
export_fs.makeopendir('policies')
used_all_attempts = CapaFactory.create(showanswer='finished', max_attempts="1", attempts="1", due=self.tomorrow_str) self.assertTrue(used_all_attempts.answer_available())
self.assertIn(orphan_chapter.location, self.store.get_orphans(course.id))
monitoring_dataset = DenseDesignMatrix(X=X)
self.t_ = None
check_lti_popup(parent_window)
'STUDIO_REQUEST_EMAIL': '',
MIN_IDEAL_BATCH_DURATION = .2
self._submit_photos( face_image=self.IMAGE_DATA, photo_id_image=self.IMAGE_DATA )
y = np.reshape(y, (-1, 1))
self.assertEqual(context['currency'], 'PKR') self.assertEqual(context['currency_symbol'], 'Rs')
status = 'failed' reason = { 'current_date': now, 'deadline': deadline }
request = Request(self.request_factory.get('/')) request.user = requesting_user with check_mongo_calls(0): return list_courses(request, specified_user.username, org=org, filter_=filter_)
throughputs = benchmark_throughputs(configuration) plot_benchmark_throughput(throughputs, configuration)
response = self.session.post( STUDIO_BASE_URL + '/xblock/', data=json.dumps(create_payload), headers=self.headers, )
return self.best_estimator_.predict_proba(X)
manager = LibraryImportManager(*args, **kwargs) return list(manager.run_imports())
html_theme_path = ['themes']
if self.request.COOKIES.get(settings.SESSION_COOKIE_NAME): self.client.response.cookies[settings.SESSION_COOKIE_NAME] = self.request.COOKIES[ settings.SESSION_COOKIE_NAME ]
if published.visible_to_staff_only: return False
self._remove_subtree(BlockKey.from_usage_key(location), new_structure['blocks'])
self.assertEqual(len(actual), 2) self.assertEqual(actual, expected)
adder = { 'type': 'text', 'contents': choice_text, 'tail_text': '', 'value': '' } components.append(adder)
sys.exit(0)
X_scaled_back = scaler.inverse_transform(X_scaled) assert_array_almost_equal(X_scaled_back, X)
wait_for_present(css_selector=css, timeout=wait_time) return world.browser.find_by_css(css)
self.assertIn("logo_image", json_data)
if branch == ModuleStoreEnum.BranchName.published: revision = ModuleStoreEnum.RevisionOption.published_only store.delete_item(itemloc, user_id, revision=revision)
mock_count.return_value = None with self.assertRaises(BuildFailure): pavelib.quality.run_jshint("")
angle = np.arctan2(w[0][1], w[0][0])
top_level_export_dir = 'exported_source_course' export_course_to_xml( modulestore, contentstore, source_course_key, export_dir, top_level_export_dir, ) import_course_from_xml( modulestore, 'test_user', export_dir, source_dirs=[top_level_export_dir], static_content_store=contentstore, target_id=source_course_key, create_if_not_present=True, raise_on_failure=True, )
while True: if mode == "B": if X_pinv is None: X_pinv = linalg.pinv2(X, **pinv2_args) x_weights = np.dot(X_pinv, y_score)
UserFactory.create(username=self.USERNAME, email=self.EMAIL, password=self.PASSWORD)
del context_mock.context self.assertIn("this module is temporarily unavailable", render_to_string("courseware/error-message.html", None))
ccx = CcxFactory(course_id=self.course.id, coach=self.coach) ccx_locator = CCXLocator.from_course_locator(self.course.id, unicode(ccx.id))
target_names = np.array(['a', 'b', 'c']) y = target_names[y_idx]
self.assertLessEqual( datetime.datetime.now(UTC()), child.start )
return get_course_cohort_settings(course_key).is_cohorted
user_profile = UserProfile.objects.get(user=user) self.assertEqual(user_profile.name, "Robot Name")
self.settings_detail.course_pacing = 'Self-Paced' self.settings_detail.save_changes() self.settings_detail.refresh_page() self.assertEqual(self.settings_detail.course_pacing, 'Self-Paced')
data['course_price'] = 100 response = self.client.post(set_course_price_url, data) self.assertTrue("CourseMode price updated successfully" in response.content)
X_pred_transformed = kpca.transform(X_pred) assert_equal(X_pred_transformed.shape[1], X_fit_transformed.shape[1])
encoder=CourseSettingsEncoder
homework_1_score = 1.0 / 2 homework_2_score = 1.0 / 1 self.check_grade_percent(round((homework_1_score + homework_2_score) / 2, 2))
activations = self._forward_pass(activations)
self.client.ajax_post( self.seq1_url, data={'isPrereq': True} ) mock_add_prereq.assert_called_with(self.course.id, self.seq1.location)
pass
if usage_key.block_type != "problem": return False descriptor = self.store.get_item(usage_key, depth=0) assert isinstance(descriptor, CapaDescriptor) return capa_type in descriptor.problem_types
self._count(X, Y)
if self.learning_rate <= 0: raise ValueError("learning_rate must be greater than zero")
self.tracker = DjangoTracker() tracker.register_tracker(self.tracker)
record_purchase(params, result['order']) return {'success': True, 'order': result['order'], 'error_html': ''}
raise ValueError( 'Second argument should be a filename, %s (type %s) was given' % (filename, type(filename)) )
print("", file=out) print("{} violations total".format(self.total_violations), file=out)
patcher = patch('pavelib.quality.sh') self._mock_paver_sh = patcher.start()
self.assertEqual(correct_map.get_correctness('1_2_1'), 'correct')
xblock.children = children
state = dict(state.items() + matrices.items()) del matrices
x_squared_norms_from_csr = row_norms(X_csr, squared=True) labels_csr, inertia_csr = _labels_inertia( X_csr, x_squared_norms_from_csr, noisy_centers) assert_array_almost_equal(inertia_csr, inertia_gold) assert_array_equal(labels_csr, labels_gold)
self.get_data_specs(model)[0].validate(data)
atexit.register(self.release_readlock, lockdirName=lockdirName)
F, _ = f_regression(X, y)
CourseEnrollment.enroll(user, course_id) self.assertTrue(CourseEnrollment.is_enrolled(user, course_id)) self.assert_enrollment_event_was_emitted(user, course_id)
self.assertEqual(is_active, new_is_active) self.assertEqual(course_mode, new_mode)
self.create_credentials_config(enable_learner_issuance=False) actual = get_user_program_credentials(self.user) self.assertEqual(actual, [])
top_idx = set(component.argsort()[-3:][::-1]) assert_true(tuple(sorted(top_idx)) in correct_idx_grps)
check_ortho(T, "x scores are not orthogonal") check_ortho(U, "y scores are not orthogonal")
self.full_path = full_path self.directory = os.path.dirname(full_path) self.is_file = os.path.isfile(full_path) self.violations = []
pass
link_cohort_to_partition_group( test_cohort, self.user_partition.id, self.groups[0].id, ) self.assert_student_in_group(self.groups[0])
pass
rval = shared(obj.get_value()) obj.__getstate__ = None
ModeCreationPage(self.browser, self.course_id, mode_slug=u'verified', mode_display_name=u'Verified Certificate', min_price=10, suggested_prices='10,20').visit()
sum_sqr_XX = conv2d(T.sqr(X), filters=filters, border_mode='full')
from __future__ import unicode_literals
msg = re.sub('(?ms)<html>(.*)</html>', '\\1', msg)
return model.log_prob(X) - self.noise.log_prob(X)
for layer in layer_to_state: old = layer_to_state[layer] new = updated[layer] if layer_to_clamp[layer]: assert new is old else: add_updates(old, new)
u_flipped_with_transpose, _, v_flipped_with_transpose = randomized_svd( mat, 3, flip_sign=True, transpose=True) u_based, v_based = max_loading_is_positive( u_flipped_with_transpose, v_flipped_with_transpose) assert_true(u_based) assert_false(v_based)
repr = [inputs]
return self._cds.local_modules[usage_id].scope_ids.def_id
self.login_student() self.assertEqual(self.get_progress_detail(), u'2/2')
df[k] = np.sum(mask)
return set(MicrositeOrganizationMapping.objects.all().values_list('organization', flat=True))
child_vertical = ItemFactory.create(parent_location=vertical.location, category='vertical', display_name='Child Vertical') self.assertEqual(xblock_type_display_name(child_vertical), u'Vertical')
if settings == DEFAULT_SETTINGS: args.append('--skip-collect') call_task('pavelib.assets.update_assets', args=args)
return models.Client.objects.create( name=name, user=user, client_id=client_id, redirect_uri=redirect_uri, client_type=constants.PUBLIC, )
self.go_to_sequential_position(2) execute_video_steps(tab2_video_names)
course_org_filter = microsite.get_value('course_org_filter')
RM_SUBDIRS_RETRY_TIME = 0.1
try: post_dict = urlparse.parse_qs(contents, keep_blank_values=True) return { key: list_val[0] for key, list_val in post_dict.items() }
return cls.default() | { cls.PAYLOAD_EXTRA_FIELDS }
assert_almost_equal(dists[0], 0, decimal=5)
self._each_parens('(x+y)', 'x+y', '(')
return self.q(css='.create-team.wrapper-msg .copy')[0].text
p, h = max_pool_c01b(z, (pool_rows, pool_cols) ) func = function([z], [p, h], mode = mode_without_gpu)
try: original_published = super(DraftModuleStore, self).get_item(item_location) except ItemNotFoundError: original_published = None
for enrollment in manual_enrollments: self.assertEqual(enrollment.enrollment.mode, CourseMode.HONOR)
response = self.client.get(manage_users_url) self.assertEqual(response.status_code, 200) self.assertIn(extra_user.username, response.content)
spec_mapping = tuple( self._fill_mapping(sub_space, sub_source) for sub_space, sub_source in safe_zip( space.components, source))
return self.k1.is_stationary() and self.k2.is_stationary()
return settings.FEATURES.get('ENABLE_OPENBADGES', False)
re.compile(r'^Course Outline \|'): [ "js/base", "js/models/course", "js/models/location", "js/models/section"],
yaml_src_path = os.path.join(os.path.dirname(__file__), 'test_vae_cost_vae_criterion.yaml') train_object = yaml_parse.load_path(yaml_src_path) train_object.main_loop()
dense_classifier = dense_results = AdaBoostRegressor( base_estimator=CustomSVR(), random_state=1 ).fit(X_train, y_train)
self.assertTrue(exam_attempts_section.is_search_text_field_visible)
mock_get.return_value = Mock(status_code=200, text=response_success, content=response_success) transcript_name = transcripts_utils.youtube_video_transcript_name(youtube_text_api) self.assertEqual(transcript_name, 'Custom')
assert_equal(distances.shape, (n_queries,)) assert_equal(distances.dtype, object) assert_equal(neighbors.shape, (n_queries,)) assert_equal(neighbors.dtype, object)
self.courseware.go_to_sequential_position(1) execute_video_steps(tab1_video_names)
self.make_course() url = self.make_url('pdf_book', book_index=0, chapter=1) response = self.client.get(url) self.assertEqual(response.status_code, 404)
def refresh_thread_page(self, thread_id): self.browser.refresh() self.thread_page.wait_for_page()
f = open(json_file_path) lines = f.readlines() f.close() content = ''.join(lines) return yaml.load(content)
try: course_key = CourseKey.from_string(key) except InvalidKeyError: course_key = key return isinstance(course_key, CourseKey)
page = DashboardPage(self.browser) page.wait_for_page() self.assertIn( 'The course you are looking for is closed for enrollment', page.banner_text )
self.form_data.setlist('requested_fields', ['field1', 'field2'])
event_name = '.'.join(['edx', 'certificate', 'configuration', event_name]) tracker.emit(event_name, event_data)
if hasattr(X, 'T'): assert_raises(ValueError, transformer.transform, X.T)
self.assertIsInstance( descriptor._field_data._authored_data._source, OverrideFieldData )
index = 0 params = kernel.get_params() for hyperparameter in kernel.hyperparameters: if hyperparameter.bounds is "fixed": continue size = hyperparameter.n_elements
if other_names is None: other_names = []
return xblock._edited_on
mouse_hover_action = ActionChains(self.browser).move_to_element(element) mouse_hover_action.perform()
assert_array_equal(clf.predict([[0.2, -1.0]]), np.array([-1]))
new_patch = patch(function_name, new=mock) new_patch.start() self.addCleanup(new_patch.stop) return mock
response = self.api_response()
self.assertIsNone( GeneratedCertificate.certificate_for_student(students[4], self.course.id) )
alt_text = self.BANNER_ALT_MESSAGES.get(status) if alt_text: self.assertContains(response, alt_text)
node = mock.Mock(due=1, extended_due=2) self.assertEqual(self.call_fut(node), 2)
return self.q(css=".field-time-limit").visible
course_data_path = path(self.data_dir) / source_courselike.data_dir
self.assertNotContains(response, "How it Works") self.assertNotContains(response, "Find courses") self.assertNotContains(response, "Schools & Partners")
HTTPServer.shutdown(self)
self.assertEqual(self.client.session.get('attempting_upgrade'), is_upgrade)
block_type = 'html' for idx in xrange(0, 16): block_id = _make_block_id(block_type, idx) self.all_units.append((block_type, block_id))
module_system = get_test_system()
return self.q(css='.bit-publishing .wrapper-visibility').first.text[0]
microsite_orgs = microsite.get_all_orgs() return [course for course in courses if course.location.org not in microsite_orgs]
if bulk_write_record.active and course_key.branch in bulk_write_record.dirty_branches: return bulk_write_record.structure_for_branch(course_key.branch)
raise NotImplementedError()
bad_exceptions[math] = None
return Response(get_thread(request, thread_id))
self.steps = tosequence(steps) transforms = estimators[:-1] estimator = estimators[-1]
mako_middleware_process_request(request)
disabled = ()
clf = NearestCentroid() clf.fit(X, y) assert_array_equal(clf.predict(T_csr), true_result)
scaler = StandardScaler(with_mean=True).fit(X) assert_raises(ValueError, scaler.transform, X_csr) assert_raises(ValueError, scaler.transform, X_csc)
for param in self.params: value = param.get_value(borrow=True) if not isfinite(value): raise RuntimeError("NaN in " + param.name)
y = train['y'][:, 0] - 1 assert y.shape == (5000,)
continue_learning = (self.model.continue_learning() and extension_continue) assert continue_learning in [True, False, 0, 1] while continue_learning: if self.exceeded_time_budget(t0, time_budget): break
random_state = check_random_state(0) p = random_state.rand(n_samples) * (2 * np.pi - 0.55) t = random_state.rand(n_samples) * np.pi
assert_equal(train.intersection(test), set())
stack = [node] locations = [] while stack: curr = stack.pop() locations.append(curr.location) if curr.has_children: stack.extend(curr.get_children()) return locations
self.q(css='.page-content-secondary .members-info .team-member').first.click()
my_estimator = MyEstimator() str(my_estimator)
css = '.group-allocation' return self.find_css(css).first.text[0]
staff_user = UserFactory(username='test_staff_user', email='test_staff_user@openedx.org', password='test') CourseStaffRole(self.master_course_key).add_users(staff_user)
problem_descriptor = modulestore().get_item(usage_key) problems[unicode(usage_key)] = problem_descriptor
if self._course_id is not None: url += "?{params}".format( params=urlencode({ "course_id": self._course_id, "enrollment_action": "enroll" }) )
def is_browser_on_page(self): wait_for_ajax_or_reload(self.browser) return self.q(css='body.view-settings').visible
self.assertTrue(num_orig_tabs >= 5)
items = store.get_items(course_key)
pygments_style = 'sphinx'
for axes in all_axes: axes.get_xaxis().set_visible(False) axes.get_yaxis().set_visible(False)
with self.assertRaises(IOError): CourseOverview.load_from_module_store(self.store.make_course_key('Non', 'Existent', 'Course'))
responsibilities = np.zeros((X.shape[0], self.n_components))
self.register_flag_response("comment", comment_id)
anonymous_client = APIClient() request_method = getattr(anonymous_client, method) response = request_method(self.url) self.check_response(response, 401) self.assert_no_events_were_emitted()
GeneratedCertificateFactory( user=self.bob, course_id=self.alternate_course_id, mode=MODES.verified, status=failing_status, )
super(TestProctoredExams, self).setUp() self.course = CourseFactory.create( org='edX', course='900', run='test_run', enable_proctored_exams=True )
resp = self.client.get(course_wiki_page, follow=True) target_url, __ = resp.redirect_chain[-1] self.assertTrue(reverse('signin_user') in target_url)
if file_name == os.path.basename(__file__): return results
return ItemFactory.create( parent_location=parent.location, category="video", display_name="Group {} Sees This Video".format(group), )
self.notes_page.go_to_page(2) self._verify_pagination_info( notes_count_on_current_page=1, header_text='Showing 26-26 out of 26 total', previous_button_enabled=True, next_button_enabled=False, current_page_number=2, total_pages=2 )
request = Request(self.request_factory.get('/')) request.user = requesting_user with check_mongo_calls(0): return course_detail(request, target_user.username, course_key)
proba[np.isnan(proba)] = 1. / n_classes
self.assertTrue('Activate Course Enrollment' in resp.content)
clf = GradientBoostingClassifier(n_estimators=10, random_state=1) clf.fit(X, y)
self.assertEqual(res_json['message'], u'Please select certificate statuses from the list only.')
X_centered = X - X.mean(axis=0) lw = LedoitWolf(assume_centered=True) lw.fit(X_centered) shrinkage_ = lw.shrinkage_
all_lists = np.all([not hasattr(v, "rvs") for v in self.param_distributions.values()]) rnd = check_random_state(self.random_state)
_export_field_content(item, item_dir)
RequestCache.clear_request_cache()
response = requests.post(self.url) self.assertEqual(response.status_code, 400)
return self.q(css="a#add-allowance").present
if self.post_dict.get('roles'): role = '<h5>Role: {}</h5>'.format(self.post_dict['roles']) else: role = ''
latex_documents = [('index', 'user_guide.tex', u('scikit-learn user guide'), u('scikit-learn developers'), 'manual'), ]
n_samples = 12 n_features = 2 n_estimators = 5 rng = np.random.RandomState(42) X = rng.rand(n_samples, n_features)
super(ForumTestCase, self).setUp() self.course = CourseFactory.create(org='testX', number='727', display_name='Forum Course')
cls.clear_caches()
ret = regenerate_user_certificates( student, course_id, course=course, forced_grade=options['grade_value'], template_file=options['template_file'], insecure=options['insecure'] )
return mock_url_prefix + handler_name
return self.child(title)
xblock._published_by = published_block.edit_info.edited_by xblock._published_on = published_block.edit_info.edited_on
self.assertFalse(self._has_changes(published_xblock.location))
X, y = make_blobs() branching_factor = 9
super(TestEventPublishing, self).setUp() self.mock_user = UserFactory() self.mock_user.id = 1 self.request_factory = RequestFactory()
from request_cache.middleware import RequestCache
for name in datasets: datasets[name] = datasets[name].T
self.cart = Order.get_cart_for_user(self.user) CertificateItem.add_to_order(self.cart, self.verified_course_key, self.cost, 'verified') self.cart.start_purchase()
if 'display_name' in param_dict: param_dict['course_name'] = param_dict['display_name']
compute_full_tree = self.n_clusters < max(100, .02 * n_samples)
with self.assertRaisesRegexp(UserPartitionError, "Cannot assign user to an empty user partition"): RandomUserPartitionScheme.get_group_for_user(self.MOCK_COURSE_ID, self.user, empty_partition)
return self.storage_space.np_format_as(batch, space)
return course_metadata_utils.display_name_with_default(self)
self._test_visible_to_students(True, 'public_released', self.past, publish=True)
clf = GradientBoostingClassifier(n_estimators=10, random_state=1) clf.fit(X, y)
CELERY_RESULT_BACKEND = 'djcelery.backends.cache:CacheBackend'
user = request.user
max_row = np.sqrt(n_plots) max_row = np.round(max_row) max_row = int(max_row)
DEPRECATED_ADVANCED_COMPONENT_TYPES = []
raise NotImplementedError()
while r < 100: r = r * 10 while r >= 1000: r = r / 10
return '{}.{}'.format(self.backend_class.__module__, self.backend_class.__name__)
resp = self.client.get(self.url) return json.loads(resp.content)
if requested_child == 'first': return children[0] elif requested_child == 'last': return children[-1] else: return children[0]
XBLOCK_FIELD_DATA_WRAPPERS = ()
score_css = "div.chapters>section:nth-of-type({0}) div.sections>div:nth-of-type({1}) div.scores>ol>li".format( chapter_index, section_index )
group_element_names = { 'checkbox': 'checkboxgroup', 'radio': 'radiogroup', 'multiple': 'choicegroup' }
assert_raises(ValueError, ForestEstimator(oob_score=True, bootstrap=False).fit, X, y)
STATES_WITH_STATUS = [state for state in READY_STATES] + [PROGRESS]
pass
return SON([ (key, id_dict[key]) for key in ('tag', 'org', 'course', 'category', 'name', 'revision') ])
self._verify_cell_data_for_user(user_1, course.id, 'Cohort Name', '') self._verify_cell_data_for_user(user_2, course.id, 'Cohort Name', '')
return _render_certificate_template(request, context, course, user_certificate)
state = (self._corrupt_switch, self._sample_switch, self._bias_switch)
response = requests.get(self.url, params={"test_param": 2}) self.assertEqual(response.status_code, 200)
for line in installed_list_file:
photo_id_key = data_dict["PhotoIDKey"].decode("base64") user_photo_key = data_dict["UserPhotoKey"].decode("base64")
child_descriptor = self.child_descriptor if child_descriptor is None: return None return self.system.get_module(child_descriptor)
return urllib.quote_plus(smart_str(val))
return len(self.q(css='.xblock-header').filter( lambda el: 'xblock-header-video' in el.get_attribute('class')).results)
split_test = self._update_partition_id(0) self.assertEqual(2, len(split_test.children)) initial_group_id_to_child = split_test.group_id_to_child
start_index = start_index + len(start_delim)
SplitMongoKVSid = namedtuple('SplitMongoKVSid', 'id, def_id') new_contract('BlockUsageLocator', BlockUsageLocator)
return hashlib.md5(settings.PROFILE_IMAGE_SECRET_KEY + username).hexdigest()
assert_false("copyright" in vocabulary)
'id': unicode(location)
endorsement = obj.get("endorsement") return endorsement["time"] if endorsement else None
metrics_report = (Env.METRICS_DIR / "safecommit") _write_metric(violations_count_str, metrics_report) sh("cat {metrics_report}".format(metrics_report=metrics_report), ignore_error=True)
return True
yield check_pipeline_consistency
data_specs = (IndexSpace(max_labels=10, dim=1), 'targets') it = self.test.iterator(mode='sequential', data_specs=data_specs, batch_size=100) for y in it: pass
profile_page.privacy = privacy
company_label = _(u"Company")
assert_array_almost_equal(grad_interp[:n_features], grad[:n_features]) assert_almost_equal(grad_interp[-1] + alpha * w[-1], grad[-1])
headers = super(WeightActs, self).c_headers() headers.append('weight_acts.cuh') return headers
Y = np.dot(U, V)
rval_space = out_space
num_queries = 2
self.assertEqual(resp.status_code, 200)
alpha_ = 1. / np.var(y) lambda_ = 1.
return self.q(css=self._bounded_selector('.remove-admin-role')).present
if add: auth.add_users(caller, CourseCreatorRole(), user) else: auth.remove_users(caller, CourseCreatorRole(), user)
step = None if 0 in cost_matrix.shape else _step1
self.certificates_section.wait_for_certificate_exceptions_section()
span_element = rendered_html.find('span') self.assertEqual(span_element.get('attr'), "TEST")
self.course = CourseFactory.create()
sequential2 = ItemFactory.create( parent_location=self.chapter.location, category='sequential', display_name='Section 2', modulestore=store, publish_item=True, start=datetime(2015, 3, 1, tzinfo=UTC), )
the_system = test_capa_system() the_system.render_template = mock.Mock() the_system.render_template.return_value = "<div>Input Template Render</div>"
match = re.search(r'(.*?/common)(?:$|/)', path(__file__)) COMMON_ROOT = match.group(1)
self.wait_for_element_visibility(selector, 'Success div is shown')
return wrap_fragment(frag, static_replace.replace_static_urls( frag.content, data_dir, course_id, static_asset_path=static_asset_path ))
rsp_msg = rsqt_msg.get_response()
self._verify_masquerade_for_all_groups()
return '<p class="error_msg">EXCEPTION!</p>'
get_request_dict = {CapaFactory.input_key(): '3.14'} result = module.save_problem(get_request_dict)
seed = module.seed self.assertTrue(seed is not None)
if self.instance: raise ValidationError("This field is not allowed in an update.") return value
assert_true(X_scaled is X)
MAX_DATABASE_LOCK_RETRIES = 5
self.base_extauth_bypass_sending_activation_email(True)
primary_course = CourseFactory.create(org=primary, emit_signals=True) alternate_course = CourseFactory.create(org=alternate, emit_signals=True)
self.course_info_page.visit() self.tab_nav.go_to_tab('Progress')
CHINESE_LANGUAGE_CODE_MAP = {
self.middleware.process_request(self.request) self.assertNotIn(LANGUAGE_SESSION_KEY, self.request.session)
return self.q(css=self.ADD_MISSING_GROUPS_SELECTOR).present
index_tab = [] for i in xrange(3): index_tab.extend(repeat(i, set_range[i]))
manage.py ... transfer_students -f edX/Open_DemoX/edx_demo_course -t edX/Open_DemoX/new_demoX -c true
FEATURES['ENABLE_COURSEWARE_INDEX'] = True FEATURES['ENABLE_LIBRARY_INDEX'] = True SEARCH_ENGINE = "search.tests.mock_search_engine.MockSearchEngine"
return (-2 * self.score(X) * X.shape[0] + self._n_parameters() * np.log(X.shape[0]))
if kernel != kernel_white: K1 = kernel(X) K2 = pairwise_kernels(X, metric=kernel) assert_array_almost_equal(K1, K2)
X, y = make_hastie_10_2(n_samples=20, random_state=1) X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=43)
X, y = make_blobs(random_state=1) for Model in [DPGMM, VBGMM]: dpgmm = Model(n_components=10, random_state=1, alpha=20, n_iter=50, verbose=2)
visible_layer = BinaryVector(nvis=100) hidden_layer = BinaryVectorMaxPool(detector_layer_dim=500, pool_size=1, layer_name='h', irange=0.05, init_bias=-2.0) model = DBM(visible_layer=visible_layer, hidden_layers=[hidden_layer], batch_size=100, niter=1)
self.assertEquals(response.status_code, 403)
logging.exception(u"Failed to generate thumbnail for {0}. Exception: {1}".format(content.location, str(e)))
template_pdf = "certificate-template-{id.org}-{id.course}.pdf".format(id=course_id)
message = self.q(css='BODY').text[0] match = re.search('Payment page', message) return True if match else False
with patch.object(XQueueInterface, 'send_to_queue') as mock_send: mock_send.return_value = (0, None) if success else (1, self.ERROR_MSG) yield mock_send
rng = np.random.RandomState(0) iris_weights = rng.randint(10, size=iris.target.shape) boston_weights = rng.randint(10, size=boston.target.shape)
inheritable = InheritanceMixin.fields.keys() if name in inheritable: for ancestor in _lineage(block): if self.get_override(ancestor, name) is not NOTSET: return False
iris = datasets.load_iris() X = iris.data y = iris.target X, y = X[y != 2], y[y != 2] n_samples, n_features = X.shape
self._verify_components_visible(['discussion']) self._verify_student_view_visible(['discussion'])
termination_criterion = EpochCounter(5)
course_keys = map(self._parse_course_key, args)
return self.q(css='body.view-team').present and not self.q(css='.ui-loading').present
assert_array_almost_equal(X_transformed[:, :-1], svd.fit_transform(X)) assert_array_equal(X_transformed[:, -1], select.fit_transform(X, y).ravel())
(child_to_delete_location, old_parent_location, ModuleStoreEnum.RevisionOption.draft_preferred), (child_to_delete_location, old_parent_location, ModuleStoreEnum.RevisionOption.published_only),
assert images.type.broadcastable == acts.type.broadcastable assert images.type.broadcastable == denoms.type.broadcastable assert images.type.broadcastable == dout.type.broadcastable
self._enabled = True
clf = self.factory(alpha=0.1, n_iter=1000, fit_intercept=False, class_weight={1: 0.001}) clf.fit(X, y)
robust_cov = MinCovDet().fit(X)
log.debug("children of randomize module (should be only 1): %s", self.child)
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'numpydoc', 'sphinx.ext.autosummary'] #, 'ext']
uncertainty_index = np.argsort(pred_entropies)[-10:]
course = def_ms.courses.get(course_path, None)
input_css = "$('.CodeMirror')[0].CodeMirror.setValue('{}');".format(response_str) self.browser.execute_script(input_css)
self._create_and_purchase_verified(student, course.id)
try:
clf_invalid_method = CalibratedClassifierCV(clf, method="foo") assert_raises(ValueError, clf_invalid_method.fit, X_train, y_train)
usage_key, _ = strip_ccx(usage_key) return self._modulestore.has_item(usage_key, **kwargs)
CourseEnrollment.unenroll(user, course_id) self.assert_no_events_were_emitted()
f = function([X, y], [gradients[W].sum(), clipped_gradients[W].sum()], allow_input_downcast=True)
if count: failure_string = "Too many pep8 violations. " + violations_count_str failure_string += "\n\nViolations:\n{violations_list}".format(violations_list=violations_list) raise BuildFailure(failure_string)
except CyclicDefinitionError: return default_location
assert_(loaded['a'].yaml_src.find("${TEST_VAR}") != -1) del environ['TEST_VAR']
full_name = UserProfile.objects.get(user=user).name
_, _, exclude_dictionary = LmsSearchFilterGenerator.generate_field_filters(user=self.user) self.assertNotIn('org', exclude_dictionary)
empty = ParameterGrid({}) assert_equal(len(empty), 1) assert_equal(list(empty), [{}]) assert_grid_iter_equals_getitem(empty) assert_raises(IndexError, lambda: empty[1])
_ = lambda text: text
listen_for_course_publish(self, self.course.id)
api.remove_credit_requirement_status("bob", self.course_key, "grade", "grade")
kl_divergence = 2.0 * np.dot(P, np.log(P / Q))
if self.xqueue_grade_response is not None: XQueueResponseFixture(self.submission, self.xqueue_grade_response).install()
LogoutPage(self.browser).visit() LmsAutoAuthPage(self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id).visit()
intra_clust_dists = np.ones(distances.shape[0], dtype=distances.dtype)
self.assertListEqual(json.loads(response.content), expected)
with self.assertRaises(ValueError): microsite.get_backend('microsite_configuration.microsite.invalid_method', BaseMicrositeBackend)
return self.asset_md.get(item, default)
is_active = models.BooleanField(default=True)
X = rng.random_sample((10, 3))
inlier_idxs_subset = sample_idxs[inlier_mask_subset] X_inlier_subset = X[inlier_idxs_subset] y_inlier_subset = y[inlier_idxs_subset]
set_idxs = safe_zip(*minibatch)[0]
svm = SVC(kernel="precomputed") assert_raises(ValueError, cval.cross_val_score, svm, X, y)
cov = ShrunkCovariance(shrinkage=0.5) cov.fit(X) assert_array_almost_equal( shrunk_covariance(empirical_covariance(X), shrinkage=0.5), cov.covariance_, 4)
updated_overview = CourseOverview.get_from_id(course.id) self.assertEqual(updated_overview.version, 10)
assert_array_equal(labels, labels_csr) assert_array_almost_equal(new_centers, new_centers_csr) assert_almost_equal(incremental_diff, incremental_diff_csr) assert_almost_equal(old_inertia, old_inertia_csr) assert_almost_equal(new_inertia, new_inertia_csr)
self.assertTrue(self.user.roles.filter(name="Student", course_id=self.course_key))
clf = GradientBoostingClassifier(n_estimators=100, random_state=1)
self.certificates_section.wait_for_certificate_invalidations_section()
self.assertEqual(course.edited_by, "testassist@edx.org") self.assertDictEqual(course.grade_cutoffs, {"Pass": 0.55})
test = -3
value = True if value == "true" else False
course_display_name = self.advanced_settings.get('Course Display Name') self.advanced_settings.set('Course Display Name', 1) self.advanced_settings.wait_for_modal_load()
f, p = f_oneway(X.astype(np.float), y) assert_array_almost_equal(f, fint, decimal=4) assert_array_almost_equal(p, pint, decimal=4)
pass
non_editable_metadata_fields = self.split_test_module.non_editable_metadata_fields self.assertIn(SplitTestDescriptor.due, non_editable_metadata_fields) self.assertIn(SplitTestDescriptor.user_partitions, non_editable_metadata_fields) self.assertNotIn(SplitTestDescriptor.display_name, non_editable_metadata_fields)
clf.intercept_scaling = 100 clf.fit(X, y) intercept1 = clf.intercept_ assert_less(intercept1, -1)
correctness = correctmap.get_correctness('1_2_1') self.assertEqual(correctness, 'correct')
thread = cc.Thread.find(thread_id) result = _vote_or_unvote(request, course_id, thread, value) thread_voted.send(sender=None, user=request.user, post=thread) return result
from .celery import APP as CELERY_APP
centers = clusterer.cluster_centers_ ax2.scatter(centers[:, 0], centers[:, 1], marker='o', c="white", alpha=1, s=200)
from pylearn2.datasets import cifar10
sh("i18n_tool generate")
config = settings.PROFILE_IMAGE_BACKEND storage_class = get_storage_class(config['class']) return storage_class(**config['options'])
cv = (rng.rand() + 1.0) ** 2 samples = mixture.sample_gaussian( mu, cv, covariance_type='spherical', n_samples=n_samples)
self._set_microsite_config_from_obj(microsite.site.domain, domain, microsite)
return _vote_or_unvote(request, course_id, cc.Comment.find(comment_id), undo_vote=True)
costMatrix *= T.neq(Y, -1) return model.cost_from_cost_matrix(costMatrix)
assert_equal(est.estimators_[0, 0].max_depth, 1) for i in range(1, 11): assert_equal(est.estimators_[-i, 0].max_depth, 2)
return ModuleStoreEnum.Type.mongo
self.publish(location.version_agnostic(), user_id, blacklist=EXCLUDE_ALL, **kwargs)
ridge_gcv.fit(filter_(X_diabetes), y_diabetes) alpha_ = ridge_gcv.alpha_ ret.append(alpha_)
self.assertEqual( res_json['message'], u"Student (username/email={user_name}) already in certificate exception list.".format(user_name=user) )
CONFIG_PREFIX = SERVICE_VARIANT + "." if SERVICE_VARIANT else ""
n_samples = 80 n_features = 5 repeat = 10
self._test_visible_to_students(False, 'private_unreleased', self.future)
if usage_id_filter is None and usage_key_filter is not None: usage_id_filter = usage_key_filter
return self.get_selector('.certificate-exception-container div.message')
return sparse.csr_matrix(self.coef_)
return array.array(str("i"))
n_samples = 10000 n_features = 100 n_queries = 30 rng = np.random.RandomState(42)
q = (cdist(x, mu[np.newaxis], "mahalanobis", VI=A) ** 2).reshape(-1) return q
EmptyPromise( lambda: self.q(css='div.add-xblock-component').present, 'Wait for the menu of components to be present' ).fulfill()
score[i] += n_ranked_above / rank[label]
info_log.assert_called_with('email sent to new created user at %s', 'test_student@example.com')
module.reset_problem({})
update_course_structure.apply_async([unicode(course_key)], countdown=0)
version_guid = course_key.as_object_id(version_guid) return self.db_connection.get_structure(version_guid, course_key)
self.assertIsNone( CourseEnrollment.enroll_by_email("not_jack@fake.edx.org", course_id) ) self.assert_no_events_were_emitted()
return json.dumps(files.split())
self.course_nav.go_to_vertical('Test Vertical-0')
return - 2 * self.score(X).sum() + 2 * self._n_parameters()
survey = self._create_test_survey() self.assertFalse(survey.has_user_answered_survey(self.student)) self.assertEquals(len(survey.get_answers()), 0)
m_obj = re.match(r'^/courses/{}'.format(settings.COURSE_ID_PATTERN), input_str) if m_obj: return CourseKey.from_string(m_obj.group('course_id')) return None
comment = cc.Comment.find(comment_id) result = _vote_or_unvote(request, course_id, comment, value) comment_voted.send(sender=None, user=request.user, post=comment) return result
target = [-1] * len(JUNK_FOOD_DOCS) + [1] * len(NOTJUNK_FOOD_DOCS)
try: return datetime.utcfromtimestamp(int(timestamp)).replace(tzinfo=UTC) except (ValueError, TypeError): return None
return False
self.assertEqual(len(mail.outbox), 0) user_status = VerificationStatus.objects.filter(user=self.user).count() self.assertEqual(user_status, 0)
self.wait_for_element_visibility( self._bounded_selector(self.VIEWER_SELECTOR), "Note Viewer is visible." )
destination_block.edit_info.source_version = ( new_block.edit_info.source_version or new_block.edit_info.update_version )
'openedx.core.djangoapps.safe_sessions.middleware.SafeSessionMiddleware',
limiter.tick_bad_request_counter(request)
if not settings.configured: settings.configure()
clf = LassoCV()
super(LibraryEditPageTest, self).setUp() self.lib_page = LibraryEditPage(self.browser, self.library_key) self.lib_page.visit() self.lib_page.wait_until_ready()
if len(indices) != n_samples: return False hit = np.zeros(n_samples, bool) hit[indices] = True if not np.all(hit): return False return True
default=_("Blank Advanced Problem")
'milestones',
'openedx.core.djangoapps.programs',
config.toggle() self.assertFalse(config.details_error_icon_is_present) self.assertFalse(config.details_message_is_present)
X = csr_matrix(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
content_range = {'start': 0, 'stop': 1, 'end': 2}
world.wait_for_ajax_complete()
self._active_count -= 1
train, target = iris.data, iris.target n_samples, n_features = train.shape
log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]
if i + 1 == len(course_keys): self.assertTrue(badge_class.get_for_user(user)) else: self.assertFalse(badge_class.get_for_user(user))
'lms.djangoapps.verify_student',
return self.q(css='.hidden-contents').visible
'SHIB_DISABLE_TOS': False,
return ['name', 'locale']
rng = np.random.RandomState(0) noise = 0.1 * rng.randn(Npts, 1) X = np.concatenate((X, noise), 1)
if self.increasing == 'auto': self.increasing_ = check_increasing(X, y) else: self.increasing_ = self.increasing
reg_code = CourseRegistrationCode.objects.create( code="abcd1234", course_id=self.course.id, created_by=self.user )
legacy_profile = UserProfile.objects.get(id=self.user.id) legacy_profile.year_of_birth = 2000 legacy_profile.save()
fields = ["field1", "field2", "field3"] block_structure.request_xblock_fields(*fields)
try: select = Select(query.first.results[0]) return (True, select.first_selected_option.text) except StaleElementReferenceException: return (False, None)
coach_user = UserFactory( username='test_coach_user', email='test_coach_user@openedx.org', password='test' ) CourseCcxCoachRole(self.master_course_key).add_users(coach_user)
self._get_hasher().fit(X, y=y) return self
self._auto_auth(self.USERNAME, self.EMAIL, False)
store = self._verify_modulestore_support(None, 'create_course') course = store.create_course(org, course, run, user_id, **kwargs)
centers = [[1, 1], [-1, -1], [1, -1]] X, labels_true = make_blobs(n_samples=750, centers=centers, cluster_std=0.4, random_state=0)
return {"library": unicode(normalized_structure_key)}
self._setup_mode_and_enrollment(self.FUTURE, "verified")
cost_value.name = 'objective'
if not iboost == self.n_estimators - 1: sample_weight *= np.exp(estimator_weight * ((sample_weight > 0) | (estimator_weight < 0)))
self._block_relations.pop(usage_key, None) self._block_data_map.pop(usage_key, None)
try: from setuptools import setup except ImportError: from distutils.core import setup
pass
self._install_course_fixture() self._navigate_to_course_unit_page()
body.update(custom_parameters)
bias = T.dvector() kerns = T.dvector() input = T.dmatrix() rng = N.random.RandomState(3423489)
self.exceptions.extend([KeyboardInterrupt, WorkerInterrupt])
self._assets.extend(asset_name)
problem = new_loncapa_problem(xml_str) problem.done = True problem.student_answers = {'1_2_1': 'choice_1'}
for pattern in self.ALLOW_URL_PATTERNS: if pattern.match(request.path) is not None: return None
row = reader.next()
self.desired_space = Conv2DSpace(shape=space.shape, channels=space.num_channels, axes=('c', 0, 1, 'b'))
if settings.ROOT_URLCONF != 'lms.urls': raise unittest.SkipTest('Test only valid in lms')
kf = KFold(3) kf2 = KFold(3, shuffle=True, random_state=0) kf3 = KFold(3, shuffle=True, random_state=1)
self.assert_oauth_status("fooooooooooToken", status.HTTP_401_UNAUTHORIZED)
assert rbmA_params[0].shape[0] == rbmB_params[0].shape[0] assert len(rbmA_params[1]) == len(rbmB_params[1])
results = np.array(np.where(state.marked == 1)).T
for idx in range(num): (user, _, _) = _do_create_account(make_random_form()) if course_key is not None: CourseEnrollment.enroll(user, course_key)
y_pred1 = clf.fit(X1, y).predict(X1) assert_array_equal(y_pred1, y, 'solver %s' % solver)
course.cohort_config = {'cohorted': True} self.assertTrue(course.is_cohorted)
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
with open(self.f.name, 'w') as f: f.write("foo/hello/test.py:304:15: E203 whitespace before ':'")
return super(NullBackend, self).get_value_for_org(org, val_name, default)
return lxml.html.tostring(self.table)
try: if block_data.asides: aside_fields = {block_key.type: {}} for aside in block_data.asides: aside_fields[block_key.type].update(aside['fields']) except AttributeError: pass
y = np.array(g(X) > 0, dtype=int)
estimator.fit(X_train)
self._add_entrance_exam() self.init_course_access() self._verify_unfulfilled_milestone_response()
registration_price = CourseMode.min_course_price_for_currency( course_key, settings.PAID_COURSE_REGISTRATION_CURRENCY[0] ) course_price = get_cosmetic_display_price(course, registration_price) can_add_course_to_cart = _is_shopping_cart_enabled and registration_price
incxml = etree.XML(ifp.read())
oob_error = 1 - clf.oob_score_ error_rate[label].append((i, oob_error))
course = get_course_overview_with_access(user, 'staff', course_id) return bool(has_access(user, 'staff', course))
self.tab_nav.mathjax_has_rendered()
print(metrics.classification_report(y_test, y_predicted, target_names=dataset.target_names))
logger.debug( "Comment Service received POST request {0} to path {1}" .format(json.dumps(post_dict), self.path) )
EmptyPromise(lambda: self.is_button_shown('transcript_button'), "transcript button is shown").fulfill()
preds2 = np.zeros_like(y) for train, test in cv.split(X, y): est.fit(X[train], y[train]) preds2[test] = est.predict(X[test])
return LibrarySearchIndexer.do_library_reindex(store, self.library.location.library_key)
return self.list_display
if not GlobalStaff().has_user(request.user): raise PermissionDenied()
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
self.launch_uri = self.uri + 'wrong_lti_endpoint' response = requests.post(self.launch_uri, data=self.payload) self.assertIn('Invalid request URL', response.content)
account_settings = AccountSettingsPage(self.browser).visit() account_settings.switch_account_settings_tabs('accounts-tab')
def __init__(self): super(NullSpace, self).__init__()
descriptor.runtime.export_fs = MemoryFS() node = etree.Element('unknown') descriptor.add_xml_to_node(node)
self.client.logout() resp = self.client.get(self.url_unlocked) self.assertEqual(resp.status_code, 200)
yield check_parameters_default_constructible, name, Estimator
PARTNER_SUPPORT_EMAIL = ''
_SEUPD_WHICH = ['LM', 'SM', 'LA', 'SA', 'BE']
'lang_pref.middleware.LanguagePreferenceMiddleware',
request.user = request.client.user
mlb = MultiLabelBinarizer() assert_array_equal(mlb.fit(inp).transform(inp), indicator_mat) assert_array_equal(mlb.inverse_transform(indicator_mat), inp)
print(file=ex_file) print('Examples using ``%s``' % backref, file=ex_file) print('%s--' % ('-' * len(backref)), file=ex_file) print(file=ex_file)
self.assertOLXIsPublishedOnly(block_list_publish) self.assertOLXIsDraftOnly(block_list_untouched)
chapter = path[1].name if n > 1 else None section = path[2].name if n > 2 else None vertical = path[3].name if n > 3 else None position = None
self._assert_cannot_reverify()
self.assertTrue(self.store.has_item(course.id.make_usage_key('html', "multi_parent_html")))
from instructor.views.api import save_registration_code
css = '.group-name' self.find_css(css).first.fill(value)
problem1_content_before_switch = self.problem_page.problem_content
create_course(step, course)
with check_mongo_calls(courses_list_from_group_calls): _accessible_courses_list_from_groups(self.request)
self._do_create_preferences_test(True)
LogoutPage(self.browser).visit()
package.where=dataset_data_path;
make_user_coach(coach, master_course_key)
self.video.speed = '1.0'
with remove_ccx(course_key) as (course_key, restore): return restore(self._modulestore.get_course( course_key, depth=depth, **kwargs ))
return etree.Element("optionresponse")
for layer, state in safe_izip(dbm.hidden_layers, H_hat): upward_state = layer.upward_state(state) layer.get_output_space().validate(upward_state)
self.assertTrue('success' in result and not result['success'])
super(TestHeaderMenu, self).setUp()
assert V is orig_V assert drop_mask is orig_drop_mask
'lms.djangoapps.verify_student',
response_element.set("answer", unicode(answer))
return self.q(css="#is_prereq:checked").present
user = UserSerializer() class Meta(object): model = UserPreference depth = 1
print not iseia(2200, (E48, E96, E192)) print iseia(5490e2, (E48, E96, E192)) print iseia(2200) print not iseia(5490e2)
return self.q(css='{} input[name=entrance-exam-task-history]'.format(self.EE_CONTAINER))
moments_1[k] = moments_1[i] + moments_1[j] moments_2[k] = moments_2[i] + moments_2[j]
return abs(dt1 - dt2) < allowed_delta
multi_target_forest.fit(X, y)
self.courseware_page.stop_timed_exam()
else: response.status_code = 403 response.content = msg
url(r'^programs/(?P<program_id>\d+)/[\w\-]*/?$', views.program_details, name='program_details_view'),
assert pdp.shape == (1, 4) assert axes[0].shape[0] == 4
n_nonzeros = int(opts.ratio_nonzeros * opts.n_features)
module = CapaFactory.create(max_attempts=0) self.assertFalse(module.should_show_check_button())
courselike_label = self.parent_xml.split('.')[0]
log.exception(u"Error occurred while caching course enrollment details for course %s", course_id) raise errors.CourseEnrollmentError(u"An unexpected error occurred while retrieving course enrollment details.")
return self.func_to_count(param)
_("This is the wiki for **{organization}**'s _{course_name}_.").format( organization=course.display_org_with_default, course_name=course.display_name_with_default_escaped, )
AutoAuthPage( self.browser, username="testcert", email="cert@example.com", password="testuser", course_id=self.course_id ).visit()
ASSET_XML_PATH = COURSE_DATA_DIR / AssetMetadata.EXPORTED_ASSET_DIR / AssetMetadata.EXPORTED_ASSET_FILENAME
return len(self._max_scores_cache)
translations_selector = '.metadata-video-translations .remove-setting' return self.q(css=translations_selector).attrs('data-lang')
response = self.client.get(self.url, params)
fit_params = fit_params if fit_params is not None else {} fit_params = dict([(k, _index_param_value(X, v, train)) for k, v in fit_params.items()])
features = [
version = unichr(unicode_char)
digits = datasets.load_digits()
rerun_course_data = {'source_course_key': unicode(source_course_key)} if not destination_course_data: destination_course_data = self.destination_course_data rerun_course_data.update(destination_course_data) destination_course_key = _get_course_id(self.store, destination_course_data)
iris = load_iris() X = iris.data[:, [0, 2]] y = iris.target X = X[y != 2] y = y[y != 2]
self.coach = UserFactory.create() self.mstore = modulestore()
has_previous_line = self.start_line > 1 if has_previous_line: line_to_check = string_lines.line_number_to_line(self.start_line - 1) self._mark_disabled(line_to_check, scope_start_string=True) if self.is_disabled: return
results.append(benchmark(SGDClassifier(alpha=.0001, n_iter=50, penalty=penalty)))
ANALYTICS_DASHBOARD_URL = ENV_TOKENS.get("ANALYTICS_DASHBOARD_URL", ANALYTICS_DASHBOARD_URL) ANALYTICS_DASHBOARD_NAME = ENV_TOKENS.get("ANALYTICS_DASHBOARD_NAME", PLATFORM_NAME + " Insights")
self.assertTrue(item.is_staff_only) if hasattr(item, 'children'): for child in item.children(): self._verify_descendants_are_staff_only(child)
if any(new_locator.block_id == child.block_id for child in new_parent.children): continue new_parent_cursor = 0 for old_child_loc in old_parent.children: if old_child_loc.block_id == draft_location.block_id:
go_to_section("data_download")
return (tok.lower() for tok in re.findall(r"\w+", doc))
admin.site.register(CourseEventBadgesConfiguration, ConfigurationModelAdmin)
axis = np.linspace(emp_percentiles[0, col], emp_percentiles[1, col], num=grid_resolution, endpoint=True)
input_dict = {'1_2_1': '-1', '1_2_2': '2', '1_2_3': '3'} correct_map = problem.grade_answers(input_dict)
fl = mlp_composite.layers[0]
random_state = np.random.RandomState(0) X = np.c_[X, random_state.randn(n_samples, 200 * n_features)]
self.assertTrue(pipeline.running(request))
GEOIP_PATH = REPO_ROOT / "common/static/data/geoip/GeoIP.dat" GEOIPV6_PATH = REPO_ROOT / "common/static/data/geoip/GeoIPv6.dat"
d1 = DenseDesignMatrix(topo_view=topo_view) slice_d = from_dataset(d1, 5) assert slice_d.X.shape[1] == d1.X.shape[1] assert slice_d.X.shape[0] == 5
for key, value in dict_: self[key] = value
SORT_REVISION_FAVOR_PUBLISHED = ('_id.revision', pymongo.ASCENDING)
if response.status_code != 200: log.error( "Outcome service response: Unexpected status code %s", response.status_code ) return False
from markdown.util import etree
css_include = compressed_css('style-main-v1') self.assertIn(u'lms-main-v1.css', css_include)
self._collection.clear() self._uri_cache.clear()
STATUS = Choices('created', 'ready', 'submitted', 'must_retry', 'approved', 'denied') user = models.ForeignKey(User, db_index=True)
self.assertIn('wrapper-xblock-message', html) self.assertNotRegexpMatches(html, r'wrapper-xblock[^-]+')
self._update_release_dates(self.date_one, self.date_one, self.date_one) self._verify_release_date_source(self.vertical, self.chapter)
return self.str_versions
total_amount = models.FloatField()
data[:, 5] = data[:, 4] / data[:, 5]
GIT_REPO_DIR = ENV_TOKENS.get('GIT_REPO_DIR', '/edx/var/edxapp/course_repos') GIT_IMPORT_STATIC = ENV_TOKENS.get('GIT_IMPORT_STATIC', True)
if response_msg: tree.append(self._render_response_msg_html(response_msg))
component = self.store.get_item(xblock.location) component.display_name = 'Changed Display Name'
if updated_user.password != old_password_hash: entry = PasswordHistory() entry.create(updated_user)
self.events.append(event)
return [ destination_course.make_usage_key(*k) for k in dest_structure['blocks'][block_key].fields['children'] ]
self.check_response('done_0', 'done-unmarked') self.check_response('done_1', 'done-unmarked')
self.assertGreaterEqual(iteration_over_courses_time_1.elapsed, iteration_over_groups_time_1.elapsed) self.assertGreaterEqual(iteration_over_courses_time_2.elapsed, iteration_over_groups_time_2.elapsed)
self.seq_1_vert_1_handle = 2 self.seq_1_vert_2_handle = 3 self.chap_1_seq_2_handle = 4
if start_date is None: start_date = datetime.datetime(1970, 1, 1)
self.client.logout()
resp = self.create_xblock(parent_usage_key=chap_usage_key, category='sequential') self.seq_usage_key = self.response_usage_key(resp) self.seq_update_url = reverse_usage_url("xblock_handler", self.seq_usage_key)
AT_xT = self.rmul_T(self.transpose_left(x, False)) rval = self.transpose_right(AT_xT, True) return rval
self.assertEqual( StudentModule.objects.filter( student=self.module_to_reset.student, course_id=self.course.id, module_state_key=self.module_to_reset.module_state_key, ).count(), 0 )
@classmethod def get_template_dir(cls): return 'foo'
course_orphans = self.store.get_orphans(course_locator) self.assertEqual(len(course_orphans), 0)
n_components = init.shape[1] if n_samples != init.shape[0]: raise ValueError("init matrix should be of shape (%d, %d)" % (n_samples, n_components)) X = init
call_command( "migrate_to_split", str(self.course.id), str(self.user.id), )
self.assertTrue(filesystem.exists('policy.json'))
self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 1)
self.assertIn(self.test_form, resp.content)
team_membership = team['membership'] del team['membership']
mdata = AssetMetadata(asset_key, asset_key.path) mdata.from_storable(all_assets[asset_idx]) mdata.update(attr_dict)
BROKER_HEARTBEAT = 10.0 BROKER_HEARTBEAT_CHECKRATE = 2
if partial_text: wait_for(lambda _: css_html(css_selector, index=index), timeout=8)
return True
Xcoo = coo_matrix(X) mkchi2(k=2).fit_transform(Xcoo, y)
lasso_lars = LassoLars(alpha=alpha, fit_intercept=False, verbose=verbose, normalize=False, precompute=gram, fit_path=False) lasso_lars.fit(dictionary.T, X.T, Xy=cov) new_code = lasso_lars.coef_
transformer = Conv2D(filters=filters, batch_size=len(input), input_space=input_space, border_mode='full') sum_sqr_XX = transformer.lmul(X ** 2)
super(SharedModuleStoreTestCase, cls).setUpClass() cls.start_modulestore_isolation()
train_with_monitoring_datasets( train_dataset=dataset1, monitoring_datasets=even_monitoring_datasets, model_force_batch_size=False, train_iteration_mode='sequential', monitor_iteration_mode='sequential')
list_display = ('user', 'course_id')
task_input = { 'statuses_to_regenerate': [ CertificateStatuses.downloadable, CertificateStatuses.error, CertificateStatuses.generating ] }
y_1 = regr_1.predict(X) y_2 = regr_2.predict(X)
super(SplitMongoKVS, self).__init__(copy.deepcopy(initial_values))
if created: enrollment.mode = CourseMode.DEFAULT_MODE_SLUG enrollment.is_active = False enrollment.save()
self.lengths = [len(s) for s in self._sequence_data] self.len_unique = np.unique(self.lengths)
return self.check_outbox(u"Vous avez été")
return self.get_selector('#disabled-btn-start-generating-certificates')
y_proba = clf.predict_proba(T) assert_true(np.all(y_proba >= 0.0)) assert_true(np.all(y_proba <= 1.0))
return SearchEngine.get_search_engine(self.INDEX_NAME)
indices = np.arange(n_features) generator.shuffle(indices) X[:, :] = X[:, indices]
self._fit_transform(X) return self.embedding_
course_email_template = course_email.get_template() try: connection = get_connection() connection.open()
err = Exception mock_index_dictionary.return_value = err
CELERY_RESULT_BACKEND = 'djcelery.backends.cache:CacheBackend'
return course_metadata_utils.course_end_datetime_text( self.end, format_string, self.runtime.service(self, "i18n").strftime )
self.config = dict()
mono_shape = shape[:s_index] + (1, ) + shape[(s_index + 1):]
rval = X.copy()
def __init__(self, developer_message, user_message=None): self.developer_message = developer_message self.user_message = user_message
try: return CourseKey.from_string(data) except InvalidKeyError as ex: raise serializers.ValidationError("Invalid course key: {msg}".format(msg=ex.msg))
exp_doc_topic = np.exp(_dirichlet_expectation_2d(doc_topic_distr))
with self.assertRaises(CourseActionStateItemNotFoundError): CourseRerunState.objects.find_first(course_key=destination_course_key)
return self.q(css=self.prefix + " .signatory-details-list, .signatory-edit-list").present
from __future__ import unicode_literals
active_script = "return " + title_selector + " === document.activeElement;" return self.browser.execute_script(active_script)
return microsite.get_value('platform_name', settings.PLATFORM_NAME)
MONGO_PORT_NUM = int(os.environ.get('EDXAPP_TEST_MONGO_PORT', '27017')) MONGO_HOST = os.environ.get('EDXAPP_TEST_MONGO_HOST', 'localhost')
country_model = apps.get_model("embargo", "Country") for country_code, __ in list(countries): country_model.objects.get_or_create(country=country_code)
user2 = UserFactory.create() user2.save() assert_is_none(SoftwareSecurePhotoVerification.active_for_user(user2))
if conf.get('normalize_on_the_fly', False): return data
plt.figure(2, figsize=(3, 2.2)) plt.imshow(face_compressed, cmap=plt.cm.gray, vmin=vmin, vmax=vmax)
dual_coefs = np.empty([n_targets, n_samples])
self.aes = self._layers
draft_only = 'rev-opt-draft-only'
raise NotImplementedError()
self.q(css='a.instructor-info-action').first.click() staff_debug_page = StaffDebugPage(self.browser) staff_debug_page.wait_for_page() return staff_debug_page
multi_db = True COURSE_SLUG = "100" COURSE_NAME = "test_course"
resp = self.client.get(self.url, HTTP_ACCEPT='application/x-tgz') self._verify_export_succeeded(resp)
self.definition = block_data.get('definition', None)
raise NotImplementedError('partial sum')
xblock_group_access = get_field_on_block(xblock, 'group_access', default_value={})
CourseEnrollment.enroll(user, course_id) self.assertTrue(CourseEnrollment.is_enrolled(user, course_id)) self.assert_enrollment_event_was_emitted(user, course_id)
self.q(css=self._bounded_selector(".tab-manage_students")).first.click()
FEATURES['ENABLE_SPECIAL_EXAMS'] = True
self._api_base = api_base self._configuration = configuration
format = ugettext("DATE_TIME_FORMAT") if format == "DATE_TIME_FORMAT": format = DEFAULT_DATE_TIME_FORMAT
FEATURES['MILESTONES_APP'] = True
BROKER_HEARTBEAT = 10.0 BROKER_HEARTBEAT_CHECKRATE = 2
non_staff_client, _ = self.create_non_staff_authed_user_client() response = non_staff_client.delete(outline_url, {}, HTTP_ACCEPT='application/json') self.assertEqual(response.status_code, 403)
course_overview = enrollment.course_overview if not course_overview: log.error( "User %s enrolled in broken or non-existent course %s", user.username, enrollment.course_id ) continue
if serialized_block['type'] == 'video': self.assertIn('student_view_data', serialized_block)
required_content = milestones_helpers.get_required_content(course, user)
ROLE = 'beta_testers' def __init__(self, *args, **kwargs): super(CourseBetaTesterRole, self).__init__(self.ROLE, *args, **kwargs)
html, __ = self._get_container_preview(root_usage_key)
self._update_head(course_locator, index_entry, course_locator.branch, new_structure['_id'])
if key_betas is not None: betas = numpy.hstack((betas, key_betas)) betas.sort()
if user: self.q(css='input[id^=sd_fu_]').first.fill(user) self.q(css='section.staff-modal a.staff-debug-rescore').click()
try: return cls.objects.get(Q(invoice_id=invoice_id), Q(status='completed') | Q(status='refunded')) except InvoiceTransaction.DoesNotExist: return None
from __future__ import unicode_literals
def __repr__(self): return _build_repr(self)
if len(unicode(final_grade)) > 7: final_grade = u'{:.5f}'.format(final_grade) else: final_grade = unicode(final_grade)
self.class_log_prior_ = (np.log(self.class_count_) - np.log(self.class_count_.sum()))
url(r'^lang_pref/session_language', 'lang_pref.views.update_session_language', name='session_language'),
CourseEnrollmentFactory( user=self.user, is_active=True, mode=mode, course_id=unicode(self.course.id), )
self.add_team_configuration(max_team_size=4, topics=[]) self.assertFalse(self.course.teams_enabled)
set_credit_requirements(self.course.id, requirements)
self._pool = None
self.assertDeserializeEqual(-2.78, '-2.78')
fit_transform = transform
METRICS_WITH_AVERAGING = [ "precision_score", "recall_score", "f1_score", "f2_score", "f0.5_score" ]
ref_inlier_mask = np.ones_like(ransac_estimator.inlier_mask_ ).astype(np.bool_) ref_inlier_mask[outliers] = False
return self.q(css=' '.join([self.PAGE_SELECTOR, css_selector]))
honor.suggested_prices = '5, 10, 15' honor.save() self.assertTrue(CourseMode.has_payment_options(self.course_key))
return self.conditional.encode_conditional_params(z)
regr = linear_model.LinearRegression()
attempt = SoftwareSecurePhotoVerification(user=self.user, photo_id_key="dummy_photo_id_key") attempt.mark_ready() attempt.save() attempt.submit()
assert_less(distances_ratio.max(), 1 + eps) assert_less(1 - eps, distances_ratio.min())
return self.q(css='section.about-accomplishments').present
VERIFY_STUDENT = AUTH_TOKENS.get("VERIFY_STUDENT", VERIFY_STUDENT)
self.client.login(username=self.white_label_course_instructor.username, password='test')
assert_less(np.sum(s_clf.coef_ != 0.0), 2 * n_informative)
with mock_create_basket(exception=exceptions.Timeout): response = self._post_to_view() self.assertValidEcommerceInternalRequestErrorResponse(response) self.assertUserNotEnrolled()
clf = MockClassifier() grid_search = GridSearchCV(clf, {'foo_param': [1]}) grid_search.fit(X, y) assert_true(hasattr(grid_search, "grid_scores_"))
emp_cov = EmpiricalCovariance().fit(X)
return self._num_batches_seen
course = CourseFactory.create( org=course_location.org, number=course_location.course, run=course_location.run ) enrollment = CourseEnrollment.enroll(self.student, course.id) return course, enrollment
if lookup == 'in': stripped_value = [_strip_object(el) for el in value] else: stripped_value = _strip_object(value) return stripped_value
self.n_iter_ = 0 self.t_ = 0 self.n_outputs_ = y.shape[1]
if 'user_id' in kwargs: kwargs['user_id'] = str(kwargs['user_id']) return kwargs
assert_array_equal(X_trans, [[0., 1., 0., 1., 1.], [1., 0., 1., 0., 1.]])
logger.info(self.__str__())
t3 = TfidfTransformer(use_idf=True) assert_raises(ValueError, t3.transform, counts_train)
return redirect_with_get('register_user', request.GET)
return list(set(enrolled_students) - set(students_already_have_certs))
self.certificates_section.wait_for_certificate_exceptions_section()
parameters = { 'vect__max_df': (0.5, 0.75, 1.0), #'vect__max_features': (None, 5000, 10000, 50000),
self.go_to_tab_and_assert_problem(2, self.problem2_name)
for app in ADDL_INSTALLED_APPS: INSTALLED_APPS += (app,)
ans = set()
img = circle1 + circle2 mask = img.astype(bool) img = img.astype(float)
self.assertIsNotNone(ver_block)
XBLOCK_FIELD_DATA_WRAPPERS = ()
frgd_img = to_img(data.X[i], 28) frgd_img = frgd_img.convert('L')
else: assert self.line_search_mode == 'exhaustive'
with check_mongo_calls(import_reads, first_import_writes): import_course_from_xml( source_store, 'test_user', TEST_DATA_DIR, source_dirs=['manual-testing-complete'], static_content_store=source_content, target_id=source_course_key, create_if_not_present=True, raise_on_failure=True, )
self.store.delete_item(vertical.location, self.user_id) self.assertFalse(self._has_changes(sequential.location))
self.wait_for_ajax() return self.q(css='.join-team .join-team-message').text[0]
ica = FastICA(n_components=1, whiten=False, random_state=0) assert_warns(UserWarning, ica.fit, m) assert_true(hasattr(ica, 'mixing_'))
data["children"] = obj["children"]
if created: _send_new_pending_email(instance)
self.q(css="input.proctored_exam").first.click()
width = self.ext.config['gametrailers_width'][0] height = self.ext.config['gametrailers_height'][0] return flash_object(url, width, height)
problem = self.build_problem(script=script, cfn="check_func")
iris = datasets.load_iris()
from pylearn2.blocks import Block from pylearn2.utils import sharedX
pass
violations_count_str = "Number of {safecommit_script} violations: {num_violations}\n".format( safecommit_script=safecommit_script, num_violations=num_violations )
raise NotImplementedError(str(type(self)) + " does not implement get_default_cost.")
{ u'description': 'Test description', u'version': CERTIFICATE_SCHEMA_VERSION },
pass
self.create_random_units(False, conditional_loc)
valid_assocs = [a for a in associations if a.getExpiresIn() > 0] if valid_assocs: valid_assocs.sort(lambda a: a.getExpiresIn(), reverse=True) assoc = valid_assocs.sort[0]
transcripts_info = video_descriptor.get_transcripts_info() transcript_langs = video_descriptor.available_translations(transcripts_info, verify_assets=False)
add_users(self.admin, CourseCreatorRole(), self.user)
enrollment = CourseEnrollment.get_or_create_enrollment(user, course_id) self.assertFalse(CourseEnrollment.is_enrolled(user, course_id)) self.assert_no_events_were_emitted()
types = [(MockDataFrame, MockDataFrame)] try: from pandas import Series, DataFrame types.append((DataFrame, Series)) except ImportError: pass
dataset = datasets.load_digits() X = dataset['data'] y = dataset['target']
if not hasattr(self, 'n_samples_seen_'): self.n_samples_seen_ = X.shape[0] else: max_abs = np.maximum(self.max_abs_, max_abs) self.n_samples_seen_ += X.shape[0]
if "Subprocess return code: 1" not in error_message: return False else: return True
self.send_response(500, 'Bad Request: does not contain API key') self.send_header('Content-type', 'text/plain') self.end_headers() return False
brc = Birch(n_clusters=None, branching_factor=1, threshold=0.01) assert_raises(ValueError, brc.fit, X)
return self.store.check_supports(block.location.course_key, 'copy_from_template')
try: microsite = Microsite.objects.get(key='default') except Microsite.DoesNotExist: pass
self.fit_, self.partial_fit_ = True, False return self._fit(X)
context = {} _update_context_with_basic_info(context, course_id, platform_name, configuration) invalid_template_path = 'certificates/invalid.html'
self.assertLess(old_edited_on, updated_component.edited_on) self.assertEqual(updated_component.edited_by, edit_user)
return social_user.user.username
self.assertEqual(safe_key('test', 'prefix', 5), 'prefix:5:test')
mock_file.name = name return mock_file
assert np.all((ps == 0) + (ps == 1)) assert np.all((hs == 0) + (hs == 1))
return self
return str((template_name, sorted(context.iteritems())))
CELERY_ALWAYS_EAGER = True
return len(np.unique(X.nonzero()[1]))
self.assertFalse(result, msg="User should not have access because the user isn't staff.")
add_course_url = urlparse.urljoin(course.ccx_connector, CCXCON_COURSEXS_URL) resp = oauth_ccxcon.post( url=add_course_url, json=payload, headers=headers, timeout=CCXCON_REQUEST_TIMEOUT )
return None
with self.assertRaises(SurveyFormNotFound): SurveyForm.get(self.test_survey_name)
self.assertTrue(self.video.downloaded_transcript_contains_text('srt', 'Welcome to edX.'))
if which_set in ['train', 'test']: data_x, data_y = load_data("{0}{1}_32x32.mat".format(path, which_set))
from __future__ import unicode_literals
module.xml_attributes = xml_attrs
self._create_video()
return json.loads(self.look_at_question(self.problem_display_name).content)['progress_detail']
if not user.is_active: response_payload = { 'unique_student_identifier': user.username, 'inactiveUser': True, } return JsonResponse(response_payload)
registration_codes_list = CourseRegistrationCode.objects.filter( course_id=course_id ).order_by('invoice_item__invoice__company_name')
self.space._validate_impl(is_numeric, batch[0])
self.courseware_page.click_previous_button_on_bottom() self.assert_navigation_state('Test Section 1', 'Test Subsection 1,1', 2, next_enabled=True, prev_enabled=True)
num_drafts = self._get_draft_counts(course) self.assertEqual(num_drafts, 1)
user = self.create_user_and_enroll(enrollment_type) if verification_status: self.add_verification_status(user, verification_status)
cls._validate_cookie_params(session_id, user_id) safe_cookie_data = SafeCookieData( cls.CURRENT_VERSION, session_id, key_salt=get_random_string(), signature=None, ) safe_cookie_data.sign(user_id) return safe_cookie_data
EmptyPromise( lambda: self.find_css('a.detail-toggle.hide-details').present, 'Certificate details are expanded' ).fulfill()
self.assertEqual(self.do_email_validation(self.user.email), 'Old email is the same as the new email.')
k3 = 0.66**2 \ * RationalQuadratic(length_scale=1.2, alpha=0.78) k4 = 0.18**2 * RBF(length_scale=0.134) \
self.train_set.adjust_for_viewer(self.train_set.X)
filterwarnings('ignore', message='No request passed to the backend, unable to rate-limit')
import numpy as np from sklearn.tree import DecisionTreeRegressor import matplotlib.pyplot as plt
query_params = deepcopy(query_params) query_params.update({ "page": page_num, "page_size": page_size }) return url_path + "?" + urlencode(query_params)
X = iris.data y = np.array(iris.target) est = GradientBoostingClassifier(n_estimators=20, max_depth=1, random_state=1, init=ZeroEstimator()) est.fit(X, y)
if is_updated or asides_updated: new_structure = self.version_structure(course_key, original_structure, user_id) block_data = self._get_block_from_structure(new_structure, block_key)
return self._section_scores(chapter_index, section_index)
return deserialize_count_specs(self.courses_enrolled)
__, __, course = self.load_test_import_course(target_id=course_id, module_store=module_store)
def fit(self, X, y): super(CustomSVC, self).fit(X, y) self.data_type_ = type(X) return self
self.enable_saml() response = self.client.get(self.LOGIN_URL) self.assertEqual(response.status_code, 302)
problem.grade_answers({'1_2_1': 'test'})
'MILESTONES_APP': False,
for course_key, store_name in self.mappings.iteritems(): if store_name == key: self.mappings[course_key] = store self.modulestores.append(store)
AutoAuthPage(self.browser, course_id=self.course_id).visit()
if close_bracket and not hang_closing: yield (start, "E123 closing bracket does not match " "indentation of opening bracket's line") hangs[depth] = hang
dest_info.edit_info.previous_version = dest_info.edit_info.update_version dest_info.edit_info.update_version = old_dest_structure_version dest_info.edit_info.edited_by = user_id dest_info.edit_info.edited_on = datetime.datetime.now(UTC)
try: CertificateInvalidation.objects.get( generated_certificate=self.generated_certificate, invalidated_by=self.global_staff, notes=self.notes, active=True, ) except ObjectDoesNotExist: self.fail("The certificate is not invalidated.")
course_image = u'在淡水測試.jpg' self.course = CourseFactory.create(course_image=course_image)
student_module__in=[module.id for module in student_modules]
d = TreeEstimator(random_state=0, max_depth=max_depth).fit(X, y) s = TreeEstimator(random_state=0, max_depth=max_depth).fit(X_sparse, y)
return reverse_course_url( 'textbooks_detail_handler', self.course.id, kwargs={'textbook_id': textbook_id} )
y_train = self.y_train_ if y_train.ndim == 1: y_train = y_train[:, np.newaxis]
is_collection = False
self.top_words = self.top_dict( temp_all_words, self.num_top_words )
return render_to_response(*args, **kwargs)
coupon = Coupon(code=code, description='testing code', course_id=course_key, percentage_discount=self.percentage_discount, created_by=self.user, is_active=is_active) coupon.save()
else: return CommitOnSuccessManager(using, read_committed)
for n_comp in np.arange(1, X.shape[1]): pca = PCA(n_components=n_comp, svd_solver='randomized', random_state=0)
datasetCache = cache.datasetCache im_path = datasetCache.cache_file(im_path) label_path = datasetCache.cache_file(label_path)
url = xblock_studio_url(xblock) self.assertIsNotNone(url) resp = self.client.get_html(url) self.assertEqual(resp.status_code, 200) return resp.content
UserProfile(user=user).save()
problem = self.build_problem(answer="Second", case_sensitive=False)
leaf_ptr = self.dummy_leaf_.next_leaf_ leaves = [] while leaf_ptr is not None: leaves.append(leaf_ptr) leaf_ptr = leaf_ptr.next_leaf_ return leaves
return self._compiled_cache[2:]
tid = tid + random.choice(string.ascii_lowercase)
return "<p>{raw_body}</p>".format(raw_body=raw_body)
self.assertEqual(test, expected)
self.update_enrollment(is_active=False)
self.q(css=".action-toggle-notes").first.click() return self
n_jobs, n_estimators, starts = _partition_estimators(self.n_estimators, self.n_jobs)
X, y = datasets.make_classification(n_samples=2000, n_features=10, n_informative=3, n_redundant=0, n_repeated=0, shuffle=False, random_state=1)
url = reverse("progress", kwargs={"course_id": unicode(self.course.id)}) return self.client.get(url)
if not has_course_author_access(request.user, course_key): return HttpResponse(status=403)
return False
with self.assertNumQueries(1): RestrictedCourse.is_restricted_course(course_id) RestrictedCourse.is_disabled_access_check(course_id)
list_of_ids = [unicode(top_parent_object.location)] for child in top_parent_object.get_children(): list_of_ids.extend(id_list(child)) return list_of_ids
staff_role.add_users(self.user)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=0)
try:
if not self.q(css="input.practice_exam").present: return False
for __ in range(int(num_responses)): response_element = self.create_response_element(**kwargs)
middleware.RequestCache.clear_request_cache()
return User.objects.none()
self._create_search_index() super(StudioLibraryContainerCapaFilterTest, self).setUp()
EmptyPromise( lambda: self.current_form != old_form, "Finish toggling to the other form" ).fulfill()
payload['email'] = user.email
response = self.client.get(self.url) self.assert_no_xss(response, '<script>alert("XSS")</script>')
export_extra_content( export_fs, self.modulestore, self.courselike_key, xml_centric_courselike_key, 'custom_tag_template', 'custom_tags' )
rubric = RubricPage(self.browser) rubric.wait_for_page(timeout=60) return rubric
is_enrolled = CourseEnrollment.is_enrolled(self.user, self.course.id) self.assertFalse(is_enrolled)
assert_equals( '"' + mock_static_content.get_canonicalized_asset_path.return_value + '"', replace_static_urls(STATIC_SOURCE, DATA_DIRECTORY, course_id=COURSE_KEY) )
editable_fields[SplitTestFields.user_partition_id.name] = self._create_metadata_editor_info( SplitTestFields.user_partition_id )
assert len(self.hidden_layers) > 0
self.counter = 0
self.q(css=self.experiment_groups_css + " .new-button").first.click()
errstring = "Invalid course_id" with self.assertRaisesRegexp(CommandError, errstring): call_command('export_olx', 'x/y/z')
self._assert_course_verification_status(VERIFY_STATUS_APPROVED)
self.assertEqual(message.text, expected_message) self.assertEqual(message.type, expected_message_type)
err = ItemNotFoundError mock_get_course.return_value = err
all_assets.extend(course_assets.setdefault(asset_type, [])) asset_idx = all_assets.find(asset_key)
self.courseware_page.start_proctored_exam()
if not hasattr(self, 'center'): self.center = False if not hasattr(self, 'gcn'): self.gcn = False
'ENABLE_PREREQUISITE_COURSES': False,
X = iris.data[45:100, :] y = iris.target[45:100] solvers = ("lbfgs", "newton-cg", "liblinear") class_weight_dict = _compute_class_weight_dictionary(y)
codeparam_element = etree.SubElement(response_element, "codeparam")
for msg in all_messages: self.assertNotContains(response, msg)
x = X.mean(axis=0) d = clf.decision_function([x])
decision_only = OneVsRestClassifier(svm.SVR()).fit(X_train, Y_train) assert_raises(AttributeError, decision_only.predict_proba, X_test)
X2 = np.ones(17) kf = KFold(3) check_cv_coverage(kf, X2, y=None, labels=None, expected_n_iter=3)
try: user.email_user( subject, message, theming_helpers.get_value('default_from_email', settings.DEFAULT_FROM_EMAIL) )
self.assert_user_setting_event_emitted( setting='profile_image_uploaded_at', old=TEST_UPLOAD_DT, new=None )
X = np.linspace(0.1, 9.9, 20) X = np.atleast_2d(X).T
self.dbm = dbm
is_enrolled = CourseEnrollment.is_enrolled(self.user, self.course.id) self.assertFalse(is_enrolled)
answer_element = etree.SubElement(codeparam_element, "answer_display") answer_element.text = str(answer_display)
block_structure.request_xblock_fields('category')
if query: url += '?' + query
self.check_modal_shows_correct_contents(self.type_fields) self.advanced_settings.refresh_and_wait_for_load()
METRICS_WITH_NORMALIZE_OPTION = [ "accuracy_score", "jaccard_similarity_score", "zero_one_loss", ]
linkcode_resolve = make_linkcode_resolve('sklearn', u'https://github.com/scikit-learn/' 'scikit-learn/blob/{revision}/' '{package}/{path}#L{lineno}')
if logout_first: self.client.logout() self.client.login(username=self.user.username, password=self.user_password)
return self.skip_entrance_exam_button.click()
self.payment_and_verification_flow.webcam_capture() self.payment_and_verification_flow.next_verification_step(self.immediate_verification_page)
array_val = request.POST.getlist(key) answers[key] = request.POST[key] if len(array_val) == 0 else ','.join(array_val)
rate = '40/minute' def allow_request(self, request, view): return self.has_api_key_permissions(request) or super(EnrollmentUserThrottle, self).allow_request(request, view)
return cls.objects.filter( username=username, course__enabled=True, deadline__gt=datetime.datetime.now(pytz.UTC) ).select_related('course')
super(CertificatePage, self).__init__(browser) self.user_id = user_id self.course_id = course_id
self.youtube_configuration['time_to_response'] = 2.0 self.metadata = self.metadata_for_mode('youtube_html5')
self._update_release_dates(self.date_one, self.date_one, self.date_one) self._verify_release_date_source(self.sequential, self.chapter)
tasks = instructor_task.api.get_entrance_exam_instructor_task_history(course_id, entrance_exam_key, student)
nested_args = mapping.nest(theano_args) fixed_var_descr = self.cost.get_fixed_var_descr(model, nested_args) self.on_load_batch = fixed_var_descr.on_load_batch
self.enrollment.can_refund = True self.assertTrue(self.enrollment.refundable())
for i in range(self.n_layers_ - 1): end = start + layer_units[i + 1] self._intercept_indptr.append((start, end)) start = end
AutoAuthPage(self.browser, course_id=self.course_id).visit()
dict(safe_zip(range(-19, 20), range(-19, 20))),
start = datetime.now(UTC) self.add_icrv_xblock(related_assessment_name="Midterm A", start_date=start)
module_store = modulestore() course_items = import_course_from_xml( module_store, self.user.id, TEST_DATA_DIR, ['toy'], static_content_store=contentstore(), verbose=True ) course = course_items[0] verify_asset_locked_state(False)
self.user.is_active = user_is_active
input_dict = {'1_2_1': '42'} correct_map = problem.grade_answers(input_dict)
self.assertEqual(response.status_code, status_code) self.assertDictEqual(response.data, {'detail': msg})
assert_equal(grid_search_no_score.best_params_, grid_search.best_params_) assert_equal(grid_search.score(X, y), grid_search_no_score.score(X, y))
if DEBUG_ACCESS: log.debug(*args, **kwargs)
url = reverse('instructor_dashboard', kwargs={'course_id': unicode(course_key)}) if section is not None: url += u'#view-{section}'.format(section=section) return url
confirmation_message = self.cohort_management_page.get_cohort_discussions_message(key=key) self.assertEqual("Your changes have been saved.", confirmation_message)
self.database.connection._ensure_connected() return self.database.connection.max_wire_version
LogoutPage(self.browser).visit() AutoAuthPage(self.browser, course_id=self.course_id, staff=False).visit()
ForestEstimator = FOREST_ESTIMATORS[name] est = ForestEstimator(max_depth=1, max_leaf_nodes=4, n_estimators=1, random_state=0).fit(X, y) assert_greater(est.estimators_[0].tree_.max_depth, 1)
return []
anova_filter = SelectKBest(f_regression, k=3) clf = svm.SVC(kernel='linear')
assert_array_almost_equal(coef_unsorted.toarray(), coef_sorted.toarray()) assert_array_almost_equal(sparse_svc.predict_proba(X_test_unsorted), sparse_svc.predict_proba(X_test))
n_estimators, n_classes = self.estimators_.shape leaves = np.zeros((X.shape[0], n_estimators, n_classes))
xqueue_interface = XQueueInterface("http://example.com/xqueue", Mock())
fignum = 1
self.assertTrue(self.store.has_changes(component))
course = CourseFactory.create() create_account(self.USERNAME, self.PASSWORD, self.EMAIL)
return CertificateStatuses.is_passing_status(cert_status)
"Test for Annotation Xmodule functional logic."
return None
self.course_nav.go_to_vertical('Test Vertical-0') self.video.wait_for_video_player_render() self.video.speed = '2.0'
return self.q(css="div.problem span.message").text[0]
SYMMETRIC_METRICS = [ "accuracy_score", "unnormalized_accuracy_score", "hamming_loss", "jaccard_similarity_score", "unnormalized_jaccard_similarity_score", "zero_one_loss", "unnormalized_zero_one_loss",
clear_data_home(data_home=data_home) assert_false(os.path.exists(data_home))
self.verify_end_date('edX/toy/TT_2012_Fall')
mkn = max_kernel_norm dn = detector_normalization on = output_normalization
super(XMLParsingSystem, self).__init__(**kwargs) self.process_xml = process_xml
self.data = data
cohort_a = CohortFactory.create(course_id=course.id, name=u'Cohørt A', users=[user_a]) CourseUserGroupPartitionGroup( course_user_group=cohort_a, partition_id=cohort_scheme_partition.id, group_id=cohort_scheme_partition.groups[0].id ).save()
return JsonResponse( {"error": "If group_id is specified, user_partition_id must also be specified."}, 400 )
X = X_digits_binary[:50] y = y_digits_binary[:50]
success = 'correct' for answer_id in correct_map: if not correct_map.is_correct(answer_id): success = 'incorrect'
user, client_name = mock_get_id_token.call_args[0] self.assertEqual(user, self.user) self.assertEqual(client_name, "programs")
pass
if sparse: decay = .01
result = next(k for k in parse_result if isinstance(k, numbers.Number)) return result
return None
y_size = n_classes + 1 while (not allow_unlabeled and y_size == 0) or y_size > n_classes: y_size = generator.poisson(n_labels)
return True
assert_raises(ValueError, auc, [0.0], [0.1])
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
with self.assertRaises(ValueError): with store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course.id):
cohort_list[0].users.remove(*user_list) assert_events("removed", user_list, cohort_list[:1]) mock_tracker.reset_mock()
course_listing = self.q(css=".course").filter(lambda el: course_name in el.text).results
_params = [sharedX(rng.randn(5)), sharedX(rng.randn(5, 3)), sharedX(rng.randn(4, 4, 4))]
#templates_path.append('source/_templates')
if not old_is_active: new_enrollment.update_enrollment(is_active=False, skip_refund=True)
distances = np.sqrt(2. * distances) return children, n_components, n_leaves, parent, distances
class_mapping = defaultdict(int) class_mapping.default_factory = class_mapping.__len__ yt = self._transform(y, class_mapping)
warnings.warn("Do you really want to regularize the detector units to be more active than the pooling units?")
self.tree = etree.XML(problem_text)
CONFIG_FILE = open(settings.REPO_ROOT / "docs" / "lms_config.ini") CONFIG = ConfigParser.ConfigParser() CONFIG.readfp(CONFIG_FILE)
full_url = ( reverse(next_url, kwargs={'course_id': unicode(self.course.id)}) if next_url else next_url )
assert_allclose(ecov.error_norm(prec_pred[k]), 0, atol=0.1)
COURSE_REGEX = re.compile(r'^(.*?/courses/)(?!v[0-9]+/[^/]+){}'.format(settings.COURSE_ID_PATTERN))
example_input[1, 3] = 0.0 example_input[1, 4] = 1.0
self._check_vocabulary() return [t for t, i in sorted(six.iteritems(self.vocabulary_), key=itemgetter(1))]
yield found + 1, "E201 whitespace after '%s'" % char
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
field_dict.update(self._field_overrides.get(name, {}))
ModeCreationPage(self.browser, self.course_id).visit()
children = self.q(css='.note-section') return [EdxNotesSubsectionGroup(self.browser, child.get_attribute("id")) for child in children]
self.user = user self.role = role
if settings.FEATURES.get('EMBARGO'): urlpatterns += ( url(r'^embargo/', include('embargo.urls')), )
if dataset.y is not None: dataset.y = numpy.repeat(dataset.y, num_patches / X.shape[0])
if self._usage_key is None: self._usage_key = self.get_course_key().make_usage_key_from_deprecated_string(self._results_fields["id"]) return self._usage_key
if all_students and student: return HttpResponseBadRequest( "all_students and unique_student_identifier are mutually exclusive." ) if all_students and delete_module: return HttpResponseBadRequest( "all_students and delete_module are mutually exclusive." )
content = map(lambda l: l[:-1].split(', '), content)
self.assertOrphanCount(course.id, 1) self.assertOrphanCount(published_branch, 1)
for svd_10, svd_20 in svds_10_v_20: assert_array_almost_equal( svd_10.explained_variance_ratio_, svd_20.explained_variance_ratio_[:10], decimal=5, )
self.assertFalse(course.is_cohorted)
lw = LedoitWolf() loglik_lw = lw.fit(X_train).score(X_test)
pass
regex = r'^\d+'
update_url = reverse_usage_url("xblock_handler", usage_key) return self.client.ajax_post( update_url, data={ 'metadata': metadata, } )
self.assertEqual(module.attempts, 1)
FEATURES['EMBARGO'] = True
post_params = sign(self.CLIENT_POST_PARAMS)
params.pop('svc') params.pop('anova') params2.pop('svc') params2.pop('anova') assert_equal(params, params2)
clf = self.factory() assert_raises(ValueError, clf.fit, X2, Y2, coef_init=np.zeros((2, 2)))
self.assert_enrollment_status(expected_status=status.HTTP_401_UNAUTHORIZED)
(ModuleStoreEnum.RevisionOption.published_only, 'assertOLXIsDeleted'), (ModuleStoreEnum.RevisionOption.all, 'assertOLXIsDeleted'), (None, 'assertOLXIsDeleted'),
return self.get_text('.title')
self.problem_page.click_choice('choice_choice_1') self.problem_page.click_check() self.problem_page.wait_for_expected_status('label.choicegroup_incorrect', 'incorrect')
self.assertContains(resp, 'Robot_Super_Course')
num_incorrect = num_pool - 1 num_incorrect = min(num_incorrect, len(incorrect_choices))
self.centroids_ = self.init_centroids_[:n_samples + 1, :] self.squared_norm_ = self.init_sq_norm_[:n_samples + 1]
non_displayed_tabs = set(old_tab_list) - set(new_tab_list) new_tab_list.extend(non_displayed_tabs)
self.new_post_button.click() EmptyPromise( lambda: ( self.new_post_form ), "New post action succeeded" ).fulfill()
cohort = CohortFactory(course_id=self.course.id, users=[]) self._verify_non_staff_cannot_access( add_users_to_cohort, "POST", [unicode(self.course.id), cohort.id] )
for test_index in self._iter_test_indices(X, y, labels): test_mask = np.zeros(_num_samples(X), dtype=np.bool) test_mask[test_index] = True yield test_mask
if sp.issparse(X): centers = _k_means._centers_sparse(X, labels, n_clusters, distances) else: centers = _k_means._centers_dense(X, labels, n_clusters, distances)
_view_name = "profile_image_remove" _replacement_method = 'openedx.core.djangoapps.profile_images.views.ProfileImageView.delete'
train = yaml_parse.load(yaml_file) train.main_loop()
pass
dbm = make_random_basic_binary_dbm( rng = rng, pool_size_1 = pool_size_1, )
emp_cov = np.dot(X.T, X) / n_samples
from .xqueue import * from .support import * from .webview import *
path = microsite_tags.microsite_template_path('footer.html') self.assertEqual("footer.html", path)
clf = LogisticRegressionCV(cv=precomputed_folds) clf.fit(train, target)
self.wait_for_captions() captions_selector = self.get_element_selector(CSS_CLASS_NAMES['captions_text']) subs = self.q(css=captions_selector).html return ' '.join(subs)
if len(new_name) < NAME_MIN_LENGTH: raise serializers.ValidationError( "The name field must be at least {} characters long.".format(NAME_MIN_LENGTH) ) return new_name
iris = load_iris() perm = rng.permutation(iris.target.size) iris.data = iris.data[perm] iris.target = iris.target[perm]
self.assertNotContains(response, "How it Works") self.assertNotContains(response, "Schools & Partners")
response = self.client.get(reverse("dashboard")) self.assertHttpOK(response)
patcher = patch('config_models.models.cache', Mock(get=Mock(return_value=None))) patcher.start() self.addCleanup(patcher.stop)
self.user.is_active = False self.user.save()
dlogz = self.log_mean(log_ais_w)
post_login_handler = _finish_auth_url(params) js_success_var = 'var nextUrl = "{}";'.format(post_login_handler) self.assertContains(response, js_success_var)
httpretty.register_uri( httpretty.POST, re.compile(r"http://localhost:4567/api/v1/(\w+)/threads"), body=_get_thread_callback(thread_data) )
if get_parents and current_node != start_node: parents = get_parents(current_node)
world.css_click(button_class) perform_action_in_plugin(action)
return self.user
if create_after_overview: self.assertFalse(hasattr(course_overview, 'image_set')) self.set_config(enabled=True) course_overview = CourseOverview.get_from_id(course.id)
state = dict(self.__dict__) state.pop('f_', None) return state
if not hasattr(self, 'mask_weights'): self.mask_weights = None
from ._scipy_sparse_lsqr_backport import lsqr as sparse_lsqr
iris = datasets.load_iris() X, y = iris.data[:, 1:3], iris.target
clf = ForestClassifier(random_state=0).fit(X, y)
n_clusters_1 = len(set(labels)) - int(-1 in labels) assert_equal(n_clusters_1, n_clusters)
self.assertFalse(views.is_course_passed(self.course, None, self.student, self.request))
for output_dir in [self.temp_dir_1, self.temp_dir_2]: call_command('export', course_id, output_dir)
before = attempt.created_at - timedelta(seconds=1) self.assertFalse(attempt.active_at_datetime(before))
teams_configuration = {} teams_configuration["topics"] = [] if topics is None else topics if max_team_size is not None: teams_configuration["max_team_size"] = max_team_size self.course.teams_configuration = teams_configuration
assert layer_name is None
for code in sorted_codes: print(code + '. ' + codebook[code])
return cls.objects.filter(course_id=course_key, status=status).count()
cv_iter = list(cv_iter) scorer = check_scoring(estimator, scoring=scoring)
c = GSNCost( [ (0, 1.0, reconstruction_cost),
url = "{base}/course_modes/choose/{course_id}/".format( base=BASE_URL, course_id=self._course_id ) return url
X = np.arange(-200, 200) y = 0.2 * X + 20 data = np.column_stack([X, y])
self.unit_page.xblocks[xblock_index].edit()
self.refresh_cached_metadata_inheritance_tree(xblock.scope_ids.usage_id.course_key, xblock.runtime)
self.update_structure(usage_locator.course_key, new_structure)
self.assertIsNone(self.request.session.get(SESSION_KEY))
mock_object = Mock() object_config = { 'pk': obj_id, 'name': "object {}".format(obj_id) } mock_object.configure_mock(**object_config) return mock_object
for n_neighbors in [3, 5, 7]: I_computed = _compute_mi(x, y, False, False, n_neighbors) assert_almost_equal(I_computed, I_theory, 1)
return self.q(css='h1.page-header-title').text
XA_checked, XB_checked = check_pairwise_arrays(XA, XB) assert_equal(XA_checked.dtype, np.float32) assert_equal(XB_checked.dtype, np.float32)
feature_names=feature_names[:-1], DESCR=descr_text)
ax_response.toMessage(response.fields)
return [CourseEnrollmentFactory(user=self.user, course_id=c) for c in course_ids]
self.assertEqual(tab.name, expected_name)
pass
user = User.objects.get(username=username) world.scenario_dict['USER'] = user
cv = list(super(StratifiedValidationKFold, self).__iter__()) for train, valid, test in get_k_fold_splits(cv): yield train, valid, test
BULK_EMAIL_ROUTING_KEY_SMALL_JOBS = LOW_PRIORITY_QUEUE
assert_true(X_scaled is not X)
need_space = (prev_end, start != prev_end)
response = self.api_response() self.assertIn("/courses/{}/jump_to_id/".format(self.course.id), response.data['handouts_html'])
return np.log(x / (1. - x))
f = np.asarray(f).ravel() prob = special.fdtrc(dfbn, dfwn, f) return f, prob
clf = self.factory(alpha=0.1, n_iter=1000, class_weight={0: 0.5}) clf.fit(X, Y)
response = client2.post(self.url, creds) self._assert_response(response, success=True)
return sorted(modules_by_category[category], key=get_module_sort_key)
pass
self.assertIsNone(course_outline_initial_state('no-such-locator', course_structure))
self.store.mappings = {} course_key = self.course_locations[self.MONGO_COURSEID].course_key with check_exact_number_of_calls(self.store.default_modulestore, 'has_course', 1):
print('Loading model...') model = serial.load(model_path) model.set_batch_size(m) return model
if p.active and p.groups and (schemes is None or p.scheme.name in schemes):
child._field_data.set(child, 'due', child_due) compute_inherited_metadata(descriptor) self.override_metadata_check(descriptor, child, course_due, child_due)
plt.subplots_adjust(wspace=0.25) plt.show()
course = self.store.get_course(self.course.id, depth=None)
rng = np.random.RandomState(0) noise = noise_scale * rng.randn(*X.shape) X_iso2 = iso.transform(X + noise)
if serialized_block['id'] == unicode(self.html_block.location): self.assertTrue(serialized_block['visible_to_staff_only']) else: self.assertFalse(serialized_block['visible_to_staff_only'])
a = '\xe0\xe1\xe2\xe3\xe4\xe5\xe7\xe8\xe9\xea\xeb' expected = 'aaaaaaceeee' assert_equal(strip_accents_ascii(a), expected)
print "running action..." action(eobjs.email)
'session_inactivity_timeout.middleware.SessionInactivityTimeout',
FEATURES['ORGANIZATIONS_APP'] = True
errstring = "Unparsable course_id" with self.assertRaisesRegexp(CommandError, errstring): call_command('export_olx', 'InvalidCourseID')
pygments_style = 'sphinx'
if hasattr(course, 'syllabus_present') and course.syllabus_present: course.tabs.append(CourseTab.load('syllabus'))
diabetes_y_train = diabetes.target[:-20] diabetes_y_test = diabetes.target[-20:]
data = np.copy(X.data[start: end]) nz = n_samples - data.size median[f_ind] = _get_median(data, nz)
self.assert_enrollment_activation(False, selected_mode)
for missing in SUBMISSION_RESET_KWARGS: kwargs = SUBMISSION_RESET_KWARGS.copy() del kwargs[missing] submissions_score_reset_handler(None, **kwargs) self.signal_mock.assert_not_called()
if r == 0: return True
edge_model = covariance.GraphLassoCV()
response = self.client.get(reverse('verify_student_create_order'), create_order_post_data) self.assertEqual(response.status_code, 405)
assert_equal('Paragraph', dropdowns[0].text) assert_equal('Font Family', dropdowns[1].text)
random_state = check_random_state(0) y_true = random_state.randint(0, 2, size=(n_samples, )) y_pred = random_state.randint(0, 2, size=(n_samples, ))
chapter_aside.data_field = 'another one value' self.store.update_item(new_chapter, self.user_id, asides=[chapter_aside])
p, h = max_pool_c01b(z, (pool_rows, pool_cols), top_down = t) func = function([z, t], [p, h], mode = mode_without_gpu)
url_path = embargo_api.message_url_path(self.course.id, 'courseware') self.assertEqual(url_path, '/embargo/blocked-message/courseware/default/')
try: return getattr(self, '_%s_cache' % related_name) except AttributeError: pass
ext_user = User.objects.get(email=self.ext_user.email) self.assertTrue(auth.user_has_role(ext_user, CourseInstructorRole(self.course.id)))
self.update_version = edit_info.get('update_version', None)
if subtitles: self.assets.append('subs_3_yD_cEKoCk.srt.sjson') self.navigate_to_course_unit()
still_in_grace = CapaFactory.create(showanswer='past_due', max_attempts="1", attempts="1", due=self.yesterday_str, graceperiod=self.two_day_delta_str) self.assertFalse(still_in_grace.answer_available())
if not request.user.is_authenticated(): raise PermissionDenied delete_user_preference(request.user, NOTIFICATION_PREF_KEY) return HttpResponse(status=204)
_, labels_no_copy = affinity_propagation(S, preference=preference, copy=False) assert_array_equal(labels, labels_no_copy)
target = [-1] * len(JUNK_FOOD_DOCS) + [1] * len(NOTJUNK_FOOD_DOCS)
y = test['y'][:, 0] - 1 assert y.shape == (8000,)
course = CourseFactory.create() create_account(self.USERNAME, self.PASSWORD, self.EMAIL)
data_to_sign = self._compute_digest(user_id) self.signature = signing.dumps(data_to_sign, salt=self.key_salt)
LETTUCE_SELENIUM_CLIENT = os.environ.get('LETTUCE_SELENIUM_CLIENT', 'local')
cc_thread, context = _get_thread_and_context(request, thread_id) if can_delete(cc_thread, context): cc_thread.delete() thread_deleted.send(sender=None, user=request.user, post=cc_thread) else: raise PermissionDenied
self.X_topo_space = self.view_converter.topo_space
raise NotImplementedError
elem = self.get_setting_element(label) select = Select(elem) select.select_by_value(value) self.save()
if is_whitelisted: LOGGER.info( u"Student %s is whitelisted in '%s'", student.id, unicode(course_id) ) passing = True else: passing = False
add_function_parentheses = False
self.service.remove_credit_requirement_status( self.user.id, no_credit_course.id, 'grade', 'grade' )
packages_really_to_upgrade=[] for this_package in packages_to_upgrade: if this_package in installed_packages_list:
self.duration_sec = 'unknown'
axis = uniques
epsilon = 1e-9 * np.var(X, axis=0).max()
reg = LinearRegression(fit_intercept=intercept) reg.fit(X, y, sample_weight=sample_weight) coefs1 = reg.coef_ inter1 = reg.intercept_
assert_equal(lfw_people.images.shape, (10, 62, 47)) assert_equal(lfw_people.data.shape, (10, 2914))
query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(None, query) self.assertIs(result, None)
raise NotImplementedError()
self._set_block_values(block_structure, self.transform_data_key)
_step.given('I edit the component') world.wait_for_ajax_complete() _step.given('I save changes')
return PROCESSOR_MODULE.get_purchase_endpoint()
self.assertEqual(max_scores_cache.num_cached_from_remote(), 1)
self.user = User.objects.get(pk=self.user.pk)
cost = SumOfCosts([SumOfParams(), (0., DummyCost())])
def __init__(self, role, org): super(OrgRole, self).__init__(role, org)
post_params = {key: json.dumps(val)} response = requests.put(self.url, data=post_params) self.assertEqual(response.status_code, 200)
msg = etree.tostring(fromstring_bs(msg, convertEntities=None), pretty_print=True)
return CoursewareSearchIndexer.do_course_reindex(store, self.course.id)
url = self.reverse_url(reverse_args, **kwargs) response = self.url_method(url, **kwargs) if expected_response_code is not None: self.assertEqual(response.status_code, expected_response_code) return response
TASK_LOG = logging.getLogger('edx.celery.task')
CELERYD_PREFETCH_MULTIPLIER = 1
return [fold.set_input_space(space) for fold in self._folds]
self.assert_no_xpath(xml, "//label[@class='choicegroup_incorrect']", self.context)
'openedx.core.djangoapps.credentials',
startup.enable_microsites() directories = LOOKUP['main'].directories self.assertEqual(len([directory for directory in directories if 'external_module' in directory]), 1)
return structure_key
return function([], T.cast(T.argmax(self.estimated_rewards), 'int32'))
self.create_mode('professional', 'Professional Education Verified Certificate', 10)
return [ parent_block_key for parent_block_key, value in structure['blocks'].iteritems() if block_key in value.fields.get('children', []) ]
request_info = xmodule_instance_args.get('request_info', {}) if xmodule_instance_args is not None else {} task_info = {'student': student.username, 'task_id': _get_task_id_from_xmodule_args(xmodule_instance_args)}
if state == {}: continue
self.send_response(200) self.send_header('Content-type', 'application/json') self.end_headers() self.wfile.write(response)
(self.gx, self.gy) = [int(x) - 15 for x in m.groups()]
z = self.sample_from_p_z(num_samples=num_samples, **kwargs) theta = self.decode_theta(z) X = self.sample_from_p_x_given_z(num_samples=num_samples, theta=theta)
with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, course_key): self.assertTrue(self.store.has_item(problem_location)) assertProblemNameEquals(problem_original_name)
return super(AdaBoostRegressor, self).fit(X, y, sample_weight)
err = Exception mock_index_dictionary.return_value = err
prior = DummyPrior() vae = DummyVAE() prior.set_vae(vae) prior.set_vae(vae)
return view_func(request, *args, **kwargs)
item = self.get_item(item_location)
out = out + out.T
course_names = self.dashboard_page.wait_for_page().available_courses self.assertIn(self.course_info["display_name"], course_names)
p, h = prob_max_pool_c01b(z, (pool_rows, pool_cols), top_down = t) func = function([z, t], [p, h], mode = mode_with_gpu)
with self.assert_logged(r'SafeCookieData signature error .*|test_session_id|.*: ' + sig_error_string): yield
student = self._user_factory_with_history() self.assertFalse(PasswordHistory.is_password_reset_too_soon(student))
if feature_names is None: feature_names = [str(i) for i in range(gbrt.n_features)] elif isinstance(feature_names, np.ndarray): feature_names = feature_names.tolist()
segments = mailchimp.listStaticSegments(id=list_id) for seg in segments: if seg['name'].startswith('random'): mailchimp.listStaticSegmentDel(id=list_id, seg_id=seg['id'])
p = safe_sparse_dot(v, self.components_.T) p += self.intercept_hidden_ return expit(p, out=p)
return self.courses.values()
iris = load_iris()
return self.backend_name == social_auth.provider
course_url = '/home/' resp = self.client.get_html(course_url) self.assertEquals(resp.status_code, 200)
return self.q(css="a.remove-attempt").present
for gen in xrange(3): gc.collect(gen) scanner.dump_all_objects( format_str.format("gc-gen-{}".format(gen)) )
self.assertEquals(resp.status_code, 400)
wiki_slug = None wiki_tag = xml_object.find("wiki") if wiki_tag is not None: wiki_slug = wiki_tag.attrib.get("slug", default=None) xml_object.remove(wiki_tag)
FEATURES['ENABLE_TEAMS'] = True
transformed_grid = hasher.transform(np.c_[xx.ravel(), yy.ravel()]) y_grid_pred = nb.predict_proba(transformed_grid)[:, 1]
from django.core.wsgi import get_wsgi_application
courses, in_process_course_actions = _accessible_courses_summary_list(request)
grader_payload = xqueue_body.get('grader_payload')
if modes_dict is None: modes_dict = cls.modes_for_course_dict(course_id) if cls.HONOR in modes_dict: return cls.HONOR elif cls.AUDIT in modes_dict: return cls.AUDIT
try: config = cls.objects.get(course_key=course_key) return config.verified_cohort_name except cls.DoesNotExist: return None
scaler_batch = MinMaxScaler().fit(X)
OAUTH2_PROVIDER_APPLICATION_MODEL = 'oauth2_provider.Application'
email, password = self._create_unique_user()
self.certificates_section.fill_certificate_invalidation_user_name_field(invalid_user) self.certificates_section.click_invalidate_certificate_button() self.certificates_section.wait_for_ajax()
self.page.visit()
context = { "request": get_request_or_stub() }
VISIBLE_CONTENT = [ ['class=&#34;problems-wrapper'], ['Some HTML for group 1'] ]
course_outline_page = CourseOutlinePage( self.browser, new_org, self.course_number, self.course_run ) course_outline_page.visit() course_outline_page.wait_for_page()
with self.assertRaisesRegexp(CommandError, 'Error: too few arguments'): call_command('delete_orphans')
n_samples = X_diabetes.shape[0]
shrinkages = np.logspace(-2, 0, 30) negative_logliks = [-ShrunkCovariance(shrinkage=s).fit(X_train).score(X_test) for s in shrinkages]
return hasattr(self, '_has_shuffle')
permutation = np.asarray(permutation, dtype=np.intp) return _update_cdnmf_fast(W, HHt, XHt, permutation)
ovr = OneVsRestClassifier(LinearSVC(random_state=0)) assert_raises(ValueError, lambda x: ovr.coef_, None)
CourseFinanceAdminRole(self.course.id).add_users(self.instructor)
from __future__ import unicode_literals
return self.enabled and self.enable_certification
X = np.atleast_2d(np.random.uniform(0, 10.0, size=100)).T X = X.astype(np.float32)
cohort = get_course_cohorts(self.course)[0]
user2 = UserFactory.create(email=self.new_email, password="test2")
new_lr = self._base_lr / (self.decay_factor ** self._count) if new_lr <= self.min_lr: self._min_reached = True new_lr = self.min_lr
train.algorithm.termination_criterion = EpochCounter(max_epochs=1) train.extensions.pop(0) train.save_freq = 0 train.main_loop()
precision = [1.] recall = [0.] tp = 0 fp = 0 fn = len(pos_scores) count = fn
return ( self.q(css="#login-anchor").is_present() and self.q(css="#register-anchor").is_present() and self.current_form is not None )
unique_together = (('microsite', 'template_uri'),)
Push.alert( data=push_payload, channels={"$in": push_channels}, where={"deviceType": "android"}, )
return self.qty * self.unit_cost
return CourseFactory.create( org=course_location.org, number=course_location.course, run=course_location.run )
if not hasattr(self, 'names_to_del'): self.names_to_del = set() self.names_to_del = self.names_to_del.union(names)
pass
self.assertTrue(profile_page.profile_has_default_image) self.assertTrue(profile_page.profile_has_image_with_public_access())
Axes3D
parent_element.remove(solution_element)
if child.location.category == 'problem': c_problem += 1 stack_data = []
y = column_or_1d(y, warn=True) _check_numpy_unicode_bug(y) self.classes_ = np.unique(y) return self
self.assertEqual(len(httpretty.httpretty.latest_requests), 1)
mongo_course = self.store.get_course(self.course_locations[self.MONGO_COURSEID].course_key) mongo_course.wiki_slug = 'simple' self.store.update_item(mongo_course, self.user_id)
assert_true(X_scaled is not X)
request = get_request_for_user(user) request.method = method request.META = {'CONTENT_TYPE': ['application/json']} request.body = body request.session = session or {} return request
message = models.CharField(max_length=MAX_MESSAGE_LENGTH)
on_course_publish(course_key)
return self.ebm.free_energy(X)
'submissions', 'openassessment', 'openassessment.assessment', 'openassessment.fileupload', 'openassessment.workflow', 'openassessment.xblock',
self.enrollment.can_refund = True self.assertTrue(self.enrollment.refundable())
if not os.path.isdir(orig_path): raise IOError("You need to download the SVHN format2 dataset MAT files " "before running this conversion script.")
self.q(css='.add-xblock-component-button[data-type={}]'.format(category_type)).first.click() return self.q(css='.{}-type-tabs>li>a'.format(category_type)).text
self.assertEqual(initially_enrolled, CourseEnrollment.is_enrolled(self.user, course_id))
user = User.objects.get(email=staff_email) token = default_token_generator.make_token(user) uidb36 = int_to_base36(user.id)
self.run_prereqs(X, d) a(*X) actual_ne += self._flat_data_specs[0].np_batch_size(X)
make_asset_xml(num_assets, ASSET_XML_PATH) validate_xml(ASSET_XSD_PATH, ASSET_XML_PATH)
h_rows, h_cols = self.h_space.shape num_h = float(h_rows * h_cols) rval[self.transformer._filters] = 1. /num_h rval[self.b] = 1. / num_h
module = CapaFactory.create(rerandomize=RANDOMIZATION.ALWAYS, done=True) self.assertFalse(module.should_show_save_button())
for label, clf_err in error_rate.items(): xs, ys = zip(*clf_err) plt.plot(xs, ys, label=label)
topo = self.train.get_batch_topo(1) assert topo.ndim == 4
template_obj = MicrositeTemplate.get_template_for_microsite( microsite_get_value('site_domain'), uri )
Xt = X for name, transform in self.steps[:-1]: Xt = transform.transform(Xt) return self.steps[-1][-1].decision_function(Xt)
self._aborting = False if not self._managed_pool: n_jobs = self._initialize_pool() else: n_jobs = self._effective_n_jobs()
fig, axs = plot_partial_dependence(clf, boston.data, ['CRIM', 'ZN', ('CRIM', 'ZN')], grid_resolution=grid_resolution, feature_names=boston.feature_names)
return settings.STATIC_URL + relative_url
binarized = label_binarize(y, classes, neg_label=neg_label, pos_label=pos_label, sparse_output=sparse_output) assert_array_equal(toarray(binarized), expected) assert_equal(issparse(binarized), sparse_output)
safe_exec("rnums = [random.randint(0, 999) for _ in xrange(100)]", g, random_seed=17) self.assertEqual(g['rnums'], rnums)
_, s, _ = linalg.svd(X, full_matrices=False)
CountryAccessRule.objects.all().delete()
self.store.publish(self.vertical_x1a, self.user_id) self.store.publish(problem_location, self.user_id)
assert_greater(mb_k_means.cluster_centers_.any(axis=1).sum(), 10)
X_train, X_test, y_train, y_test = train_test_split(cal_housing.data, cal_housing.target, test_size=0.2, random_state=1) names = cal_housing.feature_names
_ = self.runtime.service(self, "i18n").ugettext check = _('Check') final_check = _('Final Check')
self.go_to_tab_and_assert_problem(1, self.problem1_name) problem1_content_after_coming_back = self.problem_page.problem_content self.assertEqual(problem1_content_before_switch, problem1_content_after_coming_back)
paid_course = CourseFactory.create() CourseModeFactory.create(course_id=paid_course.id, min_price=50, mode_slug=CourseMode.HONOR) CourseInstructorRole(paid_course.id).add_users(self.instructor) return paid_course
verify_date_or_time(COURSE_END_TIME_CSS, DEFAULT_TIME) verify_date_or_time(ENROLLMENT_START_TIME_CSS, DEFAULT_TIME) verify_date_or_time(ENROLLMENT_END_TIME_CSS, DUMMY_TIME)
if display_name is not None: metadata['display_name'] = display_name
return theano.function(*args, on_unused_input='ignore', **kwargs)
course = get_course_and_check_access(course_key, user)
self.mean_ = numpy.mean(X, axis=0) X -= self.mean_
return False
for student in students[:4]: self.assertIn( GeneratedCertificate.certificate_for_student(student, self.course.id).status, CertificateStatuses.PASSED_STATUSES )
self.check_index_and_outline(self.client)
return self.q(css="{} .action-close".format(self.TAB_SELECTOR)).present
df += int(self.smooth_idf) n_samples += int(self.smooth_idf)
continue
world.clear_courses()
self.store.mappings.clear() library = self.store.get_library(library_key) self.assertEqual(library.location.library_key, library_key)
response = self.client.post(reverse('admin:student_courseaccessrole_add'), data=data) self.assertRedirects(response, reverse('admin:student_courseaccessrole_changelist'))
skip_if_no_sklearn() mapping = {'dataset_iterator': 'StratifiedDatasetValidationKFold'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
self._update_release_dates(self.date_one, self.date_two, self.date_two) self._verify_release_date_source(self.sequential, self.sequential)
staff_user = UserFactory.create() CourseStaffRole(self.course.location.course_key).add_users(staff_user)
state_below=dbm.hidden_layers[-2].upward_state(H_hat[-1])))
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_key_string)
COURSE_NAME = 'manual-testing-complete'
sequential.display_name = 'sequential1' sequential = self.store.update_item(sequential, self.user_id) self.assertTrue(self.store.has_published_version(sequential))
user = User.objects.select_related('profile').get(username=username)
mean_tpr = np.zeros_like(all_fpr) for i in range(n_classes): mean_tpr += interp(all_fpr, fpr[i], tpr[i])
self._tags[course_id][key] = value
self.refresh_course()
X = rng.randint(0, 4, size=(1000, 1)) y = rng.rand(1000) n_trees = 500
self.login_staff() content = self.get_course_info_page().content self.assertIn("OOGIE BLOOGIE", content)
parent_ids = [ valid_parent for valid_parent in all_parent_ids if self.has_path_to_root(valid_parent, course) ]
face = sp.face(gray=True)
h = alpha_i * np.ones(s_i) - np.dot(Vi.T, np.ones(n_neighbors))
filename = '_' + fragment_name contents[filename] = fragment
self.course_nav.q(css='button.check.Check').click() self.course_nav.wait_for_ajax()
self.class_weight_ = np.empty(0) return column_or_1d(y, warn=True).astype(np.float64)
gp.fit(X, y)
if len(y.shape) != 1: G_diag = G_diag[:, np.newaxis] return G_diag, c
return not self.user_partition_id == SplitTestFields.no_partition_selected['value']
do_test(1)
breadcrumbs = self.q(css=self.BOOKMARKED_BREADCRUMBS).text return [breadcrumb.replace('\n', '').split('-') for breadcrumb in breadcrumbs]
assert_almost_equal(s[:k], sa)
self.assertEqual(resp.status_code, 200)
for idx in range(3): self._create_cert(self.courses[idx].id, self.user, CertificateStatuses.error)
self.assertContains(resp, 'Robot_Course_Outside_Microsite')
split_tests = store.get_items(course.id, qualifiers={'category': 'split_test'}) return GroupConfiguration._get_content_experiment_usage_info(store, course, split_tests)
num_students = len(students) self.assertDictContainsSubset({'attempted': num_students, 'succeeded': num_students, 'failed': 0}, result)
if position != seq_module.position: seq_module.position = position
self.__init__()
X = np.atleast_2d([1., 3., 5., 6., 7., 8.]).T
DEBUG = False USE_TZ = True SESSION_COOKIE_SECURE = False SESSION_SAVE_EVERY_REQUEST = False SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'
_write_test_file(file_name, "This is an arbitrary file for testing uploads")
'openedx.core.djangoapps.common_views',
response = urllib2.urlopen(req)
response = self.client.post(reverse('admin:student_courseaccessrole_add'), data=data) self.assertRedirects(response, reverse('admin:student_courseaccessrole_changelist'))
verify_order(self.html_usage_key, self.seq_usage_key, 2) verify_order(self.seq_usage_key, self.chapter_usage_key, 0)
context['accomplishment_copy_course_description'] = _('a course of study offered by ' '{partner_short_name}.').format( partner_short_name=context['organization_short_name'], platform_name=platform_name)
pass
return ''.join(traceback.format_exception(*exc_info))
if vertical: return '{vertical} {video_element}'.format( vertical=self.get_video_vertical_selector(self.current_video_display_name), video_element=class_name) else: return class_name
course_fixture.add_children(*[ self._build_fixture(self.UnitState(*state)) for state in itertools.product(*features) ])
return middleware.RequestCache.get_request_cache(name)
try: return content and content['user_id'] == str(user.id) except KeyError: return False
STATIC_GRAB = False DEV_CONTENT = True
required_fields = set(fields) all_fields = set(self.fields.keys()) for field_name in all_fields - required_fields: self.fields.pop(field_name)
allowed_params = ('page', 'page_size', 'text')
if '.' + transcript_format not in self.q(css=transcript_selector).text[0]: return False
self.client.login(username=self.global_staff.username, password="test")
return '{0.org}_{0.course}'.format(course_key)
assert_raises(ValueError, MLPClassifier( algorithm='sgd').partial_fit, X, y, classes=[2])
raise NotImplementedError(str(self.__class__) + " does not " + "implement kl_divergence")
return self._get_course_info(request, course)
EXAMPLE_SLUG = '15bb687e0c59ef2f0a49f6838f511bf4ca6c566dd45da6293cabbd9369390e1a'
try: return X.iloc[indices] except ValueError: warnings.warn("Copying input dataframe for slicing.", DataConversionWarning) return X.copy().iloc[indices]
instance = kwargs['instance'] instance.orig_state = instance.state
private_vertical = get_and_verify_publish_state('vertical', self.PRIVATE_VERTICAL, False)
expr = stripXML(self.mathml_start + expr + self.mathml_end) expected = stripXML(self.mathml_start + expected + self.mathml_end)
if thirdparty: scheme = "https" if settings.HTTPS == "on" else "http" url = '{scheme}://{host}{path}'.format( scheme=scheme, host=settings.SITE_NAME, path=url )
raise ItemNotFoundError(usage_locator)
self.video.show_captions()
self.attributes["commentable_id"] = self.attributes["id"] self.retrieved = True return self
OAUTH_OIDC_ISSUER = 'https://www.example.com/oauth2'
return self.storage_space.np_format_as(design_mat, self.topo_space)
root = get_or_create_root()
self._check_non_staff_light(self.course) self._check_non_staff_dark(self.course) self._check_non_staff_light(self.test_course) self._check_non_staff_dark(self.test_course)
ridge.fit(X, y, sample_weight=np.ones(n_samples)) assert_greater(ridge.score(X, y), 0.47)
b = np.zeros((self.dim * 3,))
result = symmath_check(expected_str, expected_str, dynamath=[dynamath]) self.assertTrue('ok' in result and result['ok'])
#add_module_names = True
X = np.arange(100)[:, np.newaxis] y = np.ones(100) y[:50] = 0.0
spaces = map(lambda c: get_space(c[0]), self.costs)
with self.assertNumQueries(0): self.assertRaises(KeyError, self.kvs.get, user_state_key('not_a_field'))
pass
return cls.verification_valid_or_pending(user, earliest_allowed_date, queryset).exists()
for param, value in zip(self.get_params(), values): param.set_value(value, borrow=borrow)
model = Bookmark fields = ( 'id', 'course_id', 'usage_id', 'block_type', 'display_name', 'path', 'created', )
return re.compile(r"<([^>]+)>", flags=re.UNICODE).sub(" ", s)
self.track_selection_page.visit()
image_shape = (64, 64)
self.cohort_management_page.select_discussion_topic(self.inline_key)
self.assertContains( self.client.ajax_post(course_update_url, {'garbage': 1}), 'Failed to save', status_code=400 )
return self.filter_by(data, "usage_id", usage_id)
super(CertificatesListHandlerTestCase, self).setUp('contentstore.views.certificates.tracker')
G = neighbors.kneighbors_graph(X, n_neighbors, mode='distance').toarray()
composite_space = CompositeSpace(spaces) sources = tuple(sources) return (composite_space, sources)
with check_mongo_calls_range(max_finds=4, max_sends=2): self._update_partitions(reload_items=False)
additional_data = { u'video_bumper': { u'value': { "transcripts": {}, "video_id": "video_001" } } } self.course_fixture.add_advanced_settings(additional_data)
emails = list(emails)
user = User.objects.get(email=email) self.assertFalse(user.is_active) return user
return self.entrance_exam_message_selector.is_present()
all_assets, count = content_store.get_all_content_for_course(course.id) self.assertEqual(len(all_assets), 0) self.assertEqual(count, 0)
self.assertTrue(retry.called) (__, kwargs) = retry.call_args exc = kwargs['exc'] self.assertIsInstance(exc, SMTPDataError)
get_request_dict = {} result = module.reset_problem(get_request_dict)
object_image_index = [0, ] blank_image_index = [0, ] blank_label = _get_blank_label(dataset)
parent.insert(parent.index(next_include), incxml)
X, y = X[y < 2], y[y < 2]
unicode_text = "好 各位同学".decode('utf-8')
assert_true(score_auc < 1.0) assert_true(score_accuracy < 1.0) assert_not_equal(score_auc, score_accuracy)
(['honor', 'verified', 'audit'], 'honor'),
TreeClassifier = CLF_TREES[name] _y = np.vstack((y, np.array(y) * 2)).T
X = [[-2, -1], [-1, -1], [-1, -2], [1, 1], [1, 2], [2, 1]] y = [1, 1, 1, 1, 1, 1]
click_css(page, component_css, 0)
enable_self_generated_certs.delay(unicode(course_key))
set_tsign = sub(set_limit, flo(div(set_sizes, set_batch))) set_tsize = mul(set_tsign, flo(div(set_range, set_limit)))
self._coef_indptr = [] self._intercept_indptr = [] start = 0
rng = np.random.RandomState() mean = rng.uniform(1e-6, 1. - 1e-6, (rows, cols, channels))
super(ProblemTypeTestBase, self).setUp() self.courseware_page.visit() self.problem_page = ProblemPage(self.browser)
with patch('capa.capa_problem.LoncapaProblem.grade_answers') as mock_grade: error_msg = u"Superterrible error happened: ☠" mock_grade.side_effect = Exception(error_msg)
course_info_page = CourseInfoPage(self.browser, self.course_id) self._make_har_file(course_info_page)
rng = self.mlp.rng if self.irange is None: raise ValueError("Recurrent layer requires an irange value in " "order to initialize its weight matrices")
stochastic = False
rng = np.random.RandomState(0)
features = map(lambda l: l[:-1], content) targets = map(lambda l: l[-1], content) del content
self.course = CourseFactory()
self.client.login(username=self.username, password=self.password)
problem = new_loncapa_problem(xml_str)
extra_fields = microsite.get_value( 'REGISTRATION_EXTRA_FIELDS', getattr(settings, 'REGISTRATION_EXTRA_FIELDS', {}) )
source_blocks.extend(self._problem_type_filter(library, dest_block.capa_type))
response = self.client.post(reverse('donation')) self.assertEqual(response.status_code, 404)
x_likelihood = numpy.sum((-energy_fn(1.0) + hq - log_z)[:batch_size0])
return super_float("".join(parse_result))
AccessTestData(partition_groups={1: 1, 2: 2}, merged_parents_list=[{1: {}}]), AccessTestData(partition_groups={1: 1, 2: 2}, merged_parents_list=[{1: {3}}]),
self.set_config(True) super(CourseOverviewImageSetTestCase, self).setUp()
self.user = user
self._create_courses_and_enrollments( (self.TEST_ORG, True), (self.TEST_ORG, True), (self.TEST_ORG, True), )
from __future__ import division
return self.student_view(context)
return year - year_of_birth - 1
micro_measure = metric(y_true, y_pred, average="micro") assert_almost_equal(micro_measure, metric(y_true_binarize.ravel(), y_pred_binarize.ravel()))
return self.__dict__.get(attr)
courses = self._get_courses_for_org(org_list) only_courses = options.get("courses")
import_static_content( data_path, self.static_content_store, dest_id, subpath='static', verbose=self.verbose )
CourseFixture(**self.course_info).install()
self.log_in_as_instructor() self.student_admin_section = self.visit_instructor_dashboard().select_student_admin()
self.base_loader = base_loader
with self.assertRaises(ItemNotFoundError): modulestore().get_item(course.location.for_branch(BRANCH_NAME_PUBLISHED))
try: user_preferences = get_user_preferences(request.user, username=username) except UserNotAuthorized: return Response(status=status.HTTP_403_FORBIDDEN) except UserNotFound: return Response(status=status.HTTP_404_NOT_FOUND) return Response(user_preferences)
with open(self.TEST_INDEX_FILENAME, "w+") as index_file: json.dump({}, index_file) self.addCleanup(remove_file, self.TEST_INDEX_FILENAME)
if values is not None: course_ids = list(set(course_ids) & set(values))
return str(uuid.uuid4())
self.assertFalse(user_can_skip_entrance_exam(self.anonymous_user, self.course))
self.get_data_specs(model)[0].validate(data) return None
with self.assertRaises(PermissionDenied): self.get_form(expected_valid=False)
assert_equal(iterations, expected_n_iter) if n_samples is not None: assert_equal(collected_test_samples, set(range(n_samples)))
names = []
COURSE_SLUG = "100" COURSE_NAME = "test_course"
tmp_dir = mkdtemp() try: course_dir = export_course_to_directory(course_key, tmp_dir) compress_directory(course_dir, filename) finally: shutil.rmtree(tmp_dir, ignore_errors=True)
serializer.save(changed_by=self.request.user)
return [lib for lib in modulestore().get_libraries() if has_studio_read_access(user, lib.location.library_key)]
#
parent = np.arange(n_nodes, dtype=np.intp) used_node = np.ones(n_nodes, dtype=np.intp) children = []
expected_message = self.get_dashboard_enrollment_message() self.assertTrue(expected_message in response.content)
pass
if is_editable: self.assertTrue(profile_page.privacy_field_visible) self.assertEqual(profile_page.visible_fields, self.PRIVATE_PROFILE_FIELDS)
self.assert_grade(problem, "Other String", "incorrect") self.assert_grade(problem, "second", "incorrect")
act_grad = self._activation_grad(inputs) jacobian = self.weights * act_grad.dimshuffle(0, 'x', 1) return jacobian
ps_shared_cache_1 = self._create_service(username, shared_cache) ps_shared_cache_2 = self._create_service(username, shared_cache)
boston = datasets.load_boston() perm = rng.permutation(boston.target.size) boston.data = boston.data[perm] boston.target = boston.target[perm]
return Fragment(self.get_html())
if '@' in username_or_email: return User.objects.get(email=username_or_email) else: return User.objects.get(username=username_or_email)
y_true += [0]*n_classes y_pred += [0]*n_classes
CertificateGenerationConfiguration.objects.create(enabled=True)
subtask_status_info[current_task_id] = new_subtask_status.to_dict()
return self.runtime.get_subtree_edited_on(self)
prefix = unichr(unicode_char)
X, y = make_multilabel_classification(allow_unlabeled=False, random_state=0) X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
long_name = u"Финансовое программирование и политика, часть 1: макроэкономические счета и анализ"
course = self.store.delete_course(course_key, self.user_id)
self.assertEqual(parent.graceperiod, new_block.graceperiod) self.assertEqual(parent.start, new_block.start) self.assertEqual(course.start, new_block.start)
import datetime import json import ddt import mock from nose.plugins.attrib import attr from pytz import UTC from django.utils.timezone import UTC as django_utc
for status in statuses: if reverifications[status]: reverifications[status].sort(key=lambda x: x.date) return reverifications
return self._cohort_name( self._get_cohort_options().filter(lambda el: el.is_selected()).first.text[0] )
item = self.cart.orderitem_set.all().select_subclasses()[0] self.assertEquals(item.unit_cost, self.get_discount(self.cost))
self.mock_tracker.reset_mock()
response = self.csrf_client.post( '/oauth2-test/', data={'access_token': self.access_token.token} ) self.assertEqual(response.status_code, status.HTTP_200_OK)
log.info("Send-email task %s for email %s: succeeded", current_task_id, email_id) update_subtask_status(entry_id, current_task_id, new_subtask_status)
self.validate_xblock_info_consistency(xblock_info, has_child_info=True, has_ancestor_info=True)
return HttpResponseBadRequest()
self.assertEquals(block_counts_for_course['chapter'], 2)
SplitModuleTest.modulestore = class_(
plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=plt.cm.spectral)
row = (y*outshp[1]+x)*inshp[0]*ksize + l + fmapi*ksize if ws else\ y*outshp[1] + x
"error": "invalid_client", "error_description": "{} is not a public client".format(client_id),
world.css_click(subsection_css)
field_data_cache = FieldDataCache.cache_for_descriptor_descendents( course_id, self.staff_user, descriptor ) return render.get_module( self.staff_user, self.request, location, field_data_cache, )
self.label_index_to_name = ('category', 'instance', 'elevation', 'azimuth', 'lighting condition')
problem = self.build_problem( choice_type='checkbox', choices=[False, False, True, True, False], credit_type='halves' )
check_is_fitted(self, 'cluster_centers_') X = self._check_test_data(X) x_squared_norms = row_norms(X, squared=True) return -_labels_inertia(X, x_squared_norms, self.cluster_centers_)[1]
self._validate_params(self.n_features, self.input_type) return self
self.course_nav.go_to_vertical('Test Vertical-2')
__BACKUP_ATTRIBUTE_NAME = '__monkey_patch'
SkippedReverification.add_skipped_reverification_attempt( checkpoint=self.checkpoint, user_id=self.user.id, course_id=unicode(self.course.id) )
if f.__call__.func_code.co_flags & STAR_ARGS: return f numargs = f.__call__.func_code.co_argcount if hasattr(f.__call__,"im_self"): numargs -= 1
assert np.allclose(dt.mean(dtype='float64'), 0) assert np.allclose(dt.std(dtype='float64'), 1.)
if len(self.credit_type) > 1: raise LoncapaProblemError('Only one type of partial credit is allowed for Checkbox problems.')
time.sleep(0.2)
policy = self.grading_policy policy['GRADE_CUTOFFS'] = value self.grading_policy = policy
CMS_BASE = 'localhost:8001'
self.register_get_thread_response(thread) return get_comment_list(self.request, thread["id"], endorsed, page, page_size)
test_string = "%%user_id%%" result = Ks.substitute_keywords_with_data( test_string, self.context, ) self.assertEquals(test_string, result)
if huber_warm.n_iter_ is not None: assert_equal(1, huber_warm.n_iter_)
buggy = Buggy() buggy.a = 2 assert_raises(RuntimeError, clone, buggy)
settings.STATICFILES_DIRS.append( (u'themes/{}'.format(settings.THEME_NAME), theme_root / 'static') )
request = Request.blank('/translation/uk') response = self.item.transcript(request=request, dispatch='translation/uk') self.assertEqual(response.status, '404 Not Found')
team.add_user(self.user)
dis_flat_w = dis_flat[sim_flat != 0]
raise NotImplementedError()
MAX_BOOKMARKS_PER_COURSE = ENV_TOKENS.get('MAX_BOOKMARKS_PER_COURSE', MAX_BOOKMARKS_PER_COURSE)
return store.create_item(user.id, usage_key.course_key, usage_key.block_type, block_id=usage_key.block_id)
if not download_video_link and self.download_video: if self.source: download_video_link = self.source elif self.html5_sources: download_video_link = self.html5_sources[0]
message_template = 'emails/course_creator_revoked.txt'
stress = ((dis.ravel() - disparities.ravel()) ** 2).sum() / 2
self.course.end = None self.assertEqual( course_complete.badge_description(self.course, 'honor'), 'Completed the course "Badged" (honor)' )
LOGGER.exception('Failed to award certificate for program %s to user %s', program_id, username) retry = True
CREDIT_TASK_MAX_RETRIES = 5
render_kw_only_separator = False
for key in kv_dict: self.kvs.set(key, 'test_value')
X = X[:5, :] y = y[:5] clf.fit(X, y) assert_array_equal(np.diff(clf.scores_) > 0, True)
AutoAuthPage(self.browser, username=username, email=email, course_id=self.course_id, staff=True).visit()
return ( 'name', 'enabled', 'lti_consumer_key', 'lti_max_timestamp_age', 'change_date', 'changed_by', 'edit_link', )
state.marked[state.marked == 2] = 0 return _step3
self.course = self.store.publish(self.course.location, self.user_id)
elif (self.closed() and not is_survey_question) or needs_reset: return False else: return True
context['accomplishment_copy_about'] = _('About {platform_name} Accomplishments').format( platform_name=platform_name )
return start_index
stop = 0 for k, centroid in enumerate(centroids): start, stop = stop, stop + n_samples_per_cluster[k]
REPORT_REQUESTED_EVENT_NAME = u'edx.instructor.report.requested'
json_fields = json.dumps(fields, cls=EdxJSONEncoder) rerun_course.delay(unicode(source_course_key), unicode(destination_course_key), request.user.id, json_fields)
kwargs.update(arg)
course_masquerade = get_course_masquerade(user, course_key) return course_masquerade.role if course_masquerade else None
FeatureAgglomeration().fit(X)
self.set_date('release_date', "#start_date", date)
self.assertIn(self.provider.name, response.content)
course = CourseFactory.create() self.assertIsInstance(course, CourseDescriptor)
extra['tz_aware'] = extra.get('tz_aware', True)
sample_weight /= sample_weight_sum
z = mask[:, None] * z + (1 - mask[:, None]) * state_before
while top_level_logger.handlers: top_level_logger.handlers.pop()
assert_array_almost_equal(grad_1, grad_2) assert_almost_equal(loss_1, loss_2)
'API': 'www.youtube.com/iframe_api',
role = CourseCcxCoachRole(self.course.id) role.add_users(self.coach) self.request_factory = RequestFactory()
start = TODAY().replace(tzinfo=pytz.UTC) override_field_for_ccx(ccx, course, 'start', start) override_field_for_ccx(ccx, course, 'due', None)
expected_response = { "enabled": False } self._verify_cohort_settings_response(expected_response)
elif not yield_descendants_of_unyielded and not any(yield_results[parent] for parent in parents): continue
random_state = check_random_state(42)
return self.page_num - 1
self.client = Client()
self.parse_xml()
LANGUAGE_KEY = 'pref-lang'
X = generator.randn(n_samples, n_features)
return self._send_lti2(payload)
assert_array_equal(clf.predict([[0.2, -1.0]]), np.array([-1]))
self.assertTrue('success' in result and not result['success'])
if not (self.n_jobs == 1 or self.n_jobs is None): path_params['copy_X'] = False
self.assertEqual(new_version.test_content_field, 'Explicitly set') self.assertEqual(new_version.test_settings_field, 'Explicitly set')
UNENROLL_DONE.send(sender=None, course_enrollment=self.course_enrollment, skip_refund=skip_refund)
return K, np.empty((X.shape[0], X.shape[0], 0))
test = [[1], [3], [4]] assert_array_almost_equal(clf.predict(test), [1, 3, 4], 2)
profile_image_names = get_profile_image_names(username) create_profile_images(uploaded_file, profile_image_names)
continue
response_properties = ["codeparam", "responseparam", "answer", "openendedparam"]
subsection_css = ( ".course-navigation .chapter-content-container:nth-of-type({0}) " ".menu-item:nth-of-type({1})" ).format(sec_index + 1, subsec_index + 1)
upload_csv_to_report_store(rows, 'may_enroll_info', course_id, start_date)
emit_field_changed_events( user_profile, user_profile.user, sender._meta.db_table, excluded_fields=['meta'] )
new_locator = course_key.make_usage_key(block_key.type, block_key.id) return self.get_item(new_locator, **kwargs)
self.shape = tuple(shape) self.num_channels = num_channels if axes is None: axes = self.default_axes assert len(axes) == 4 self.axes = tuple(axes)
partitions = self._get_partition_info() self.assertEqual(len(partitions), 1) self.assertEqual(partitions[0]["scheme"], "verification")
with np.errstate(under='ignore'): rbm1.score_samples([np.arange(1000) * 100])
X_no_array = NotAnArray(X_dense) result = check_array(X_no_array) assert_true(isinstance(result, np.ndarray))
parse_coverage( Env.BOK_CHOY_REPORT_DIR, Env.BOK_CHOY_COVERAGERC )
options_str = ",".join(options)
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
layer_to_chains = model.sampling_procedure.sample( layer_to_chains, self.theano_rng, layer_to_clamp=layer_to_clamp, num_steps=1 )
self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course_key))
OIDC_COURSE_HANDLER_CACHE_TIMEOUT = 0
if not add_noise: assert_almost_equal(np.dot(s1_, s1) / n_samples, 1, decimal=3) assert_almost_equal(np.dot(s2_, s2) / n_samples, 1, decimal=3)
self.estimators_ = []
raise NotImplementedError
self.update_structure(dest_course_key, new_structure)
if (extmath.norm(my_mean - my_old_mean) < stop_thresh or completed_iterations == max_iter): return tuple(my_mean), len(points_within) completed_iterations += 1
dummy_v = T.tensor4() dummy_v.name = 'dummy_v'
return u'<p class="error_msg">{msg}</p>'.format(msg=msg)
course_page = CoursewarePage(self.browser, self.course_id) self.browser.get(course_page.url + '?tpa_hint=oa2-dummy')
self._navigate_to_courseware_video() self.video.wait_for_video_class()
if not hasattr(self, 'components_'): self._init_latent_vars(n_features)
response.data["start"] = (self.page.number - 1) * self.get_page_size(self.request)
MUTABLE = False
n_clusters_range = [2, 10, 50, 90] n_samples = 100 n_runs = 10
CREDIT_TASK_MAX_RETRIES = 5
return True
start_flow_url = reverse('verify_student_start_flow', args=[unicode(self.course.id)]) self.assertRedirects(response, start_flow_url)
region[np.logical_and(firstring, righthalf)] = 2 region[np.logical_and(secondring, np.logical_not(righthalf))] = 2
REST_FRAMEWORK,
self.block.group_access = group_access self.block = self.store.update_item(self.block, ModuleStoreEnum.UserID.test)
csv_file = open(path, 'r')
predictions = cval.cross_val_predict(clf, X_sparse, X) assert_array_equal(predictions.shape, (10, 2))
if raise_error is not None: raise raise_error
all_answers = survey.get_answers(limit_num_users=1) self.assertEquals(len(all_answers.keys()), 1)
for enrollment in _ENROLLMENTS: if student_id == enrollment['student'] and course_id == enrollment['course']['course_id']: return enrollment
self.assertFalse(self.cmap.is_partially_correct('9_2_1'))
CONTEXT_EXTRA_FIELDS = 'context_extra_fields'
if is_request_from_mobile_app(request): return MobilePlatform.get_instance(user_agent)
serializer = CreditProviderCallbackSerializer(data=data, provider=provider) serializer.is_valid(raise_exception=True)
return getattr(self.cost, attr)
other_parent_loc = course_key.make_usage_key('vertical', 'zeta') other_parent = store.get_item(other_parent_loc) self.assertIn(shared_item_loc, other_parent.children)
self.check_emails_sent(50, task_history_request, True)
sample_weight = np.ones(n_samples, dtype=np.float64, order='C')
return sorted(course_module.teams_topics, key=lambda t: t['name'].lower())
rbm1.random_state = 42 d_score = rbm1.score_samples(X) rbm1.random_state = 42 s_score = rbm1.score_samples(lil_matrix(X)) assert_almost_equal(d_score, s_score)
self._enroll(course.id, "verified")
assert grad_counter.get_value() == train_batches * updates_per_batch
if not (name == 'HuberRegressor' and estimator.n_iter_ is None): assert_greater_equal(estimator.n_iter_, 1)
raise _NotFittedError(msg % {'name': type(estimator).__name__})
return module.sort_key or module.discussion_target
input_dict = {'1_2_1': '21'} correct_map = problem.grade_answers(input_dict)
last_sum = last_mean * last_sample_count new_sum = X.sum(axis=0)
'post_params_decline': post_params_decline
return has_access(user, action, xmodule.descriptor, course_key)
response = requests.post(self.url, data={"test_param": None}) self.assertEqual(response.status_code, 400)
super(StudioPagePerformanceTest, self).setUp() AutoAuthPage(self.browser, staff=True).visit()
log.exception("Couldn't load textbook ({0}, {1})".format(title, book_url)) continue
return self.client.get(reverse('xdomain_proxy'))
'STORE_BILLING_INFO': False,
url(r'^get_students_opened_subsection$', 'class_dashboard.dashboard_data.get_students_opened_subsection', name="get_students_opened_subsection"),
course_outline_page = CourseOutlinePage( self.browser, self.course_info['org'], self.course_info['number'], self.course_info['run'] ) course_outline_page.visit()
if not is_mongo_running(): msg = colorize('red', "Mongo is not running locally.") print msg sys.exit(1)
nbrs = NearestNeighbors(n_neighbors=1).fit(X) dist, ind = nbrs.kneighbors(X, return_distance=True)
cm = metrics.confusion_matrix(y_test, y_predicted) print(cm)
sample_weight = compute_sample_weight({1: 2, 2: 1}, y) assert_array_almost_equal(sample_weight, [2., 2., 2., 1., 1., 1.])
microsite.set_by_domain(self.microsite_subdomain) self.assertEqual(microsite.get_value('platform_name'), 'Test Microsite')
y_weights = np.dot(Y.T, x_score) / np.dot(x_score.T, x_score)
y = NORBSmall.load(which_set, 'cat') y_extra = NORBSmall.load(which_set, 'info')
self.check_emails_sent(1, task_history_request, True)
self._create_course_unit(youtube_stub_config={'youtube_api_blocked': True}) self.assertFalse(self.video.is_button_shown('play'))
response = self.client.get(reverse('branding.views.courses')) self.assertEqual(response.status_code, 200)
return self._create_user(username, email, is_staff=True)
terms_of_service_and_honor_code = branding_api.get_tos_and_honor_code_url() if terms_of_service_and_honor_code != branding_api.EMPTY_URL: data.update({'company_tos_url': terms_of_service_and_honor_code})
assert_raises(ValueError, _fast_dot, A, A[0, :][None, :])
tags = list(tags or []) tags.append('LMS')
def test_compare_phases_ignored(self): self.assertTrue(compare_chemical_expression( "H2O(s) + CO2", "H2O+CO2", ignore_state=True))
print("--- Dense matrices")
if name is None: return REQUEST_CACHE else: return REQUEST_CACHE.data.setdefault(name, {})
docs_train, docs_test, y_train, y_test = train_test_split( dataset.data, dataset.target, test_size=0.25, random_state=None)
assert_true((ovr_clf.predict(iris.data) == cs_clf.predict(iris.data)).mean() > .9)
if isinstance(authored_data, CmsFieldData):
tree = etree.fromstring(u'<div>{}</div>'.format(html))
mock_plugin = Mock() mock_plugin.type = tab_type mock_plugin.priority = priority return mock_plugin
self.assertEqual( len(CourseEnrollment.objects.filter(mode='honor', user_id__in=real_user_ids)), 0 )
return True
return cls.objects.filter(order__status='purchased', coupon__course_id=course_id).aggregate(Count('coupon'))
invalid_list = [None, "string", 5, datetime.datetime.today()]
if asset_collection is None: asset_collection = self.DEFAULT_ASSET_COLLECTION_NAME self.asset_collection = self.database[asset_collection]
from django.utils.translation import get_language
self.assertEqual(i18n_service.ugettext(self.test_language), 'dummy language')
if LoginFailures.is_feature_enabled(): LoginFailures.clear_lockout_counter(user)
icrv_blocks = get_course_blocks(course_key, VERIFICATION_BLOCK_CATEGORY)
assert isinstance(course_key, CourseKey) store = self._get_modulestore_for_courselike(course_key) try: return store.get_course(course_key, depth=depth, **kwargs) except ItemNotFoundError: return None
'config_models',
Ua, sa, Va = \ randomized_svd(X, k, power_iteration_normalizer=normalizer, random_state=0) assert_almost_equal(s[:rank], sa[:rank])
tasks = instructor_task.api.get_instructor_task_history(course_id, module_state_key, student)
from __future__ import unicode_literals
unenroll_email( course_id=ccx_key, student_email=staff.email, email_students=send_email, email_params=email_params, )
transformers = Parallel(n_jobs=self.n_jobs)( delayed(_fit_one_transformer)(trans, X, y) for name, trans in self.transformer_list) self._update_transformer_list(transformers) return self
if missing_values == 0: n_zeros_axis = np.zeros(X.shape[not axis], dtype=int) else: n_zeros_axis = X.shape[axis] - np.diff(X.indptr)
y_pred[:, k] += learning_rate * tree.predict(X).ravel()
self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])
assert X.shape == (96 * 96 * 3, 100000) assert X.dtype == 'uint8'
with mock.patch('openedx.core.lib.courses.create_course_image_thumbnail') as patched_create_thumbnail: course_overview = CourseOverview.get_from_id(course_overview.id) patched_create_thumbnail.assert_not_called()
else: self.log_error( "Multiple response patterns matched '{0}'".format(xqueue_body_json), ) return
category_name = "problem" return world.ItemFactory.create( parent_location=section_location(course), category=category_name, display_name=str(problem_type), data=problem_xml, metadata=metadata )
for branch in [ModuleStoreEnum.RevisionOption.published_only, ModuleStoreEnum.RevisionOption.draft_only]: super(DraftVersioningModuleStore, self).fix_not_found( self._map_revision_to_branch(course_key, branch), user_id )
test_course_data = self.assert_created_course() course_id = _get_course_id(self.store, test_course_data) course_module = self.store.get_course(course_id) self.assertEquals(course_module.language, 'hr')
if not arglist and not parse_argv: arglist = [] (options, args) = parser.parse_args(arglist) options.reporter = None
data={'metadata': {'user_partition_id': str(partition_id)}}
mode_display_name = models.CharField(max_length=255, verbose_name=_("Display Name"))
proba = sum(_samme_proba(estimator, n_classes, X) for estimator in self.estimators_)
return etree.Element( 'video_asset', attrib={'export_edx_video_id': edx_video_id} )
cs = self.ax.scatter(support_vectors[:, 0], support_vectors[:, 1], s=80, edgecolors="k", facecolors="none") self.contours.append(cs)
view_html = None
if not os.path.isdir(os.path.join(local_path, 'h5')): os.makedirs(os.path.join(local_path, 'h5'))
random_state = check_random_state(self.random_state) return gaussian_random_matrix(n_components, n_features, random_state=random_state)
self.initiate_rerun()
view_name = None
user=user, course_id=course.location.course_key, status=CertificateStatuses.downloadable
monitor = lm.LiveMonitor() monitor.update_channels(['train_objective'], start=0, end=2) assert(len(monitor.channels['train_objective'].val_record) == 2)
self.assertEqual(new_version.location.course_key, target_location_namespace)
train = CIFAR10(which_set='train') topo = train.get_batch_topo(1) assert topo.ndim == 4
team_list = self.get_teams_list(user=user, expected_status=200, data=course_one_data) self.assertEqual(team_list['count'], 1)
self.assertTrue(self.store.has_changes(xblock))
return self
answer_ids = [] for response in self.responders.keys(): results = self.responder_answers[response] answer_ids.append(results.keys()) return answer_ids
from yaml import Loader, SafeLoader
all_fpr = np.unique(np.concatenate([fpr[i] for i in range(n_classes)]))
pruned_block_relations = defaultdict(_BlockRelations) old_block_relations = self._block_relations
return dict( [ ("IS_REQUEST_IN_MICROSITE", microsite.is_request_in_microsite()) ] )
X_ = X[:, np.newaxis, :] Y_ = Y[np.newaxis, :, :]
output = StringIO.StringIO() import_log_handler = logging.StreamHandler(output) import_log_handler.setLevel(logging.DEBUG)
diag_mask = (connectivity.row != connectivity.col) connectivity.row = connectivity.row[diag_mask] connectivity.col = connectivity.col[diag_mask] connectivity.data = connectivity.data[diag_mask] del diag_mask
if isinstance(target_name, numbers.Integral): target_name = col_names[target_name] if isinstance(data_name, numbers.Integral): data_name = col_names[data_name]
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit() attempt.deny("Not valid!")
with super(UpdateThreadUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
return eval(xml.text)
def __init__(self, *args, **kwargs): super(OrgInstructorRole, self).__init__('instructor', *args, **kwargs)
users_state = {}
api.set_credit_requirement_status(username, self.course_key, "grade", "grade") self.assert_grade_requirement_status('satisfied', 0)
skip_if_no_sklearn() mapping = {'dataset_iterator': 'StratifiedDatasetValidationShuffleSplit'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
httpretty.register_uri(httpretty.POST, "https://verify.example.com/submit/")
total_cost += l1_act_cost
return self._match_registry.keys() + self._prefix_registry.keys()
selector = self.get_element_selector(VIDEO_BUTTONS[button_id]) return self.q(css=selector).visible
'USE_MICROSITES': False,
return BACKEND.get_all_config()
new_mean_squared_grad = (self.decay * mean_square_grad + (1 - self.decay) * T.sqr(grads[param]))
from __future__ import unicode_literals
title_label = _(u"Title")
self.setup_system_xmodule_mocks_for_lti20_request_test() mock_request = self.get_signed_lti20_mock_request(self.GOOD_JSON_PUT) response = self.xmodule.lti_2_0_result_rest_handler(mock_request, None) self.assertEqual(response.status_code, 404)
assert_array_almost_equal((tfidf ** 2).sum(axis=1), [1., 1., 1.])
provider_url = reverse('openid-provider-xrds') factory = RequestFactory() request = factory.request() abs_provider_url = request.build_absolute_uri(location=provider_url)
assert key.user_id == self.user.id
course_outline_url = reverse_course_url('course_handler', updated_course.id) response = self.client.get_html(course_outline_url)
if not hasattr(self, 'freeze_set'): self.freeze_set = set([])
distinct_value_indices = np.where(np.logical_not(isclose( np.diff(y_score), 0)))[0] threshold_idxs = np.r_[distinct_value_indices, y_true.size - 1]
boston = datasets.load_boston() perm = rng.permutation(boston.target.size) boston.data = boston.data[perm] boston.target = boston.target[perm]
for offset, name in enumerate(positional[non_default_count:]): annotation = annotations.get(name, _empty) parameters.append(Parameter(name, annotation=annotation, kind=_POSITIONAL_OR_KEYWORD, default=defaults[offset]))
parent_ids.sort(key=lambda parent: (parent.type, parent.id)) return BlockUsageLocator.make_relative( locator, block_type=parent_ids[0].type, block_id=parent_ids[0].id, )
from urllib2 import HTTPError from urllib2 import quote from urllib2 import urlopen
return self.q(css="div.problem div.capa_inputtype.textline div.correct span.status").is_present()
self.certificates_section.add_certificate_exception(self.user_name, '')
return s if len(s) <= 80 else s[:77] + "..."
def _tile_columns(self): raise NotImplementedError('TODO')
return self.q(css='li.prerequisites > .tip').visible
condition = label.any(axis=1) return tuple(var.compress(condition, axis=0) for var in (train, label))
cv = np.tile(covars, (means.shape[0], 1, 1)) return _log_multivariate_normal_density_full(X, means, cv)
if field_decorator is None: self.field_decorator = lambda x: x else: self.field_decorator = field_decorator
VerificationDeadline.set_deadline(self.course.id, self.VERIFICATION_DEADLINE)
if current.node in visited or not filter_func(current.node): stack.pop() continue
return xmlstore.get_item(usage_key, for_parent=for_parent)
return [user.name for user in self.users]
if ((X.data if sparse else X) < 0).any(): raise ValueError("Entries of X must be non-negative.")
self.browser.execute_script("window.scrollTo" + str(self.coordinates_for_scrolling(UNDO_BUTTON_SELECTOR))) self.q(css=UNDO_BUTTON_SELECTOR).click() self.wait_for_ajax()
X = [[1, 1, 0], [1, 1, 0], [1, 0, 0]] tr = TfidfTransformer(smooth_idf=False, norm='l2')
self.assertEqual(safe_key(1, 'prefix', 'version'), 'prefix:version:1')
return np.all([kernel.is_stationary() for kernel in self.kernels])
choice_element.append(inp)
self._submit_photos( face_image=self.IMAGE_DATA + "4567", photo_id_image=self.IMAGE_DATA + "8910", ) initial_data = self._get_post_data()
pygments_style = 'sphinx'
return self.q(css='.wrapper-content ' + self.certficate_css + ' .no-content').text[0]
REQUIRE_DEBUG = False
if type(obj) is self.np.memmap: obj = self.np.asarray(obj) return Pickler.save(self, obj)
context['accomplishment_banner_opening'] = _("{fullname}, you earned a certificate!").format( fullname=user_fullname )
self.instructor = AdminFactory.create() self.client.login(username=self.instructor.username, password="test")
parent = modulestore.get_parent_location(next_usage)
raise BuildFailure(file_not_found_message)
if not choice.get('id'): choice.set("id", chr(ord("A") + index))
actual = json.loads(response.content)['detail'] self.assertEqual(actual, expected_msg)
mask = labels == curr_label current_distances = distances[mask]
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_key_string) get_course_with_access(request.user, 'staff', course_key)
_y = np.vstack((y, np.array(y) * 2)).T clf = ForestClassifier(random_state=0).fit(X, _y)
self.settings_page.visit() self._set_pre_requisite_course()
return json.loads(self._pre_requisite_courses_json)
is_dynamic = False
with self.assertRaises(Exception): self.build_problem(type="invalidtextgroup")
mock = MagicMock(return_value=return_value) new_patch = patch(function_name, new=mock) new_patch.start() self.addCleanup(new_patch.stop) return mock
return self.mean_h_given_v(v)
msg = "0 sample(s) (shape=(0,)) while a minimum of 1 is required." assert_raise_message(ValueError, msg, check_array, [], ensure_2d=False)
self.account_settings_page = AccountSettingsPage(self.browser) self.account_settings_page.visit() self.account_settings_page.wait_for_ajax()
list_check = lambda x: isinstance(x, list) clf = CheckingClassifier(check_X=list_check) scores = cross_val_score(clf, X.tolist(), y2.tolist())
STATIC_ROOT = TEST_ROOT / "staticfiles"
return html
self.format_caller_node = node.func.value
self.assertIn(self.user_name, self.certificates_section.last_certificate_exception.text) self.assertIn(expected_notes, self.certificates_section.last_certificate_exception.text)
course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
import matplotlib.pyplot as plt import numpy as np from time import time
results_by_url = {} root = None
from ..gaussian_process.kernels import Kernel as GPKernel
xpath = "//div[@class='{0}']".format(expected_css_class) self.assert_has_xpath(xml, xpath, self.context)
X = check_array(X) n_eval, _ = X.shape n_samples, n_features = self.X.shape n_samples_y, n_targets = self.y.shape
self.client.login(username=self.white_label_course_instructor.username, password='test')
m_log_alphas = -np.log10(model.cv_alphas_)
config_course_cohorts( course, is_cohorted=True, auto_cohorts=["AutoGroup"] )
try: return get_student_from_identifier(unique_student_identifier) except User.DoesNotExist: raise DashboardError( _("Could not find student matching identifier: {student_identifier}").format( student_identifier=unique_student_identifier ) )
self.q(css='.create-team .action-cancel').first.click() self.wait_for_ajax()
self.create_programs_config() mock_init.side_effect = Exception actual = utils.get_programs(self.user) self.assertEqual(actual, []) self.assertTrue(mock_init.called)
self.prev_floatX = config.floatX config.floatX = 'float64'
self.dashboard_page.visit()
for mode in available_modes: CourseModeFactory.create(mode_slug=mode, course_id=self.course.id)
self.assertIn(REG_STR, resp.content)
unbalanced = ImageFile(get_image('unbalanced')) self.assertRaises(ValidationError, validate_badge_image, unbalanced)
self.assertIsNone(utils.find_staff_lock_source(self.orphan))
super(AutoAuthEnabledTestCase, self).setUp() self.url = '/auto_auth' self.client = Client()
self.check_index_and_outline(course_staff_client)
resp = self.client.get(reverse('courseenrollments')) self.assertEqual(resp.status_code, status.HTTP_200_OK)
cache_key = self._cache_key_for_kvs_key(kvs_key) if cache_key not in self._cache: raise KeyError(kvs_key.field_name) field_object = self._cache[cache_key] return json.loads(field_object.value)
form_desc = json.loads(response.content)
sparse_results = sparse_classifier.staged_score(X_test_sparse, y_test) dense_results = dense_classifier.staged_score(X_test, y_test) for sprase_res, dense_res in zip(sparse_results, dense_results): assert_array_equal(sprase_res, dense_res)
year_of_birth = self.year_of_birth year = datetime.now(UTC).year if year_of_birth is not None: return self._calculate_age(year, year_of_birth)
self.verify_lists_expected_cohorts([])
authentication_classes = () permission_classes = ()
d_clf = ElasticNet(alpha=alpha, l1_ratio=0.8, fit_intercept=fit_intercept, max_iter=max_iter, tol=1e-7, positive=positive, warm_start=True) d_clf.fit(X_train.toarray(), y_train)
assert_array_equal(np.sort(X_counted.data), np.sort(X_hashed.data))
config = models.CourseTalkWidgetConfiguration.current() config.enabled = enabled config.platform_key = self.PLATFORM_KEY config.save()
MIGRATION_MODULES = NoOpMigrationModules()
if not is_entrance_exams_enabled(): return False if not course.entrance_exam_enabled: return False if not course.entrance_exam_id: return False return True
if xblock_access is not None: block.group_access = xblock_access update_block(self.course)
raise ValueError("Invalid value for train_size: %r" % train_size)
message = self.q(css='div.wrapper-msg') if message.present: return message.text[0] return None
first_request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO["username"])
clf = PCA(n_components=2) X_true = clf.fit_transform(X_true)
tol = 2 * np.finfo(A.dtype).eps
import_course_from_xml( draft_store, 999, DATA_DIR, ['test_import_course'], static_content_store=content_store, do_import_static=False, verbose=True, target_id=SlashSeparatedCourseKey('guestx', 'foo', 'bar') )
return request.build_absolute_uri(staticfiles_storage.url(name))
if certificate_data.get('course_title'): certificate_response["course_title"] = certificate_data['course_title']
modulestore().get_item(usage_key)
if output_pixel_vals: channel_defaults = [0, 0, 0, 255] else: channel_defaults = [0., 0., 0., 1.]
resp = self.client.delete(reverse_usage_url('xblock_handler', usage_key)) self.assertEqual(resp.status_code, 204)
html = self.get_problem_html(encapsulate=False)
deadline = second_attempt.created_at + timedelta(days=1) query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(deadline, query) self.assertEqual(result, second_attempt)
if "enrollment_action" in request.POST: del request.POST["enrollment_action"] if "course_id" in request.POST: del request.POST["course_id"]
alpha = float(alpha) random_state = check_random_state(random_state)
wtf_numpy = np.zeros((pool_size_1,)) for i in xrange(pool_size_1): wtf_numpy[i] = on_probs[i] on_probs = wtf_numpy
msg = '<html>' + msg + '</html>'
indices = np.searchsorted(sorted_labels, labels[:n_labels]) tp_sum = tp_sum[indices] true_sum = true_sum[indices] pred_sum = pred_sum[indices]
self.factory(penalty='foobar', l1_ratio=0.85)
idx = int(rng.rand(1) * n_samples) entry = X[idx] seen.add(idx)
try: return self.encrypt_session_key(request.session.session_key) except AttributeError: return ''
return self.q(css='.pub-status').first.text[0]
pass
session = requests.Session() response = session.get(LMS_BASE_URL + "/auto_auth?superuser=true")
return self.q(css='.wrapper-create-course #new-course-org')
return { "id": update["id"], "date": update["date"], "content": update["content"], }
def __init__( self ): super(Empty,self).__init__() self.name = "Empty" self.mayReturnEmpty = True self.mayIndexError = False
if config_file_path.endswith(suffix_to_strip): config_file_full_stem = config_file_path[0:-len(suffix_to_strip)] else: config_file_full_stem = config_file_path
rval = 1./ (self.model.alpha + self.model.w ) rval.name = 'var_s1' return rval
attempt = SoftwareSecurePhotoVerification(user=user) attempt.status = 'approved' attempt.save()
self.q(css=".settings-tab-button[data-tab='access']").first.click() self.wait_for_element_visibility('#is_prereq', 'Gating settings fields are present.')
termination_criterion = EpochCounter(5)
est = RandomForestClassifier() transformer = SelectFromModel(estimator=est) transformer.fit(data, y) assert_true(transformer.estimator is est)
from urllib2 import urlopen from urllib2 import HTTPError
return repr(tuple(key))
if email_opt_in is not None: opt_in = email_opt_in == 'true' mock_update_email_opt_in.assert_called_once_with(self.user, self.course.org, opt_in) else: self.assertFalse(mock_update_email_opt_in.called)
self.assertEquals(3, self.response.content.count('grade_None'))
allow_user = user.is_active or user.is_anonymous() return allow_user and self.config.checkout_on_ecommerce_service
W, U, b = self._params if self.weight_noise: W = self.add_noise(W) U = self.add_noise(U)
params['signed_field_names'] = 'reason_code,message' params['signature'] = self._signature(params)
with warnings.catch_warnings(record=True): estimator = Estimator() set_testing_parameters(estimator) set_random_state(estimator) estimator.fit(X, y) y_pred = estimator.predict(X)
from urllib.request import urlopen PY2 = False
msg = "Singleton array array(42) cannot be considered a valid collection." assert_raise_message(TypeError, msg, check_array, 42, ensure_2d=False)
self.assertEquals( block_key in block_structure, block_key not in missing_blocks, 'Expected presence in block_structure for block_key {} to match absence in missing_blocks.'.format( unicode(block_key) ), )
return cls.objects.filter(registration_code__code=course_reg_code).exists()
rec_check = records[tb_offset:] try: rname = rec_check[0][1] if rname == '<ipython console>' or rname.endswith('<string>'): return rec_check except IndexError: pass
delattr(self._modulestore, name)
newrelic.agent.add_custom_parameter('course_id', unicode(self.course_key)) newrelic.agent.add_custom_parameter('org', unicode(self.course_key.org))
raise tools.DashboardError("Oh noes!")
if total is None: return (None, None) else: max_scores_cache.set(problem_descriptor.location, total)
embargoed_countries = models.TextField( blank=True, help_text="A comma-separated list of country codes that fall under U.S. embargo restrictions" )
self.variables = variables self.p = p
if self.base_dir is None: return False return resource_exists(self.module, os.path.join(self.base_dir, path))
rng = np.random.RandomState(0) n, p = 50, 3
raise ItemNotFoundError(destination_course)
ext_user = User.objects.get(email=self.ext_user.email) self.assertTrue(auth.user_has_role(ext_user, CourseInstructorRole(self.course.id)))
return self.q(css='.actual-course-number .certificate-value').first.text[0]
if self.only_on_web: return {"only_on_web": True}
self.other_sequential_2.children.append(self.other_vertical_1.location)
data = fetch_species_distributions() species_names = ['Bradypus Variegatus', 'Microryzomys Minutus']
'ENABLE_DEBUG_RUN_PYTHON': False,
else: return _(u"Donation for {platform_name}").format(platform_name=settings.PLATFORM_NAME)
UserFactory.create(email=self.new_email) self.assertEqual(self.do_email_validation(self.new_email), 'An account with this e-mail already exists.')
context.update(configuration.get('default', {}))
for db_alias in self.dbs.keys(): sh("cp {db_cache} {db}".format(db_cache=self.db_caches[db_alias], db=self.dbs[db_alias]))
self.assertEqual(two_toys.grade_cutoffs['C'], 0.5999)
store.delete_course(refetch_course.id, user)
return Fragment(self.FRAG_CONTENT)
return None
html = descriptor.get_html() rendered_content = descriptor.render(STUDIO_VIEW).content self.assertEqual(html, rendered_content)
last_request = httpretty.last_request() return json.loads(last_request.body)
X -= X.min()
task_progress.skipped += 1
url = "{base}/verify_student/{entry_point}/{course}/".format( base=BASE_URL, entry_point=self._entry_point, course=self._course_id ) return url
world.wait_for_visible('#data-student-profiles-table')
return anonymous_id_for_user(user, None, save=save)
for course_key in courses: self.assertTrue(is_course_in_block_structure_cache(course_key, self.store))
if user_partition.active: for group_id in group_ids: try: user_partition.get_group(group_id) except NoSuchUserPartitionGroupError: has_invalid_groups = True
credit_state = self.service.get_credit_state(self.user.id, self.course.id) self.assertEqual(credit_state['credit_requirement_status'][0]['status'], "satisfied")
stack = deque([_Node(start_node, get_children)])
pass
self.add_to_cart() self.request.user = self.user context = user_has_cart_context_processor(self.request) self.assertFalse(context['should_display_shopping_cart_func']())
return self.q(css='.warning').results[0].text
return text
resp = self._get_footer(params={'language': language}) self.assertEqual(resp.status_code, 200) json_data = json.loads(resp.content)
self._make_eligible() self._purchase_credit() self._initiate_request()
err_loc_emp_full[i, j] = np.sum(X.mean(0) ** 2) err_cov_emp_full[i, j] = EmpiricalCovariance().fit(X).error_norm( np.eye(n_features))
self.course_info_page.visit() self.tab_nav.go_to_tab('Course')
self.assertNotEqual(order.processor_reply_dump, '')
cc_user = cc.User.from_django_user(request.user) cc_user.default_sort_key = request.GET.get('sort_key') cc_user.save()
self.input_space = input_space
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
self.q(css=self._bounded_selector('.add-admin-role')).click() wait_for_ajax_or_reload(self.browser)
return self.q(css=self._bounded_selector('{} p.{}'.format(self.VALIDATION_SELECTOR, css_class)))
return v[::-1], W[:, ::-1]
self.prepare_new_page() totals_table.drawOn(self.pdf, self.margin + left_padding, self.second_page_start_y_pos - rendered_height) return self.second_page_start_y_pos - rendered_height - self.min_clearance
'LICENSING': False,
descriptor = modulestore().get_course(course_key) del descriptor.graceperiod modulestore().update_item(descriptor, user.id)
ForestClassifier = FOREST_CLASSIFIERS[name]
super(IndexSequenceSpace, self)._validate_impl(is_numeric, batch)
rendered_html = etree.XML(problem.get_html())
with super(ForumDiscussionSearchUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
if isinstance(estimator, DBSCAN): return if "random_state" in estimator.get_params(): estimator.set_params(random_state=random_state)
evecs /= np.apply_along_axis(np.linalg.norm, 0, evecs)
course_email = cls( course_id=course_id, sender=sender, subject=subject, html_message=html_message, text_message=text_message, template_name=template_name, from_addr=from_addr, )
self.course_enrollment = CourseEnrollment.enroll(user=self.user, course_key=self.course_id, mode=self.mode) self.save()
self.assertEquals(xmodule_tabs.CourseTabList.get_tab_by_id(self.course.tabs, tab.tab_id), tab)
honor_mode = CourseMode.mode_for_course(course_key, CourseMode.HONOR) audit_mode = CourseMode.mode_for_course(course_key, CourseMode.AUDIT)
assert_almost_equal(np.abs(Yt[0][0]), 1., 1)
assert_false(hasattr(seq, 'attempts'))
languages.sort() return languages
max_depth = ((2 ** 31) - 1 if self.max_depth is None else self.max_depth) max_leaf_nodes = (-1 if self.max_leaf_nodes is None else self.max_leaf_nodes)
sequential = self.store.create_child( self.user_id, chapter.location, 'sequential', block_id='subsection_one' ) self.store.publish(sequential.location, self.user_id)
return self.update(id=entry_id, updated_user=user, should_display=should_display)
def handle(self, *args, **options): return json.dumps(eventtracker.get_tracker().resolve_context())
out_size = get_encoded_size(img_h, img_w, rings) output = numpy.zeros((batch_size, out_size * chans))
self.assertTrue('success' in result and not result['success'])
label = _(u"I agree to the {platform_name} {terms_of_service}.").format( platform_name=get_themed_value("PLATFORM_NAME", settings.PLATFORM_NAME), terms_of_service=terms_link )
return "/assets/" + self._course_key + "/"
msg_format += _(" (out of {total})")
component_types = COMPONENT_TYPES[:]
if user.is_anonymous(): return None
url = self.browser.current_url fragment_index = url.find('#') if fragment_index >= 0: url = url[0:fragment_index]
allow_access(course_ccx, staff, 'staff')
video = ItemFactory.create(parent_location=child_vertical.location, category="video", display_name="My Video") self.assertIsNone(xblock_studio_url(video))
course.tabs.append(CourseTab.load("edxnotes")) modulestore().update_item(course, user_id)
with check_mongo_calls(1): self._run_command()
self.assertContains(response, unicode(self.course.id))
del_cached_content(thumbnail_location) if thumbnail_content is not None: content.thumbnail_location = thumbnail_location
type_in_codemirror(self, 0, content)
request = RequestCache.get_current_request() return getattr(request, 'user', None)
server_port = 4567 self.server_url = 'http://127.0.0.1:%d' % server_port
cmap = CorrectMap() for answer_id in answer_ids: cmap.update(CorrectMap(answer_id=answer_id, queuestate=None)) self.problem.correct_map.update(cmap)
self.assert_can_access(self.beta_user, self.alpha_module.discussion_id, thread_id, True)
newXBlock = self.store.publish(xblock.location, self.user_id) self.assertFalse(self.store.has_changes(newXBlock))
for error_inputs, error_message in self.BAD_JSON_INPUTS: for einput in error_inputs: with self.assertRaisesRegexp(LTIError, error_message): self.xmodule.parse_lti_2_0_result_json(einput)
return bool(_OVERRIDES_DISABLED.disabled)
probas = self.predict_proba(X) return self.classes_[np.argmax(probas, axis=1)].ravel()
'id': course_id, 'name': course_overview.display_name, 'number': course_overview.display_number_with_default, 'org': course_overview.display_org_with_default,
digits = datasets.load_digits() X = np.asarray(digits.data, 'float32') X, Y = nudge_dataset(X, digits.target)
subject = u'Confirmation and Invoice for {course_name}'.format(course_name=course.display_name) message = render_to_string('emails/registration_codes_sale_email.txt', context)
if expected_labels != [self.VISIBILITY_LABEL_ALL]: expected_labels.append(self.VISIBILITY_LABEL_SPECIFIC) self.assertItemsEqual(expected_labels, [option.text for option in visibility_editor.selected_options])
filters = {'course_id': course_key, 'user': request.user} if uri != '': filters['uri'] = uri
self.save_and_verify_discussion_topics(key=self.inline_key)
return cls.api_access_status(user) == cls.APPROVED
diff = y - activations[-1] deltas[last] = -diff
sign_active = np.empty(max_features, dtype=np.int8) drop = False
score_means = list() score_stds = list() percentiles = (1, 3, 6, 10, 15, 20, 30, 40, 60, 80, 100)
staff = self.make_staff() self.assertTrue(CourseStaffRole(self.course.id).has_user(staff))
return 'configuration/{}/current/{}'.format(cls.__name__, entity_id)
for kernel in kernels: K_call_diag = np.diag(kernel(X)) K_diag = kernel.diag(X) assert_almost_equal(K_call_diag, K_diag, 5)
self.client.login(username=self.coach.username, password="test")
X1 *= np.sqrt(p)
url = reverse('instructor_dashboard', kwargs={'course_id': self.course.id.to_deprecated_string()}) self.assert_request_status_code(200, url)
results = [] for option in self.all_options: button = option.find_element_by_css_selector('input.input') if button.is_selected(): results.append(option) return results
elif video_descriptor.html5_sources: video_url = video_descriptor.html5_sources[0] else: video_url = video_descriptor.source
self.results = batch()
textinput = self.q(css=self._bounded_selector("#cohort-name")).results[0] textinput.clear() textinput.send_keys(cohort_name)
student_module = StudentModule.objects.filter( course_id=self.course.id, student=self.student_user ) baseline = BaseStudentModuleHistory.get_history(student_module) self.assertEqual(len(baseline), 3)
validate_badge_image(get_image('good'))
self.client.logout() response = self.client.get(self.get_token_url) self.assertEqual(response.status_code, 302)
selector = RFE(estimator, step=0.20) sel = selector.fit(X, y) assert_equal(sel.support_.sum(), n_features // 2)
D, E = pairwise_distances_argmin_min(X, Y, metric=minkowski, metric_kwargs={"p": 2}) assert_array_almost_equal(D, [0, 1]) assert_array_almost_equal(E, [1., 1.])
self.assertTrue(self._has_changes(locations['grandparent'])) self.assertTrue(self._has_changes(locations['parent']))
self.value = {}
self.find_css('.collection-name-input').first.fill(value)
last = self.n_layers_ - 2
X = rng.rand(n_samples, n_features)
prompt = len(channels.values()) > 1
if self.total_curr_counts == 0: self.reset() raise StopIteration()
self.dispatch_table = copyreg.dispatch_table.copy()
if not patterns: return default return any(fnmatch(filename, pattern) for pattern in patterns)
rng = make_np_rng(None, 322, which_method="shuffle")
xf.XMODULE_FACTORY_LOCK.enable()
try: existing_user = User.objects.get(username=username) existing_user_profile = UserProfile.objects.get(user=existing_user) except ObjectDoesNotExist: raise UserNotFound() return existing_user, existing_user_profile
with self.assertRaises(UnsupportedRevisionError): self.store.delete_item( private_leaf.location, self.user_id, revision=ModuleStoreEnum.RevisionOption.draft_preferred )
assert_array_almost_equal(dist1, dist2)
CertificateGenerationConfiguration(enabled=True).save() resp = views.progress(self.request, course_id=unicode(self.course.id)) self.assertNotContains(resp, 'Request Certificate')
def __init__(self, msg, eigenvalues, eigenvectors): ArpackError.__init__(self, -1, {-1: msg}) self.eigenvalues = eigenvalues self.eigenvectors = eigenvectors
user_partititons = self.course.user_partitions self.assertEqual(len(user_partititons), 2) self.assertEqual(user_partititons[0].name, 'Name 0')
old_name = None if "name" in update: old_name = existing_user_profile.name
if not self.test_spec: test_spec = self.test_dir else: test_spec = self.test_dir / self.test_spec
AccessTestData(partition_groups={1: 1, 2: 2}, merged_parents_list=[{1: {1}}], expected_access=True),
modulestore = XMLModuleStore( DATA_DIR, source_dirs=['toy'], xblock_mixins=(XModuleMixin,), load_error_modules=False)
close_bracket = (token_type == tokenize.OP and text in ']})')
unique_student_identifier = strip_if_string(unique_student_identifier) if "@" in unique_student_identifier: student = User.objects.get(email=unique_student_identifier) else: student = User.objects.get(username=unique_student_identifier) return student
self.n_layers_ = len(layer_units)
modulestore().update_item(course, ModuleStoreEnum.UserID.primitive_command)
actions = None
'lang_pref.middleware.LanguagePreferenceMiddleware',
if not hasattr(self, 'non_redundant'): self.non_redundant = False if not hasattr(self, 'mask_weights'): self.mask_weights = None
return HttpResponse()
Y = np.zeros((y.shape[0], self.K), dtype=np.float64) for k in range(self.K): Y[:, k] = y == k
module = CapaFactory.create(rerandomize=RANDOMIZATION.ALWAYS, show_reset_button=False, done=True) self.assertTrue(module.should_show_reset_button())
THEME_NAME = ENV_TOKENS.get('THEME_NAME', None) COMPREHENSIVE_THEME_DIR = path(ENV_TOKENS.get('COMPREHENSIVE_THEME_DIR', COMPREHENSIVE_THEME_DIR))
'microsite_configuration',
self.login_page.visit() self.assertScreenshot('#login .login-providers', 'login-providers-{}'.format(self.browser.name))
if not isinstance(choices[0], (list, tuple)): choices = [choices]
y_score = sparse_random_matrix(n_components=y_true.shape[0], n_features=y_true.shape[1], random_state=random_state)
self.store.delete_item( self.icrv.location, ModuleStoreEnum.UserID.test, revision=ModuleStoreEnum.RevisionOption.published_only ) self._update_partitions()
y = np.zeros(n_eval) if eval_MSE: MSE = np.zeros(n_eval)
self.assertFalse(self._has_changes(locations['grandparent'])) self.assertFalse(self._has_changes(locations['parent']))
scalings = (V[:rank] / std).T / S[:rank]
svc = LinearSVC(random_state=0) multi_class_svc = OneVsRestClassifier(svc) multi_target_svc = MultiOutputClassifier(multi_class_svc)
link_index = None for index in range(len(all_links)): if course_id in all_links[index]: link_index = index break
return _write_styles('.xmodule_display', output_root, _list_modules())
self.assertEqual(user_info["version"], settings.EDXMKTG_USER_INFO_COOKIE_VERSION)
with storebuilder.build() as (__, store): course1 = CourseFactory.create(modulestore=store) course2 = CourseFactory.create(modulestore=store)
]
sorted_active_contents = sorted(active_contents, key=itemgetter('group_name')) sorted_inactive_contents = sorted(inactive_contents, key=itemgetter('group_name'))
n_samples = 12 n_samples_partial_fit = 3 n_features = 2 rng = np.random.RandomState(42) X = rng.rand(n_samples, n_features) X_partial_fit = rng.rand(n_samples_partial_fit, n_features)
can_enroll = bool(has_access(request.user, 'enroll', course)) invitation_only = course.invitation_only is_course_full = CourseEnrollment.objects.is_course_full(course)
response = self.client.post(url, { 'unique_student_identifier': self.student.email, })
response = client.post(url, data=json.dumps(data), content_type=content_type) self.assertEqual(expected_status, response.status_code) return response
return Fragment(self.get_html())
first_transaction.delete() second_transaction.delete() self._assert_history_transactions([])
if node_ids: if labels: node_string += 'node ' node_string += characters[0] + str(node_id) + characters[4]
old_stdout, old_stderr = sys.stdout, sys.stderr try: sys.stdout = StringIO() sys.stderr = StringIO()
unit = self.go_to_unit_page() component = unit.xblocks[1] self.modify_display_name_and_verify(component)
XQUEUE_INTERFACE['url'] = 'http://localhost:8040'
world.browser.execute_script("window.scrollTo(0,1024)") assert world.is_css_present("button.check.is-disabled")
(['honor', 'verified', 'audit'], ['1', '2', '3']),
self._layers.append(layer) if self._params is not None: self._params.update(layer._params)
self._setup_mode_and_enrollment(self.PAST, "verified")
code = "1/0" g = {} cache = {} with self.assertRaises(SafeExecException): safe_exec(code, g, cache=DictCache(cache))
self.courseware_page.visit() annotation_component_page = AnnotationComponentPage(self.browser) self.assertEqual( annotation_component_page.component_name, 'Test Annotation Module'.format() ) return annotation_component_page
self.assertIn('donation_for_course', self.client.session) self.assertIn(unicode(self.course.id), self.client.session['donation_for_course'])
if (n_inliers_subset == n_inliers_best and score_subset < score_best): continue
pca = PCA(n_components=15, whiten=False) data = pca.fit_transform(digits.data)
x = _ravel(x) return np.dot(x, x)
centers = [[1, 1], [-1, -1], [1, -1]] X, _ = make_blobs(n_samples=10000, centers=centers, cluster_std=0.6)
raise NotImplementedError
face = face / 255
html_module = self.store.get_item(course_id.make_usage_key('html', 'nonportable')) self.assertIn('/static/foo.jpg', html_module.data)
assert_not_in(attribute, seq.xml_attributes)
if key.scope not in self.VALID_SCOPES: return False
clf = MockClassifier() grid_search = GridSearchCV(clf, {'foo_param': [1, 2, 3]}, refit=True) grid_search.fit(X, y)
if isinstance(usage_key, BlockUsageLocator):
clf = svm.SVC(kernel='linear') clf.fit(X, y)
'edxmako.middleware.MakoMiddleware',
return self._validation_paragraph('not-configured').present
source_keys = [source_container.children[0]] new_blocks = self.store.copy_from_template(source_keys, dest_key=course.location, user_id=self.user_id) self.assertEqual(len(new_blocks), 1)
folds_iter = self.iterator(mode="sequential", num_batches=nfolds) folds = list(folds_iter) return folds
EmptyPromise( lambda: self.field(field_id) is not None, "Field with id \"{0}\" is in DOM.".format(field_id) ).fulfill()
from docutils.statemachine import ViewList self.content = ViewList(lines, self.content.parent)
current_year = datetime.datetime.now().year self.set_year_of_birth(current_year - 10) self.assertFalse(self.profile.requires_parental_consent())
vec = np.zeros(n_features * n_classes) vec[0] = 1 hess_col = hessp(vec)
with super(CreateSubCommentUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
split_store = modulestore()
response = requests.Response() response.status_code = 400 return response
completed = True
self._make_eligible() self._purchase_credit() request_uuid = self._initiate_request() self._set_request_status(request_uuid, "rejected")
response = perform_search( "unique", user=self.user, size=10, from_=0, course_id=unicode(self.course.id)) self.assertEqual(response['total'], 1)
super(XBlockTestCase, self).setUp()
self.assertEqual( utils.get_discussion_category_map(self.course, self.instructor, cohorted_if_in_list, exclude_unstarted), expected )
self.q(css=self.content_groups_css + " .action-add").first.click()
django.test.signals.template_rendered.send(sender=None, template=None, context=kwargs) return orig_render(*args, **kwargs)
for url_name, url_path in header_urls.iteritems(): header_urls[url_name] = request.build_absolute_uri(url_path)
clf = linear_model.LogisticRegression(C=1e5) clf.fit(X, y)
max_scores_cache.set(self.locations[0], 1) self.assertEqual(max_scores_cache.num_cached_updates(), 1)
response_dict = self._get_page_data(response) self.assertEqual(response_dict['message_key'], expected_message)
curr_batch_size = np.minimum(self._batch_size, self.len_curr_counts[curr_len]) curr_pos = self.len_indices_pos[curr_len]
return cls._do_reindex(modulestore, library_key)
return inst.user.username
if request.user.is_authenticated() and survey.utils.must_answer_survey(course, user): return redirect(reverse('course_survey', args=[unicode(course.id)]))
return u"{user}, {course}".format( user=self.username, course=self.course.course_key, )
axes = self.input_axes assert len(axes) == 4
image_dtype = numpy.dtype(image_dtype)
youtube_str = '1.00:p2Q6BrNhdh8' youtube_str_hack = '1.0:p2Q6BrNhdh8' self.assertEqual( VideoDescriptor._parse_youtube(youtube_str), VideoDescriptor._parse_youtube(youtube_str_hack) )
changed_module = StudentModule.objects.get(pk=self.module_to_reset.pk) self.assertEqual( json.loads(changed_module.state)['attempts'], 0 )
fake_data_api.reset() cached_details = api.get_course_enrollment_details(self.COURSE_ID)
#'papersize': 'letterpaper',
module_path, _, name = path.rpartition('.') return getattr(import_module(module_path), name)
K_test = np.dot(X_[180:], X_[:180].T) y_test = y_[180:]
self._set_form_verification_deadline(form, None) form.save()
raise ReferentialIntegrityError( u"{} parents claim {}".format(len(parents), location) )
xmin, xmax = plt.xlim() ymin, ymax = plt.ylim() coef = clf.coef_ intercept = clf.intercept_
print(('%10s ' + '%16s ' * (len(header_fields) - 1)) % tuple(header_fields))
mako_middleware_process_request(request)
init_params = init_params[1:]
log.debug(u"Referrer hostname is `None`, so it is not on the whitelist.")
course_enrollment.mode = u'verified' course_enrollment.save() self.assertEqual(course_enrollment.mode, u'verified')
output = tensor.dot(patch_stack, kerns.flatten(2).T).reshape((B, OR, OC, K))
cache.clear() CertificateGenerationConfiguration.objects.create(enabled=True) self.client.login(username=self.global_staff.username, password='test')
SECRET_KEY = "very_secret_bok_choy_key"
return iter(self.estimators_)
assert_not_equal(len(np.intersect1d(tr_a, tr_b)), len(tr1))
self.create_programs_config(enable_student_dashboard=False) actual = utils.get_programs_for_dashboard(self.user, self.COURSE_KEYS) self.assertEqual(actual, {})
return self._find_block(self.course, self.chapter_url_name, 'chapter', CONTENT_DEPTH - 1)
fe_bp_h1 = free_energy_at_beta(W_list, b_list, nsamples, beta, pa_bias, marginalize_odd=marginalize_odd) free_energy_fn = theano.function([beta], fe_bp_h1)
try: WindowsError except NameError: WindowsError = None
),
default="images_course_image.jpg"
target = target / 100000.0
args.extend(arg)
cache.clear()
y_pred[:, k] += (learning_rate * tree.value[:, 0, 0].take(terminal_regions, axis=0))
for key in kwargs: args["openid." + key] = kwargs[key]
for idx, code in enumerate(sorted(final_codes)):
choices.append((choice.get("name"), components))
start_index = expression.end_index
X, y, _, _, _ = _preprocess_data(X, y, fit_intercept, normalize, copy=False)
self.assertEqual(meter.progress, list(progresses))
factory_class = SparseSGDClassifier
'ENABLE_CORS_HEADERS': False,
students = self._create_students(10)
for name in names: if name not in self.names_to_del: self.names_to_del.append(name)
self.assertEquals(len(audit_log_calls), 0)
from django.core.wsgi import get_wsgi_application application = get_wsgi_application()
SupportedFieldType( 'merged_visible_to_staff_only', VisibilityTransformer, requested_field_name='visible_to_staff_only', )
log.exception(ex)
self.mock_tracker.reset_mock() try: views.server_track(request, str(sentinel.event_type), '{}')
self.seed = randomization_bin(self.runtime.seed, unicode(self.location).encode('utf-8'))
self.assertEquals(preview.latex_preview('2^3^(4+5)'), '2^{3^{4+5}}')
return self.badgeassertion_set.filter(user=user)
unique_rank, inv_rank = np.unique(y_score[i], return_inverse=True) n_ranks = unique_rank.size rank = n_ranks - inv_rank
fetched = self.store.get_item(discussion_item.location)
component_css = 'button[data-category=html]' if boilerplate: component_css += '[data-boilerplate={}]'.format(boilerplate) else: component_css += ':not([data-boilerplate])'
provider_url = reverse('openid-provider-xrds') factory = RequestFactory() request = factory.request() abs_provider_url = request.build_absolute_uri(location=provider_url)
return len(self.xblock_components)
result = {} for key in keys: if key in d: result[key] = d[key] return result
password_label = _(u"Password")
answer_map = dict() for response in self.responders.keys(): results = self.responder_answers[response] answer_map.update(results)
cohorted_topics = self.q(css=self._bounded_selector('.check-discussion-subcategory-%s:checked' % key)) return len(cohorted_topics.results)
enrollment.activate() self.assertTrue(CourseEnrollment.is_enrolled(user, course_id)) self.assert_no_events_were_emitted()
LETTUCE_SELENIUM_CLIENT = os.environ.get('LETTUCE_SELENIUM_CLIENT', 'local')
URLCONF_MODULES = ['myapp.url', 'another_app.urls']
return SurveyAnswer.get_answers(self, user, limit_num_users=limit_num_users)
if auth_entry and auth_entry in pipeline.AUTH_DISPATCH_URLS: redirect_uri = pipeline.AUTH_DISPATCH_URLS[auth_entry]
self.assertEqual(response.status_code, 200)
if self.cleaned_data.get("verification_deadline"): return self.cleaned_data.get("verification_deadline").replace(tzinfo=UTC)
uncommented_start_index = self._uncommented_start_index(mako_template, start_index) if uncommented_start_index != start_index: start_index = uncommented_start_index continue
repr(fbeta_score)
return self.teams_configuration.get('max_team_size', None)
weights[rng.rand(n_samples) < 0.1] = 0
_ = lambda text: text
with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
self.assert_enrollment_status()
for data in generated_certificates: data['report_run_date'] = report_run_date
if ancestor: direct_children_only = lambda parent: parent == ancestor ancestors.append(create_xblock_info( ancestor, include_child_info=include_child_info, course_outline=course_outline, include_children_predicate=direct_children_only )) collect_ancestor_info(get_parent_xblock(ancestor))
def _str_header(self, name, symbol='`'): return ['**' + name + '**'] + [symbol*(len(name)+4)]
return self.cmap
course = course or self.course role = Role.objects.create(name=role_name, course_id=course.id) role.users = users
instructor_task = self._create_entry() succeeded, message = get_task_completion_info(instructor_task) self.assertFalse(succeeded) self.assertEquals(message, "No status information available")
if library: component_types = [component for component in component_types if component != 'discussion']
coffee = cls.js.setdefault('coffee', []) js = cls.js.setdefault('js', [])
with mock_create_basket(exception=exceptions.SlumberBaseException): response = self._post_to_view() self.assertValidEcommerceInternalRequestErrorResponse(response) self.assertUserNotEnrolled()
#default_role = None
return self.q(css='h1.page-header')[0].text.split('\n')[-1]
clean_warning_registry() with warnings.catch_warnings(record=True) as w: warnings.simplefilter('always')
self.assertTrue(exam_attempts_section.is_student_attempt_visible)
pred = np.argmax(sp_clf.decision_function(iris.data), 1) assert_array_almost_equal(pred, clf.predict(iris.data.toarray()))
self.assertEqual(item.title, title) self.assertEqual(item.subtitles, subtitles)
for inputfile in inputfiles:
with self.assertRaises(SearchIndexingError): reindex_course_and_check_access(self.course.id, self.user)
jll = safe_sparse_dot(X, (self.feature_log_prob_ - neg_prob).T) jll += self.class_log_prior_ + neg_prob.sum(axis=1)
course_url = u'/course/{}'.format(unicode(self.course.id)) self.assertEqual(xblock_studio_url(self.course), course_url)
TASK_LOG.info(u'%s, Task type: %s, Finalizing grade task', task_info_string, action_name) return task_progress.update_task_state(extra_meta=current_step)
return '{path}?username={username}&course_key={course_key}'.format( path=reverse(self.view_name), username=eligibility.username, course_key=eligibility.course.course_key )
VerificationCheckpoint.objects.create(course_id=self.course.id, checkpoint_location=self.checkpoint_midterm)
del self.bias_from_marginals
if self.choice is None: return None return self.descriptor.get_children()[self.choice]
STUDENTMODULEHISTORYEXTENDED_OFFSET = ENV_TOKENS.get( 'STUDENTMODULEHISTORYEXTENDED_OFFSET', STUDENTMODULEHISTORYEXTENDED_OFFSET )
self.assertIn("Email or password is incorrect.", self.login_page.wait_for_errors())
try: record = cls.objects.get(course_id=course_id) return record.email_enabled except cls.DoesNotExist: return False
self.user = User.objects.create_user(self.uname, self.email, self.password)
checkpoint = verification_statuses.get(checkpoint) has_completed_check = bool(checkpoint)
n_clusters_1 = len(set(labels)) - int(-1 in labels) assert_equal(n_clusters_1, n_clusters)
from .utils.validation import check_array data = check_array(data, accept_sparse='csr') row_ind, col_ind = self.get_indices(i) return data[row_ind[:, np.newaxis], col_ind]
n_jobs, n_estimators, starts = _partition_estimators(self.n_estimators, self.n_jobs)
ENROLLMENT_COURSE_DETAILS_CACHE_TIMEOUT = ENV_TOKENS.get('ENROLLMENT_COURSE_DETAILS_CACHE_TIMEOUT', 60)
xpath = "//div[@class='%s ']" % div_class self.assert_has_xpath(xml, xpath, self.context)
if hasattr(self, 'usesTime') and self.usesTime(): record.asctime = self.formatTime(record, self.datefmt)
non_draft_loc = as_published(location)
for n_neighbors in [3, 5, 7]: I_computed = _compute_mi(x, y, True, False, n_neighbors) assert_almost_equal(I_computed, I_theory, 1)
from __future__ import unicode_literals
raise NotImplementedError
for kernel in kernels: gpc = GaussianProcessClassifier(kernel=kernel).fit(X, y) assert_almost_equal(gpc.log_marginal_likelihood(gpc.kernel_.theta), gpc.log_marginal_likelihood(), 7)
self.assert_grade(problem, 'choice_3', 'incorrect')
self._verify_branch_setting(ModuleStoreEnum.Branch.draft_preferred) _verify_revision_is_published(location)
descriptor = modulestore().get_course(course_key) model = cls(descriptor) return model
X_train += 1.
cls.objects.filter(user=user, name=name).delete() cls.objects.create(user=user, name=name, value=value)
post_params = sign(self.CLIENT_POST_PARAMS)
if settings.THEME_NAME == "": settings.THEME_NAME = None return
self.assertEqual(len(courses), 1)
problem_page.click_hint() self.assertIn("Hint (1 of 2): mathjax should work1", problem_page.extract_hint_text_from_html) problem_page.verify_mathjax_rendered_in_hint()
c = 0.03 X_c = (X + c)[:, np.newaxis, :] Y_c = (Y + c)[np.newaxis, :, :]
cls.create_and_enroll_student( courses=[cls.test_course_2], username='student_enrolled_other_course_not_on_team' )
profile_privacy = UserPreference.get_value(user, ACCOUNT_VISIBILITY_PREF_KEY) return profile_privacy if profile_privacy else configuration.get('default_visibility')
url = reverse('verify_student_start_flow', kwargs=course_kwargs)
template_packages = [__name__] @classmethod def get_template_dir(cls): return 'templates/test'
self.advanced_settings.undo_changes_via_modal()
is_increasing = assert_no_warnings(check_increasing, x, y) assert_true(is_increasing)
self.thread_cache = threading.local()
self.assertIn( ccx_course_key, [access.course_id for access in all_courses] )
iris = datasets.load_iris() X = iris.data[:, [0, 2]] y = iris.target
request.session['attempting_upgrade'] = (message == self.UPGRADE_MSG)
self.factory(eta0=0, learning_rate="constant")
module = CapaFactory.create(rerandomize=RANDOMIZATION.NEVER, max_attempts=2, done=True) self.assertTrue(module.should_show_save_button())
self.assertFalse(user_has_role(self.user, CourseCreatorRole()))
return y - expit(pred.ravel())
django_cache.clear() config_cache.clear()
X_train, X_test, y_train, y_test, sw_train, sw_test = \ train_test_split(X, y, sample_weight, test_size=0.9, random_state=42)
X_mb = X[:10] X_mb_csr = X_csr[:10] x_mb_squared_norms = x_squared_norms[:10] x_mb_squared_norms_csr = x_squared_norms_csr[:10]
dataname = dataname.lower().replace(' ', '-') return re.sub(r'[().]', '', dataname)
self.assertEqual(item.title, title) self.assertEqual(item.notes, notes)
return self.q(css='input[name=export-ora2-data]')
bulk_ops_record.unnest()
tmp = sorted(class_mapping, key=class_mapping.get)
scenarios = { "2_choices_correct": ("checkbox_two_choices", "correct"), "2_choices_incorrect": ("checkbox_two_choices", "incorrect"),
self.q(css=self.NEXT_PAGE_BUTTON_CSS).click() self.wait_for_ajax()
AutoAuthPage(self.browser, course_id=self.course_id).visit()
meta = xml_object.find('meta') if meta is None: return '' dmdata = meta.text if remove: xml_object.remove(meta) return dmdata
roles = (CourseStaffRole, CourseInstructorRole)
try: self[key] except KeyError: return default
return MilestoneError() if get_pre_requisite_courses_not_completed(user, course_id) else ACCESS_GRANTED
self.xblock_fields = {}
self.assertTrue(res_json['success']) self.assertEqual( res_json['message'], u"Certificate generation started for white listed students." )
if settings.FEATURES.get('AUTOMATIC_AUTH_FOR_TESTING'): urlpatterns += ( url(r'^auto_auth$', 'student.views.auto_auth'), )
tmp = X[i, :].copy() X[i, :] = X[j, :] X[j, :] = tmp
self.assertEqual(len(mail.outbox), 0)
for video in videos: video["status"] = StatusDisplayStrings.get(video["status"])
dup_gr_nbrs = np.all(sample_mask, axis=1) sample_mask[:, 0][dup_gr_nbrs] = False
response = self.client.post(self.url, { "email": self.EMAIL, }) self.assertHttpBadRequest(response)
META_UNIVERSITIES = {'UTx': ['UTAustinX']}
with filesystem.open('updates.html', 'r') as grading_policy: on_disk = grading_policy.read() self.assertEqual(on_disk, course_updates.data)
settings.ALLOWED_HOSTS.append(hostname) self.addCleanup(settings.ALLOWED_HOSTS.pop)
return microsite.get_value( 'COURSE_ABOUT_VISIBILITY_PERMISSION', settings.COURSE_ABOUT_VISIBILITY_PERMISSION )
self.event[u'old'] = self.event[u'current_tab'] self.event[u'new'] = self.event[u'current_tab'] + self.offset
stack.append(_Node(next_child, get_children))
active_attempts = cls.objects.filter(user=user, status='ready').order_by('-created_at') if active_attempts: return active_attempts[0] else: return None
iterator = super(HDF5DatasetDeprecated, self).iterator(*args, **kwargs) iterator.__class__ = HDF5DatasetIterator return iterator
return reverse_course_url(self.VIEW_NAME, course_key)
if hang_closing: yield start, "E133 closing bracket is missing indentation"
pass
return Response(create_comment(request, request.data))
def __init__(self, *vargs): pass
assert isinstance(location, (NoneType, UsageKey)) if location is None: return None return super(UsageKeyField, self).to_mongo(location.to_deprecated_string())
html_logo = 'logos/scikit-learn-logo-small.png'
self.reload_course() new_tab = CourseTabList.get_tab_by_type(self.course.tabs, tab_type) self.assertEqual(new_tab.is_hidden, new_is_hidden_setting)
if expected != actual: raise AssertionError("values not equal, expected: %r, actual: %r" % (expected, actual))
return self.find_courses(data['user'], CourseStaffRole.ROLE, data.get('values'))
naughty_update = { "username": "not_allowed", "gender": "undecided", "email": "not an email address" }
prefix = _('Hint ({hint_num} of {hints_count}): ').format(hint_num=hint_index + 1, hints_count=len(demand_hints))
cohort_list[0].users.add(*user_list) cohort_list[0].users.clear() assert_events("removed", user_list, cohort_list[:1]) mock_tracker.reset_mock()
with mock_create_refund(status=200, response=[]): self.send_signal() self.assertFalse(mock_send_notification.called)
X2, Y2, p_c, p_w_c = make_multilabel_classification( n_samples=25, n_features=20, n_classes=3, random_state=0, allow_unlabeled=allow_unlabeled, return_distributions=True)
return self._folds[0].get_params()
self.update_structure(course_key, new_structure)
num_braces = 0
super(TestFooter, self).setUp() cache.clear()
denied_banner = any(item.display for item in reverifications["denied"])
return dict(map(get_discussion_id_map_entry, get_accessible_discussion_modules(course, user)))
ecommerce_service = EcommerceService() if ecommerce_service.is_enabled(user): url = ecommerce_service.checkout_page_url(sku)
Xt = np.array(X).T
rval = X.copy()
requirement = CreditRequirement.objects.create( course=course, namespace='grade', name='grade', )
return (0., 0., 0., 0)
if self.fitted: self.fit()
_, setting = self._get_setting_entry(field_name) return self._verify_setting_entry(setting, field_name, field_value)
'edx_proctoring',
name = _make_profile_image_name(username) return {size: _get_profile_image_filename(name, size) for size in _PROFILE_IMAGE_SIZES}
sh("pip uninstall --disable-pip-version-check -y {}".format(package_name)) uninstalled = True
self.assertTrue(cohorts.is_course_cohorted(self.course.id))
self.descriptor = self.modulestore.return_value.get_item.return_value
#source_encoding = 'utf-8-sig'
b_float32 = astype(a_int32, dtype=np.float32, copy=False) assert_equal(b_float32.dtype, np.float32)
return self.q(css=TEAMS_HEADER_CSS + ' .page-description')[0].text
membership = CohortMembership.objects.create( user=user, course_user_group=get_random_cohort(course_key) ) return request_cache.data.setdefault(cache_key, membership.course_user_group)
username_or_email = row.get('email') or row.get('username') cohort_name = row.get('cohort') or '' task_progress.attempted += 1
cache_timeout = 300 string_field = models.TextField() int_field = models.IntegerField(default=10)
selector = self.get_element_selector(CSS_CLASS_NAMES['poster']) return self.q(css=selector).visible
X = coo_matrix(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
CELERYD_HIJACK_ROOT_LOGGER = False
return redirect(reverse('cas-login'))
return self.background_task_history_button.click()
xpath = "//p[@class='status']" self.assert_has_text(xml, xpath, expected_text, exact=False)
return course_metadata_utils.course_start_date_is_default( self.start, self.advertised_start )
return self.get_setting_element(self.PROBLEM_TYPE_LABEL).get_attribute('value')
xpath = "//div[@class='indicator-container']/span" self.assert_no_xpath(xml, xpath, self.context)
transform = AdditiveChi2Sampler(sample_steps=3) X_trans = transform.fit_transform(X) Y_trans = transform.transform(Y)
save_child_position(self.course, self.chapter_url_name) save_child_position(self.chapter, self.section_url_name)
CourseStaffRole(self.course.id).add_users(self.instructor) self.test_send_to_all()
act_func = None if i == 0: act_func = self.aes[0].act_dec else: act_func = self.aes[i - 1].act_enc
correct = ['unknown'] * len(idset) messages = [''] * len(idset) overall_message = ""
assert_no_warnings(metric, y_true_bin, y_pred_bin)
topo_tensors = norb.get_topological_view(single_tensor=False) expected_topo_tensors = tuple(expected_topo_tensor[:, i, ...] for i in range(2))
VerificationCheckpoint.objects.create( course_id=self.course.id, checkpoint_location=self.checkpoint_midterm, )
store = contentstore() assets, __ = store.get_all_content_for_course(location.course_key) for asset in assets: asset_location = asset['asset_key'] del_cached_content(asset_location) store.delete(asset_location)
with check_number_of_calls(object_with_method, method_name, num_calls, num_calls): yield
self.cart1 = Order.get_cart_for_user(self.first_verified_user) CertificateItem.add_to_order(self.cart1, self.course_key, self.cost, 'verified') self.cart1.purchase()
params = self.get_params() updates = OrderedDict(izip_no_length_check(params, params)) self.modify_updates(updates) f = function([], updates=updates) f()
return self.child_at(index)
'ENABLE_DASHBOARD_SEARCH': False,
if not callable(getattr(estimator, method)): raise AttributeError('{} not implemented in estimator' .format(method))
assert_array_equal(np.intersect1d(train, test), [])
mock_from_django_user.return_value = Mock()
return cls.objects.filter(microsite_id=microsite_pk).values_list('organization', flat=True)
key_fields = key_fields or cls.KEY_FIELDS return 'configuration/{}/key_values/{}'.format(cls.__name__, ','.join(key_fields))
return np.empty(0, dtype=np.int), np.empty(0, dtype=float)
return _check_range_and_return('rotation change', label, -4, 4)
if msg:
for req_file in PYTHON_REQ_FILES: sh("pip install -q --disable-pip-version-check --exists-action w -r {req_file}".format(req_file=req_file))
from sklearn.linear_model import ElasticNet
super(SSLClientTest, self).setUp() self.client = Client() self.factory = RequestFactory() self.mock = Mock()
key = cleaned_string(key) key_prefix = cleaned_string(key_prefix) version = cleaned_string(version)
thumbnail_content, thumbnail_location = static_content_store.generate_thumbnail(content)
SECRET_KEY = 'dev key'
try: return PaidCourseRegistrationAnnotation.objects.get(course_id=self.course_id).annotation except PaidCourseRegistrationAnnotation.DoesNotExist: return u""
context.update(get_certificate_header_context(is_secure=request.is_secure())) context.update(get_certificate_footer_context())
self.set_config(False)
form_descriptions = _get_form_descriptions(request)
return 'bookmarked' if self.q(css='.bookmark-button.bookmarked').present else ''
self.split_mongo.create_course( self.split_course_key.org, self.split_course_key.course, self.split_course_key.run, self.user_id, fields=fields, root_block_id='runid' )
self.assertEqual( StudentModule.objects.filter( student=self.module_to_reset.student, course_id=self.module_to_reset.course_id, ).count(), 0 )
assert preprocessor.P_.shape == (self.X.shape[1], self.X.shape[1]) assert_allclose(np.dot(preprocessor.P_, preprocessor.inv_P_), identity, rtol=1e-4)
self.assertEqual(courses_list, courses_list_by_groups)
est = TreeEstimator() assert_raises(NotFittedError, est.apply, T)
with self.assertRaises(auth_models.User.DoesNotExist): self.get_user_by_email(strategy, email)
from sklearn.neighbors import kneighbors_graph connectivity = kneighbors_graph(X, n_neighbors=10, include_self=False)
if 'user_id' in context and 'course_id' in context: message_body = substitute_keywords_with_data(message_body, context)
self.q(css='.dropdown-menu li a').nth(2).click()
clf_3 = ForestEstimator(n_estimators=15, max_depth=3, warm_start=True, random_state=1, bootstrap=True, oob_score=False) clf_3.fit(X, y) assert_true(not(hasattr(clf_3, 'oob_score_')))
return self.q(css='{} input[name=reset-entrance-exam-attempts]'.format(self.EE_CONTAINER))
try: model.add_polyak_channels(self._worker.param_to_mean, algorithm.monitoring_dataset) except AttributeError: pass
assert_array_equal(X_r, iris.data)
response = data['submission']
super(TabsPageTests, self).setUp()
BODY_SELECTOR = ".note-section" TITLE_SELECTOR = ".course-subtitle"
json_output = json.dumps(returned_result) if len(json_output) > 1023: raise ValueError("Length of task output is too long: {0}".format(json_output)) return json_output
FOOTER_OPENEDX_URL = "http://open.edx.org"
if cls.USE_PLUGIN_MANAGER: return set(cls.get_available_plugins().itervalues()) else: return set()
self.assertEqual( second_group.id, ps_uncached.get_user_group_id_for_partition(user_partition_id) )
self._assert_no_redirect(self.course_with_bogus_survey)
assert_equals('"/static/data_dir/file.png"', replace_static_urls(STATIC_SOURCE, DATA_DIRECTORY))
rng = np.random.RandomState(0) X = rng.normal(size=(10, 4)) y = multioutput_estimator_convert_y_2d(name, X[:, 0]) regressor = Regressor()
django_settings.SOCIAL_AUTH_LOGIN_ERROR_URL = '/'
BULK_EMAIL_LOG_SENT_EMAILS = False
alphas = alphas[:n_iter + 1] coefs = coefs[:n_iter + 1]
super(CourseGraderUpdatesTest, self).setUp() self.url = get_url(self.course.id, 'grading_handler') self.starting_graders = CourseGradingModel(self.course).graders
global Image if Image is None: raise RuntimeError("You are trying to use PIL-dependent functionality" " but don't have PIL installed.")
clf = RandomForestClassifier(n_estimators=25) clf.fit(X_train_valid, y_train_valid) clf_probs = clf.predict_proba(X_test) score = log_loss(y_test, clf_probs)
splitted_data = train_test_split(X, y, random_state=42) with TempMemmap(splitted_data) as (X_train, X_test, y_train, y_test): _lars_path_residues(X_train, y_train, X_test, y_test, copy=False)
multioutput = None
config.set_options(ignore_setup_xxx_py=True, assume_default_configuration=True, delegate_options_to_subpackages=True, quiet=True)
self._captions_visibility(False)
return response.content
pca = PCA(n_components=2)
super(MixedModuleStore, self).clone_course(source_course_id, dest_course_id, user_id, fields, **kwargs)
filter_sequence_ui_event = lambda event: event.get('name', '').startswith('edx.ui.lms.sequence.')
std = Xc.std(axis=0) std[std == 0] = 1. fac = 1. / (n_samples - n_classes)
annotation_input_selector = self.active_problem_selector('.annotation-input') return self.q(css=annotation_input_selector).visible
return ( obj["anonymous"] or obj["anonymous_to_peers"] and not self.context["is_requester_privileged"] )
cls.js.setdefault('xmodule_js', resource_string(__name__, 'js/src/xmodule.js'))
ModeCreationPage( self.browser, self.course_id, mode_slug=u'verified', mode_display_name=u'Verified Certificate', min_price=10, suggested_prices='10,20' ).visit()
rval = -(self.beta * T.dot(state, self.ising_bias()))
self._lock = threading.Lock()
num_vis = rng.randint(1,11) n_classes = rng.randint(1, 11)
role = CourseCcxCoachRole(course_key) self.assertTrue(role.has_user(self.coach))
data_x = np.cast[config.floatX](data['data']) data_x = data_x[MNISTPlus.idx[which_set]]
self.navigate_to_video()
return ' '.join([ descriptor.display_org_with_default, descriptor.display_number_with_default ])
while np.sum(support_) > n_features_to_select: features = np.arange(n_features)[support_]
self.browser.set_window_size( initial['width'], initial['height'] )
try: data_root = path(settings.GITHUB_REPO_ROOT) subdir = base64.urlsafe_b64encode(repr(courselike_key)) course_dir = data_root / subdir filename = request.FILES['course-data'].name
session = self.client.session session['attempting_upgrade'] = True session.save()
self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + H2 -> H2O2', exact=True))
rotation = np.zeros((n_components, n_components)) rotation[:, 0] = vectors[random_state.randint(n_samples), :].T
return self.posterior.get_params()
if value is None and key != '_id.revision': del query[key]
cache = {"course_cache": "blah blah blah"} modulestore().request_cache.data.update(cache)
return (isinstance(subspace, NullSpace) or (isinstance(subspace, CompositeSpace) and len(subspace.components) == 0))
report_dir = (Env.REPORT_DIR / system).makedirs_p()
if isinstance(source, (tuple, list)): source, = source
if self.beta0 is not None: self.beta0 = np.atleast_2d(self.beta0) if self.beta0.shape[1] != 1: self.beta0 = self.beta0.T
self.assertEqual(rendered_html.tag, "div")
from __future__ import unicode_literals
course_mode_info = self._enrollment_with_complete_course('honor') self.assertTrue(course_mode_info['show_upsell']) self.assertEquals(course_mode_info['days_for_upsell'], 1)
block_wrappers.append(partial( replace_static_urls, getattr(descriptor, 'data_dir', None), course_id=course_id, static_asset_path=static_asset_path or descriptor.static_asset_path ))
try: from xblock_django.user_service import DjangoXBlockUserService from crum import get_current_user
self.wait_for_ajax() self.wait_for_element_presence(MODAL_SELECTOR, 'Validation Modal is present')
email_body = mail.outbox[0].body result = re.search(r'(?P<url>https?://[^\s]+)', email_body) self.assertIsNot(result, None)
variation = close - open
rgr_ridge = Ridge(alpha=0.2) rgr_ridge.fit(proj_operator, proj.ravel()) rec_l2 = rgr_ridge.coef_.reshape(l, l)
if self.transcript_language == 'en': return Transcript.asset(self.location, youtube_id).data
course = CourseFactory.create() course.display_coursenumber = escaping_content
component_2 = _graph_connected_component(affinity, p[stop - 1]) assert_equal(component_2.sum(), component_size) assert_array_equal(component_1, component_2)
decision_only = OneVsRestClassifier(svm.SVR()).fit(X_train, Y_train) assert_raises(AttributeError, decision_only.predict_proba, X_test)
r = [] for attr, value in sorted(self.__dict__.items()): if attr.startswith("hyperparameter_"): r.append(value) return r
X_scaled_back = scaler.inverse_transform(X_scaled) assert_true(X_scaled_back is not X) assert_true(X_scaled_back is not X_scaled) assert_array_almost_equal(X_scaled_back, X)
return [self.modulestore.get_item(child) for child in self.children]
wait_for( func=lambda _: EC.invisibility_of_element_located((By.CSS_SELECTOR, css_selector,)), timeout=timeout, timeout_msg="Timed out waiting for {} to be invisible.".format(css_selector) )
min_estimators = 15 max_estimators = 175
v0 = random_state.uniform(-1,1, A.shape[0]) w, _ = eigsh(A, k=k, sigma=0.0, v0=v0)
selectors = compound_hint.get('value').upper().split() selector_set = set(selectors)
extra_params = dict(x_left_lower_corner=-94.8, Nx=1212, y_left_lower_corner=-56.05, Ny=1592, grid_size=0.05) dtype = np.int16
if definition_id is None: definition_id = LocalId()
npy_filename_root = os.path.join(preprocess('${PYLEARN2_DATA_PATH}'), 'icml07data', 'npy', npy_filename)
self.assertEqual(json.loads(resp.content).get('status'), 'Transcripts are supported only for "video" modules.')
module.system.user_is_staff = False
"xmodule_js",
for X in (X_dense, X_sparse_pruned, X_sparse_unpruned):
CourseRerunState.objects.initiated(source_course_key, destination_course_key, request.user, fields['display_name'])
log.debug( "SafeCookieData received empty user_id '%s' for session_id '%s'.", user_id, session_id, )
u = linalg.solve_triangular(self.G.T, np.dot(self.Ft.T, rt) - f.T, lower=True)
n_classes = 4 n_samples = 100
n_splits = int(n_features / block_size) X2 = X ** 2 emp_cov_trace = np.sum(X2, axis=0) / n_samples mu = np.sum(emp_cov_trace) / n_features
self.go_to_tab_and_assert_problem(1, self.problem1_name) problem1_content_after_coming_back = self.problem_page.problem_content self.assertIn(problem1_content_after_coming_back, problem1_content_before_switch)
self.q(css="button.js-reset").click()
for n_labels in range(2, 10): y_score = np.ones((1, n_labels))
self._mock_paver_needs = patch.object(pavelib.quality.run_quality, 'needs').start() self._mock_paver_needs.return_value = 0
self.assertEqual(len(mail.outbox), 1)
return LibraryLocator( self.courselike_key.org, self.courselike_key.library )
for memmap in (self.X, self.y): memmap.flush() memmap.setflags(write=False)
assert_raises(ValueError, pipe.set_params, anova__C=0.1)
if 'account_privacy' in update: update_user_preferences( requesting_user, {'account_privacy': update["account_privacy"]}, existing_user )
return _render_report_form(start_date, end_date, start_letter, end_letter, report_type, date_fmt_error=True)
return self._decision_function(X)
upload_csv_to_report_store(rows, 'student_profile_info', course_id, start_date)
speed_selector = self.get_element_selector(CSS_CLASS_NAMES['video_speed']) return self.q(css=speed_selector).text[0]
for row in data: writer.writerow(row) csv_data = read_and_flush() yield csv_data
activation_key = create_account(self.USERNAME, self.OLD_PASSWORD, self.OLD_EMAIL) activate_account(activation_key)
expr = stripXML(self.mathml_start + expr + self.mathml_end) expected = stripXML(self.mathml_start + expected + self.mathml_end)
est = TreeEstimator(min_samples_split=10, max_leaf_nodes=max_leaf_nodes, random_state=0) est.fit(X, y) node_samples = est.tree_.n_node_samples[est.tree_.children_left != -1]
X_blobs, _ = make_blobs(n_samples=100, centers=10, random_state=0) X_blobs = sparse.csr_matrix(X_blobs)
self.assertEqual( res_json['message'], u'Please select one or more certificate statuses that require certificate regeneration.' )
train_data, test_data, target_train, target_test = train_test_split( data, target, test_size=.2, random_state=0)
expected_classes = ['Different persons', 'Same person'] assert_array_equal(lfw_pairs_train.target_names, expected_classes)
self.rng = make_np_rng(None, [2012, 10, 17], which_method="uniform")
self.navigate_to_video()
with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
self.browser.switch_to_window(browser_window_handles[-1])
self.post.assert_called_with(callback_url, data=expected_callback_dict)
train_with_monitoring_datasets( train_dataset=dataset1, monitoring_datasets=no_monitoring_datasets, model_force_batch_size=False, train_iteration_mode='sequential', monitor_iteration_mode='sequential')
with self.assertRaisesRegexp(CommandError, regex): call_command('git_add_course', *args, stderr=StringIO.StringIO())
mask = np.ones((size, size), dtype=np.int16) A = grid_to_graph(n_x=size, n_y=size, n_z=size, mask=mask) assert_true(connected_components(A)[0] == 1)
self.assertTrue('Activate Course Enrollment' in response.content)
self.label_distributions_ = np.zeros((n_samples, n_classes)) for label in classes: self.label_distributions_[y == label, classes == label] = 1
for url_name in self.EXPECTED_URL_NAMES: self.assertContains(response, reverse(url_name))
raise NotImplementedError()
if has_access(user, u'staff', descriptor.location, course_id): system.error_descriptor_class = ErrorDescriptor else: system.error_descriptor_class = NonStaffErrorDescriptor
if not is_prerequisite_courses_enabled(): return None from milestones import api as milestones_api milestones_api.remove_course_milestone( course_key, milestone, )
return list( { attr: video[attr] for attr in ["edx_video_id", "client_video_id", "created", "duration", "status"] } for video in _get_videos(course) )
self.assertTrue(self._has_changes(published_xblock.location))
self.registration.activate() self.assertTrue(self.user.is_active) self.assertFalse(mock_segment_identify.called)
metadata_translations = dict(RawDescriptor.metadata_translations) metadata_translations['id'] = 'discussion_id' metadata_translations['for'] = 'discussion_target'
rho_0 = math.tanh(F - 1.96 * F_se) rho_1 = math.tanh(F + 1.96 * F_se)
structure_entry = self._lookup_course(structure_id, head_validation=head_validation) root = structure_entry.structure['root'] result = self._load_items(structure_entry, [root], depth, **kwargs) return result[0]
dot_update = (old_W * scal_points).sum(axis=0)
answer = event_info.get('answers', {}).get(response.answer_id) if answer is not None: event_info['answers'][response.answer_id] = response.unmask_name(answer)
if N.size(imshp)==2: inshp = (1,)+imshp
if not alpha == 0: assert_array_less(np.diff(costs), 0)
return self.answer_values
labels = [0, 1, 2, 3] * 3 + [4, 5] * 5
if course_mode_has_price and (access['finance_admin'] or access['sales_admin']): sections.append(_section_e_commerce(course, access, paid_modes[0], is_white_label, is_white_label))
import_course_from_xml( self.store, self.user.id, root_dir, ['test_export'], static_content_store=content_store, target_id=course_id, )
start = datetime.now(UTC) self.add_icrv_xblock(related_assessment_name="Midterm A", start_date=start)
MIN_PRICE = 1438
norb_train = FoveatedNORB(which_set="train", scale=1, restrict_instances=[4, 6, 7, 8])
assert V is orig_V assert drop_mask is orig_drop_mask
cache.clear()
"median_absolute_error",
H, W = img_shape Hs, Ws = tile_spacing
teams_per_topic = 10 topics = self.setup_topics(num_topics=self.NUM_TOPICS, teams_per_topic=teams_per_topic) self.assert_serializer_output(topics, num_teams_per_topic=teams_per_topic, num_queries=1)
course_registration_codes = CourseRegistrationCode.objects.filter(order=self.cart)
return set_logged_in_cookies(request, response, user)
if self._count >= self.start: return self.final_momentum return self._init_momentum
SOCIAL_MEDIA_FOOTER_URLS = {}
lazymod_py_file = lazymod.__file__ if lazymod_py_file.endswith("c"): lazymod_py_file = lazymod_py_file[:-1]
plt.subplot(2, 2, i + 1) plt.subplots_adjust(wspace=0.4, hspace=0.4)
url = BASE_URL + "/howitworks" def is_browser_on_page(self): return self.q(css='body.view-howitworks').present
_sentinel = object()
config = DashboardConfiguration(recent_enrollment_time_delta=timeout) config.save()
ret = get_editable_fields( Comment(user_id=context["cc_requester"]["id"], type="comment"), context ) ret |= NON_UPDATABLE_COMMENT_FIELDS return ret
always_cohort_inline_discussions = models.BooleanField(default=True)
result = self.client.login(username=self.USERNAME, password=self.NEW_PASSWORD) self.assertTrue(result)
if not GlobalStaff().has_user(request.user): raise PermissionDenied()
self.add_credit_course() CourseFactory.create(org='edX', number='DemoX', display_name='Demo_Course')
'edxval',
for lib in self.list_libraries(): if all([lib[key] == kwargs[key] for key in kwargs]): return True return False
colors = ['r-', 'b-', 'y-', 'm-']
CreditProvider.objects.create( provider_id="ASU", enable_integration=True, provider_url="https://credit.example.com/request" )
A = np.abs(random_state.randn(10, 10)) A[:, 2 * np.arange(5)] = 0
self.wait_for_element_visibility('.create-user-button', "Add team member button is available") self.click_add_button() self.set_new_user_email(email) self.click_submit_new_user_form() self.wait_for_page()
self.assertFalse([ requirement for requirement in requirements if requirement['namespace'] == 'proctored_exam' ])
Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape)
url(r'^api/val/v0/', include('edxval.urls')),
instance._state.db = using or DEFAULT_DB_ALIAS
click_css(self, 'a.action-cancel', require_notification=False)
params = [(param, request.GET[param]) for param in POST_AUTH_PARAMS if param in request.GET]
clf = svm.LinearSVC(random_state=0).fit(X, Y) sp_clf = svm.LinearSVC(random_state=0).fit(X_sp, Y)
self._add_block(self._block_relations, root_block_usage_key)
with open(self.TEST_INDEX_FILENAME, "w+") as index_file: json.dump({}, index_file)
microsite_courses = get_courses(user, org=alternate) self.assertTrue( all(course.org == alternate_course.org for course in microsite_courses) )
b = np.zeros((self.dim * 4,))
super(DashboardPage, self).__init__(browser)
user = User.objects.get(email=staff_email) token = default_token_generator.make_token(user) uidb36 = int_to_base36(user.id)
with self.assertRaises(IntegrityError): VerificationCheckpoint.objects.create(course_id=self.course.id, checkpoint_location=self.checkpoint_midterm)
return check_sum_of_calls(XBlock, ['__init__'], instantiations, instantiations, include_arguments=False)
v0 = random_state.uniform(-1, 1, A.shape[0]) _, u = eigsh(A, ncv=self.n_svd_vecs, v0=v0)
params["username"] = params["password"] = "test_username_and_password" assert_password_error("Username and password fields cannot match")
self.login(self.enrolled_user)
if ( tag == 'msubsup' and len(k) == 3 and gettag(k[2]) == 'mrow' and
eps = 1e-5 n, m = V.shape W, H = _initialize_nmf(V, r, init, random_state=0)
return super(NullBackend, self).is_request_in_microsite()
@receiver(pre_delete, sender=CohortMembership)
CONFIG_ROOT = path(os.environ.get('CONFIG_ROOT', ENV_ROOT))
if packages_to_upgrade==[]:
epoch_num = 1
raise NotImplementedError()
self.root_block_usage_key = root_block_usage_key
assert isinstance(reference, UsageKey) if source_course_id == reference.course_key: return reference.map_into_course(dest_course_id) else: return reference
language = models.CharField(blank=True, max_length=255, db_index=True) location = models.CharField(blank=True, max_length=255, db_index=True)
self.navigate_to_video()
return HttpResponse(json.dumps(request.META))
if not settings.FEATURES.get('MILESTONES_APP', False): return [] from milestones import api as milestones_api return milestones_api.get_course_milestones(course_id)
email_placeholder = _(u"username@domain.com")
self.lc_block = self.store.get_item(self.lc_block.location) self._bind_course_module(self.lc_block) self.lc_block.xmodule_runtime.publish = self.publisher
self.components_ = self._make_random_matrix(self.n_components_, n_features)
rvals, _ = scan( armijo, outputs_info=states, n_steps=n_iters, name='armijo', mode=theano.Mode(linker='cvm'), profile=profile)
request = build_launch_request() views.lti_launch(request, unicode(COURSE_KEY), unicode(USAGE_KEY)) render.assert_called_with(request, USAGE_KEY)
resp = self.client.get_html(get_url('course_handler', course_key, 'course_key_string')) return resp
if act_func is not None: activations[i] = act_func(activations[i])
faces_centered = faces - faces.mean(axis=0)
raise NotImplementedError("Deleting files from a package is not supported")
with super(ForumEventTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
EmptyPromise( lambda: self.q(css='a.button.action-primary').present, 'Delete prompt is displayed' ).fulfill()
WebDriverWait(browser, 6).until(EC.alert_is_present()) return browser.switch_to.alert
'rss_proxy',
self.assertEqual(resp.status_code, 400)
category_start_date = None for entry in entries: if category_start_date is None or entry["start_date"] < category_start_date: category_start_date = entry["start_date"]
for observer in self.observers: observer.update(event, self)
gp = GaussianProcessRegressor(kernel=kernel)
def loss_grad_fun(t): return mlp._loss_grad_lbfgs(t, X, Y, activations, deltas, coef_grads, intercept_grads)
world.visit(video_url)
view_converter = dense_design_matrix.DefaultViewConverter((image_size, image_size, 1), axes)
def __init__(self, n_components=8, random_state=None): super(GaussianRandomProjectionHash, self).__init__( n_components=n_components, random_state=random_state)
'CUSTOM_COURSE_URLS': False
return TEST_COURSE_KEY.make_usage_key('problem', problem_url_name)
ORA_STUB_URL = os.environ.get('ora_url', 'http://localhost:8041')
classifier.fit(data[:n_samples / 2], digits.target[:n_samples / 2])
super(CoachAccessTestCaseCCX, cls).setUpClass() cls.course = CourseFactory.create()
'ENABLE_SHOPPING_CART': False,
for student in students[:4]: CertificateWhitelistFactory.create( user=student, course_id=self.course.id, whitelist=True )
age = years_ago - 1 self.assertEqual(self.profile.age, age)
action()
from django.test import TestCase
channels=3
self.set_config(True) CourseOverviewImageSet.create_for_course(overview) self.assertTrue(hasattr(overview, 'image_set'))
output = StringIO.StringIO() test_log_handler = logging.StreamHandler(output) test_log_handler.setLevel(logging.DEBUG) glog = git_import.log glog.addHandler(test_log_handler)
else: return ""
recipients_info[email] += 1 to_list.pop()
self.create_programs_config() self.mock_programs_api(status_code=500) actual = utils.get_programs(self.user) self.assertEqual(actual, [])
actual = json.loads(response.content) self.assertEqual(actual, expected)
assert_raises(VerificationException, attempt.submit) assert_raises(VerificationException, attempt.approve) assert_raises(VerificationException, attempt.deny)
self.wait_for_ajax() video_selector = '{0}'.format(CSS_CLASS_NAMES['video_container']) self.wait_for_element_presence(video_selector, 'Video is initialized')
X = X_digits_multi[:10] y = y_digits_multi[:10]
rnd = np.random.RandomState(42) n_samples = 10 X = rnd.uniform(size=(n_samples, 4))
remove_all_instructors(action_state.course_key)
if self.user is not None and self.user.username == username: user = self.user else: user = User.objects.get(username=username)
img.thumbnail((width_sc, height_sc), Image.ANTIALIAS)
raise NotImplementedError()
for idx, asset in enumerate(orig): self.assertEquals(assets[idx].asset_id.asset_type, asset[0]) self.assertEquals(assets[idx].asset_id.path, asset[1])
rmtree(fs_root, ignore_errors=True)
super(IndexPage, self).__init__(browser)
if (os.path.exists(lockdirName) and os.path.isdir(lockdirName)): os.rmdir(lockdirName)
return self.make_call(reverse('teams_list'), expected_status, 'post', data, **kwargs)
assert result == any(subbatch_results), ("composite batch had a " "mixture of numeric and " "symbolic subbatches. This " "should never happen.") return result
filenames = np.array(filenames) target = np.array(target)
w = np.zeros(n_features + 1) loss_interp, grad_interp = _logistic_loss_and_grad( w, X, y, alpha=1. ) assert_array_almost_equal(loss, loss_interp)
with self.assertNumQueries(0): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
assert sp.issparse(rp.transform(sparse_data))
module.system.DEBUG = True
return settings.STATIC_URL + relative_url
pass
orphan = course_key.make_usage_key('chapter', 'OrphanChapter') self.store.create_item( self.user_id, orphan.course_key, orphan.block_type, block_id=orphan.block_id )
reconstruction_error = np.linalg.norm(K - K_iso) / Npts assert_almost_equal(reconstruction_error, clf.reconstruction_error())
CELERY_IMPORTS = ( 'openedx.core.djangoapps.programs.tasks.v1.tasks', )
resp_params['signed_field_names'] = ",".join(signed_fields)
self.update_structure(destination_course, destination_structure) self._update_head(destination_course, index_entry, destination_course.branch, destination_structure['_id'])
mode = 2 if Minv is None: Minv_matvec = get_inv_matvec(M, symmetric=True, tol=tol) else: Minv = _aslinearoperator_with_dtype(Minv) Minv_matvec = Minv.matvec M_matvec = _aslinearoperator_with_dtype(M).matvec
all_corr = ['absolute_exponential', 'squared_exponential', 'cubic', 'linear']
graders = _filter_entrance_exam_grader(graders)
if fit_intercept: grad[-1] = z0.sum()
response = client.get('/')
self._build_data_specs()
return self.report_download_links.map(lambda el: el.text)
with self.assertRaises(GitImportErrorRemoteBranchMissing): git_import.add_repo(self.TEST_REPO, repo_dir / 'edx4edx_lite', 'asdfasdfasdf')
code = np.empty((n_samples, n_components)) slices = list(gen_even_slices(n_samples, _get_n_jobs(n_jobs)))
check_estimators_unfitted("estimator", CorrectNotFittedErrorClassifier)
log_proba = clf.predict_log_proba(X)
return render_to_string('courseware/date_summary.html', self.get_context())
st_mode = st.st_mode read_all = stat.S_IRUSR read_all |= stat.S_IRGRP read_all |= stat.S_IROTH
pass
X = np.random.RandomState(21).randn(10, 3) y = np.random.RandomState(12).randn(10)
self._set_group_access({0: [1]}) expected[0]["groups"][1]["selected"] = True self.assertEqual(self._get_partition_info(), expected)
return { 'username': user.username, 'email': user.email, 'first_name': user.first_name, 'last_name': user.last_name, }
COMMENT_WITH_NL = tokenize.generate_tokens(['#\n'].pop).send(None)[1] == '#\n'
BASE_URL = os.environ.get('test_url', 'http://localhost:8003')
self.set_logged_in_cookies(request)
proba[(1.0 < proba) & (proba <= 1.0 + 1e-5)] = 1.0
n = len(X4) rng = np.random.RandomState(13) idx = np.arange(n) rng.shuffle(idx)
django_settings.SOCIAL_AUTH_LOGIN_REDIRECT_URL = _SOCIAL_AUTH_LOGIN_REDIRECT_URL
self.assertNotIn(self.notes_tab, self.course.tabs)
super(DraftModuleStore, self).delete_course(course_key, user_id)
org_list = list(set(org_list) | set(course.org for course in courses))
org_filter_out_set = microsite.get_all_orgs()
if self.initial_index is None: return self.index.get('versions', {}).keys()
y_upper = clf.predict(xx)
completion_check(user)
self.assertEqual(expected_block.fields, actual_block.fields) for field in expected_block.fields.values(): self.assertFieldEqual(field, expected_block, actual_block)
EmptyPromise( lambda: message in (self.message_for_field(field_id) or ''), "Messsage \"{0}\" is visible.".format(message) ).fulfill()
X = [[0]] Y = [[1], [2]] D = euclidean_distances(X, Y) assert_array_almost_equal(D, [[1., 2.]])
dataset = fetch_olivetti_faces(shuffle=True, random_state=rng) faces = dataset.data
Xs = {'train': x[0:ntrain], 'test': data['data'][0:ntest]}
self.create_credentials_config() self.create_programs_config()
input_dict = {'1_2_1': '21'} correct_map = problem.grade_answers(input_dict)
y[::5] += 3 * (0.5 - rng.rand(X.shape[0]/5))
world.wait_for( lambda _: world.css_has_value(grace_period_css, grace_period) )
if len(xml_object.xpath(cls._child_tag_name)) == 0: raise ValueError("Poll_question definition must include \ at least one 'answer' tag")
AutoAuthPage(self.browser, username="second", email="second@example.com", no_login=True).visit()
if (y_type not in ["binary", "multiclass", "multilabel-indicator"]): raise ValueError("{0} is not supported".format(y_type))
non_staff_client, _ = self.create_non_staff_authed_user_client() response = non_staff_client.get(index_url, {}, HTTP_ACCEPT='application/json') self.assertEqual(response.status_code, 403)
from __future__ import unicode_literals
acts = self._hidden_input(inputs) hiddens = self.act_enc(acts) act_grad = tensor.grad(hiddens.sum(), acts) return act_grad
#html_last_updated_fmt = '%b %d, %Y'
fit_params = fit_params if fit_params is not None else {} fit_params = dict([(k, _index_param_value(X, v, train)) for k, v in fit_params.items()])
block = self.get_a_block() self.assertEqual(block.inherited, "the default") self.assertEqual(block.not_inherited, "nothing")
self.q(css=self.EXPAND_COLLAPSE_CSS).click()
problem_item = self.store.create_item(self.user_id, test_course_key, 'problem', 'Problem_Item') self.assertFalse(self.store.has_published_version(problem_item))
log.warning( u"More than 1 ranges in Range header: %s for content: %s", header_value, unicode(loc) )
MobileApiConfig(video_profiles="mobile_low,youtube").save()
self.assertTrue(certificate_generation_history.exists())
X, y = datasets.make_friedman1(n_samples=1200, random_state=random_state, noise=1.0) X_train, y_train = X[:200], y[:200] X_test, y_test = X[200:], y[200:]
if isinstance(grade_response, dict) and 'msg' in grade_response: grade_response['msg'] = "<div>{0}</div>".format(grade_response['msg'])
return self.masquerade and self.masquerade.role == 'student'
cohorts_status = {}
exams = get_all_exams_for_course(unicode(self.course.id)) self.assertEqual(len(exams), 1)
mixed_stores.remove(store) mixed_stores.insert(0, store) return
ModeCreationPage( self.browser, self.course_id, mode_slug=u'verified', mode_display_name=u'Verified Certificate', min_price=10, suggested_prices='10,20' ).visit()
for _, record in self._active_records: if branch and branch not in record.index.get('versions', {}): continue
self.NOTE_ID_DOES_NOT_EXIST = 99999
self.assertEqual(response.status_code, 400)
"payment_params": get_signed_purchase_params( cart, callback_url=callback_url, extra_data=extra_data ),
try: return cls.objects.get(user=user).status except cls.DoesNotExist: return None
self.verbose = bool(self.verbose)
__ = CourseOverview.get_from_id(course.id)
X_orig = sparse_random_matrix(5, 5, density=0.75, random_state=0)
xml = self.render_to_xml(self.context) xpath = "//div[@class='indicator-container']/span[@class='status correct']" self.assert_has_xpath(xml, xpath, self.context)
VERSION = 4
task_progress.failed += 1 err_rows.append([student.id, student.username, err_msg])
microsite.enable_microsites(log)
new_f.func_name = f.func_name return new_f
course = self.store.create_course('org_x', 'course_y', 'run_z', self.user_id) signal_handler.send.assert_called_with('course_published', course_key=course.id)
for state in READY_STATES: instructor_tasks = instructor_tasks.exclude(task_state=state) return instructor_tasks.order_by('-id')
#html_theme_options = {}
sh( "mongo {} --eval 'db.dropDatabase()' > /dev/null".format( Env.BOK_CHOY_MONGO_DATABASE, ) )
msg = '<div class="capa_alert">%s</div>' % msg return msg
FEATURES['ENABLE_LTI_PROVIDER'] = True INSTALLED_APPS += ('lti_provider',) AUTHENTICATION_BACKENDS += ('lti_provider.users.LtiBackend',)
test_invalid_token("AAAAAAAAAAAAAAAAAAAAAMoazRI7ePLjEWXN1N7keLw=", "padding")
check_node(test_course.location, None, after_create, self.user_id, after_create, after_edit, editing_user)
non_editable_fields = super(HtmlDescriptor, self).non_editable_metadata_fields non_editable_fields.append(HtmlDescriptor.use_latex_compiler) return non_editable_fields
if self._is_anonymous(obj) or obj["user_id"] is None: return None else: user_id = int(obj["user_id"]) return self._get_user_label(user_id)
reduced_likelihood_function_value = - np.inf par = {}
X = check_array(X, ensure_min_features=2, ensure_min_samples=2, estimator=self)
layers = model.get_all_layers() states = [final_state['V_hat']] + final_state['H_hat']
mb_data = MNIST(which_set='test').X[105:106, :]
with Timer() as iteration_over_courses_time_2: courses_list, __ = _accessible_courses_list(self.request) self.assertEqual(len(courses_list), USER_COURSES_COUNT)
return fetch_lfw_people(download_if_missing=download_if_missing, **kwargs)
rectangle_str = "(10,10)-(20,20);(100,100)-(200,200)"
time_last_reset = user.date_joined
self.assertFalse(CourseEnrollment.is_enrolled(self.user, self.course.id)) self.assert_no_events_were_emitted()
from __future__ import print_function
self.assertEqual(microsite.get_backend(None, BaseMicrositeBackend), None)
SITE_ID = 1 SITE_NAME = "example.com" HTTPS = 'on' ROOT_URLCONF = 'lms.urls'
super(TestTrackerInstantiation, self).setUp() self.get_backend = tracker._instantiate_backend_from_name
choices_correct = self._check_student_choices(binary_choices) inputs_correct = self._check_student_inputs(numtolerance_inputs) correct = choices_correct and inputs_correct
estimator.set_params(k=1)
return super(NullBackend, self).get_template_path(relative_path, **kwargs)
self.find_css('.action-edit .edit').first.click()
num_examples = 40 theano_rng = MRG_RandomStreams(2012+11+1)
return None
create_account(self.ALTERNATE_USERNAME, self.OLD_PASSWORD, self.NEW_EMAIL)
self.q(css=selector)[0].send_keys(value)
'ALLOW_WIKI_ROOT_ACCESS': True,
dummy_course = CourseFactory.create() GeneratedCertificateFactory.create( user=self.user, course_id=dummy_course.id, status=CertificateStatuses.generating, mode='honor' )
with check_mongo_calls(max_find.pop(0), max_send): self.assertFalse(self.store.has_item(self.fake_location))
self.assert_student_in_group(new_groups[0], new_user_partition)
from .tasks import update_library_index
self._assert_steps_displayed( response, PayAndVerifyView.PAYMENT_STEPS + PayAndVerifyView.VERIFICATION_STEPS, PayAndVerifyView.MAKE_PAYMENT_STEP, )
data = JUNK_FOOD_DOCS + NOTJUNK_FOOD_DOCS
return True
if self._is_in_bulk_operation(course_key, ignore_case): return self._get_bulk_ops_record(course_key, ignore_case).index else: return self.db_connection.get_course_index(course_key, ignore_case)
self.assertTrue(image_url.endswith('src_course_image-png-{}x{}.jpg'.format(*target)))
response = self.client.get(self.url) expected_html = '<button class="is-disabled" disabled>Enable Student-Generated Certificates</button>' self.assertContains(response, expected_html)
if not conf.get('sparse', False): valid_set = valid_set.get_value(borrow=True) test_set = test_set.get_value(borrow=True)
return self.q(css=self.experiment_groups_css).present or self.q(css=".experiment-groups-doc").present
non_cohort.users.add(*user_list) non_cohort.users.clear() self.assertFalse(mock_tracker.emit.called)
if isinstance(value, Country): if value.code: return value.code else: return None return value
X, y = check_X_y(X, y, multi_output=True, y_numeric=True) self.y_ndim_ = y.ndim if y.ndim == 1: y = y[:, np.newaxis]
self.submit_question_answer('p2', {'2_1': u'Incorrect'})
assert hasattr(self, 'shape')
BROKER_POOL_LIMIT = 0 BROKER_CONNECTION_TIMEOUT = 1
if correct: self.problem_page.click_choice("choice_0") self.problem_page.click_choice("choice_2") else: self.problem_page.click_choice("choice_1")
return HttpResponse(status=status.HTTP_500_INTERNAL_SERVER_ERROR)
([[], []], 0 ),
prb1 = StudentModule.objects.get( course_id=self.course.id, student=self.student_user )
field_name = models.CharField(max_length=64, db_index=True)
tasks = json.loads(response.content)['tasks'] self.assertEqual(len(tasks), 0)
values = ','.join(values)
self._validate_layer_names(layers) total = 0 for layer in self.layers: if layer.layer_name in layers: total += layer.get_input_space().get_total_dimension() return total
#categories = None
cache_key = cls.MESSAGE_URL_CACHE_KEY.format( access_point=access_point, course_key=course_key ) url = cache.get(cache_key)
super(TestLibraryExport, self).setUp() self.export_page = ExportLibraryPage(self.browser, self.library_key) self.export_page.visit()
log_proba = all_log_proba[0]
return render_to_string(template_name, dictionary, context, namespace="lms." + namespace)
def award(self, badge_class, user, evidence_url=None): return BadgeAssertionFactory(badge_class=badge_class, user=user)
extract_dir_relative = path.relpath(extract_dir, settings.DATA_DIR)
for status in ["submitted", "must_retry", "approved"]: attempt.status = status attempt.save() assert_true(SoftwareSecurePhotoVerification.user_has_valid_or_pending(user), status)
if not settings.FEATURES.get('ENABLE_VIDEO_UPLOAD_PIPELINE'): filtered_list.append('video_upload_pipeline')
self.store_precision = True
context[context_key] = request.META.get(header_name, '').decode('latin1')
n_faces = 5 rng = check_random_state(4) face_ids = rng.randint(test.shape[0], size=(n_faces, )) test = test[face_ids, :]
pass
BULK_EMAIL_MAX_RETRIES = 5
#html_logo = None
ForestRegressor = FOREST_REGRESSORS[name]
if not (isinstance(from_space, VectorSpace) and from_space.sparse): kwargs['batch_size'] = batch_size
module.system.user_is_staff = True
next_url = request.GET.get('next') if next_url: return redirect(next_url) else: return redirect('/course/')
if not run_diff_quality( violations_type="pylint", prefix=pythonpath_prefix, reports=pylint_reports, percentage_string=percentage_string, branch_string=compare_branch_string, dquality_dir=dquality_dir ): diff_quality_percentage_pass = False
assert_true(resample() is None)
self.addCleanup(self._mock_paver_needs.stop) self.addCleanup(os.remove, self.f.name)
self._xblock_map = {}
X_scaled_back = scaler.inverse_transform(X_scaled) assert_array_almost_equal(X_scaled_back, X)
CommitOnSuccessManager.ENABLED = False OuterAtomic.ALLOW_NESTED = True if not hasattr(OuterAtomic, 'atomic_for_testcase_calls'): OuterAtomic.atomic_for_testcase_calls = 0 OuterAtomic.atomic_for_testcase_calls += 1 return wrapped_func(*args, **kwargs)
(['honor', 'verified', 'audit'], 'course_modes_choose', CourseMode.HONOR),
return 1
self.dataset_remote_dir = "" self.dataset_local_dir = ""
thumbnail_content = StaticContent(thumbnail_file_location, thumbnail_name, 'image/jpeg', thumbnail_file)
progress = _progress_summary(student, request, course, field_data_cache, scores_client) if progress: return progress.chapters else: return None
class DraftReorderTestCase(ModuleStoreTestCase):
self._create_cert(self.courses[0].id, self.user, CertificateStatuses.error, mode)
response_dict = {(answer_key_prefix + k): v for k, v in responses.items()} resp = self.client.post(modx_url, response_dict)
DEBUG = True
signal_handler.send.assert_called_with('course_published', course_key=course.id)
if self.assume_centered: self.location_ = np.zeros(X.shape[1]) else: self.location_ = X.mean(0)
self.assertRaises(TypeError, Progress, 2j, 3)
DEPRECATED_SETTINGS = ["CSS Class for Course Reruns", "Hide Progress Tab", "XQA Key"]
mako_middleware_process_request(request)
self.hash_functions_ = [] self.trees_ = [] self.original_indices_ = []
parser.add_argument( '--commit', action='store_true', dest='commit', default=False, help='Really commit the changes, otherwise, just dry run', )
index = world.get_setting_entry_index(DISPLAY_NAME) world.set_field_value(index, '3.4') verify_modified_display_name()
CourseEnrollment.unenroll_by_email("jack@fake.edx.org", course_id) self.assertFalse(CourseEnrollment.is_enrolled(user, course_id)) self.assert_unenrollment_event_was_emitted(user, course_id)
pass
assert_equal(sys.modules['warnings'].filters, [])
def __unicode__(self): return u'ApiAccessConfig [enabled={}]'.format(self.enabled)
marginalize_odd = (depth % 2) == 0
if GeneratedCertificate.certificate_for_student(self.user, self.course_id) is not None: return False
allow_access(course_ccx, instructor, 'instructor')
self._submit_photos( face_image=self.IMAGE_DATA, photo_id_image=self.IMAGE_DATA, ) attempt = SoftwareSecurePhotoVerification.objects.get(user=self.user) attempt.photo_id_key = "dummy_photo_id_key" attempt.save()
self.TA_role_2.inherit_permissions(self.TA_role)
return self.construct_scalar(node)
if form.is_valid(): form.save( from_email=theming_helpers.get_value('default_from_email', settings.DEFAULT_FROM_EMAIL), domain_override=orig_host, use_https=is_secure ) else: raise UserNotFound
course = CourseFactory.create(default_store=default_store) not_enrolled_user = UserFactory.create() self.request.user = AdminFactory.create()
NAME_MIN_LENGTH = 2 NAME_MAX_LENGTH = 255
'DISPLAY_ANALYTICS_ENROLLMENTS': True,
attempt.status = "must_retry" attempt.system_error("System error") attempt.approve() attempt.status = "must_retry" attempt.deny(DENY_ERROR_MSG)
else: return HttpResponse(status=405)
return StudentModule.objects.get(course_id=self.course.id, student=User.objects.get(username=username), module_type=descriptor.location.category, module_state_key=descriptor.location, )
self.record_visit_unit( 'Lecture 1 - Doing the Right Thing', 'Discussion Prompt: Ethics of Torture', 'Discussion Prompt: Ethics of Torture' )
the_html = problem.get_html() self.assertRegexpMatches(the_html, r"<div>\s+</div>")
if predicate: self.assertTrue(expression) else: self.assertFalse(expression)
if params is None: params = {} data = copy(self.defaults) data.update(params) return self.request_body_xml_template.format(**data)
clf.intercept_scaling = 1 clf.fit(X, y) assert_almost_equal(clf.intercept_, 0, decimal=5)
user = User.objects.get(email=staff_email) token = default_token_generator.make_token(user) uidb36 = int_to_base36(user.id)
return self.q(css=self._bounded_selector('.add-admin-role')).text[0]
X = np.asarray(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
self.assertFalse('Invalid' in response.content)
if enrollment.mode in CourseMode.VERIFIED_MODES:
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
cache.delete(CreditCourse.CREDIT_COURSES_CACHE_KEY)
for result in resultset: location = as_published(Location._from_deprecated_son(result['_id'], course_id.run))
config.add_extension( '_isotonic', sources=['_isotonic.c'], include_dirs=[numpy.get_include()], libraries=libraries, )
selector = '{} .acid-parent-block {} .pass'.format(self.context_selector, test_selector) return bool(self.q(css=selector).execute(try_interval=0.1, timeout=3))
return [program['course_codes'][cc]['display_name'] for cc in course_codes]
self.check_val('False', False)
if math_expr.strip() == "": return float('nan')
self.course_nav.go_to_section('Test Section', 'Test Subsection')
with check_mongo_calls(max_find, max_send): self.store.unpublish(self.vertical_x1a, self.user_id)
self.client.ajax_post( self.seq1_url, data={'isPrereq': False} ) mock_remove_prereq.assert_called_with(self.seq1.location)
world.edit_component() type_in_codemirror(0, text) world.save_component()
self.assertEqual(config.get_text('.action-primary'), "Create") self.assertFalse(config.delete_button_is_present) config.save()
return JsonResponse({"error": unicode(err)}, 400)
has_active_or_pending = SoftwareSecurePhotoVerification.user_has_valid_or_pending( user, queryset=verifications )
SECRET_KEY = 'dev key'
if tmpdir is not None: shutil.rmtree(tmpdir)
self.verify_validation_update_usage_info(expected_result, mocked_message)
with super(SingleThreadUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create(discussion_topics={'dummy_discussion_id': {'id': 'dummy_discussion_id'}})
if not settings.FEATURES.get('MILESTONES_APP', False): return [] from milestones import api as milestones_api return milestones_api.get_milestones(namespace)
for batch in chunk(formated_data, SUBSCRIBE_BATCH_SIZE): result = mailchimp.listBatchSubscribe(id=list_id, batch=batch, double_optin=False, update_existing=True)
#
def __contains__(self, item): return True def __getitem__(self, item): return "notmigrations"
return str(self.q(css='.main-article h1').text[0])
self._wait_for( lambda: self.state == state, 'State is {state}'.format(state=state) )
if not _check_equality(treedic['1 cleaned_mm_list'], treedic['2 cleaned_mm_list']): return False
return np.asarray([clf.predict_proba(X) for clf in self.estimators_])
self.cache.set(key, compressed_pickled_data, None)
__, __ = self.log_in_as_instructor()
with warnings.catch_warnings(record=True): estimator = Estimator()
return theano._asarray(arg, dtype=dtype)
module = self.get_student_module(username, descriptor) state = json.loads(module.state) return state['attempts']
usage_id = LocationKeyField(max_length=255, db_index=True)
K = self.kernel_(self.X_train_)
assert len(self.dbm.hidden_layers) > 0
y_pred_rf = rf.predict_proba(X_test)[:, 1] fpr_rf, tpr_rf, _ = roc_curve(y_test, y_pred_rf)
urlconf = settings.ROOT_URLCONF if urlconf and urlconf in sys.modules: reload(sys.modules[urlconf]) reloaded = import_module(urlconf) reloaded_urls = reloaded.urlpatterns set_urlconf(tuple(reloaded_urls))
from sklearn import datasets datasets.mldata.urlopen = mock_mldata_urlopen(mock_datasets)
if which == 'LM':
assert key.user_id == self.user.id
transduction = self.classes_[np.argmax(self.label_distributions_, axis=1)] self.transduction_ = transduction.ravel() self.n_iter_ = self.max_iter - remaining_iter return self
#add_module_names = True
centered_obs = observations - self.location_ mahalanobis_dist = np.sum( np.dot(centered_obs, precision) * centered_obs, 1)
trainer = yaml_parse.load(test_yaml_layer1 % {'layer0_filename': layer0_filename, 'layer1_filename': layer1_filename}) trainer.main_loop()
return sum(i.line_cost for i in self.orderitem_set.filter(status=self.status))
layer_1_detector = FilterActs()(images, filters)
frag = Fragment(u"Hello there!") return frag
student_id = AutoAuthPage(self.browser).visit().get_user_id()
self.course_nav.go_to_section('Test Section 2', 'Test Subsection 2')
fgraph = f.maker.env
rnd = np.random.RandomState(0) X = rnd.normal(size=(3, 1)) mcd = MinCovDet() mcd.fit(X)
self.teams_page.click_all_topics() self.verify_my_team_count(0)
mod = inspect.getmodule(register_check) for (name, function) in inspect.getmembers(mod, inspect.isfunction): register_check(function)
AA = 1. / np.sqrt(np.sum(least_squares * sign_active[:n_active]))
with TIMER.timer("insert_course_index", course_context): course_index['last_update'] = datetime.datetime.now(pytz.utc) self.course_index.insert(course_index)
if key.field_name in self._fields: del self._fields[key.field_name]
return len(self.q(css='nav.course-navigation a.chapter'))
_verify_page_names('First', 'Empty')
FEATURES['ENABLE_PAYMENT_FAKE'] = True
OAUTH_ID_TOKEN_EXPIRATION = 5 * 60
UID_FIELD = "email"
i18n_service = ModuleI18nService(None) self.assertEqual(i18n_service.ugettext(self.test_language), 'XYZ-TEST-LANGUAGE')
while f1 != f2: f1=f2 (f2,ext)=os.path.splitext(f1)
y = iris.target
second_attempt = SoftwareSecurePhotoVerification.objects.create(user=user)
incremental_count = batch.shape[0] sample_count = batch.shape[0]
def custom_score(y_true, y_pred): return (((y_true == y_pred).sum() - (y_true != y_pred).sum()) / y_true.shape[0])
sim = np.array([[0, 5, 9, 4], [5, 0, 2, 2], [3, 2, 0, 1], [4, 2, 1, 0]])
client_args={"disable_ssl_certificate_validation": True}
return self.get_text('.group-configuration-id .group-configuration-value')
edit_link = "//" + settings.CMS_BASE + '/container/' + unicode(block.location)
return os.sep.join(__file__.split(os.sep)[:-4]) + '/data/imports/' + filename
return unicode(CCXLocator.from_course_locator(obj.course.id, obj.id))
if self.serversonly: return ""
from __future__ import unicode_literals
NOTIFICATION_EMAIL_CSS = ENV_TOKENS.get('NOTIFICATION_EMAIL_CSS', NOTIFICATION_EMAIL_CSS) NOTIFICATION_EMAIL_EDX_LOGO = ENV_TOKENS.get('NOTIFICATION_EMAIL_EDX_LOGO', NOTIFICATION_EMAIL_EDX_LOGO)
honor, _ = self.create_mode('honor', 'Honor') self.assertFalse(CourseMode.has_payment_options(self.course_key))
return dict( itertools.chain.from_iterable( store.heartbeat().iteritems() for store in self.modulestores ) )
X = np.ones((10, 2)) X[:5, :] = 0
Xt = X for name, transform in self.steps[:-1]: Xt = transform.transform(Xt) return self.steps[-1][-1].predict_log_proba(Xt)
assert_greater(gpc.log_marginal_likelihood(gpc.kernel_.theta), gpc.log_marginal_likelihood(kernel.theta))
label_to_fold = np.zeros(len(unique_labels))
FROM_ABOUT_INFO = from_about_dictionary FROM_COURSE_PROPERTY = from_course_property FROM_COURSE_MODE = from_course_mode
request.url = 'http://testurl/' self.xmodule.verify_oauth_body_sign(request)
meter = utils.ProgramProgressMeter(self.user, []) self._assert_progress(meter)
cauth = CourseAuthorization(course_id=self.course.id, email_enabled=True) cauth.save()
return md5(key + md5(key).hexdigest()).hexdigest()[:AES.block_size]
for key, expected_value in subset.iteritems(): self.assertEquals(superset[key], expected_value)
self.course.edxnotes = False self.assertEqual("original_get_html", self.problem.get_html())
block_types_list = {'block_type1', 'block_type2'} for field_name in ['block_counts', 'student_view_data']: self.form_data.setlist(field_name, block_types_list) self.cleaned_data[field_name] = block_types_list
from shoppingcart.processors.CyberSource2 import processor_hash
source = String( help=_("The external URL to download the video."), display_name=_("Download Video"), scope=Scope.settings, default="" ) download_video = Boolean(
SECRET_KEY = '85920908f28904ed733fe576320db18cabd7b6cd'
class_counts = np.bincount(y)[2:] assert_almost_equal(np.dot(cw, class_counts), y.shape[0]) assert_true(cw[0] < cw[1] < cw[2])
key = 'a' * length
import scipy.sparse as sp import numpy as np
grad_shared = sharedX(zv) z_shared = sharedX(zv)
subject = "Re-verification Status" mock_send_email.assert_called_once_with(self.user.id, subject, ANY)
X, y = make_hastie_10_2(n_samples=20, random_state=1) clf = BaggingClassifier(n_estimators=5, warm_start=True, oob_score=True) assert_raises(ValueError, clf.fit, X, y)
lib_key = LibraryLocator("TestOrg", "TestLib") result = self.draft_store.has_course(lib_key) assert_false(result)
pass
for i in xrange(int(numpy.sqrt(N)),0, -1): if 0 == N % i: return (i, N/i)
#show_authors = False
if not organizations_enabled(): return None from organizations import api as organizations_api return organizations_api.add_organization_course(organization_data=organization_data, course_key=course_id)
SITE_ID = 1 SITE_NAME = "localhost:8001" HTTPS = 'on' ROOT_URLCONF = 'cms.urls'
#epub_max_image_width = 0
self.problem_section = ItemFactory.create(parent_location=chapter.location, category='sequential', metadata={'graded': True, 'format': 'Homework'}, display_name=TEST_SECTION_NAME)
figure_list = []
y = iris.target colors = "bry"
description = "A Location object, saved to the DB in the form of a string" KEY_CLASS = UsageKey
key = self.lti_consumer.consumer_key self.assertTrue(SignatureValidator(self.lti_consumer).check_client_key(key))
with self.assertRaises(xmodule.exceptions.NotFoundError): module.rescore_problem()
msg = 'Disabling timed exam {exam_id}'.format(exam_id=exam['id']) log.info(msg) update_exam( exam_id=exam['id'], is_proctored=False, is_active=False, )
text = views.course_about(self.request, unicode(course_key)).content return text
if not self.has_course(source_course_id): raise ItemNotFoundError("Cannot find a course at {0}. Aborting".format(source_course_id))
self._assert_request_status(request_uuid, "pending")
block_structure_result = xblock_key in block_structure has_access_result = bool(has_access(user, 'load', self.get_block(i), course_key=self.course.id))
pieces = modulename.split('.') str_e = str(e) found = True in [piece.find(str(e)) != -1 for piece in pieces]
start = datetime.now(UTC) first_block = self.add_icrv_xblock(related_assessment_name="Midterm Start Date")
now_patch = patch('onelogin.saml2.utils.OneLogin_Saml2_Utils.now', return_value=timestamp) now_patch.start() self.addCleanup(now_patch.stop)
for create_data, additional_data_to_expect in data: xblock_cache = XBlockCache.create(create_data) create_data.update(additional_data_to_expect) self.assert_xblock_cache_data(xblock_cache, create_data)
return "input_" + cls.answer_key(response_num, input_num)
self.q(css=".xblock-student_view .timed-exam .start-timed-exam").first.click() self.wait_for_element_presence(".proctored_exam_status .exam-timer", "Timer bar")
with super(UserProfileUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
return not self.q(css=CSS_CLASS_NAMES['video_spinner']).visible
connectivity = connectivity + connectivity.T
is_enrolled = CourseEnrollment.is_enrolled(self.user, self.course.id) self.assertTrue(is_enrolled)
DEFAULT_SITE_ID = 1
self.login_and_enroll() self.logout()
score_dict = self.get_score() return score_dict['score'] == score_dict['total']
del installed_packages_list[package.name]
num_optout = len(optouts) to_list = [recipient for recipient in to_list if recipient['email'] not in optouts] return to_list, num_optout
self.assertEqual(module.attempts, 1)
self.assertDeserializeEqual('False', 'False') self.assertDeserializeEqual('True', 'True')
page.wait_for_component_menu() click_css(page, 'button>span.large-advanced-icon', menu_index, require_notification=False)
raised = False try: fmt.theano_expr(theano.tensor.itensor3()) except ValueError: raised = True assert raised
for draft in to_process_drafts: draft_loc = Location._from_deprecated_son(draft["_id"], course_key.run) draft_as_non_draft_loc = as_published(draft_loc)
cls.course_hidden_visibility = CourseFactory.create( display_name='Hidden_course', org='TestMicrositeX', catalog_visibility=CATALOG_VISIBILITY_NONE, emit_signals=True, )
from __future__ import print_function
self._create_students(num_emails - 1)
self._test_run_with_task( generate_certificates, 'certificates generated', 0, 0, expected_attempted=1, expected_total=1 )
STATIC_ROOT = (TEST_ROOT / "staticfiles" / "cms").abspath()
estimator.set_params(alpha=.5)
get_request_dict = { CapaFactoryWithFiles.input_key(response_num=2): fileobjs, CapaFactoryWithFiles.input_key(response_num=3): 'None', }
categories = np.empty(N_CATEGORIES, dtype=object) for k in category_names.keys(): categories[category_names[k]] = k
self.client.login(username="jack", password="test") LinkedInAddToProfileConfiguration( company_identifier='0_mC_o2MizqdtZEmkVXjH4eYwMj4DnkCWrZP_D9', enabled=True ).save()
request = get_request_for_user(self.user) answer_entrance_exam_problem(self.course, request, self.problem_1)
if is_staff is not None: user.is_staff = (is_staff == "true") user.save()
StudentModuleHistoryExtended.objects.filter(student_module=instance).all().delete()
self.random_start = int(self.random_start)
except ProcessingError as err: log.warning("Module encountered an error while processing AJAX call", exc_info=True) return JsonResponse({'success': err.args[0]}, status=200)
errstring = "Course not found." with self.assertRaisesRegexp(CommandError, errstring): call_command('force_publish', unicode('course-v1:org+course+run'))
response = self.client.post(self.url, data) self.assertHttpBadRequest(response)
self.user.is_staff = True
with self.assertRaisesRegexp(GitExportError, unicode(GitExportError.CANNOT_PULL)): git_export_utils.export_to_git( course_key, 'https://user:blah@example.com/r.git')
return cls.objects.get(course_key=course_key, enabled=True)
THIRD_PARTY_AUTH_OLD_CONFIG = AUTH_TOKENS.get('THIRD_PARTY_AUTH', None)
success = 'correct' for answer_id in correct_map: if not correct_map.is_correct(answer_id): success = 'incorrect'
base_attr = super(BulkAssertionTest, self).__getattribute__(name) if name.startswith('assert'): return self._wrap_assertion(base_attr) else: return base_attr
'PREVENT_CONCURRENT_LOGINS': True,
MODULESTORE_FIELD_OVERRIDE_PROVIDERS = ()
text_list = self._find_within(selector).text return text_list[0] if text_list else None
self.assertTrue(self.video.downloaded_transcript_contains_text('txt', 'Equal transcripts'))
else: final_codes ,= set(codebook.keys())
content_type, __ = mimetypes.guess_type(template)
self._check_parameters(X)
import numpy as np import matplotlib.pyplot as plt from sklearn.tree import DecisionTreeRegressor from sklearn.ensemble import AdaBoostRegressor
courses_list_by_groups, __ = _accessible_courses_list_from_groups(self.request) self.assertEqual(courses_list_by_groups, [])
time = {} n_samples = np.linspace(start=0, stop=opts.n_population, num=opts.n_steps).astype(np.int)
if path_cache is not None: path_cache[block_key] = True
url(r'^gradebook$', 'instructor.views.gradebook_api.spoc_gradebook', name='spoc_gradebook'),
pass
for library in NPM_INSTALLED_LIBRARIES: sh('/bin/cp -rf node_modules/{library} {vendor_dir}'.format( library=library, vendor_dir=NPM_VENDOR_DIRECTORY, ))
settings.ALLOWED_HOSTS = ["the_valid_website.com"] with self.assertRaises(SuspiciousOperation): safe_get_host(request)
ret_list.append('%s: %s,' % (key, val))
assert isinstance(course_key, CourseKey) store = self._get_modulestore_for_courselike(course_key) return store.delete_course(course_key, user_id)
response = self.client.get(self.url) self.assertTrue(self.e_commerce_link in response.content) self.assertFalse('Coupons List' in response.content)
self.assertIsNone(xblock_info.get('is_header_visible', None))
breadcrumbs = self._breadcrumb(num_units=num_units, modified_name=modified_name) breadcrumbs.reverse() self.assertEqual(bookmarked_breadcrumbs, breadcrumbs)
providers_string = _("{first_providers}, and {last_provider}").format( first_providers=u", ".join(providers[:-1]), last_provider=providers[-1] )
instance.set_grading_policy(policy)
from __future__ import unicode_literals
mock_tracker.assert_any_call( event_name, kwargs, )
CreditRequirementStatus.add_or_update_requirement_status( username, req_to_update, status=status, reason=reason )
return BACKEND.get_dict(dict_name, default, **kwargs)
return self._validation_paragraph('warning').present
def test_real_user(useless): useless_user = Mock(email='fake@fake.com', id=useless) return useless_user
MAX_STUDENTS_PER_PAGE_GRADE_BOOK = 20
REQUIRE_JS = "js/vendor/requirejs/require.js"
success = self.success return (bool(success), success)
termination_criterion = EpochCounter(5)
with open(Env.METRICS_DIR / "pep8", "w") as f: f.write(violations_count_str + '\n\n') f.write(violations_list)
response = self.get_with_bearer_token('/oauth2-test/') self.assertEqual(response.status_code, status.HTTP_200_OK)
world.wait_for_ajax_complete()
import pickle
course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
providers = OAuth2ProviderConfig.objects.all() self.assertEquals(len(providers), 1) self.assertEquals(providers[pcount].id, provider1.id)
return redirect(AUTH_DISPATCH_URLS[AUTH_ENTRY_LOGIN])
sorted_grid_scores = list(sorted(search.grid_scores_, key=lambda x: x.mean_validation_score)) best_score = sorted_grid_scores[-1].mean_validation_score assert_equal(search.best_score_, best_score)
if not sparse.issparse(X) or has_sw: solver = 'cholesky' else: solver = 'sparse_cg'
self.events = []
self.assertEqual(resp.status_code, 200)
self._verify_unit_warning( self.UnitState(is_released=True, publish_state=self.PublishState.NEVER_PUBLISHED, is_locked=True), self.STAFF_ONLY_WARNING )
self.q(css="a#add-allowance").click() self.wait_for_element_presence("div.modal div.modal-header", "Popup should be visible")
tab2_css = 'div.ui-tabs-panel#tab2' world.wait_for_visible(tab2_css)
return usage_key.block_type in self.block_types_affecting_grading
history = HistoricalRecords()
PaymentFakeView.PAYMENT_STATUS_RESPONSE = new_status return HttpResponse()
photo_id_url = ( self.image_url("photo_id") if copy_id_photo_from is None else self.image_url("photo_id", override_receipt_id=copy_id_photo_from.receipt_id) )
print("Estimated coefficients (true, normal, RANSAC):") print(coef, model.coef_, model_ransac.estimator_.coef_)
n_dtypes = 2 old_nchannels = shape[2] shape[2] = old_nchannels / 2 assert shape[2] * 2 == old_nchannels, \
return library.location.library_key
ORDER_STATUS_MAP = { 'cart': 'defunct-cart', 'paying': 'defunct-paying', }
if not settings.FEATURES.get('ALLOW_WIKI_ROOT_ACCESS', False): raise PermissionDenied()
status = None
exclude = ('dashboard_tracking_code',)
(32, False, u"False"),
raise NotImplementedError()
self.reset_password_page.visit()
page.wait_for_ajax()
if hasattr(self.current_request_configuration, 'cache'): self.current_request_configuration.cache[key] = value
self._set_level_of_education(level_enum) self.assertEqual(self.profile.level_of_education_display, display_level)
error_msg = exc_info_to_str(sys.exc_info())
y_pred1 = clf.fit(X7, y6).predict(X7) assert_array_equal(y_pred1, y6)
allowance_section.click_add_allowance_button()
course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
course_key = course.location.course_key
xpath = "//section[@class='math-string']/span[2]/p/b" self.assert_has_text(xml, xpath, 'tail')
CountryAccessRule.invalidate_cache_for_course(restricted_course.course_key)
iris = datasets.load_iris()
shutil.rmtree(root_dir)
resp_params = PaymentFakeView.response_post_params(post_params) self.assertEqual(resp_params.get('decision'), 'REJECT')
K.flat[::n_samples + 1] -= alpha[0]
return BlockUsageLocator(course_key, 'course', course_key.run)
from track.backends.django import TrackingLog
rng = make_np_rng(None, 322, which_method="shuffle")
cache.delete(key)
with self.assertRaises(NotFoundError): self.item.get_transcript(transcripts)
_ = lambda text: text
self.verbose_mod = 1 self.start_time = time() self.begin_at_stage = begin_at_stage
X_1d = X_1row.ravel() max_abs = np.abs(X_1d).max() assert_array_almost_equal(X_1d / max_abs, maxabs_scale(X_1d, copy=True))
X_, y_ = make_classification(n_samples=200, n_features=100, random_state=0)
pass
self.release_languages('fa')
self._initialize_mixed(mappings={})
for terms_of_service in ["", "false", "not_boolean"]: params["terms_of_service"] = terms_of_service assert_terms_of_service_error("You must accept the terms of service.")
split_test = self._assert_children(2) group_id_to_child = split_test.group_id_to_child.copy() self.assertEqual(2, len(group_id_to_child))
update_course_in_cache.apply_async([unicode(course_key)], countdown=0)
self.coach = AdminFactory.create(password="test") self.client.login(username=self.coach.username, password="test")
if not hasattr(self, 'needs_reformat'): self.needs_reformat = self.needs_reshape del self.needs_reshape
return self._create_progress_entry(student, task_state=SUCCESS)
self.browser.execute_script("jQuery.fx.off = true;")
classes = ('credit-eligibility', 'eligibility-heading') method = self.assertContains if is_requirement_displayed else self.assertNotContains
assert all(np.all(this_point.cv_validation_scores == 0.0) for this_point in gs.grid_scores_ if this_point.parameters['parameter'] == FailingClassifier.FAILING_PARAMETER)
return { 'success': True, 'contents': prefix + hint_text, 'hint_index': hint_index }
clf_unconstrained = LassoCV(n_alphas=3, eps=1e-1, max_iter=max_iter, cv=2, n_jobs=1) clf_unconstrained.fit(X, y) assert_true(min(clf_unconstrained.coef_) < 0)
clf = clone(model) clf = model.fit(X, y)
assert_true(check_random_state(None) is np.random.mtrand._rand) assert_true(check_random_state(np.random) is np.random.mtrand._rand)
if np.abs(np_var(A) - two_pass_var(A)).max() < 1e-6: stable_var = np_var else: stable_var = two_pass_var
_ZFILE_PREFIX = asbytes('ZF') _MAX_LEN = len(hex_str(2 ** 64))
re.compile(r'^Schedule & Details Settings \|'): [ "jquery", "js/base", "js/models/course", "js/models/settings/course_details", "js/views/settings/main"],
pass
if timeout_in_seconds: utc_now = datetime.utcnow()
super(StudioValidation, self).__init__(xblock_id) self.summary = None
altered_grader = CourseGradingModel.fetch(self.course.id) self.assertEqual(test_grader.grace_period, altered_grader.grace_period, "Noop update")
safe_cookie_data_1 = SafeCookieData.create(session_id, user_id) self.assertTrue(safe_cookie_data_1.verify(user_id))
httpretty.register_uri( httpretty.GET, "http://localhost:4567/api/v1/threads/{id}".format(id=thread_id), body="", status=status_code )
if not self.fields['download_track'].is_set_on(self) and self.track: self.download_track = True
'AUTH_USE_OPENID': False, 'AUTH_USE_CERTIFICATES': False, 'AUTH_USE_OPENID_PROVIDER': False, 'AUTH_USE_SHIB': False, 'AUTH_USE_CAS': False,
root_block = block_structure.get_xblock(block_structure.root_block_usage_key) user_partitions = getattr(root_block, 'user_partitions', []) or [] block_structure.set_transformer_data(cls, 'user_partitions', user_partitions)
if not self.ALLOW_NESTED and connection.in_atomic_block: raise transaction.TransactionManagementError('Cannot be inside an atomic block.')
cls._assert_block_values(block_structure, cls.collect_data_key)
module.save() return module
cmap.set(self.answer_id, queuestate=queuestate, correctness='incomplete', msg=msg)
with self.settings(PIPELINE_ENABLED=True): js_include = compressed_js('base_application') self.assertIn(u'lms-base-application.js', js_include)
if m > n: m, n = n, m
for key, val in new_block.edit_info.to_storable().iteritems(): if getattr(destination_block.edit_info, key) is None: setattr(destination_block.edit_info, key, val)
error_msg = "XQueue could not decode grade request" self._send_immediate_response(False, message=error_msg)
pass
url(r'^programs/id_token/$', ProgramsIdTokenView.as_view(), name='programs_id_token'), url(r'^program/', ProgramAuthoringView.as_view(), name='programs'),
with store.bulk_operations(xblock.location.course_key):
CourseModeFactory.create( course_id=self.course.id, mode_slug='professional', mode_display_name='professional', )
input_dict = {'1_2_1': '1', '1_2_2': '2', '1_2_3': '3'} correct_map = problem.grade_answers(input_dict)
try: from code_block_timer import CodeBlockTimer except ImportError: CodeBlockTimer = None
treedic = {} treedic['1'] = _get_final_tree(s1) treedic['2'] = _get_final_tree(s2)
return self.make_call( reverse('team_membership_detail', args=[team_id, username]), expected_status, 'get', data, **kwargs )
if definition is None: definition = self.db_connection.get_definition(definition_guid, course_key) bulk_write_record.definitions[definition_guid] = definition if definition is not None: bulk_write_record.definitions_in_db.add(definition_guid)
rng = np.random.RandomState(0)
evaluate_prerequisite(self.course, self.prob2.location, self.user.id) self.assertFalse(mock_module_score.called)
all_variables, all_functions = add_defaults(variables, functions, case_sensitive)
expected_p, expected_h = h1.mf_update( state_below = v.upward_state(v_state), state_above = h2.downward_state(h2_state), layer_above = h2)
centers[center_idx] /= counts[center_idx]
try: raise TypicalMemoryError("test") except TypicalMemoryError as e: pass
('ALIGN', (2, 0), (4, 0), 'CENTER'),
pass
graph = image.img_to_graph(face)
require_course_email_auth = models.BooleanField(default=True)
@ignore_warnings def decorator_no_warning(): _warning_function() _multiple_warning_function()
return int(self.q(css=self.CURRENT_PAGE_NUMBER_CSS).text[0])
self.dashboard_page.visit()
assert_true(X_scaled is not X) assert_true(X_csr_scaled is not X_csr)
randomize_module = RandomizeModule( randomize_descriptor, self.system, scope_ids=ScopeIds(None, None, self.course.id, self.course.id) )
instructor = InstructorFactory(course_key=self.course.id) self.client.logout() self.client.login(username=instructor.username, password='test')
diff_quality_percentage_pass = True
self.components_ = X[self.core_sample_indices_].copy()
edit_button = self.q(css='.fa-pencil') edit_button.click()
TASK_LOG.info(u'%s, Task type: %s, Finalizing detailed enrollment task', task_info_string, action_name) return task_progress.update_task_state(extra_meta=current_step)
if all_students or delete_module: if not has_access(request.user, 'instructor', course): return HttpResponseForbidden(_("Requires instructor access."))
clf = ForestClassifier(class_weight='auto', warm_start=True, random_state=0) assert_warns(UserWarning, clf.fit, X, y) assert_warns(UserWarning, clf.fit, X, _y)
cumsum = -np.cumsum(clf.oob_improvement_)
grid_dimension = [0, ]
for course_mode in CourseMode.objects.filter(course_id=self.course.id): course_mode.sku = '' course_mode.save()
if self.axis == 0: X = check_array(X, accept_sparse='csc', dtype=np.float64, force_all_finite=False)
return len(get_event_differences(expected_event, actual_event, tolerate=tolerate)) == 0
self.alpha = alpha
self.assertEqual(response.status_code, 302) self.assertEqual( response.url, reverse('courseware', args=[course_id]) )
X = sparse.csr_matrix(X)
return getattr(self.client, method)(*args, HTTP_X_EDX_API_KEY=TEST_API_KEY, **kwargs)
with storebuilder.build() as (__, store): course = CourseFactory.create(modulestore=store)
CoursewareSearchIndexer.do_course_reindex(store, course.id) deleted_count = 1 + load_factor + (load_factor ** 2) + (load_factor ** 3) self.assert_search_count(course_size - deleted_count)
from nose.tools import assert_equal from nose.tools import assert_not_equal from nose.tools import assert_true from nose.tools import assert_false from nose.tools import assert_raises from nose.tools import raises from nose import SkipTest from nose import with_setup
assert_not_debug_mode()
return self.q(css=".certificates").present
clf = GradientBoostingClassifier(n_estimators=100, random_state=1) clf.fit(X, y)
alpha_scaled = float(alpha) / n_samples
assert_array_equal(X.A, v.transform(iter(D) if iterable else D).A)
titles = ['Label Spreading 30% data', 'Label Spreading 50% data', 'Label Spreading 100% data', 'SVC with rbf kernel']
self.assert_no_xpath(xml, "//label[@class='choicegroup_incorrect']", self.context)
PERSONAL = 'personal' BUSINESS = 'business' ORDER_TYPES = ( (PERSONAL, 'personal'), (BUSINESS, 'business'), )
EmptyPromise( lambda: len(self.report_download_links) >= 1, 'Waiting for downloadable report' ).fulfill()
return FAKE_MICROSITE.get(name, default)
drop_idx = [active.pop(ii) for ii in idx]
if settings.ROOT_URLCONF != 'lms.urls': raise unittest.SkipTest('Test only valid in lms') super(XBlockTestCase, cls).setUpClass()
self.navigate_to_video()
FEATURES['LICENSING'] = True
if 'last_update' in from_index: query['last_update'] = from_index['last_update']
num_braces = 0
if is_verified: self.assertTrue(CourseMode.is_verified_slug(mode_slug)) else: self.assertFalse(CourseMode.is_verified_slug(mode_slug))
signal_handler.reset_mock() section = self.store.create_item(self.user_id, course.id, 'chapter') signal_handler.send.assert_called_with('course_published', course_key=course.id)
microsite.set_by_domain(self.microsite.site.domain) self.assertEqual(microsite.get_dict('nested_dict'), self.microsite.values['nested_dict'])
(index < 2 or tokens[index - 2][1] != 'class') and not keyword.iskeyword(prev_text)): yield prev_end, "E211 whitespace before '%s'" % text
self.addCleanup(ModuleIsolation().clean_up)
all_assets.extend(course_assets.setdefault(asset_key.block_type, [])) idx = all_assets.find(asset_key)
with self.assertRaisesRegexp(CommandError, ".* requires one or more arguments.*"): call_command('reindex_course')
if len(inputfiles) > settings.MAX_FILEUPLOADS_PER_INPUT: msg = 'Submission aborted! Maximum %d files may be submitted at once' % \ settings.MAX_FILEUPLOADS_PER_INPUT return msg
self.assertEqual(len(self.video.q(css='video')), 1)
lbound = N.array([kshp[0]-1,kshp[1]-1]) if mode=='valid' else N.zeros(2) ubound = lbound + (inshp[1:]-kshp+1) if mode=='valid' else fulloutshp
requests.put( '{}/set_config'.format(COMMENTS_STUB_URL), data=self.get_config_data() )
return " ".join(str(arg) for arg in args if arg)
CourseEnrollment.enroll(self.user, self.course.id)
return self.pk_with_subclass, set([self._tax_deduction_msg()])
import lettuce.django
if tasks.environment.dry_run: return
query_features.append('cohort') query_features_names['cohort'] = _('Cohort')
mongo_course = self.store.get_course(self.course_locations[self.MONGO_COURSEID].course_key) self.assertEqual(len(mongo_course.children), 1)
self.client.logout()
cert = request._req.subprocess_env.get(certkey, '')
result = api.get_credit_providers(['fake_provider_id']) self.assertEqual(result, [])
from __future__ import unicode_literals
self.video.click_player_button('transcript_button')
url(r'^api/certificates/', include('lms.djangoapps.certificates.apis.urls', namespace='certificates_api')),
self.profile.profile_image_uploaded_at = datetime.datetime.now() self.profile.save() self.assertFalse(self.profile.has_profile_image)
MIGRATION_MODULES = NoOpMigrationModules()
super(GroupConfigurationsListHandlerTestCase, self).setUp()
if course is None: course = modulestore().get_course(course_id, depth=0)
self.store.convert_to_draft(self.vertical_x1a, self.user_id) self.store.convert_to_draft(self.vertical_y1a, self.user_id)
ROLE = 'staff' def __init__(self, *args, **kwargs): super(CourseStaffRole, self).__init__(self.ROLE, *args, **kwargs)
return has_team_api_access(request.user, obj.course_id)
self.assertTrue(hasattr(course_overview_before, 'image_set'))
return {}
settings.WIKI_ENABLED = False self.assertIsNone(self.get_wiki_tab(self.user, self.course)) self.assertIsNone(self.get_wiki_tab(self.instructor, self.course))
version = sys.version_info if version[0] == 3: if version[1] == 3: reload = None else: from importlib import reload
component = self.store.publish(component.location, self.user_id) self.assertFalse(self.store.has_changes(component))
if 'truncated' not in kwargs: kwargs['truncated'] = [] self.assert_event_emitted( USER_SETTINGS_CHANGED_EVENT_NAME, table=self.table, user_id=self.user.id, **kwargs )
resp = self.client.get(reverse_usage_url('xblock_handler', usage_key)) self.assertEqual(resp.status_code, 200)
resp = self.client.get('/course/bad/course/key/entrance_exam') self.assertEqual(resp.status_code, 400)
v.fit(["to be or not to be", "and me too", "and so do you"]) assert False, "we shouldn't get here"
send_admin_notification = Signal(providing_args=["user"])
self.assertTrue(CourseEnrollment.is_enrolled(self.user, destination_course_key))
assert_equal(pairwise_distances([[1]], metric=lambda x, y: 5)[0, 0], 5)
import urllib.request urlopen = urllib.request.urlopen
if isinstance(key, LibraryLocator): key = unicode(key) return LIBRARY_REST_URL + key
return u"{}?{}".format(reverse('finish_auth'), urllib.urlencode(params))
return self.q(css='.prompt.{dialog_type}'.format(dialog_type=dialog_type)).visible
if not (is_fitted or has_partial_fit): raise NotFittedError("Fit training data before predicting")
u'resource_link_id': self.get_resource_link_id(), u'lis_result_sourcedid': self.get_lis_result_sourcedid(),
import django try: django.setup()
self.redefine_option_problem(problem_url_name) self.render_problem('u1', problem_url_name) self.check_state('u1', descriptor, 2, 2, 1)
child_position = None if is_entrance_exams_enabled(): if category == 'chapter' and is_entrance_exam: fields['is_entrance_exam'] = is_entrance_exam
get_request_dict = {CapaFactory.input_key(): '3.14'} result = module.save_problem(get_request_dict)
pipe = Pipeline([('cls', LinearRegression())])
terms_text = _(u"Terms of Service") terms_link = u"<a href=\"{url}\">{terms_text}</a>".format( url=marketing_link("TOS"), terms_text=terms_text )
memory = Memory(os.path.join(get_data_home(), 'covertype_benchmark_data'), mmap_mode='r')
n_components = 100 n_features = 500
task_type = 'rescore_problem' task_class = rescore_problem task_input, task_key = encode_problem_and_student_input(usage_key) return submit_task(request, task_type, task_class, usage_key.course_key, task_input, task_key)
X = variation.copy().T X /= X.std(axis=0) edge_model.fit(X)
self.track_selection_page.enroll('verified')
unpickled_scorer = pickle.loads(pickle.dumps(scorer)) score3 = unpickled_scorer(clf, X_test, y_test) assert_almost_equal(score1, score3)
self.setup_cohorts(self.course)
snapshot = super(CourseRegistrationCodeInvoiceItem, self).snapshot() snapshot['course_id'] = unicode(self.course_id) return snapshot
self._submit_photos( face_image=self.IMAGE_DATA, photo_id_image=self.IMAGE_DATA, full_name=self.FULL_NAME )
return T.maximum(0.0, x)
base_estimator.fit(X_inlier_best, y_inlier_best)
sh('git clean -fdX conf/locale')
return BrandingApiConfig.current().enabled
X = 0.3 * rnd.randn(100, 2) X_train = np.r_[X + 2, X - 2]
return {}
self.assertEqual(self.team_page.team_name, self.team['name']) self.assertTrue(self.team_page.edit_team_button_present)
return 0
#show_authors = False
n_features = 2000 t = np.pi * np.linspace(0, 1, n_features)
module.lcp.get_score = lambda: {'score': 0, 'total': 0}
check_is_fitted(self, ["classes_", "calibrated_classifiers_"]) return self.classes_[np.argmax(self.predict_proba(X), axis=1)]
position = "numerator" numerator = [] denominator = []
self.login_user() reg_item = PaidCourseRegistration.add_to_order(self.cart, course_key, mode_slug=self.course_mode.mode_slug) return reg_item
n_rows = 1 n_cols = np.ceil(n_plots*1./n_rows) n_cols = int(n_cols) half_perimeter = n_cols + 1
unit = self.store.create_child(self.user_id, subsection.location, 'vertical') signal_handler.send.assert_not_called()
course.cohort_config = {} self.assertFalse(course.is_cohorted)
public_vertical = get_and_verify_publish_state('vertical', self.PUBLISHED_VERTICAL, True)
del params["name"] assert_name_error("Your legal name must be a minimum of two characters long")
label_css = 'button.show span.show-label' world.wait_for(lambda _: world.css_has_text(label_css, label_name))
self.outline.visit() subsection = self.outline.section(section_name).subsection(subsection_name) return subsection.expand_subsection().unit(unit_name).go_to()
return _has_staff_access_to_location(user, descriptor.location, course_key)
if not url: return url
y = y[:m]
response = organizations_helpers.get_organization_by_short_name(self.organization['short_name']) self.assertIsNone(response)
error_item_names = self.advanced_settings.get_error_item_names() self.assertEqual(set(wrong_settings_list), set(error_item_names))
Ht = check_array(H.T, order='C') X = check_array(X, accept_sparse='csr')
self.assertEquals(3, len(response.content.splitlines()))
dist_array = pairwise_distances(X).flatten() np.sort(dist_array) radius = dist_array[15]
module.system.DEBUG = False
bogus_task_id = "this-is-bogus" update_subtask_status(entry_id, bogus_task_id, new_subtask_status)
url = marketing_link(name)
n_queries = 5 queries = X[rng.randint(0, n_samples, n_queries)] distances, neighbors = lshf.radius_neighbors(queries, return_distance=True)
return "BIGSERIAL"
objects = CourseRerunUIStateManager()
assert_equal(X_counted.nnz, X_hashed.nnz)
if not self.dispatch_one_batch(self._original_iterator): self._iterating = False self._original_iterator = None
self.certificates_section.refresh()
"decision": decision,
PIPELINE_JS_COMPRESSOR = None
return self.current_group.get(user.id, {}).get(user_partition.id)
url = reverse('shoppingcart.views.postpay_callback') response = self.client.post(url, processor_response_params) self.assertRedirects(response, self._receipt_url)
try: C = linalg.cholesky(R, lower=True) except linalg.LinAlgError: return reduced_likelihood_function_value, par
statobj = inputtypes.Status('test') self.assertEqual(str(statobj), 'test') self.assertEqual(unicode(statobj), u'test')
from datetime import timedelta
super(LabelSpreading, self).__init__(kernel=kernel, gamma=gamma, n_neighbors=n_neighbors, alpha=alpha, max_iter=max_iter, tol=tol, n_jobs=n_jobs)
if compute_squared_diff: diff = centers[center_idx].ravel() - old_center_buffer.ravel() squared_diff += np.dot(diff, diff)
try: validate_new_email(self.request.user, email) except ValueError as err: return err.message
target_org = org or microsite_org courses = CourseOverview.get_all_courses(org=target_org, filter_=filter_)
item = order.orderitem_set.all().select_subclasses()[0]
y_pred_proba_mo = knn_mo.predict_proba(X_test) assert_equal(len(y_pred_proba_mo), n_output)
rng = check_random_state(0) X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=rng)
'SHOW_LANGUAGE_SELECTOR': False,
def test_invalid_sample_without_replacement_algorithm(): assert_raises(ValueError, sample_without_replacement, 5, 4, "unknown")
return self.q(css='.components-list').visible
world.scenario_dict['COURSE'] = world.CourseFactory.create( org='edx', number=course, display_name='Test Course', metadata=metadata, grading_policy=grading_policy, )
self.dashboard_page.visit()
response = self.client.get(reverse("dashboard")) self.assertHttpOK(response)
task_entry = self._create_input_entry(course_id="bogus/course/id") with self.assertRaises(ItemNotFoundError): self._run_task_with_mock_celery(task_class, task_entry.id, task_entry.task_id)
return True
return self.get_comment_list_url(obj, endorsed=True)
return self.q(css=self.xblock_component_selector).attrs('data-block-type')[index]
msg = "AttributeError or ValueError not raised by predict" assert_raises_regex(AssertionError, msg, check_estimators_unfitted, "estimator", NoSparseClassifier)
modal.release_date = '5/14/1969'
self.assertIn(self.SUCCESSFUL_RESPONSE, response.content) self.assertEqual(response.status_code, 200)
self._change_student_enrollment(self.enrolled_student, self.course, 'enroll')
return True
return self._get_element_text(".load-response-button")
#sys.path.append(os.path.abspath('some/directory'))
return image.convert('RGB')
self.url = reverse('instructor_dashboard', kwargs={'course_id': self.course_key.to_deprecated_string()}) self.email_link = '<a href="" data-section="send_email">Email</a>'
X, y = make_classification(n_samples=200, n_features=100, n_informative=3, random_state=0)
if block_id is None: if block_type == 'course': block_id = course_key.run else: block_id = u'{}_{}'.format(block_type, uuid4().hex[:5])
if mode == "login": return external_auth_login(request) elif mode == "register": return external_auth_register(request)
train_data = iter(ALL_FOOD_DOCS[:-1]) test_data = [ALL_FOOD_DOCS[-1]] n_train = len(ALL_FOOD_DOCS) - 1
self.check_event_response_by_key('flag_resource', resource, 'reason', 'reason 0')
self.advanced_settings.visit() self.assertTrue(self.advanced_settings.is_browser_on_page())
self.assertFalse(self._has_changes(published_xblock.location))
archive_object = MicrositeHistory( key=instance.key, site=instance.site, values=instance.values, ) archive_object.save()
pass
page.wait_for_element_visibility('.new-component-advanced', 'Advanced component menu is visible')
return self.q(css='input[name=calculate-grades-csv]')
course_id = CourseKeyField(max_length=255, db_index=True, unique=True)
rng = np.random.RandomState(0) X, y = make_regression(n_samples=20, n_features=1, random_state=0, noise=4.0, bias=100.0)
self.assertFalse(self.has_notes_tab(self.course, self.user))
start_index = self._line_start_indexes[line_number - 1] if len(self._line_start_indexes) == line_number: line = self._string[start_index:] else: end_index = self._line_start_indexes[line_number] line = self._string[start_index:end_index - 1] return line
self.assertIn('Cannot Find Certificate', response.content)
def setUp(self): super(TestFilteredChildren, self).setUp() self.users = {number: UserFactory() for number in USER_NUMBERS}
if self.min_weight_fraction_leaf != 0. and sample_weight is not None: min_weight_leaf = (self.min_weight_fraction_leaf * np.sum(sample_weight)) else: min_weight_leaf = 0.
return self.get_item(location)
self.assertTrue(self.video.downloaded_transcript_contains_text('srt', 'Welcome to edX.'))
assert_equal(len(matched_buttons), 1) return matched_buttons[0]
self._test_visible_to_students(False, 'private_released', self.past)
return False
for tab in tabs: if tab.tab_id == "discussion" and django_comment_client.utils.is_discussion_enabled(self.id): return True return False
has_children = True field1 = String(default="something", scope=Scope.user_state) field2 = Integer(scope=Scope.user_state)
config, _ = self.create_group_configuration_experiment([Group("0", "Group A"), Group("1", "Group B")], True)
return ''
cc_button_selector = self.get_element_selector(VIDEO_BUTTONS["transcript"]) element_to_hover_over = self.q(css=cc_button_selector).results[0] ActionChains(self.browser).move_to_element(element_to_hover_over).perform()
draft_html = self.store.get_item(course_id.make_usage_key('html', self.DRAFT_HTML)) self.assertTrue(getattr(draft_html, 'is_draft', False))
__test__ = True pass
with self.assertRaises(Exception): self.client.get(test_url)
parent_url = None if parent_loc is not None: parent_url = parent_loc.to_deprecated_string()
assets, count = content_store.get_all_content_for_course(self.course.id) self.assertEqual(count, 2)
return self.q(css='.page-header .page-title')[0].text
return getattr(settings, "MICROSITE_CONFIGURATION", False)
'name': block.display_name_with_default_escaped, 'category': block.category, 'id': unicode(block.location)
assert_raises(ValueError, cv.get_feature_names)
element = etree.fromstring(xml_str) state = {'value': 'x^2+1/2'} self.the_input = lookup_tag('formulaequationinput')(test_capa_system(), element, state)
draft_node_list = []
self.add_child()
if np.any(np.less_equal(precision, 0.0)): raise ValueError("'%s precision' should be " "positive" % covariance_type)
self.login_page.visit()
return JsonError(["username parameter is required"])
initial_photo_response = requests.get(initial_data["UserPhoto"]) self.assertEqual(initial_photo_response.status_code, 200)
return reverse_course_url('certificates.certificates_list_handler', self.course.id)
for k in np.linspace(80, n_samples, 10): k = int(k)
if 'pinned' not in thread.attributes: thread['pinned'] = False
window = tensor.alloc(0.0, batch, channel, res_r, res_c, pr, pc) window.name = 'unravlled_winodows_' + name
src_x, src_y = src_dimensions target_x, target_y = target image_x, image_y = image.size
'django.middleware.clickjacking.XFrameOptionsMiddleware',
node_position_model = manifold.LocallyLinearEmbedding( n_components=2, eigen_solver='dense', n_neighbors=6)
course_module = modulestore().get_course(course_key) if course_module is None: return Response(status=status.HTTP_404_NOT_FOUND) result_filter.update({'course_id': course_key})
if category not in ['html', 'problem', 'video']: return HttpResponseBadRequest( "Category '%s' not supported for Libraries" % category, content_type='text/plain' )
return self.q(css="div.problem p").text
site_configuration = SiteConfigurationFactory.create( site=self.site, )
W[0, 1] = .5 W[0, 2] = 1. W[0, 3] = 2.
context['ewa_diff'] = ewa_diff context['ewa_inertia'] = ewa_inertia context['ewa_inertia_min'] = ewa_inertia_min context['no_improvement'] = no_improvement return False
redirect_url = request.GET.get('redirect_url') return view_student_survey(request.user, survey_name, redirect_url=redirect_url)
block = self.store.get_item(block_location) block.group_access = access_dict self.store.update_item(block, 1)
self.outline.a11y_audit.config.set_scope( include=["div.video"] ) self.outline.a11y_audit.check_for_accessibility_errors()
nav_dict[sec_title] = self._subsection_titles(sec_index + 1)
self.assertSetEqual( set(response.data['blocks'].iterkeys()), self.non_orphaned_block_usage_keys, )
for covariance_type in ["full", "tied", "diag", "spherical"]: yield check_positive_definite_covars, covariance_type
third_party_provider = None running_pipeline = None if third_party_auth.is_enabled() and pipeline.running(request): running_pipeline = pipeline.get(request) third_party_provider = provider.Registry.get_from_pipeline(running_pipeline)
user2 = UserFactory() add_instructor(rerun_course_key, self.user, user2)
good_status, is_tarball_mimetype = self.export_page.download_tarball() self.assertTrue(good_status) self.assertTrue(is_tarball_mimetype)
course = self.store.create_course('org_x', 'course_y', 'run_z', self.user_id) signal_handler.send.assert_called_with('course_published', course_key=course.id)
if key is not None:
module_count_before = len(world.browser.find_by_css(module_css))
students = self._create_students(10)
import os
n_classes = 4 n_samples = 50
statuses = api.get_credit_requests_for_user(self.USER_INFO["username"]) self.assertEqual(statuses[0]["status"], expected_status)
return False
for enrollment in manual_enrollments: self.assertEqual(enrollment.enrollment.mode, CourseMode.DEFAULT_SHOPPINGCART_MODE_SLUG)
self.course_nav.go_to_section('Test Section', 'Test Subsection')
self.assertTrue(BulkEmailFlag.feature_enabled(course_id))
GIT_REPO_EXPORT_DIR = ENV_TOKENS.get('GIT_REPO_EXPORT_DIR', '/edx/var/edxapp/export_course_repos')
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
masquerade_settings = getattr(user, 'masquerade_settings', {}) return masquerade_settings.get(course_key, None)
return self.course_id.to_deprecated_string()
extra_context = {"platform_name": microsite.get_value('platform_name', settings.PLATFORM_NAME)}
problem_vertical = ItemFactory.create( parent_location=problem_section.location, category='vertical', display_name=problem_vertical_name ) problem_vertical_list.append(problem_vertical)
import numpy from theano import tensor
if should_recompile(): _logger.debug('recompiling')
show_email_settings_for = frozenset( enrollment.course_id for enrollment in course_enrollments if ( BulkEmailFlag.feature_enabled(enrollment.course_id) ) )
if not name: raise ValueError(u"{key} must contain at least one underscore".format(key=key))
if "field_type" in kwargs: kwargs["type"] = kwargs["field_type"]
return len(self._max_scores_updates)
return redirect(request.GET.get('next', 'dashboard'))
self.find_css('.signatory-organization-input').first.fill(value)
return self._validation_paragraph('error').text[0]
if hasattr(self, 'oob_improvement_'): self.oob_improvement_.resize(total_n_estimators) else: self.oob_improvement_ = np.zeros((total_n_estimators,), dtype=np.float64)
MAXSIZE = int((1 << 31) - 1)
super(CapaModule, self).__init__(*args, **kwargs)
self.the_input.capa_system.render_template = lambda *args: "<aaa" with self.assertRaises(etree.XMLSyntaxError): self.the_input.get_html()
all_times = self.q(css=selector).text[0]
delete_item(category='vertical', name='test_vertical')
course_about_accessor = lambda object, field_name: CourseDetails.fetch_about_attribute(object.id, field_name)
MOCK_STAFF_GRADING = True MOCK_PEER_GRADING = True
self.course = modulestore().get_course(self.course.id)
params['signature'] = signature if signature is not None else self._signature(params) return params
self.make_course(pdf_textbooks=[HTML_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('html_book', book_index=0, chapter='xyzzy')
RegistrationFactory(user=self.user)
X_non_outliers = -axis0_safe_slice(X, ~outliers_mask, n_non_outliers) grad[:n_features] = ( 2. / sigma * safe_sparse_dot(weighted_non_outliers, X_non_outliers))
return self._block_relations[usage_key].children if usage_key in self else []
self.survey.save_user_answers(self.student, self.student_answers, None) self.assertFalse(must_answer_survey(self.course, self.student))
mcc = assert_warns_message(RuntimeWarning, 'invalid value encountered', matthews_corrcoef, y_true, rng.randint(-100, 100) * np.ones(20, dtype=int))
'AUTOMATIC_VERIFY_STUDENT_IDENTITY_FOR_TESTING': False,
config = self.cohort_config if config is None: return False return bool(config.get("cohorted"))
return self.base_loader.load_template_source(template_name, template_dirs)
self.chapter = ItemFactory.create( parent_location=self.course.location, category='chapter', display_name='untitled chapter' )
self.assertNotContains(resp, self.ext_user.email)
size = tuple([X.shape[i] for i in xrange(X.ndim)]) if self.sync_channels: del size[X_space.axes.index('c')]
return self.q(css="div.problem section.inputtype div.partially-correct span.status").is_present()
self.assert_no_xpath(xml, "//label[@class='choicegroup_incorrect']", self.context)
self.publish_item(store, self.vertical.location) self.reindex_course(store) response = self.search() self.assertEqual(response["total"], 3)
return (NullSpace(), '')
return self.prior.get_params()
self.assertEqual(self.export_page.header_text, 'Library Export')
for row in db_query: curr_problem = course_id.make_usage_key_from_deprecated_string(row['module_state_key'])
version_guids, id_version_map = self.collect_ids_from_matching_indexes(branch, **kwargs) if not version_guids: return for entry in self.find_structures_by_id(version_guids): for course_index in id_version_map[entry['_id']]: yield entry, course_index
plt.subplot(2, 2, i + 1) Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
delete_thread(request, thread_id) return Response(status=204)
assert start >= 0 assert stop > start assert stop <= X.shape[0] X = X[start:stop, :] y = y[start:stop] assert X.shape[0] == y.shape[0]
course = CourseFactory.create(start=datetime(2013, 9, 16, 7, 17, 28)) course = modulestore().get_course(course.id) return course
if self._course_key is None: self._course_key = SlashSeparatedCourseKey.from_deprecated_string(self._results_fields["course"]) return self._course_key
yield check_oob_score, name, iris.data, iris.target * 2 + 1
DEFAULT_COURSE_ABOUT_IMAGE_URL = ENV_TOKENS.get('DEFAULT_COURSE_ABOUT_IMAGE_URL', DEFAULT_COURSE_ABOUT_IMAGE_URL)
return LocalFSReportStore.from_config(config_name='GRADES_DOWNLOAD')
u"\u00A9 {org_name}. All rights reserved except where noted. " u"EdX, Open edX and the edX and Open EdX logos are registered trademarks " u"or trademarks of edX Inc."
self.enrollment.update_enrollment(mode=CourseMode.HONOR)
import time
self.assertNotRegexpMatches(problem_html, r"data-block-type=[\"\']acid_aside[\"\']")
certificate_count = 3 for __ in xrange(certificate_count): self.generate_certificate(course_id=self.course.id, mode='honor', status=CertificateStatuses.downloadable)
n_classes = 3 plot_colors = "bry" plot_step = 0.02
score = score * self.weight / total total = self.weight
return self.q(css='.page-content-secondary .tooltip-custom').text[0]
return CourseDetails.fetch(course_key)
self.store.publish(problem.location, self.user.id)
scaled = scaler.fit_transform(iris.data) separate_pred = km.fit_predict(scaled)
self.runtime.publish( self, 'grade', { 'value': json_data['grade'], 'max_value': 1 } )
drafts.sort(key=lambda x: x.index)
if self.force_save_button: return not self.closed() else: is_survey_question = (self.max_attempts == 0) needs_reset = self.is_submitted() and self.rerandomize == RANDOMIZATION.ALWAYS
clf = self.factory(alpha=0.01, n_iter=5, shuffle=False) clf.fit(X, Y) Y_ = np.array(Y)[:, np.newaxis]
for __ in range(10): group2_id = RandomUserPartitionScheme.get_group_for_user( self.MOCK_COURSE_ID, self.user, self.user_partition ) self.assertEqual(group1_id, group2_id)
query = self.q(css=self._bounded_selector("#cohort-select option")) return len(query) > 0, query
clf = QuadraticDiscriminantAnalysis(reg_param=0.01) with ignore_warnings(): clf.fit(X2, y6) y_pred = clf.predict(X2) assert_array_equal(y_pred, y6)
return CreditEligibility.is_user_eligible_for_credit(course_key, username)
post_data['name'] = 'Another name'
try: configuration = json.loads(json_string) except ValueError: raise GroupConfigurationsValidationError(_("invalid JSON")) configuration["version"] = UserPartition.VERSION return configuration
self.assertEqual(test, expected)
#
('BACKGROUND', (1, 2), (1, 2), '#EEEEEE'),
rval = X.copy()
child = descriptor.get_children()[0] self.assertEqual(child.due, None)
module = CapaFactory.create(max_attempts=None, rerandomize=RANDOMIZATION.NEVER, done=False) self.assertFalse(module.should_show_save_button())
from sklearn.utils.linear_assignment_ import _hungarian
warnings.simplefilter("ignore", UserWarning) assert_equal(assert_warns(UserWarning, f), 3)
self.login(self.email, self.pw)
self.theta0, self.thetaL, self.thetaU = theta0, thetaL, thetaU self.corr = corr self.optimizer = 'Welch' self.verbose = verbose
s3_key = self._generate_s3_key("photo_id") s3_key.set_contents_from_string(encrypt_and_encode(img_data, aes_key))
parent = verticals[0] new_block = self.store.create_child( self.user.id, parent.location, 'html', 'new_component' )
iris = datasets.load_iris()
mlp.n_layers_ = 3
enetcv_constrained = ElasticNetCV(n_alphas=3, eps=1e-1, max_iter=max_iter, cv=2, positive=True, n_jobs=1) enetcv_constrained.fit(X, y) assert_true(min(enetcv_constrained.coef_) >= 0)
return getattr(super(BulkAssertionTest, self), 'assert' + assertion_name)(*args, **kwargs)
rendered_html = etree.XML(problem.get_html())
return cPickle.loads(s)
kwargs.setdefault('enabled', True) SAMLConfiguration(**kwargs).save()
course = self.store.get_course(course.id) self.assertEqual(len(course.children), 1) self.assertNotIn(dangling_pointer, course.children)
break
self.set_config(False) course = CourseFactory.create()
return str(s).replace('<', '&lt;').replace('>', '&gt;')
if len(combined) > 250: combined = fasthash(combined)
ovr = OneVsRestClassifier(DecisionTreeClassifier()) ovr.fit(iris.data, iris.target) assert_raises(AttributeError, lambda x: ovr.coef_, None)
return self.batch_size * self.num_batches
with remove_ccx(location) as (location, restore): return restore( self._modulestore.get_parent_location(location, **kwargs) )
import logging import os import functools from itertools import repeat import warnings
dir_suffix = ""
css_classes.append('xmodule_display')
VS_batch = VS.make_theano_batch() new_CS_batch = VS.format_as(VS_batch, CS) new_VS_batch = VS.undo_format_as(new_CS_batch, CS) assert new_VS_batch is VS_batch
with check_mongo_calls(1): ver_block = modulestore().get_item(self.reverification.location)
PIPELINE_JS_COMPRESSOR = None
self.navigate_to_course_unit() self.edit_component() self.open_advanced_tab() self.video.upload_handout(handout_filename) if save_settings: self.save_unit_settings()
raise NotImplementedError("Specific Modulestores must provide implementations of create_definition")
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id) if has_instructor_access_for_class(request.user, course_key): try: data = dashboard_data.get_d3_sequential_open_distrib(course_key)
if is_comment_too_deep(parent=None): return JsonError(_("Comment level too deep")) return _create_comment(request, CourseKey.from_string(course_id), thread_id=thread_id)
self.other_sequential_1.children = []
self.chapter1 = ItemFactory.create( parent_location=self.course.location, category='chapter', display_name='untitled chapter 1' )
go_to_section("data_download")
self.estimators_.extend(trees)
#latex_logo = 'images/snake_theta2-trans.png' latex_logo = None
return [item['data']['content'] for item in response['results']]
subobj.main_loop(time_budget=time_budget)
self.enroll_student(self.STUDENTS[0]['email'], self.STUDENTS[0]['password']) self.attempt_upload_file_and_verify_result(test_case, 'import_resources', self.initial_configuration)
fake_course_image = 'sample_image.png' course_overview = self._assert_image_urls_all_default(modulestore_type, fake_course_image)
return cls.current().cache_ttl
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit() attempt.approve()
for item in self.orderitem_set.all(): if item.is_discounted: item.unit_cost = item.list_price item.save()
ir = IsotonicRegression(increasing='auto', out_of_bounds="raise")
w = random_state.randn(n_features, n_targets)
continue
var_dict_list = self.randomize_variables(self.samples) try: self.tupleize_answers(answer, var_dict_list) return True except StudentInputError: return False
pythonpath = os.environ.get('PYTHONPATH', '') pythonpath = throot + ':' + pythonpath os.environ['PYTHONPATH'] = pythonpath
if len(P.shape) == 2: P = squareform(P) kl_divergence = 2.0 * np.dot(P, np.log(P / Q))
self._click_button('advanced_tab')
after_created = attempt.created_at + timedelta(seconds=1) self.assertTrue(attempt.active_at_datetime(after_created))
try: entry = cls._get_record_for_user(user) entry.delete() except ObjectDoesNotExist: return
self.user.password = u'new password' self.user.save() self.assert_user_setting_event_emitted(setting='password', old=None, new=None)
with check_mongo_calls_range(max_finds=5, max_sends=3): self._update_partitions(reload_items=False)
'ENABLE_COURSE_DISCOVERY': False,
timeout_in_seconds = 60 * 60 * 24 self._cache.set( self._encode_root_cache_key(block_structure.root_block_usage_key), zp_data_to_cache, timeout=timeout_in_seconds, )
self.courseware_search_page.visit() staff_page = StaffPage(self.browser, self.course_id) self.assertEqual(staff_page.staff_view_mode, 'Staff') return staff_page
self.send_get(self.anonymous_client, expected_status=401) self.send_put(self.anonymous_client, "new_value", expected_status=401) self.send_delete(self.anonymous_client, expected_status=401)
if (self.is_data_valid is not None and not self.is_data_valid(X_subset, y_subset)): continue
cases = [ dict(case_data, edx_video_id=""), dict(case_data, edx_video_id="vid-v1:12345"), ]
def __init__(self, location, content_type): self.location = location self.content_type = content_type
# dbar = dbarn epln = eplnn dlta = cs * dbar + sn * alpha gbar = sn * dbar - cs * alpha
self.assert_redirect_to_provider_looks_correct(self.client.get( pipeline.get_login_url(self.provider.provider_id, pipeline.AUTH_ENTRY_LOGIN)))
AUDIT_LOG.info(u"User %s w/o external auth attempting login", user)
nonce = '0123456789012345678901234567890123456789012345678901234567890123' self.assertTrue(SignatureValidator(self.lti_consumer).check_nonce(nonce))
add_user_with_status_unrequested(self.user) self.assertEqual('granted', get_course_creator_status(self.user))
(count, violations_list) = _get_pep8_violations()
timed_exam_attempt_context = None try: timed_exam_attempt_context = get_attempt_status_summary( user.id, unicode(course.id), unicode(section.location) )
subtask_status.increment(failed=num_pending, state=FAILURE) return subtask_status, exc
filter_func = filter_func or (lambda __: True)
clf = GradientBoostingClassifier(n_estimators=100, random_state=1)
return None
from pylearn2.utils import serial from pylearn2.datasets import cifar10 from pylearn2.datasets import preprocessing
resp = self.client.get_json(url) course_detail_json = json.loads(resp.content) self.assertEqual(pre_requisite_course_keys, course_detail_json['pre_requisite_courses'])
types = [i.data_type_ for i in sparse_classifier.estimators_]
if math_string != '4': raise err
COURSE_CATALOG_VISIBILITY_PERMISSION = ENV_TOKENS.get( 'COURSE_CATALOG_VISIBILITY_PERMISSION', COURSE_CATALOG_VISIBILITY_PERMISSION ) COURSE_ABOUT_VISIBILITY_PERMISSION = ENV_TOKENS.get( 'COURSE_ABOUT_VISIBILITY_PERMISSION', COURSE_ABOUT_VISIBILITY_PERMISSION )
dual_coef = linalg.solve(K, y, sym_pos=True, overwrite_a=False)
from_address = theming_helpers.get_value( 'email_from_address', settings.DEFAULT_FROM_EMAIL ) user = User.objects.get(id=user_id) user.email_user(subject, message, from_address)
min_dist_inds = dists.argmin(axis=1)
self.make_course(pdf_textbooks=[PDF_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('pdf_book', book_index=0, chapter='xyzzy')
AutoAuthPage(self.browser, course_id=self.course_id).visit()
self._create_courses_and_enrollments( (self.TEST_ORG, True), ("org_alias", True) )
super(TestRequireStudentIdentifier, self).setUp() self.student = UserFactory.create()
classes = np.unique(iris.target) clf_samme = prob_samme = None
return [ block for block in modulestore().get_items( course_key, qualifiers={"category": category}, revision=ModuleStoreEnum.RevisionOption.published_only, ) if _is_in_course_tree(block) ]
VIRTUAL_UNIVERSITIES = []
from __future__ import unicode_literals
train = SVHN('splitted_train', path=local_path) check_dtype(train)
self._get_penalty_type(self.penalty) self._get_learning_rate_type(self.learning_rate)
return numpy.arcsinh(1. / val)
css_include = compressed_css('style-main-v1', raw=True) self.assertIn(u'lms-main-v1.css?raw', css_include)
raise ItemNotFoundError(course_key)
return self.lines[0]
return submit_delete_problem_state_for_all_students(self.create_task_request(instructor), location)
pref = UserPreference.get_value(user, 'testkey_none') self.assertIsNone(pref)
time.sleep(2)
list_price = 'N/A' payment_amount = 'N/A' coupon_codes_used = 'N/A' registration_code_used = 'N/A' payment_status = _('Data Integrity Error') transaction_reference_number = 'N/A'
alpha = np.mean(emp_cov ** 2) num = alpha + mu ** 2 den = (n_samples + 1.) * (alpha - (mu ** 2) / n_features)
from __future__ import unicode_literals
self.ccx = CcxFactory(course_id=self.split_course.id, coach=self.coach) last_week = datetime.datetime.now(UTC()) - datetime.timedelta(days=7)
contents = String(scope=Scope.content) error_msg = String(scope=Scope.content) display_name = String(scope=Scope.settings)
content = json.loads(response.content) parameters = content['parameters']
region_str = "[ [1,1], [5,10], [0,10] ]"
precisions_not_pos = np.ones((n_components, n_features, n_features)) precisions_not_pos[0] = np.eye(n_features) precisions_not_pos[0, 0, 0] = -1.
return redirect(reverse('dashboard'))
self.submit_question_answer('p1', {'2_1': u'ⓤⓝⓘⓒⓞⓓⓔ'}) self.submit_question_answer('p2', {'2_1': 'Correct'})
self.video.wait_for_state('pause')
return reverse( 'verify_student_incourse_reverify', kwargs={ "course_id": unicode(course_key), "usage_id": checkpoint_location } )
pass
return '{} {}'.format(self.selector, selector)
CREDIT_PROVIDER_TIMESTAMP_EXPIRATION = 15 * 60
response = self.client.get(self.notes_url, {"text": "test"}) self.assertEqual(response.status_code, 404)
while True: rows = cursor.fetchmany(self.QUERY_INTERVAL) if not rows: break for row in rows: yield row
data2 = fetch_rcv1(shuffle=True, subset='train', random_state=77, download_if_missing=False) X2, Y2 = data2.data, data2.target s2 = data2.sample_id
return urljoin(self.internal_service_url, '/api/v1/')
y = f(X).ravel()
tab.is_hidden = request.json['is_hidden'] modulestore().update_item(course_item, request.user.id)
if classes is not None: label = label[:, classes]
scaling = 0.3 coef_grid, scores_path = lasso_stability_path(X, y, scaling=scaling, random_state=42, n_resampling=30)
self.login(self.email, self.pw)
start_delim_index = template.find(start_delim, start_index, close_char_index) if 0 <= start_delim_index < open_char_index: return None
X[0, 0] = 0 X[2, 1] = 0 X[4, 3] = 0 X_lil = sp.lil_matrix(X) X_lil[1, 0] = 0 X[1, 0] = 0
k_dims = self.k1.n_dims for i, kernel in enumerate(self.kernels): kernel.theta = theta[i * k_dims:(i + 1) * k_dims]
request_uuid = self._create_credit_request_and_get_uuid() response = self._credit_provider_callback(request_uuid, 'invalid') self.assertEqual(response.status_code, 400)
lib_page = LibraryEditPage(self.browser, LibraryLocator(org, number)) lib_page.wait_for_page()
self.course_outline.visit()
raise NotImplementedError
re.compile(r'^/admin/'),
print("{}: {}".format(self.full_path, self.rule.rule_id), file=out)
y_true, _, probas_pred = make_prediction(binary=True) expected_auc = _auc(y_true, probas_pred)
response_element = rendered_html.find("span") self.assertEqual(response_element.tag, "span")
for candidate in candidates: if system.resources_fs.exists(candidate): filepath = candidate break
raise NotImplementedError("edX Platform doesn't currently implement XBlock resource urls")
APP_UPGRADE_CACHE_TIMEOUT = 3600
self._test_group_id_passed_to_user_profile( mock_request, True, self.moderator, profiled_user, requested_cohort.id, pass_group_id )
return u"skipped_reverification.{}.{}".format(user_id, unicode(course_key))
return "visibility"
certs_api.set_cert_generation_enabled(self.course.id, True) self._assert_enable_certs_button(False)
new_module = modulestore().get_item(chapter_locator)
SIMPLE_CHILDREN_MAP = [[1, 2], [3, 4], [], [], []]
if self.closed() or submitted_without_reset: return False else: return True
'ENABLE_S3_GRADE_DOWNLOADS': False,
X = 3 * diabetes.data
raise NotImplementedError
y = np.dot(X, w) X = sp.csc_matrix(X) if n_targets == 1: y = np.ravel(y) return X, y
raised = False try: fmt = OneHotFormatter(max_labels=10, dtype='invalid') except TypeError: raised = True assert raised
return course.id.run
request.session[LANGUAGE_SESSION_KEY] = preview_lang
AutoAuthPage( self.browser, username="johndoe_saee", email=self.student_identifier, course_id=self.course_id, staff=False ).visit()
np.add(A, S, tmp) I = np.argmax(tmp, axis=1)
continue
CourseRerunState.objects.succeeded(course_key=destination_course_key)
def __init__(self, delay, func): self.func = func def start(self): self.func()
_, suff_stats = self._e_step(X, cal_sstats=True, random_init=True, parallel=parallel)
children = self.q(css=self.CHILD_SELECTOR) return [self.CHILD_CLASS(self.browser, child.get_attribute("id")) for child in children]
self.verify_staff_debug_present(True)
self.coach = coach = AdminFactory.create(password="test") self.client.login(username=coach.username, password="test")
queried_children = to_process_dict.values()
with self._secondary_action_menu_open("#comment_{}".format(comment_id)): return self._is_element_visible("#comment_{} .action-edit".format(comment_id))
pd_result = Parallel(n_jobs=n_jobs, verbose=verbose)( delayed(partial_dependence)(gbrt, fxs, X=X, grid_resolution=grid_resolution, percentiles=percentiles) for fxs in features)
neighborhoods = neighbors_model.radius_neighbors(X, eps, return_distance=False)
n_components = 100 n_features = 1000 A = gaussian_random_matrix(n_components, n_features, random_state=0)
user = BetaTesterFactory(course_key=course_descriptor.id) normal_student = UserFactory() instructor = InstructorFactory(course_key=course_descriptor.id)
import_course_from_xml(self.store, self.user.id, root_dir, create_if_not_present=True)
return ( context["is_requester_privileged"] or context["cc_requester"]["id"] == cc_content["user_id"] )
ROLE = 'library_user' def __init__(self, *args, **kwargs): super(LibraryUserRole, self).__init__(self.ROLE, *args, **kwargs)
expected_msg = 'Error: test error' self.assertEqual(expected_msg, result['success'])
new_hash = compute_fingerprint(paths) if new_hash != old_hash: install_func()
fake_course_image = 'sample_image.png' patched_create_thumbnail.side_effect = Exception("Kaboom!")
if child.visible_to_staff_only: continue
icon_class = None icon_image = None secondary = False
expected_message = self.emails[0].html_message returned_email_info = email_info[0] received_message = returned_email_info[u'email'][u'html_message'] self.assertEqual(expected_message, received_message)
pc_clf.fit(this_X_train, 2 * y_train - 1, sample_weight=sw_train) prob_pos_pc_clf_relabeled = pc_clf.predict_proba(this_X_test)[:, 1] assert_array_almost_equal(prob_pos_pc_clf, prob_pos_pc_clf_relabeled)
CourseEnrollmentFactory(user=self.moderator, course_id=self.course.id) self.moderator.roles.add(Role.objects.get(name="Moderator", course_id=self.course.id))
csmh = BaseStudentModuleHistory.get_history(student_module) self.assertEqual(len(csmh), 3)
NOTES_DISABLED_TABS = ['course_structure', 'tags']
warnings.simplefilter('ignore', ConvergenceWarning)
oh = OneHotEncoder(handle_unknown='error') oh.fit(X) assert_raises(ValueError, oh.transform, y)
bulk_record = self._get_bulk_ops_record(location.course_key)
space = [self.spaces[s] for s in self._get_sources] return space[0] if len(space) == 1 else tuple(space)
return redirect_to_custom_form(strategy.request, auth_entry, kwargs)
return Response(create_thread(request, request.data))
data = JUNK_FOOD_DOCS + NOTJUNK_FOOD_DOCS
enrollment.deactivate() self.assertFalse(CourseEnrollment.is_enrolled(user, course_id)) self.assert_unenrollment_event_was_emitted(user, course_id)
return course_metadata_utils.clean_course_key(self.location.course_key, padding_char)
self.inputs[input_id] = input_type_cls(self.capa_system, problemtree, state) return self.inputs[input_id].get_html()
monitoring_train = DenseDesignMatrix(X=X) monitoring_test = DenseDesignMatrix(X=Y)
self.certificates_section.refresh()
try: html = lxml.html.fragment_fromstring(fragment.content) except lxml.etree.ParserError: assert_student_view_invalid_html(block, fragment.content) else: assert_student_view_valid_html(block, html)
pass
assert_array_almost_equal( X_dense.astype(dtype), X2_dense, 4) assert_array_almost_equal( y_dense.astype(dtype), y2, 4)
self.import_path = import_path self.locked = locked
return CourseTeam.objects.all()
CourseRerunState.objects.get(id=rerun_state.id)
module = CapaFactory.create(attempts=1)
self._find_within(".forum-thread-expand").first.click() EmptyPromise( lambda: bool(self.get_response_total_text()), "Thread expanded" ).fulfill()
return cls
cov = pca.get_covariance() precision = pca.get_precision() assert_array_almost_equal(np.dot(cov, precision), np.eye(X.shape[1]), 12)
y_ = np.dot(f, self.beta) + np.dot(r, self.gamma)
if field_errors: raise AccountValidationError(field_errors)
self._update_head(asset_key.course_key, index_entry, asset_key.branch, new_structure['_id'])
conversions = { }
mock_refund_seat.reset_mock() self.course_enrollment.refundable = mock.Mock(return_value=False) self.send_signal() self.assertFalse(mock_refund_seat.called)
'ENABLE_COURSEWARE_SEARCH': False,
self.assertEqual(len(self._get_enrollments()), 1)
child_vertical_usage_key = self._create_vertical(parent_usage_key=root_usage_key) resp = self.create_xblock(parent_usage_key=child_vertical_usage_key, category='problem', boilerplate='multiplechoice.yaml') self.assertEqual(resp.status_code, 200)
d = get_dummy_course('2012-12-02T12:00') self.assertEqual('', d.end_datetime_text())
del params["honor_code"] assert_honor_code_error("To enroll, you must follow the honor code.")
if not request.user.is_authenticated(): return redirect(reverse('signin_user'), next=request.path)
raise NotImplementedError
self.check_discussion( tab_list=self.tabs_without_discussion, expected_discussion_link=not None, expected_can_display_value=False, )
if state != self.is_cohorted: self.q(css=self._bounded_selector('.cohorts-state')).first.click() self.wait_for_ajax()
self._wait_for( lambda: self.position == position, 'Position is {position}'.format(position=position) )
mix_clf_format = product(EXAMPLES["multilabel-indicator"], EXAMPLES["multiclass"] + EXAMPLES["binary"])
self.setup_extensions()
get_request_dict = {CapaFactory.input_key(): '3.14'} result = module.save_problem(get_request_dict)
cauth = EmbargoedState(embargoed_countries='US, AQ') cauth.save() currently_blocked = EmbargoedState.current().embargoed_countries_list
assert_raises(ValueError, ir.predict, [min(x) - 10, max(x) + 10])
return random.randint(1, 100000000)
return True
text_content.append(lt_object.get_text().encode('utf-8'))
return BadgrBackend()
render_args, _ = module.system.render_template.call_args context = render_args[1] self.assertIn("error", context['problem']['html'])
queuestate = {'key': queuekey, 'time': qtime, }
self.recursive_build(source_courselike, courselike, courselike_key, dest_id)
assert_in(role, ['instructor', 'staff'])
self.assertTrue(self.xmodule.verify_oauth_body_sign.called)
Score = namedtuple("Score", "earned possible graded section module_id")
if preference_visibility == PRIVATE_VISIBILITY: self._verify_private_account_response(response, account_privacy=PRIVATE_VISIBILITY) else: self._verify_full_shareable_account_response(response, ALL_USERS_VISIBILITY, badges_enabled=True)
redirect_response = self._redirect_if_necessary( message, already_verified, already_paid, is_enrolled, course_key, user_is_trying_to_pay, request.user, relevant_course_mode.sku ) if redirect_response is not None: return redirect_response
rgr_lasso = Lasso(alpha=0.001) rgr_lasso.fit(proj_operator, proj.ravel()) rec_l1 = rgr_lasso.coef_.reshape(l, l)
config.cancel()
remove_users(self.admin, CourseCreatorRole(), self.user) self.assertFalse(user_has_role(self.user, CourseCreatorRole()))
for app in ENV_TOKENS.get('ADDL_INSTALLED_APPS', []): INSTALLED_APPS += (app,)
microsite.set_by_domain('unknown') self.assertEqual(microsite.get_value('university'), 'default_university')
FOOTER_CACHE_TIMEOUT = 30 * 60
self.register_flag_response("thread", thread_id)
return str((template_name, context))
elif course_overview.location.org in orgs_to_exclude: continue
X_whitened = pca.fit_transform(X_.copy()) assert_equal(X_whitened.shape, (n_samples, n_components)) X_whitened2 = pca.transform(X_) assert_array_almost_equal(X_whitened, X_whitened2)
course_overviews = course_overviews.filter(org__iexact=org)
assert_equal(lfw_pairs_train.pairs.shape, (10, 2, 62, 47))
return self.q(css=TOPIC_CARD_CSS).results
searcher = SearchEngine.get_search_engine(index_name)
'WHAT_IS_VERIFIED_CERT': 'verified-certificate',
if not os.path.exists(remote_name): log.error("Error : Specified file %s does not exist" % remote_name) return filename
self.wait_for_ajax() if self.team: if not self.url.endswith(self.url_path): return False return self.q(css='.team-profile').present
if parens is not None: left_parens = parens if left_parens == '{': left_parens = r'\{'
self.navigate_to_video()
url = reverse("certificates:search") + "?user=" + user_filter if course_filter: url += '&course_id=' + course_filter return self.client.get(url)
if course is None: log.warn(u"Could not find course with ID %s.", course_id) raise Http404
return self.SEPARATOR.join([self.version, self.session_id, self.key_salt, self.signature])
courses_having_prerequisites = frozenset( enrollment.course_id for enrollment in course_enrollments if enrollment.course_overview.pre_requisite_courses ) courses_requirements_not_met = get_pre_requisite_courses_not_completed(user, courses_having_prerequisites)
return self.q(css='.page-header .page-description')[0].text
for attr in self.q(css='a.action-staff-lock>i').attrs('class'): if 'fa-check-square-o' in attr: return True return False
raise NotImplementedError
role.add_users(self.user)
self.wait_for_element_visibility( ".wrapper-notification-error.is-shown .message", "Error message is visible" ) return self.error_notification.results[0].find_element_by_css_selector('.message').text
THEME_NAME = ENV_TOKENS.get('THEME_NAME', None) COMPREHENSIVE_THEME_DIR = path(ENV_TOKENS.get('COMPREHENSIVE_THEME_DIR', COMPREHENSIVE_THEME_DIR))
self.assertDictEqual(json.loads(response.content), self._serialize_credit_course(cc1))
dist_unstructured = out_unstructured[-1] dist_structured = out_structured[-1]
self.reset_password_page.visit()
return u'{microsite_key}: {template_uri}'.format( microsite_key=self.microsite.key, template_uri=self.template_uri )
self.navigate_to_video() self.video.show_closed_captions()
self.update_masquerade(role='student', user_name=self.student_user.username) content = self.get_course_info_page().content self.assertIn("OOGIE BLOOGIE", content)
CourseRerunState.objects.failed(course_key=destination_course_key) logging.exception(u'Course Rerun Error')
return courselike
CourseModeFactory.create( course_id=self.course_key, mode_display_name="Verified Expired", mode_slug="verified_expired", expiration_datetime=past )
recall = tp / T.maximum(1., y.sum()) return recall
self.track_selection_page.enroll('verified')
if (valid_repr.shape[1] > valid_repr.shape[0]): valid_repr = numpy.dot(valid_repr, valid_repr.T) test_repr = numpy.dot(test_repr, test_repr.T)
self._do_create_preference_test(False)
self.assertNotIn(self.user_name, self.certificates_section.last_certificate_exception.text) self.assertNotIn(notes, self.certificates_section.last_certificate_exception.text)
ExampleCertificateSet.objects.all().delete()
from __future__ import unicode_literals
train.save = MethodType(only_run_extensions, train)
self.assertTrue(self._is_valid_key(key), msg="Failed for unicode character {0}".format(unicode_char))
X_composite = mlp_composite.get_input_space().make_theano_batch() X_first_part = mlp_first_part.get_input_space().make_theano_batch() X_second_part = mlp_second_part.get_input_space().make_theano_batch()
x_plot = np.linspace(0, 10, 100)
from __future__ import unicode_literals
Z = -9999 + np.zeros(land_mask.shape[0]) Z[land_mask] = np.exp(kde.score_samples(xy)) Z = Z.reshape(X.shape)
if is_css_present(css_selector): return retry_on_exception(lambda: css_find(css_selector, wait_time=timeout)[index].text) else: return ""
self.xblock_keys = [self.course.location]
if len(idset) > 1: self.context['overall_message'] = msg else: self.context['messages'][0] = msg
students_already_have_certs = User.objects.filter( ~Q(generatedcertificate__status=CertificateStatuses.unavailable), generatedcertificate__course_id=course_id)
dummy = 'void'
assert self.get_mlp() is None self.mlp = mlp
certificate_invalidation = CertificateInvalidation.objects.get(generated_certificate=generated_certificate)
PASSWORD_HASHERS = ( 'django.contrib.auth.hashers.SHA1PasswordHasher', 'django.contrib.auth.hashers.MD5PasswordHasher', )
return TagCategories.objects.all()
'example_certificate': True,
for X, y in classification_datasets: X = X y = y mlp = MLPClassifier(algorithm='sgd', max_iter=100, random_state=1, tol=0, alpha=1e-5, learning_rate_init=0.2)
master_course_object, master_course_key, _, _ = get_valid_course(unicode(ccx_course_object.course_id))
queryset = User.objects.filter( preferences__key=NOTIFICATION_PREF_KEY ).select_related( "profile" ).prefetch_related( "preferences", "courseenrollment_set", "course_groups", "roles__permissions" )
reraise_as(ImportError("Could not import %s; ImportError was %s" % (modulename, str_e)))
success, task_message = get_task_completion_info(task) status = _("Complete") if success else _("Incomplete") task_feature_dict['status'] = status task_feature_dict['task_message'] = task_message
url(r'^get_students_problem_grades$', 'class_dashboard.dashboard_data.get_students_problem_grades', name="get_students_problem_grades"),
assert_warns(DataConversionWarning, clf.fit, X, y_) assert_array_equal(clf.predict(T), true_result) assert_equal(100, len(clf.estimators_))
ALL_USERS_VISIBILITY = 'all_users'
return json.dumps(self.create_segmentio_event(**kwargs))
#ax.plot([1], [1], [1], color=c, label=label)
FOOD_CONTAINER = 3 FRUIT = 4 FURNITURE = 6 INSECTS = 7 LARGE_OMNIVORES_HERBIVORES = 11 MEDIUM_MAMMAL = 12
return self._enabled
if tag_key is None: tag_key = self.__class__.__name__ self._tag_key = tag_key
layers = [self.visible_layer] + self.hidden_layers
self.mock_programs_api() self.mock_credentials_api(self.user, reset_url=False) actual = get_programs_credentials(self.user) expected = self.expected_credentials_display_data()
self.assertIn('Welcome to edX.', self.video.captions_text)
solver = 'svd'
if is_pointer_tag(node): definition['filename'] = [filepath, filepath]
for cookie in ['csrftoken', 'sessionid']:
plt.figure() plt.legend(legend_rects, legend_labels, loc='upper left')
if privacy is None: privacy = self.PRIVACY_PUBLIC self.visit_profile_page(username, privacy=privacy)
path = []
url = reverse('course_modes_choose', args=[unicode(self.course.id)]) response = self.client.get(url)
orphans = self.store.get_orphans(course_key) self.assertEqual(len(orphans), 0)
if getattr(node, 'due', None): units.append(node) else: for child in node.get_children(): visit(child)
self.split_test_module.user_partition_id = SplitTestFields.no_partition_selected['value']
return self.q(css='.user-list .user-item').map( lambda el: UserWrapper(self.browser, el.get_attribute('data-email')) ).results
course = Course( validated_data["id"], self._new_course_mode_models(validated_data["modes"]), verification_deadline=validated_data["verification_deadline"] ) course.save() return course
layout = device.get_result()
self.kernel = kernel self.gamma = gamma self.n_neighbors = n_neighbors
users_state_after_post = self._post_words(['word1', 'word2'])
delete_indices = np.array([])
if scipy.sparse.issparse(train): idx = label.sum(axis=1).nonzero()[0] return (train[idx], label[idx])
self.assertEqual(200, response.status_code)
U, S, V = randomized_svd(X, n_components=n_components, n_iter=self.iterated_power, flip_sign=True, random_state=random_state)
return (NullSpace(), '')
return frozenset(child.data for child in self.library_fixture.children)
num_braces = 0
affinity[0, n_sample + 1] = 1 affinity[n_sample + 1, 0] = 1 affinity.flat[::2 * n_sample + 1] = 0 affinity = 0.5 * (affinity + affinity.T)
overview = CourseOverview.get_from_id(course.id) self.assertFalse(hasattr(overview, 'image_set'))
},
self.q(css='a.nav-item').filter(text='All Topics')[0].click()
y = [["ham", "spam"][i] for i in LabelEncoder().fit_transform(Y)] clf.fit(X[:, :-1], y)
unique_names = uniq_stable(names)
check_cohorted(False)
html_favicon = 'logos/favicon.ico'
out = StringIO() assert_raises(IndexError, export_graphviz, clf, out, feature_names=[])
self.course_outline.a11y_audit.config.set_scope( include=['section.edit-settings-timed-examination'] ) self.course_outline.a11y_audit.check_for_accessibility_errors()
if batch is None or (isinstance(batch, tuple) and len(batch) == 0): return True
if 'matrices_save_path' not in state: state['matrices_save_path'] = None
fallback_dtype = theano.config.floatX
return "{};q={}".format(lang, priority)
try: return User.objects.get(username=requested_username) except User.DoesNotExist: raise Http404( "Requested user '{requested_username}' does not exist.".format(requested_username=requested_username) )
self.mock_module = MagicMock() self.mock_module.id = 1 self.dispatch = 'score_update'
self._verify_unit_warning( self.UnitState(is_released=True, publish_state=self.PublishState.PUBLISHED, is_locked=False), None )
return '\n'.join([(' ' * spaces) + l for l in pprint.pformat(text).splitlines()])
self.q(css='div.problem button.save').click() self.wait_for_ajax()
#html_show_copyright = True
XDOMAIN_PROXY_CACHE_TIMEOUT = 60 * 15
EmptyPromise( lambda: self.q(css="#pre-requisite-course").present, 'Prerequisite course dropdown selector is displayed' ).fulfill()
#html_additional_pages = {}
value = models.TextField(default='null')
folders_list_in_path = folders_list_in_path[:-4]
ADVANCED_SECURITY_CONFIG = {}
inference_fn(x)
xml = ''.join(line.strip() for line in xml.split('\n')) factory = self.capa_factory_for_problem_xml(xml) module = factory.create()
XQUEUE_STUB_URL = os.environ.get('xqueue_url', 'http://localhost:8040')
return self.q(css='.bookmarks-empty-header').text[0]
return 1 / numpy.cosh(arg)
pass
fragment.add_javascript_url(self.runtime.local_resource_url(self, 'public/js/library_content_edit.js')) fragment.initialize_js('LibraryContentAuthorView') return fragment
CourseEnrollmentFactory(user=self.student, course_id=self.course.id)
self.assertEqual(1, len(editable_fields), editable_fields) self.assert_field_values( editable_fields, 'display_name', XModuleMixin.display_name, explicitly_set=False, value=None, default_value=None )
scaled = face - face.min() scaled /= scaled.max() return scaled
ridge.fit(X, y, sample_weights_OK) ridge.fit(X, y, sample_weights_OK_1) ridge.fit(X, y, sample_weights_OK_2)
X, y = make_circles(n_samples=400, factor=.3, noise=.05, random_state=0)
if dt: return JSONEncoder().default(dt) return None
_, setting = self._get_setting_entry(field_name) setting.find_element_by_class_name('setting-clear').click()
assert_greater(X.std(axis=0).std(), 43.8)
CourseEnrollment.unenroll(self.user, course_id or self.course.id)
assert_raises(ValueError, scale, X_csr, with_mean=True) assert_raises(ValueError, StandardScaler(with_mean=True).fit, X_csr)
return self._string
with np.errstate(all="ignore"): return np.ravel(sums) / np.ravel(n_non_missing)
if bootstrap_features: features = random_state.randint(0, n_features, max_features) else: features = sample_without_replacement(n_features, max_features, random_state=random_state)
resp = self.client.get_html(self.url) self.assertEqual(resp.status_code, 200) self.assertIn('course-nav-list', resp.content)
encoding = {'encoding': 'latin-1'} if six.PY3 else {}
thread = self.make_minimal_cs_thread({ "thread_type": thread_type, response_field: [make_minimal_cs_comment()], response_total_field: 5, })
self.assertIsNotNone(self.request.session)
if node.name != '__repr__': self.generic_visit(node)
return Fragment(self.FRAG_CONTENT)
from __future__ import unicode_literals
return {'html': self.get_problem_html(encapsulate=False)}
from __future__ import unicode_literals
try:
return self.get(path, data or {}, follow, HTTP_ACCEPT="application/json", **extra)
sampling_algorithm = {}
fs.set_params(select__k=2) assert_equal(fs.fit_transform(X, y).shape, (X.shape[0], 4))
clf = LinearSVC() X, y_idx = make_blobs(n_samples=100, n_features=2, random_state=42, centers=3, cluster_std=3.0)
try: return CourseRegCodeItemAnnotation.objects.get(course_id=self.course_id).annotation except CourseRegCodeItemAnnotation.DoesNotExist: return u""
if name == 'cybersource_config_key': return 'test_microsite' else: return None
self.store.publish(locations['child'], self.user_id)
X, y = datasets.make_hastie_10_2(n_samples=100, random_state=1) for Cls in [GradientBoostingRegressor, GradientBoostingClassifier]: est = Cls(n_estimators=300, max_depth=1) est.fit(X, y)
for X in [X_1row, X_1col, X_list_1row, X_list_1row]:
target_location = self.xblock.location.replace(revision='draft') _update_module_location(self.xblock, target_location)
error_code = models.CharField(blank=True, max_length=50)
indices = np.argsort(n_samples_per_label)[::-1] n_samples_per_label = n_samples_per_label[indices]
self.test_send_to_all()
from scipy import misc face = misc.face(gray=True)
ItemFactory.create(parent=self.verticals[3], category='edx-reverification-block') with check_mongo_calls_range(max_finds=6, max_sends=3): self._update_partitions(reload_items=False)
return self.example_cert_set.course_key
STATICFILES_STORAGE = 'pipeline.storage.NonPackagingPipelineStorage' STATIC_URL = "/static/"
self.assertFalse(res_json['success']) self.assertEqual( res_json['message'], u'Invalid data, generate_for must be "new" or "all".' )
actual = GroupConfiguration.get_or_create_content_group(self.store, self.course)
ASSET_XSD_PATH = PLATFORM_ROOT / "common" / "lib" / "xmodule" / "xmodule" / "assetstore" / "tests" / ASSET_XSD_FILE
templates_path = ['templates']
if support_sample_weight: if sample_weight is None: curr_sample_weight = np.ones((n_samples,)) else: curr_sample_weight = sample_weight.copy()
log.warning("Could not send email notification for refund.", exc_info=True)
for user in get_users_with_role(CourseStaffRole.ROLE): add_user_with_status_unrequested(user)
s = s + record.exc_text.decode(sys.getfilesystemencoding())
for video in self.previous_uploads: self.assertIn(video["edx_video_id"], response.content)
self.assertEqual(len(mail.outbox), 1) self.assertEqual(mail.outbox[0].to[0], self.instructor.email)
chapter = self.store.create_child(self.user_id, self.course.location, 'chapter', block_id='Overview', asides=asides) self.writable_chapter_location = chapter.location
except (TypeError, ValueError, InvalidTabsException) as err: return HttpResponseBadRequest( django.utils.html.escape(err.message), content_type="text/plain" )
resp = self.client.ajax_post( first_update_url, payload, HTTP_X_HTTP_METHOD_OVERRIDE="PUT", REQUEST_METHOD="POST" )
'Content-Type': content_type,
now = datetime.datetime.now(pytz.UTC) tomorrow = now + datetime.timedelta(days=1) nextday = tomorrow + datetime.timedelta(days=1)
super(CourseDescriptorTestCase, self).setUp() self.course = get_dummy_course(start=_TODAY)
component_class = XBlock.load_class(category, select=settings.XBLOCK_SELECT_FUNCTION) mixologist = Mixologist(settings.XBLOCK_MIXINS) return mixologist.mix(component_class)
_validate_username(username) _validate_password(password, username) _validate_email(email)
params = {'bandwidth': np.logspace(-1, 1, 20)} grid = GridSearchCV(KernelDensity(), params) grid.fit(data)
verify_file_presence(True)
num_labels_by_type = numpy.array(norb.SmallNORB.num_labels_by_type, 'int') num_labels_by_type[instance_index] = len(new_to_old_instance)
open(libcuda_convnet_so).close()
request = Mock() request.META = {'HTTP_REFERER': http_referer} request.is_secure = lambda: is_secure return request
FILE_UPLOAD_STORAGE_BUCKET_NAME = 'edxuploads' FILE_UPLOAD_STORAGE_PREFIX = 'submissions_attachments'
manage.py ... enroll_user_in_course -e test@example.com -c edX/Open_DemoX/edx_demo_course
self._process_includes()
clf = svm.SVC(kernel='linear', probability=True, random_state=0) probas_pred = clf.fit(X[:half], y[:half]).predict_proba(X[half:])
CourseEnrollmentFactory(user=self.student, course_id=self.course_id)
self.assertEqual(resp_obj.status_code, http_code) self.assertIn('error_code', resp_obj.data) self.assertEqual(resp_obj.data['error_code'], error_code_str)
plt.figure()
minimum = 1 maximum = times for i in range(times): self.assertIn(generate_int_id(minimum, maximum), range(minimum, maximum + 1))
if self.value == "": self.value = 'null'
from __future__ import unicode_literals
EmptyPromise( lambda: "login" not in self.browser.current_url, "redirected from the login page" ).fulfill()
self.q(css=self._bounded_selector(".check-discussion-subcategory-%s" % key)).first.click()
if view_html: fragment.add_content(view_html) return fragment
sreg_response = sreg.SRegResponse.extractResponse(sreg_request, sreg_data) sreg_response.toMessage(response.fields)
if not self.hyperparameter_length_scale.fixed: length_scale_gradient = \ dists * K / (self.length_scale ** 2 * base) length_scale_gradient = length_scale_gradient[:, :, np.newaxis]
self._block_data_map = defaultdict(_BlockData)
course_key = self.kwargs.get(self.lookup_field) if course_key is not None: self.kwargs[self.lookup_field] = CourseKey.from_string(course_key)
if not sp.issparse(X) or hasattr(init, '__array__'): X_mean = X.mean(axis=0) if not sp.issparse(X): X -= X_mean
fig = plt.figure(figsize=(15, 8)) plt.suptitle("Manifold Learning with %i points, %i neighbors" % (1000, n_neighbors), fontsize=14)
other_user = UserFactory() self.assertFalse(ApiAccessRequest.has_api_access(other_user))
memberships = list(CourseTeamMembership.get_memberships(team_id=team_id))
if block_key is None: block_key = BlockKey(block_data.block_type, LocalId())
from __future__ import division import numpy as np import scipy.sparse as sp import operator import array
self.assertTrue(self.video.is_aligned(True))
if np_version < (1, 7, 1): _ravel = np.ravel else: _ravel = partial(np.ravel, order='K')
serializer = serializer_cls(page, context=serializer_ctx, many=True)
user_not_added = User.objects.create_user('testuser2', 'test+courses2@edx.org', 'foo2') self.assertFalse(user_has_role(user_not_added, CourseCreatorRole()))
dbkey['run'] = _id_field['run']
return self.find_css('.staff-lock .tip-warning').visible
if public: for filename in self.filenames: make_readable(filename)
handler404 = 'contentstore.views.render_404' handler500 = 'contentstore.views.render_500'
X_sparse_pruned = sparse.csr_matrix(X_dense)
return {'HTTP_AUTHORIZATION': 'Basic ' + base64.b64encode('%s:%s' % (username, password))}
return True
content = html_parsed[0].tail
AUDIT_LOG.info("Bad password_reset user passed in.") limiter.tick_bad_request_counter(request)
from __future__ import unicode_literals
return self.make_call(reverse('team_membership_list'), expected_status, 'post', data, **kwargs)
return json.dumps({'message': 'Task revoked before running'})
return ACCESS_DENIED if is_prerequisite_courses_enabled() else ACCESS_GRANTED
url( r'^courses/{}/lti_rest_endpoints/'.format( settings.COURSE_ID_PATTERN, ), 'courseware.views.views.get_course_lti_endpoints', name='lti_rest_endpoints', ),
EDXNOTES_PUBLIC_API = 'http://localhost:8042/api/v1' EDXNOTES_INTERNAL_API = 'http://localhost:8042/api/v1'
mongouri = 'mongodb://{user}:{password}@{host}:{port}/{db}'.format(**mongo_db)
self.assert_correct_filter_response(self.url, 'asset_type', 'OTHER')
X = self._check_fit_data(X) return self.fit(X)._transform(X)
values = self.get_param_values() values = [value.reshape(value.size) for value in values] return np.concatenate(values, axis=0)
state_below=dbm.hidden_layers[-2].upward_state(H_hat[-1])))
self.get_selector('#certificate-invalidation-user').fill(student)
answer_correct = CapaFactory.create(showanswer='correct_or_past_due', max_attempts="1", attempts="0", due=self.tomorrow_str, correct=True) self.assertTrue(answer_correct.answer_available())
err = SearchIndexingError mock_index_dictionary.return_value = err
del self.bias_from_marginals
for student in students[:3]: CertificateWhitelistFactory.create( user=student, course_id=self.course.id, whitelist=True )
html.add_header(2, title_map[table_type]) html.add_to_body(phase_table.table)
raise NotImplementedError()
topo = self.train.get_batch_topo(1) assert topo.ndim == 4
print("Computing random projection") rp = random_projection.SparseRandomProjection(n_components=2, random_state=42) X_projected = rp.fit_transform(X) plot_embedding(X_projected, "Random Projection of the digits")
_MIXED_MODULESTORE = None
return getattr(request, 'need_to_delete_cookie', False)
lti_user = create_lti_user(lti_user_id, lti_consumer)
items = store.get_items(course.id, settings={'group_access': {'$exists': True}}) return GroupConfiguration._get_content_groups_items_usage_info(course, items)
assert_raises(ValueError, load_svmlight_file, datafile, n_features=20)
return self._validation_paragraph('warning').text[0]
CSRF_COOKIE_SECURE = ENV_TOKENS.get('CSRF_COOKIE_SECURE', False)
generated_password = ['first'] password = generate_unique_password(generated_password, 12) self.assertNotEquals(password, 'first')
return X
self.set_group_access(self.vertical, {1: []}) self.set_group_access(self.html, {2: None})
return "input_" + cls.answer_key(input_num)
'support',
self.full_path = full_path self._mark_disabled(string_lines.get_string())
super(IsCommentableCohortedTestCase, self).setUp() self.toy_course_key = ToyCourseFactory.create().id
L1_units = theano.tensor.abs_(model.encode(X)).sum(axis=1).mean()
return self.filter_by(data, "course_id", course_id)
drag(container, first_handle + 3, first_handle, 40) drag(container, first_handle + 2, first_handle, 40)
click_css(self, self._bounded_selector('.delete-button'), require_notification=False) confirm_prompt(self, cancel)
response_element = etree.Element("schematicresponse")
for X_minibatch in np.array_split(X, 10): km.partial_fit(X_minibatch)
if self.capa_system.xqueue is None: return {'success': False, 'message': _('Cannot connect to the queue')}
element = etree.fromstring(xml_str) renderer = lookup_tag('math')(test_capa_system(), element) self.assertEqual(renderer.mathstr, mathjax_out)
return has_access(requesting_user, CourseStaffRole.ROLE, course_key)
self._fill_flat(nested, self.spec_mapping, rval)
self.X_topo_space = self.view_converter.topo_space
self.user_partition.scheme.current_group = groups[1] group2 = self.partition_service.get_group(self.user_partition) self.assertEqual(group2, groups[1])
if not cls.is_restricted_course(course_key): return default_path
return { key: value[0] if len(value) == 1 else value for key, value in urlparse.parse_qs(query).items() }
microsite.set_by_domain(self.microsite_subdomain) self.assertTrue(microsite.is_request_in_microsite())
with remove_ccx(location) as (location, restore): return restore( self._modulestore.revert_to_published(location, user_id) )
if not isinstance(max_samples, (numbers.Integral, np.integer)): max_samples = int(max_samples * X.shape[0])
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'proj.settings')
if self.signal_handler: self.signal_handler.send("item_deleted", usage_key=usage_key, user_id=user_id)
def test_sparse_random_projection_transformer_invalid_density(): for RandomProjection in all_SparseRandomProjection: assert_raises(ValueError, RandomProjection(density=1.1).fit, data)
kwargs = {'course_id': self.course_id.to_deprecated_string(), 'note_id': str(self.pk)} return reverse('notes_api_note', kwargs=kwargs)
break
self._pool = None warnings.warn( 'Multiprocessing-backed parallel loops cannot be nested,' ' setting n_jobs=1', stacklevel=3) return 1
y = (self.y_mean + self.y_std * y_).reshape(n_eval, n_targets)
X = make_low_rank_matrix(n_samples=n_samples, n_features=n_features, effective_rank=rank, tail_strength=0.0, random_state=0) assert_equal(X.shape, (n_samples, n_features))
if cc_thread['closed']: raise PermissionDenied
with self.assertRaisesRegexp(CommandError, ".*ENABLE_TEAMS must be enabled.*"): call_command('reindex_course_team', self.team1.team_id)
os.environ[JOBLIB_SPAWNED_PROCESS] = '1'
try: result = CourseTeam.objects.get(team_id=team_id) except ObjectDoesNotExist: raise CommandError(u"Argument {0} is not a course_team team_id".format(team_id)) return result
assert_equal(hamming_loss(y1[0], y2[0]), sp_hamming(y1[0], y2[0]))
return process_request_response
iterator = SequentialSubsetIterator(10, 3, 3) for i in range(3): iterator.next()
return reverse( 'xblock_handler', args=(unicode(self.course.id), quote_slashes(self.item_url), 'xmodule_handler', dispatch) )
cohort = CohortFactory(course_id=self.course.id, users=[]) self._verify_non_staff_cannot_access(users_in_cohort, "GET", [unicode(self.course.id), cohort.id])
empty_child_container = self._create_item(self.vertical.location, 'split_test', 'Split Test') self.validate_preview_html(empty_child_container, self.reorderable_child_view, can_add=False)
override_field_for_ccx(ccx, course, 'max_student_enrollments_allowed', settings.CCX_MAX_STUDENTS_ALLOWED)
membership1 = CohortMembership( course_id=course_1_auto_cohort_1.course_id, user=self.user1, course_user_group=course_1_auto_cohort_1 ) membership1.save() membership2 = CohortMembership( course_id=course_1_auto_cohort_1.course_id, user=self.user2, course_user_group=course_1_auto_cohort_1 ) membership2.save()
context['company_privacy_urltext'] = _("Privacy Policy")
return ' '.join([self.selector, css])
get_input_space = Model.get_input_space get_output_space = Model.get_output_space
csv_file, courses_info = self.generate_registration_codes_csv(orderitems, site_name)
self.assertFalse(self.signal_fired) self.assertTrue(skip_refund) self.signal_fired = True
self._verify_components_visible(['problem']) self._verify_student_view_locked()
normalizer = proba_k.sum(axis=1)[:, np.newaxis] normalizer[normalizer == 0.0] = 1.0 proba_k /= normalizer
if self._xml_string is not None: return self._xml_string return etree.tostring(self._xml_node)
return [ desc.module_class for desc in _list_descriptors() ]
with self._mock_geoip(ip_country): result = embargo_api.check_course_access(self.course.id, user=self.user, ip_address='0.0.0.0')
l1 = np.random.normal(size=n) l2 = np.random.normal(size=n)
rval = np.log(x) rval -= rval.mean() return rval
tooltip = { 'type': 'subsection', 'num_students': num_students, 'subsection_num': c_subsection, 'subsection_name': subsection_name }
reg.fit(X, y, sample_weights_OK) reg.fit(X, y, sample_weights_OK_1) reg.fit(X, y, sample_weights_OK_2)
return dict([(k, v) for k, v in dic.iteritems() if v is not None])
url( r'^courses/{}/edxnotes'.format( settings.COURSE_ID_PATTERN, ), include('edxnotes.urls'), name='edxnotes_endpoints', ),
linter = JavaScriptLinter() results = FileResults('') linter.check_javascript_file_is_safe(data['template'], results) self._validate_data_rules(data, results)
if prev_log_likelihood is not None: change = abs(current_log_likelihood - prev_log_likelihood) if change < self.tol: self.converged_ = True break
names = F.readline().decode('ascii').strip().split(',')
course_id = None
self.correct_responses[name] = self.SCHEMATIC_CORRECT self.incorrect_responses[name] = self.SCHEMATIC_INCORRECT
account_settings = get_account_settings(self.default_request, self.different_user.username) self.assertNotIn("email", account_settings)
metadata_translations = dict(RawDescriptor.metadata_translations) metadata_translations['attempts'] = 'max_attempts'
self.login_page.visit()
return self.scope_ids.usage_id
self.assertEqual(resp.status_code, 200)
'service_status',
for p in user_partitions: has_selected = any(g["selected"] for g in p["groups"]) has_selected_groups = has_selected_groups or has_selected
clf_quantile = GradientBoostingRegressor(n_estimators=100, loss='quantile', max_depth=4, alpha=0.5, random_state=7)
AutoAuthPage( self.browser, username=self.username, email=self.email, password=self.password, course_id=self.course_id, staff=False ).visit()
self.wait_for_field(field_id) query = self.q(css='.u-field-{} {}'.format(field_id, field_type)) if query.present: query.first.click()
return self.student_email_input.is_present()
if sp.issparse(preds[0]): preds = sp.vstack(preds, format=preds[0].format) else: preds = np.concatenate(preds) return preds[inv_locs]
microsite.set_by_domain(self.microsite.site.domain) self.assertEqual(microsite.get_value('email_from_address'), self.microsite.values['email_from_address'])
return X, y
for xblock_name in self.XBLOCK_NAMES: self.check_event_response_by_key('flag_resource', resource, 'reason', 'reason 0', xblock_name)
self.setup_course() self.setup_user(admin=False, enroll=False, login=True) self.verify_response()
n_folds = 5 n_iter = 1000
return "{base}/register?course_id={course_id}&enrollment_action={action}".format( base=BASE_URL, course_id=self._course_id, action="enroll", )
'ENABLE_INSTRUCTOR_BACKGROUND_TASKS': True,
assert_array_equal(lfw_pairs_train.target, [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]) assert_array_equal(lfw_pairs_train.target_names, expected_classes)
try: return get_draft() except ItemNotFoundError: return get_published()
return self.q(css="#is_prereq").visible
template_context['js_init_parameters'] = json.dumps(frag.json_init_args).replace("/", r"\/")
EmptyPromise( lambda: self.outline_page.is_browser_on_page(), "loaded page {!r}".format(self.outline_page), timeout=30 ).fulfill()
self.assertEquals(len(mail.outbox), 3)
return dispatch_to_register()
alpha_ = 1. / np.var(y) lambda_ = np.ones(n_features)
return np.mean( [estimator.log_marginal_likelihood( theta[n_dims * i:n_dims * (i + 1)]) for i, estimator in enumerate(estimators)])
n_samples = self.X.shape[0] D = self.D ij = self.ij F = self.F
filesystem = OSFS(root_dir / 'test_export/policies/2012_Fall') self.assertTrue(filesystem.exists('grading_policy.json'))
self.bulk.insert_course_index(self.course_key, self.index_entry) self.assertConnCalls(call.insert_course_index(self.index_entry, self.course_key)) self.assertCacheNotCleared()
include_expired = not is_active if is_active is not None else False
for name in FOREST_CLASSIFIERS: yield check_gridsearch, name
self.client.login(username=self.instructor.username, password='test') response = self.client.post(url) self.assertEqual(response.status_code, 403)
return self.label_binarizer_.y_type_.startswith('multilabel')
with check_mongo_calls(max_find, max_send): wiki_courses = self.store.get_courses_for_wiki('999') self.assertEqual(len(wiki_courses), 1) self.assertIn(
self._make_eligible()
EmptyPromise(self._is_loading_in_progress, "Loading is in progress.").fulfill()
if not isinstance(message, ValidationMessage): raise TypeError("Argument must of type ValidationMessage") self.summary = message
parent = np.arange(n_nodes, dtype=np.intp) used_node = np.ones(n_nodes, dtype=bool) children = [] if return_distance: distances = np.empty(n_nodes - n_samples)
rs = np.random.RandomState(1999) n_samples = 20 n_features = 10 X = rs.randn(n_samples, n_features)
self.assertFalse(self.store.has_changes(test_course)) self.assertFalse(self.store.has_changes(chapter))
paginator = pagination_cls() page = paginator.paginate_queryset(queryset, request)
plt.matshow(importances, cmap=plt.cm.hot) plt.title("Pixel importances with forests of trees") plt.show()
check_is_fitted(self, "classes_") X = check_array(X, accept_sparse='csr') return (safe_sparse_dot(X, self.feature_log_prob_.T) + self.class_log_prior_)
assert_raises(ValueError, cval.KFold, 3, 4)
logprob, responsibilities = self.score_samples(X) return responsibilities.argmax(axis=1)
with self.assertRaises(ResponseError): submission_dict = {'test': 'test'} input_dict = {'1_2_1': json.dumps(submission_dict)} problem.grade_answers(input_dict)
raise NotImplementedError(str(self.__class__) + " does not implement " "_get_default_output_layer")
type_in_codemirror(self, 0, content)
suite = BokChoyTestSuite('', default_store='invalid') name = 'tests' self.assertEqual( suite.cmd, self._expected_command(name=name, store='invalid') )
'edxmako', 'pipeline', 'static_replace',
pass
AutoAuthPage(self.browser, course_id=self.course_id).visit()
self.assertEqual(CourseMode.is_eligible_for_certificate(mode_slug), expected_eligibility)
if self.date is not None: return datetime.now(pytz.UTC) <= self.date return False
super(GitExportError, self).__init__(unicode(message))
if shift is None: shift = (2 * generator.rand(n_features) - 1) * class_sep X += shift
#epub_cover = ()
if name == 'SITE_NAME': return 'openedx.localhost' else: return default
studentmodule.state = json.dumps(problem_state) studentmodule.save()
return aside_id.aside_type
course_path = "/courses/{}".format(course_id.to_deprecated_string())
request_token=None, course=course
seed = module.seed self.assertTrue(seed is not None)
self.expect_error_on_file_content( 'username,email\n', "The file must contain a 'cohort' column containing cohort names." )
X = np.hstack((iris.data, E)) y = iris.target
return self.system.render_template('module-error.html', { 'staff_access': False, 'data': "", 'error': "", })
X_sliced = X_sparse[np.arange(X_sparse.shape[0])] y_sliced = y_sparse[np.arange(y_sparse.shape[0])]
if self.multi_class == 'multinomial': classes_ = [None] warm_start_coef = [warm_start_coef]
X = np.array([[0, 1], [1.01, 1.], [2, 0]])
self.track_selection_page.visit()
return self.build_membership_data_raw(self.users[username].username, team.team_id)
if issparse(example): example = example.toarray()
self.assertEquals(provider2.icon_image, provider1.icon_image) self.assertEquals(provider2.name, post_data['name'])
return self.mean_h_given_v(v)
course_names = self.dashboard_page.wait_for_page().available_courses self.assertIn(self.course_info["display_name"], course_names)
if settings.FEATURES.get('ENABLE_MKTG_EMAIL_OPT_IN'): _update_email_opt_in(request, course_id.org)
CELERY_ALWAYS_EAGER = True
if expected_n_iter is not None: assert_equal(cv.get_n_splits(X, y, labels), expected_n_iter) else: expected_n_iter = cv.get_n_splits(X, y, labels)
self.assertTrue(self.store.has_changes(xblock))
super(AcidView, self).__init__(browser) if isinstance(context_selector, unicode): context_selector = context_selector.encode('utf-8') self.context_selector = context_selector
assert_array_almost_equal(theil_sen.coef_, lstq.coef_, 9)
result = self.client.get_html(self._url()) self.assertNotIn('Test certificate', result.content)
store = self._get_modulestore_for_courselike(location.course_key) return store.get_parent_location(location, **kwargs)
'reverification',
assert_true(np.any(y_pred3 != y7))
response = redirect(reverse('cas-login'))
#epub_tocdup = True
from __future__ import unicode_literals
AutoAuthPage(self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id, staff=False).visit()
super(BadImplementationAbstractEnrollmentReportProvider, self).get_user_profile(user_id)
OverrideFieldData.provider_classes = None super(SharedModuleStoreTestCase, self).setUp()
return np.dot(A, B)
l = [] for mask in xrange(16): l.append(mlp.masked_fprop(inp, mask)) outsum = reduce(lambda x, y: x + y, l)
self.assertEqual(len(site_configuration_history), 1)
else: self._send_immediate_response(False, message="Invalid request URL")
assert_almost_equal(dists[2], 1)
module, klass = settings.BADGING_BACKEND.rsplit('.', 1) module = import_module(module) return getattr(module, klass)()
self.required_html_ids = [descriptor.location.html_id() for descriptor in self.descriptor.get_required_module_descriptors()]
msg = _(u"An error occurred with SymbolicResponse. The error was: {error_msg}").format( error_msg=err, ) raise Exception(msg)
scores = cval.cross_val_score(clf, X, y) assert_array_equal(scores, clf.score(X, y))
params = self._signed_callback_params(self.order.id, self.COST, self.COST) del params[missing_param]
def __init__(self, detail): if isinstance(detail, dict): self.detail = detail else: super(_DictAPIException, self).__init__(detail)
mock_response.status_code = 200 mock_post.return_value = mock_response
user = cc.User.from_django_user(request.user) commentable = cc.Commentable.find(commentable_id) user.follow(commentable) return JsonResponse({})
check_is_fitted(self, ["classes_", "n_classes_"]) X = check_array(X) return self.base_estimator_.predict(X)
ele = (ele * 2 * numpy.pi) / 360. azi = (azi * 2 * numpy.pi) / 360.
phi_aj = phi(a_j) derphi_aj = derphi(a_j)
return "file://"+urllib.pathname2url(os.path.abspath(filename))
if block_key not in missing_blocks: self.assertEquals( set(block_structure.get_children(block_key)), set(children), )
for key in baseline: params = baseline.copy() del params[key] with self.assertRaises(CCProcessorDataException): payment_accepted(params)
old_duration = self.parallel._smoothed_batch_duration if old_duration == 0: new_duration = this_batch_duration else: new_duration = 0.8 * old_duration + 0.2 * this_batch_duration self.parallel._smoothed_batch_duration = new_duration
current_provider = provider.Registry.get_from_pipeline({'backend': backend.name, 'kwargs': kwargs}) return current_provider and current_provider.skip_email_verification
return StaticContent.compute_location(location.course_key, filename)
self.assertTrue(self.video.is_error_message_shown)
random_state = check_random_state(0) tsne = TSNE(verbose=2) X = random_state.randn(5, 2)
return deserialize_count_specs(self.courses_completed)
act_enc = activation_funcs[i + 1] act_dec = act_enc if i != 0 else activation_funcs[0] aes.append( Autoencoder(layer_sizes[i], layer_sizes[i + 1], act_enc, act_dec, tied_weights=tied) )
check_cuda(str(type(self)))
self.assertIs( bool(access.has_access(user, 'load', modulestore().get_item(block_location), self.course.id)), is_accessible )
if (llx <= ans_x <= urx) and (lly <= ans_y <= ury): correct_map.set(aid, 'correct') break
if not api_enabled(request, course_key): log.debug('Notes are disabled for course: {0}'.format(course_id)) raise Http404
return np.apply_along_axis(self, 1, X)[:, 0]
for ext in self.extensions: ext.setup(self.model, self.dataset, self.algorithm)
preprocessor = ZCA(filter_bias=0.0, n_drop_components=2) preprocessed_X = self.get_preprocessed_data(preprocessor) assert_allclose(zca_truncated_X, preprocessed_X, rtol=1e-3)
extra_block = self.make_block("html", vertical_block_course)
check_has_course_method( XMLModuleStore(DATA_DIR, source_dirs=['toy', 'simple']), SlashSeparatedCourseKey('edX', 'toy', '2012_Fall'), locator_key_fields=SlashSeparatedCourseKey.KEY_FIELDS )
staticfiles.finders.get_finder.cache_clear()
self._update_head(dest_course_key, index_entry, dest_course_key.branch, new_structure['_id'])
resp = self.create_xblock(category='static_tab') usage_key = self.response_usage_key(resp)
self.assertTrue(BulkEmailFlag.feature_enabled(self.course.id)) response = self.client.get(self.url) self.assertTrue(self.email_link in response.content)
_delete_entrance_exam(request, course_key) return _create_entrance_exam( request=request, course_key=course_key, entrance_exam_minimum_score_pct=entrance_exam_minimum_score_pct )
return {'cond_module': cond_descriptor, 'source_module': source_descriptor, 'child_module': child_descriptor}
from_xmodule = [entry_point for entry_point in entry_points if entry_point.dist.key == 'xmodule'] return default_select(identifier, from_xmodule)
check_cv_coverage(cv, expected_n_iter=3, n_samples=len(y))
self.assertEqual(len(self.certificates_page.certificates), 1)
return None
with self.store.branch_setting(ModuleStoreEnum.Branch.published_only, dest_id): self.recursive_build(source_courselike, courselike, courselike_key, dest_id)
super(XBlockAcidBase, self).setUp()
prob /= prob.sum(axis=1).reshape((prob.shape[0], -1)) return prob
log.info('Approving API request from user [%s].', self.user.id) self.status = self.APPROVED self.save()
#latex_paper_size = 'letter'
return page.q(css='.wrapper-notification-mini.is-shown').present
if cls.is_white_label(course_id, modes_dict=modes_dict): return False
self._studio_reindex()
self.assertEqual(result, allow_access)
pass
response = requests.get(self._get_url("api/v1/annotations")) self.assertEqual(response.status_code, 400)
if self.teams_configuration: return len(self.teams_configuration.get('topics', [])) > 0 return False
self.certificates_section.click_generate_certificate_exceptions_button() self.certificates_section.wait_for_ajax()
self.profile.gender = gender self.profile.save()
self.release_languages('ar, es-419')
temp_poll_answers = self.poll_answers temp_poll_answers[self.poll_answer] -= 1 self.poll_answers = temp_poll_answers
return MilestoneError() if any_unfulfilled_milestones(course_id, user.id) else ACCESS_GRANTED
kernel = self.kernel if callable(kernel): kernel = 'precomputed'
scores = cval.cross_val_score(clf, X_sparse, X) assert_array_equal(scores, clf.score(X_sparse, X))
return ACCESS_GRANTED if (can_load() or can_enroll()) else ACCESS_DENIED
X = iris.data
if 'X-Edx-Api-Key' in self.headers: response = self.server._response_str logger.debug("Comment Service: sending response %s", json.dumps(response))
real_answers = problem.get_question_answers()
return
if settings.COMPREHENSIVE_THEME_DIR: enable_comprehensive_theme(settings.COMPREHENSIVE_THEME_DIR)
all_leaves = est.tree_.children_left == TREE_LEAF assert_array_almost_equal(np.dot(node_indicator, all_leaves), np.ones(shape=n_samples))
options.mode = 'dev' test_js(options)
original_values_map = self.get_settings_fields_of_each_type() self.set_wrong_inputs_to_fields()
self.assertEqual( ImportTestCase.date.to_json(ImportTestCase.date.from_json(course_due)), child.xblock_kvs.inherited_settings['due'] )
lfw_pairs_train = fetch_lfw_pairs(data_home=SCIKIT_LEARN_DATA, resize=None, slice_=None, color=True, download_if_missing=False) assert_equal(lfw_pairs_train.pairs.shape, (10, 2, 250, 250, 3))
return self.mode_slug
return browser.execute_script("return typeof(jQuery) == 'undefined' || jQuery.active == 0")
def _get_courses_with_access_type(self, user, access_type):
self.set_select_value(self.SCORED_LABEL, str(scored)) EmptyPromise(lambda: self.scored == scored, "scored is updated in modal.").fulfill()
return self.q(css='{} input[name=entrance-exam-student-select-grade]'.format(self.EE_CONTAINER))
from __future__ import division import warnings import numpy as np from scipy import linalg
PARTNER_SUPPORT_EMAIL = 'partner-support@example.com'
if not lazy: descendent_definitions = self.get_definitions( course_key, [ block.definition for block in new_module_data.itervalues() ] ) definitions = {definition['_id']: definition for definition in descendent_definitions}
DELAY = 0.5
anon_user = Client() resp = anon_user.post( self.postback_url, self.student_answers ) self.assertEquals(resp.status_code, 302)
course_name = re.sub(r"[^\w.-]", '_', course_id.course)
self.assertEquals(len(audit_log_calls), 0)
([TestTransformer1()], []),
if revision == ModuleStoreEnum.RevisionOption.published_only: query['_id.revision'] = MongoRevisionKey.published
return get_course_topics(self.request, self.course.id)
AutoAuthPage( self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id, staff=False ).visit()
submission_dict = {'test': 'the_answer'} input_dict = {'1_2_1': json.dumps(submission_dict)} correct_map = problem.grade_answers(input_dict)
from .metrics import r2_score return r2_score(y, self.predict(X), sample_weight=sample_weight, multioutput='uniform_average')
pass
raise ValueError( "%s doesn't support multi-label classification" % ( self.__class__.__name__))
mlp.n_iter_ = 0 mlp.learning_rate_ = 0.1
self.courseware_page.visit() self.courseware_page.wait_for_page()
self.assert_created_course()
xi_, yi, swi, idx = dataset._next_py() xi = sp.csr_matrix((xi_), shape=(1, X.shape[1]))
X_dense = theano.sparse.dense_from_sparse(X) noise = self.random_stream.binomial(size=X_dense.shape, n=1, prob=self.one_ratio, ndim=None)
transcripts_utils.download_youtube_subs(good_youtube_sub, self.course, settings)
REGISTERED_ACCESS_ROLES = {}
serializer = None
clf = MyEstimator(empty=np.nan) clf2 = clone(clf)
auth = self._create_authorization_header(token) return self.csrf_client.get(target_url, params, HTTP_AUTHORIZATION=auth)
clf = ElasticNet() clf.coef_ = [1, 2, 3]
pass
Attribute('mode', 'python'), Attribute('linenumbers', 'true'), Attribute('tabsize', 4, transform=int),
permutation = rng.permutation(self.n) ind_test = permutation[:self.n_test] ind_train = permutation[self.n_test:self.n_test + self.n_train] yield ind_train, ind_test
unit = self.go_to_unit_page() verify_ordering(self, unit, [{"": ["Unit HTML", "Unit Problem"]}])
self._credit_provider_callback(request_uuid, 'approved') self._assert_request_status(request_uuid, "approved")
notification_selector = '.auto_enroll_csv .results .message-%s' % section_type self.wait_for_element_presence(notification_selector, "%s Notification" % section_type.title()) return self.q(css=notification_selector).is_present()
for X in (X_dense, X_sparse_pruned, X_sparse_unpruned):
out = -np.sum(sample_weight * log_logistic(yz)) + .5 * alpha * np.dot(w, w) return out
self.map = {} self.set_call_count = 0 self.timeout_from_last_call = 0
beta = np.array(self.beta0)
'result': {'start_index': 3, 'end_index': 11, 'quote_length': 1}
int2byte = operator.methodcaller("to_bytes", 1, "big")
return self.q(css='.course-run>.value').text
key = RSA.importKey(rsa_priv_key_str) cipher = PKCS1_OAEP.new(key) return cipher.decrypt(data)
username = "test_{uuid}".format(uuid=self.unique_id[0:6]) auto_auth_page = AutoAuthPage(self.browser, username=username).visit() user_id = auto_auth_page.get_user_id() return username, user_id
try: length = len(line.decode('utf-8')) except UnicodeError: pass
"spec", "spec_helpers",
row = self.n_eigen + self.minibatch_index self.Xt[row] = x
choice_id = "1_2_1_choiceinput_{index}bc".format(index=index) choice_value = "choiceinput_{index}".format(index=index) answer_dict[choice_id] = choice_value
super(SplitMongoModuleStore, self).clone_course(source_course_id, dest_course_id, user_id, fields, **kwargs) return new_course
if min_length > 1: params[field] = "a" assert_extra_field_error()
vectorizer = HashingVectorizer(decode_error='ignore', n_features=2 ** 18, non_negative=True)
url(r'get_coupon_codes', 'instructor.views.api.get_coupon_codes', name="get_coupon_codes"),
return []
problem.save() self.assertIn('graceperiod', own_metadata(problem)) self.assertEqual(problem.graceperiod, new_graceperiod)
'ADVANCED_SECURITY': True,
for X in [self.train.X, self.test.X]: assert X.min() == 0.0 assert X.max() == 1.0
self.define_randomized_custom_response_problem(problem_url_name, redefine=True) self.render_problem('u1', problem_url_name) self.check_state('u1', descriptor, 1, 1, 2)
self._test_visible_to_students(False, 'private_no_start', None)
B = safe_sparse_dot(Q.T, M)
item_locs.add( unicode(as_published(Location._from_deprecated_son(item['_id'], course_key.run))) )
return sorted(results, key=lambda course: unicode(course.id))
deadline = self.UPGRADE_DEADLINE if mode == "verified" else None form = self._admin_form(mode, upgrade_deadline=deadline)
self.class_names = [array[0].encode('utf-8') for array in train['class_names'][0]]
X = check_array(X, accept_sparse=['csr', 'csc'])
epoch_num = 6 termination_criterion = EpochCounter(epoch_num)
X_scaled_back = scaler.inverse_transform(X_scaled) assert_array_almost_equal(X_scaled_back, X)
return u'{microsite_key}: {organization}'.format( microsite_key=self.microsite.key, organization=self.organization )
self.q(css='div.problem .choicegroup input[value="' + choice_value + '"]').click() self.wait_for_ajax()
vect = HashingVectorizer(analyzer='char', non_negative=True, binary=True, norm=None, dtype=np.float64) X = vect.transform(test_data) assert_equal(X.dtype, np.float64)
course = self.store.create_course('org_x', 'course_y', 'run_z', self.user_id) signal_handler.send.assert_called_with('course_published', course_key=course.id)
self.update_structure(asset_key.course_key, new_structure)
for B in combinations(features, k): for b in product(*[values[B[j]] for j in range(k)]): mask_b = np.ones(n_samples, dtype=np.bool)
with self.store.default_store(ModuleStoreEnum.Type.split): resp = self.client.get_html('/c4x/InvalidOrg/InvalidCourse/asset/invalid.png') self.assertEqual(resp.status_code, 404)
course = ItemFactory.create( parent_location=self.course.location, category="course", display_name="Test course", )
'staff_access': True, 'ordered_grades': sorted(course.grade_cutoffs.items(), key=lambda i: i[1], reverse=True),
af = AffinityPropagation(preference=-50).fit(X) cluster_centers_indices = af.cluster_centers_indices_ labels = af.labels_
COURSE_ACTION_STATES = (CourseRerunState, )
for leaf in np.where(tree.children_left == TREE_LEAF)[0]: self._update_terminal_region(tree, masked_terminal_regions, leaf, X, y, residual, y_pred[:, k], sample_weight)
expected_status = ( status.HTTP_200_OK if CourseMode.DEFAULT_MODE_SLUG in configured_modes else status.HTTP_400_BAD_REQUEST ) self.assert_enrollment_status( as_server=True, is_active=False, expected_status=expected_status, )
raise ItemNotFoundError(library_id)
with self.assertRaisesRegexp(Exception, "Error in xml"): self.check_group('checkboxtextgroup', 'invalid', 'checkbox')
return self.q(css="div.problem div.problem-hint").html[0].split(' <', 1)[0]
return [self.visible_layer] + self.hidden_layers
labels = spectral_clustering(graph, n_clusters=4, eigen_solver='arpack') label_im = -np.ones(mask.shape) label_im[mask] = labels
update_course_structure(unicode(self.course.id))
student = certificate_invalidation.generated_certificate.user instructor_task.api.generate_certificates_for_students( request, course_key, student_set="specific_student", specific_student_id=student.id )
with super(InlineDiscussionUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
self._validate_estimator()
kernel = C(1.0, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2)) gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)
store = modulestore() with store.default_store('split'): store.clone_course(source_course_key, destination_course_key, user_id, fields=fields)
(['professional'], 'professional'), (['no-id-professional'], 'no-id-professional')
relevant_frames = 0 for frame_record in inspect.stack(): frame = frame_record[0] if '__unittest' in frame.f_globals: break relevant_frames += 1
if not settings.FEATURES.get('ENABLE_EDXNOTES'): filtered_list.append('edxnotes')
self.assertContains(self.client.delete(course_update_url + '19'), "delete", status_code=400)
course_listings = self.dashboard_page.get_course_listings() self.assertEqual(len(course_listings), 1)
VerificationStatus.add_verification_status(checkpoint, self.user, "submitted")
return True
pass
self.check_discussion( tab_list=self.tabs_with_discussion, discussion_link_in_course="other_discussion_link", expected_discussion_link="other_discussion_link", expected_can_display_value=True, )
super(BinomialDeviance, self).__init__(1)
clf = GradientBoostingRegressor(n_estimators=10, random_state=1) clf.fit(boston.data, boston.target)
for _ in range(num_students): random_id = uuid4().hex[:8] self.create_student(username='student{0}'.format(random_id))
self.factory().fit(X, Y, coef_init=np.zeros((3,)))
context = {'payment_support_email': microsite.get_value('payment_support_email', settings.PAYMENT_SUPPORT_EMAIL)} return render_to_response("commerce/checkout_cancel.html", context)
try: validate_email(identifier) except ValidationError: return False return True
self.user = UserFactory.build(username='test', email='test@edx.org') self.user.set_password('test_password') self.user.save()
if user is None: user = self.honor_user request = Request(self.request_factory.get('/')) request.user = user return request
for mode in available_modes: CourseModeFactory.create( course_id=self.course_key, mode_display_name=mode, mode_slug=mode, )
partitions += _other_partitions(verified_partitions, partitions, course_key) course.set_user_partitions_for_scheme(partitions, scheme) modulestore().update_item(course, ModuleStoreEnum.UserID.system)
select_element = page.q(css=selector) self.assertTrue(select_element.is_present()) return [option.text for option in Select(select_element[0]).options]
config.enabled = False config.save() self.assertFalse(VerifiedTrackCohortedCourse.is_verified_track_cohort_enabled(course_key))
print public_key_str print private_key_str
if mail: self.assertEqual(user.email, mail) self.assertEqual(list(User.objects.filter(email=postvars['email'])), [])
return re.split(r'[\s,]+', cstr)
self.course.tabs.append(CourseTab.load("notes")) self.course.advanced_modules = ["notes"]
self.seed = seed rng = make_np_rng(seed, which_method="permutation") self.permut = rng.permutation(index_tab)
np.clip(X, 0, np.finfo(X.dtype).max, out=X) return X
cur_out = self._func(*augmented) rval = [x + y for x, y in safe_zip(rval, cur_out)]
opts = parse_bokchoy_opts(options) opts['test_dir'] = 'performance' run_bokchoy(**opts)
response = self._credit_provider_callback( request_uuid, 'approved', provider_id=other_provider_id, secret_key=other_provider_secret_key, keys={other_provider_id: other_provider_secret_key} )
if not physical_line.rstrip() and line_number == len(lines): return 0, "W391 blank line at end of file"
for tab_list in [[], self.tabs_with_discussion, self.tabs_without_discussion]: self.check_discussion( tab_list=tab_list, expected_discussion_link=not None, expected_can_display_value=False, )
'notification_prefs',
with self.assertNumQueries(0): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
'correct': correct,
self.resid = np.zeros(n, tp) info = 0
X_trans = minmax_scale(X) assert_array_almost_equal(X_trans, X_expected_0_1) X_trans = minmax_scale(X, feature_range=(1, 2)) assert_array_almost_equal(X_trans, X_expected_1_2)
unit_update_url = reverse_usage_url('xblock_handler', unit_usage_key) self.assertFalse(self._is_location_published(unit_usage_key)) self.assertFalse(self._is_location_published(html_usage_key))
return self.q(css='.page-content-secondary .team-members .team-member').present
contact_info = self._latest_history()['contact_info'] for key, value in kwargs.iteritems(): self.assertEqual(contact_info[key], value)
enrollment = CourseEnrollment.objects.get( user=user, course_id=source_key )
with open(self.TEST_INDEX_FILENAME, "w+") as index_file: json.dump({}, index_file) self.addCleanup(remove_file, self.TEST_INDEX_FILENAME)
(True, "en", "lms-footer-edx.css"), (True, "ar", "lms-footer-edx-rtl.css"),
self.coach = AdminFactory.create() role = CourseCcxCoachRole(self.split_course.id) role.add_users(self.coach)
self.assertEqual(context['currency'], 'usd') self.assertEqual(context['currency_symbol'], '$')
from __future__ import unicode_literals
cluster_centers_indices = np.unique(labels) labels = np.searchsorted(cluster_centers_indices, labels)
f = function([X], output, mode="DEBUG_MODE") f(np.zeros((1, 1)).astype(X.dtype))
self._assert_cert_status(self.courses[0].id, self.user, CertificateStatuses.notpassing)
self.check_emails_sent(50, task_history_request)
assert np.all((ps == 0) + (ps == 1)) assert np.all((hs == 0) + (hs == 1))
topics_data = self._serialize_and_paginate( TopicsPagination, topics, request, BulkTeamCountTopicSerializer, {'course_id': course.id}, ) topics_data["sort_order"] = sort_order
assert_equal(X.indptr.shape[0], 7) assert_equal(X.shape[0], 6) assert_equal(X.shape[1], 22)
'course_modes',
pass
w = rng.randn(num_features)
shutil.rmtree(cachedir, ignore_errors=True)
global _local_random
if not settings.FEATURES.get('EMBARGO'): return True
#'django.contrib.auth.middleware.AuthenticationMiddleware', 'cache_toolbox.middleware.CacheBackedAuthenticationMiddleware', 'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
from __future__ import unicode_literals
if rbm.nvis < rbm.nhid: width = rbm.nvis type = 'vis' else: width = rbm.nhid type = 'hid'
data = String(scope=Scope.content, default='')
self.assert_login_response_in_pipeline_looks_correct(student_views.signin_user(strategy.request))
if prewarm == "auto": prewarm = not use_shared_mem forward_reduce_ndarray = ArrayMemmapReducer( max_nbytes, pool_folder, mmap_mode, verbose, prewarm=prewarm) forward_reducers[np.ndarray] = forward_reduce_ndarray forward_reducers[np.memmap] = reduce_memmap
self.train_set.adjust_to_be_viewed_with( self.train_set.X, np.ones(self.train_set.X.shape))
self.payment_and_verification_flow.webcam_capture() self.payment_and_verification_flow.next_verification_step(self.immediate_verification_page)
if perm != 'global': return ACCESS_DENIED return ( ACCESS_GRANTED if GlobalStaff().has_user(user) or SupportStaffRole().has_user(user) else ACCESS_DENIED )
for student in students[5:6]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.deleted, mode='honor' )
SERVICE_VARIANT = os.environ.get('SERVICE_VARIANT', None)
response = self.client.get(reverse('branding.views.courses')) self.assertEqual(response.status_code, 200)
lars_broken = linear_model.LassoLarsIC('<unknown>') assert_raises(ValueError, lars_broken.fit, X, y)
receipt_id = models.CharField( db_index=True, default=generateUUID, max_length=255, )
path = path[len(self.storage.prefix):]
n_samples, self.n_features_ = X.shape is_classification = isinstance(self, ClassifierMixin)
response = self.client.post( self.url, data='Test Invalid data', content_type='application/json', REQUEST_METHOD='DELETE' ) self.assertEqual(response.status_code, 400)
if field.source is None: field.bind(self.field_name, self)
return capa_module
PAYMENT_REPORT_GENERATOR_GROUP = ENV_TOKENS.get('PAYMENT_REPORT_GENERATOR_GROUP', PAYMENT_REPORT_GENERATOR_GROUP)
{'type': unique_tab_type}, {'type': unique_tab_type},
trainer = yaml_parse.load(topo_view_yaml % {'filename': filename}) trainer.main_loop()
mock_sh = patch('pavelib.utils.test.suites.bokchoy_suite.sh') self._mock_sh = mock_sh.start()
time_step = 5 return np.zeros((time_step, batch_size, self.dim), dtype=dtype)
module_path, _, name = engine_path.rpartition('.') return getattr(importlib.import_module(module_path), name)
width = self.ext.config['metacafe_width'][0] height = self.ext.config['metacafe_height'][0] return flash_object(url, width, height)
return "{course}_{run}_{name}".format( course=course.location.course, run=course.url_name, name=name )
mask = img.astype(bool)
response = self.client.get(self.path, **headers) self.assertEqual(response.status_code, 403)
return self.kernel.bounds
fignum = 1
i = 200 while i > 0: module = CapaFactory.create(rerandomize=rerandomize) assert 0 <= module.seed < 1000 i -= 1
metrics = {'ais': estimate_likelihood} datasets = {'mnist': MNIST}
cdn_url = getattr(settings, 'VIDEO_CDN_URL', {}).get(self.system.user_location)
self._add_user_partitions(scheme_id='cohort') actual = GroupConfiguration.get_or_create_content_group(self.store, self.course) expected = self._get_expected_content_group(usage_for_group=[]) self.assertEqual(actual, expected)
for chan_i in xrange(out_shp[-1]): channel = output[..., chan_i] start_idx = defoveate_channel(channel, rings, dense_X, start_idx)
pgettext = real_pgettext
if valid_size < 1.0: valid_size /= 1.0 - np.true_divide(self.n_test, self.n) self.valid_size = valid_size
FEATURES['COURSES_ARE_BROWSEABLE'] = True HOMEPAGE_COURSE_MAX = 9
self.send_response(200, json.dumps(content), {"Content-Type": "application/json"})
epub_title = u'getting_started' epub_author = u'EdX Doc Team' epub_publisher = u'EdX Doc Team' epub_copyright = u'2013, EdX Doc Team'
self.student_id = "99" self.student_name = "testcert" self.student_email = "cert@example.com"
('cancelled', 'cancelled')
X, redirects, index_map = get_adjacency_matrix( redirects_filename, page_links_filename, limit=5000000) names = dict((i, name) for name, i in iteritems(index_map))
root_courselike_dir = self.root_dir + '/' + self.target_dir self.process_extra(root, courselike, root_courselike_dir, xml_centric_courselike_key, export_fs)
attempt_3 = SoftwareSecurePhotoVerification( user=user, created_at=attempt_2.created_at + timedelta(days=1) ) attempt_3.save()
return client.programs.complete.post({'completed_courses': course_certificates})['program_ids']
for logger in loggers: logger.setLevel(logging.NOTSET) logger.removeHandler(import_log_handler)
self.q(css='a.nav-item').filter(text='All Topics')[0].click()
super(ViewsTestCase, self).setUp()
return sum(self.maxpoints.values())
all_assets[asset_idx] = md.to_storable()
enc.fit([[0], [1]]) assert_raises(ValueError, enc.transform, [[0], [-1]])
if course_key is not None and mode_slug in CourseMode.VERIFIED_MODES: verification_models.VerificationDeadline.set_deadline(course_key, verification_deadline)
rows, cols, channels = self.shape self.topo_space = Conv2DSpace(shape=(rows, cols), num_channels=channels, axes=self.axes)
from urllib2 import urlopen
assert key.user_id == self.user.id
inner_module = inner_get_module(location.replace(category="problem", name='choiceprob')) inner_module.attempts = 1 inner_module.save()
return False
try: json.loads(self.configuration) except ValueError: raise ValidationError('Must be valid JSON string.')
set_user_preference(user, key, value) pref = UserPreference.get_value(user, key) self.assertEqual(pref, value)
([[10, 10, 8, 11], [9, 8, 1, 1], [9, 7, 4, 10]], 15 ),
p = np.zeros((y.shape[0], k), dtype=np.float64) for i in range(k): p[:, i] = y == i
for mode in all_modes[course_key]: if mode.min_price > 0 and not CourseMode.is_credit_mode(mode): return mode
headers = {"Content-Type": request.META['CONTENT_TYPE']} result, __ = self.endpoint.validate_request(url, method, body, headers) return result
actual_items = source_store.get_items(dest_course_id, revision=ModuleStoreEnum.RevisionOption.published_only) chapter_is_found = False
PRIVATE_VISIBILITY = 'private'
versions = get_course_versions(unicode(self.course.id)) new_draft_version = versions['draft-branch'] new_published_version = versions['published-branch']
expected_url = _third_party_login_url( backend_name, "login", redirect_url=self.courseware_url ) self.assertContains(response, expected_url)
get_request_dict = {CapaFactory.input_key(): '3.14'} module.check_problem(get_request_dict)
self.store.unpublish(item_location, self.user_id) item = self.store.get_item(item_location) self.assertFalse(self.store.has_published_version(item)) _check_asides(item)
if need_space is not True and not need_space[1]: yield (need_space[0], "E225 missing whitespace around operator") need_space = False
return ( self.q(css='{} .acid-block'.format(self.context_selector)).present and wait_for_xblock_initialization(self, self.context_selector) and self._ajax_finished() )
from urllib.request import urlopen
module.system.render_template = Mock(return_value="<div>Test Template HTML</div>")
continue
_ = lambda text: text
self.basic_setup() self.check_grade_percent(0) self.assertEqual(self.get_grade_summary()['grade'], None)
linear_loss = y - safe_sparse_dot(X, w) if fit_intercept: linear_loss -= intercept abs_linear_loss = np.abs(linear_loss) outliers_mask = abs_linear_loss > epsilon * sigma
for vert in [vertical, private_vertical, public_vertical]: self.assertIn(vert.location, sequential.children)
self.client.login(username=self.instructor.username, password="test") self._assert_certificates_visible(False)
if self._is_in_bulk_operation(course_key, False): self._clear_bulk_ops_record(course_key) self.db_connection.delete_course_index(course_key)
problem = new_loncapa_problem(xml_str)
with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
eligibility = CreditEligibility.objects.get(username=self.USERNAME) eligibility.deadline = datetime.datetime.now(pytz.UTC) + datetime.timedelta(days=29) eligibility.save()
return remote_key.split(u"___", 1)[1]
EmptyPromise( lambda: self.q(css=".current-signature-image .signature-image").present, 'Signature image available' ).fulfill()
request = self.request_factory.get(path) return self.get_context_for_request(request)
get_user_credentials(self.user)
node = object() self.assertEqual(self.call_fut(node), None)
css = '#tab{tab_index} button[data-category={category_type}] span'.format( tab_index=tab_index, category_type=category_type ) return self.q(css=css).html
C = np.dot(A.T, A) C_ = fast_dot(A.T, A) assert_almost_equal(C, C_, decimal=5)
if hasattr(self, "doc"): doc = self.doc else: doc = None
self.store.delete_item(component.location, self.user_id) vertical = self.store.get_item(vertical.location) self.assertTrue(self._has_changes(vertical.location))
self.assertTrue(mock_send.called) __, kwargs = mock_send.call_args_list[0]
cost = SumOfCosts([SumOfOneHalfParamsSquared(), (0., DummyCost())])
CreditCourse.objects.create(course_key=self.course.id, enabled=True)
if form_value: cc_content.flagAbuse(user, cc_content) else: cc_content.unFlagAbuse(user, cc_content, removeAll=False)
if not all_packages: logger.warning("[up] '{0}' is not installed, " "cannot upgrade.".format(this_package)) pass
self.assertEquals(self.get_about_page_link(), "//localhost:8000/courses/mitX/101/test/about")
return self.display_name_with_default
return self._residues
if emit_signals and bulk_ops_record.is_root: self.send_pre_publish_signal(bulk_ops_record, structure_key)
return self.runtime.get_published_on(self)
self.assertTrue(self._is_valid_key(key), msg="Failed for key length {0}".format(length))
indices, indptr, spmat_shape, sptype, outshp, kmap = \ convolution_indices.sparse_eval(imgshp, kshp, nkern, step, mode)
xpath = "//div[@class='indicator-container']/span[@class='status correct']" self.assert_no_xpath(xml, xpath, self.context)
cart = Order.get_cart_for_user(request.user) cart.reset_cart_items_prices() CouponRedemption.remove_coupon_redemption_from_cart(request.user, cart) return HttpResponse('reset')
self.assertEqual(courses_list, courses_list_by_groups)
with self.assertNumQueries(4): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
self.assertIsNone(rewrite_video_url(None, None))
'CERTIFICATES_HTML_VIEW': False,
cv = check_cv(self.cv)
return not self.crosses_boundary()
StudentModuleHistory( id=initial_id, course_key=None, usage_key=None, username="", version="", created=datetime.datetime.now(), ).save()
requested_tab_id_locators = request.json['tabs']
svm = SVC(kernel="precomputed") assert_raises(ValueError, cross_val_score, svm, X, y)
return self.has_access
continue
azimuth_degrees = numpy.arange(0, 341, 20)
course_overview = CourseOverview.get_from_id(course.id)
tasks.environment = MockEnvironment()
self.factory(l1_ratio=1.1)
U = rng.randn(self.dim, self.dim) U, _ = scipy.linalg.qr(U)
self.seed %= MAX_RANDOMIZATION_BINS
CourseInstructorRole(course_key).add_users(new_instructor) auth.add_users(requesting_user, CourseStaffRole(course_key), new_instructor)
pass
resp = self.client.post(reverse('shoppingcart.views.remove_item', args=[]), {'id': reg_item.id})
IDP = 'https://idp.stanford.edu/' REMOTE_USER = 'test_user@stanford.edu'
effective_diff = np.sum((new_centers_csr - old_centers) ** 2) assert_almost_equal(incremental_diff_csr, effective_diff)
cost = SumOfCosts([SumOfParams(), (0., DummyCost())]) model = DummyModel(shapes, lr_scalers=scales) dataset = ArangeDataset(1) momentum = 0.5
clf = MyEstimator(empty=np.array([])) clf2 = clone(clf) assert_array_equal(clf.empty, clf2.empty)
order = np.argsort(categories) categories = categories[order] y = sp.csr_matrix(y[:, order])
updated_overview.version = 11 updated_overview.save()
course = world.CourseFactory.create( org='edx', number='999', display_name='Test Course' )
odds = filter(lambda i: i not in skip_idxs, range(1, len(activations), 2))
pass
try: select = Select(query.first.results[0]) select.select_by_visible_text(value) return True except StaleElementReferenceException: return False
self.client.logout() response = self.client.get( '/verify_student/software-secure-fake-response' ) self.assertEqual(response.status_code, 302)
self.validate(batch)
"download_url": ( cert.download_url or get_certificate_url(cert.user.id, cert.course_id) if cert.status == CertificateStatuses.downloadable else None ),
config_course_cohorts_legacy( course, discussions=[], cohorted=True, auto_cohort_groups=["OtherGroup"] )
self.assertEqual(self.store.has_published_version(item), publish_state)
self._update_staff_locks(True, False, False) self._verify_staff_lock_source(self.vertical, self.chapter)
for user_partition in self.user_partitions: if user_partition.id == self.user_partition_id: return user_partition return None
SplitTestTransformer.collect(block_structure)
self.assertRedirects(resp, settings.LOGIN_REDIRECT_URL + '?next=/home/')
nb = BernoulliNB() nb.fit(X_transformed, y)
wrapper_width = 75 if is_transcript_visible else 100 initial = self.browser.get_window_size()
cached_metadata = self._get_cached_metadata_inheritance_tree(course_id, force_refresh=True) if runtime: runtime.cached_metadata = cached_metadata
self.assert_grade(problem, '2*x', 'correct') self.assert_grade(problem, '3*x', 'incorrect')
ml_cost = (model.free_energy(pos_v).mean() - model.free_energy(neg_v).mean())
(12, True, u"False")
return self.asset_md.setdefault(item, default)
self.assertEqual(response.status_code, 400)
super(SurveyForm, self).save(*args, **kwargs)
return 'Enrollment data is now available in <a href="http://example.com/courses/{}" ' \ 'target="_blank">Example</a>.'.format(unicode(self.course.id))
config.toggle() config.edit() config.add_group() config.save()
return {}
self.assertEquals(preview.latex_preview('sqrt(3)'), r'\sqrt{3}')
xblock, fields = (block, block.fields)
X_train, X_test = X[:n_samples_train], X[n_samples_train:] y_train, y_test = y[:n_samples_train], y[n_samples_train:]
self.assertTrue(self.video.downloaded_transcript_contains_text('srt', '00:00:00,260'))
CONFIG_ROOT = path(os.environ.get('CONFIG_ROOT', ENV_ROOT))
action = models.CharField(max_length=100, db_index=True)
return -self.ebm.free_energy(X) - self.logZ_driver * self.logZ_lr_scale
X = X * self._idf_diag
response = self.client.get( reverse('course_modes_choose', args=[unicode(self.course.id)]), follow=False, )
for i in range(len(group) - 1): connections.append((group[i], group[i + 1]))
author_view = module_attr(AUTHOR_VIEW) has_author_view = True
self.assertIsNone(rewrite_video_url("", ""))
return obj["id"] in self.context["cc_requester"]["upvoted_ids"]
match = uncommented_line_start_index_regex.search(template, line_start_index) if match is None: return None elif match.start() < start_index: return start_index else: return match.start()
return resource_filename(self.module, os.path.join(self.base_dir, name))
self.wait_for_first_certificate_button() self.q(css=self.certficate_css + " .new-button").first.click()
return
for student in students[2:7]: CertificateWhitelistFactory.create(user=student, course_id=self.course.id, whitelist=True)
index = self.problem_list.index(problem_name) + 1 self.q(css='a.problem-button:nth-of-type({})'.format(index)).first.click()
return ApiKeyHeaderPermission().has_permission(request, self)
for i in range(9): i += 13 registration_code_redemption = RegistrationCodeRedemption( registration_code_id=i, redeemed_by=self.instructor ) registration_code_redemption.save()
self.assertFalse(self.video.is_menu_present('download_transcript'))
urlpatterns += ( url(r'^404$', handler404), url(r'^500$', handler500), )
if not trust_root.validateURL(openid_request.return_to): log.error('invalid return_to') return False
return json.loads(self.xmodule.handle_ajax(dispatch, data))
lush_magic = { 507333717: 'uint8', 507333716: 'int32', 507333713: 'float32', 507333715: 'float64' }
assert_array_almost_equal(np.asarray([1.0, 2.0, 3.0]), cw)
if hasattr(self, 'scale_'): del self.scale_ del self.n_samples_seen_ del self.mean_ del self.var_
state_label = _(u"State/Province/Region")
('defunct-cart', 'defunct-cart'),
if sp.issparse(coef): coef.data.flags.writeable = False else: coef.flags.writeable = False return coef
grader_element = etree.SubElement(codeparam_element, "grader_payload") grader_element.text = str(grader_payload)
expressions = self._find_unescaped_expressions(underscore_template) for expression in expressions: if not self._is_safe_unescaped_expression(expression): results.violations.append(ExpressionRuleViolation( Rules.underscore_not_escaped, expression ))
return self.q(css=self._bounded_selector('p.card-description')).map(lambda e: e.text).results
pass
batch0 = slice(0, chunk_size) scaler_batch = MinMaxScaler().fit(X[batch0]) scaler_incr = MinMaxScaler().partial_fit(X[batch0])
self.version_block(parent, user_id, new_structure['_id'])
init_bias = \ init_sigmoid_bias_from_array(bias_from_marginals.X / 2. + 0.5)
'msg': '', 'width': width, 'height': height,
self.notes_page.wait_for_ajax() note = self.notes_page.notes[0] assert_page(note, self.raw_note_list[2]['usage_id'], "Tags")
self._verify_non_staff_cannot_access(cohort_discussion_topics, "GET", [unicode(self.course.id)])
return self.find_css("#due_date").present
try: next_child = current.children.next()
{0: 'animal', 1: 'human', 2: 'airplane', 3: 'truck', 4: 'car', 5: 'blank'},
self._reset() return self.partial_fit(X, y)
response_dict = json.loads(response.read())
self._create_library() self._create_xblock_children(self.library_location, self.children) return self
return wrap_message(result)
xml = etree.tostring(node) block = cls.from_xml(xml, runtime, id_generator) return block
self.navigate_to_video()
lim = max(abs(abs(np.diag(fast_dot(W1, W.T))) - 1)) W = W1 if lim < tol: break
form = self.get_form(expected_valid=True) self.assertDictEqual(form.cleaned_data, expected_cleaned_data)
return self.posterior.sample_from_epsilon(shape)
MODULESTORE = TEST_DATA_SPLIT_MODULESTORE
all_unittests_suite = suites.TestSuite('All Tests', subsuites=[js_suite, python_suite]) all_unittests_suite.run()
request = HttpRequest() request.method = "GET" request.session = session
return 'Page not found (404)' in browser.find_element_by_tag_name('h1').text
message = self.q(css=self._bounded_selector(".input-group-other .copy-error")) if not message: return None return message.results[0].text
graders = { 'points': self.grade_via_points, 'false': self.grade_without_partial_credit }
self._bias_switch = True
m_log_alphas = -np.log10(model.alphas_)
if convnet_available.compiled: _logger.debug('already compiled') return True
class Meta(ConfigurationModel.Meta): app_label = "util"
end_idx = num_assets
mode = CourseModeFactory.create() mode.course_id = self.course.id mode.min_price = min_price mode.mode_slug = mode_slug mode.expiration_date = expiration_date mode.save() return mode
raise ValueError("strftime format ends with raw %")
left_index = np.searchsorted(tree, bin_X & left_mask) right_index = np.searchsorted(tree, bin_X | right_mask, side='right') return left_index, right_index
date = date.strftime('%Y-%m-%d %H:%M')
if location.category in DIRECT_ONLY_CATEGORIES: raise InvalidVersionError(location)
return self._div_for_xblock_id(xblock_id)[0].find_element_by_css_selector( '.header-actions .{action}-button.action-button'.format(action=action) )
self._configure_testshib_provider() super(TestShibIntegrationTest, self).test_login()
try:
est = Ridge(alpha=alpha, fit_intercept=intercept, solver=solver) est.fit(X, y, sample_weight=sample_weight) coefs = est.coef_ inter = est.intercept_
call_command('manage_group', TEST_GROUP) self.check_groups([TEST_GROUP])
assert_raises(ValueError, compute_sample_weight, {1: 2, 2: 1}, y_)
list1.sort() list2.sort() return list1 == list2
'ENABLE_COMBINED_LOGIN_REGISTRATION': False,
action_name = ugettext_noop('generated') task_fn = partial(upload_students_csv, xmodule_instance_args) return run_main_task(entry_id, task_fn, action_name)
log.info( "Refund successfully opened for user [%s], course [%s]: %r", unenrolled_user.id, course_key_str, refund_ids, )
AssetBaseUrlConfig.objects.create(enabled=True, base_url='fakecdn.edx.org') expected_cdn_url = "//fakecdn.edx.org"
try: verification_status = cls.objects.filter(checkpoint__photo_verification=photo_verification).latest() return verification_status.checkpoint.checkpoint_location except cls.DoesNotExist: return ""
return self.q(css='body.view-export').present
assert_equal(X.format, X_checked.format)
self.assertEqual(module.attempts, 1)
self.check_populated_course(course_id)
with self.assertRaises(NotImplementedError): send_refund_notification(self.course_enrollment, [1, 2, 3])
return self.q(css='.wrapper-create-library').visible
if self.optimizer not in self._optimizer_types: raise ValueError("optimizer should be one of %s" % self._optimizer_types)
raise NotImplementedError(str(type(self))+" does not implement setup.")
if predicate: self.assertIn(member, container) else: self.assertNotIn(member, container)
if not files: files = ["`{}`".format(coffeescript_files())] sh(cmd( "node_modules/.bin/coffee", "--compile", *files ))
course_tab_list += _get_dynamic_tabs(course, user) return course_tab_list
children = self.q(css='.note-group') return [EdxNotesTagsGroup(self.browser, child.get_attribute("id")) for child in children]
self.choice = None
selector = self.get_element_selector(CSS_CLASS_NAMES['poster']) self.q(css=selector).click()
pipeline = Pipeline([ ('vect', TfidfVectorizer(min_df=3, max_df=0.95)), ('clf', LinearSVC(C=1000)), ])
compute_inherited_metadata(course_descriptor)
self.client.login(username=self.user.username, password='test')
from openedx.core.djangoapps.credit.api.eligibility import ( is_credit_course, get_credit_requirement_status, )
changed_modules = StudentModule.objects.filter(module_state_key__in=self.ee_modules) self.assertEqual(changed_modules.count(), 0)
self.get_items_call_count += 1 item = self.blocks.get(block_key) if not item: raise ItemNotFoundError return item
return not any(self._value_matches(target, test_val) for test_val in criteria['$nin'])
content = contentstore('trashcan').find(asset_key, throw_on_not_found=False) self.assertIsNotNone(content)
components = self.q(css=".edx-notes-wrapper") return [AnnotatableComponent(self.browser, component.get_attribute("id")) for component in components]
for student in students[:7]: CertificateWhitelistFactory.create(user=student, course_id=self.course.id, whitelist=True)
self.course_info_page.visit() self.tab_nav.go_to_tab('Wiki')
language = language or settings.LANGUAGE_CODE with override_language(language): return get_subject_and_message(subject_template, message_template, param_dict)
with open(filename, 'rb') as matlab_file: matlab_dict = io.loadmat(matlab_file, struct_as_record=True)
import os CMS_SEGMENT_KEY = os.environ.get('SEGMENT_KEY')
self.assertEqual(resp.status_code, 200)
pass
for username in ["", "a"]: params["username"] = username assert_username_error("Username must be minimum of two characters long")
if hasattr(self, 'target_source'): return self.target_source else: return 'targets'
task_type = 'grade_course' task_class = calculate_grades_csv task_input = {} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
faces, target, target_names = load_func( data_folder_path, resize=resize, min_faces_per_person=min_faces_per_person, color=color, slice_=slice_)
root_dir = path(mkdtemp_clean()) export_course_to_xml( self.store, content_store, course_id, root_dir, 'test_no_xml_attributes' )
return edxval_api.get_video_info_for_course_and_profiles(unicode(course_id), video_profile_names)
STATICFILES_STORAGE = 'pipeline.storage.PipelineCachedStorage'
masks = numpy.asarray([subset.sum(axis=0) for subset in data]).squeeze() nz_feats = combine(masks).nonzero()[0]
world.wait_for_ajax_complete()
return self.cleaned_data.get("order_by") or "last_activity_at"
pass
self.problem_page.q( css='div.problem input.ctinput[type="{}"]'.format(self.choice_type) ).nth(input_num).click()
self.advanced_settings.wait_for_modal_load()
Promise(_check_func, "The 'Next Step' button is enabled.").fulfill()
assert config.mode == "DEBUG_MODE" config.mode = orig_mode
return copy.copy(self.rng)
enrolled_students = enrolled_students[offset: offset + MAX_STUDENTS_PER_PAGE_GRADE_BOOK]
X, y = datasets.make_hastie_10_2(n_samples=12000, random_state=1)
self.assertTrue(user_has_role(self.user, CourseCreatorRole()))
self.assertEqual(expected, dtime.strftime(fmt.encode('utf8')).decode('utf8'))
self.fake_payment_page.submit_payment()
X, y = make_classification(n_samples=20, n_features=10, shuffle=False, random_state=0)
module_type = BlockTypeKeyField(max_length=64, db_index=True)
assert_greater(np.abs(stable_var(A) - one_pass_var(A)).max(), tol)
SCORE_CHANGED.send( sender=None, points_possible=event['max_value'], points_earned=event['value'], user_id=user_id, course_id=unicode(course_id), usage_id=unicode(descriptor.location) )
means = np.array([[0, 0, -1], [0, 2, 0], [0, -2, 0], [0, 0, 5]])
self.lcp = self.new_lcp(None)
yield (start, "E128 continuation line " "under-indented for visual indent")
self.position = position
profile_image_names = get_profile_image_names(username) remove_profile_images(profile_image_names)
url = settings.STATIC_URL + settings.DEFAULT_COURSE_ABOUT_IMAGE_URL
super(XBlockAcidBase, self).setUp()
response = self.send_patch(self.client, {field_name: ""}) self.assertIsNone(response.data[field_name])
return self.array
X = np.cast['float32'](train['X'])
self.components_ = self.random_state_.gamma( init_gamma, init_var, (self.n_topics, n_features))
response.data["start"] = (self.page.number - 1) * self.get_page_size(self.request)
self.assertFalse(xb_user.opt_attrs[ATTR_KEY_IS_AUTHENTICATED]) self.assertIsNone(xb_user.full_name) self.assertListEqual(xb_user.emails, [])
unknown = [k for k, w in known.items() if not w] known = dict((k, w) for k, w in known.items() if w)
return sorted(get_editable_fields(obj, self.context))
if root_node is not None: visitor = OuterFormatVisitor(file_contents, results) visitor.visit(root_node) results.prepare_results(file_contents, line_comment_delim=self.LINE_COMMENT_DELIM)
with self.assertRaisesRegexp(CommandError, ".* requires one or more arguments.*"): call_command('reindex_course_team')
estimators = dict((cov_type, GaussianMixture(n_components=n_classes, covariance_type=cov_type, max_iter=20, random_state=0)) for cov_type in ['spherical', 'diag', 'tied', 'full'])
return self.get_static_transcript(request, transcripts)
bin_queries = np.asarray([hasher.transform(X)[:, 0] for hasher in self.hash_functions_]) bin_queries = np.rollaxis(bin_queries, 1)
import numpy as np self.np = np if hasattr(np, 'getbuffer'): self._getbuffer = np.getbuffer else: self._getbuffer = memoryview
self.post_process(root, export_fs)
ransac_estimator.fit(X, y)
pass
index = int(grader.get('id', len(descriptor.raw_grader))) grader = CourseGradingModel.parse_grader(grader)
return u"//{}/{}/{}".format(settings.CMS_BASE, page, unicode(course.id))
est = DummyRegressor(strategy='mean') est.fit(X, y)
self.assertTrue(storage.exists(file_name)) with storage.open(file_name, 'r') as f: self.assertEqual(expected_content, f.read())
language_options = DarkLangConfig.current().released_languages_list if settings.LANGUAGE_CODE not in language_options: language_options.append(settings.LANGUAGE_CODE) return language_options
(27, True, False, u"False"),
EmptyPromise( lambda: indicator == self.indicator_for_field(field_id), "Indicator \"{0}\" is visible.".format(self.indicator_for_field(field_id)) ).fulfill()
raise NotImplementedError("Not used")
assert_raises(ValueError, dbscan, [[0], [1]], sample_weight=[2]) assert_raises(ValueError, dbscan, [[0], [1]], sample_weight=[2, 3, 4])
if self.structure_json: return json.loads(self.structure_json) return None
return False
FEATURES['ENABLE_SERVICE_STATUS'] = True
if not isinstance(course_key, basestring): raise ValueError('course_key must be a string. {} is not acceptable.'.format(type(course_key)))
ENV_TOKENS = convert_tokens(ENV_TOKENS)
iris = load_iris() X = iris.data[:, [0, 2]] y = iris.target X = X[y != 2] y = y[y != 2]
msg = _('Error in evaluating SchematicResponse. The error was: {error_msg}').format(error_msg=err) raise ResponseError(msg)
context = { 'reorderable_items': set(), 'read_only': True } html = get_preview_fragment(request, html, context).content
mappings = mappings or {} self.store = MixedModuleStore( contentstore, create_modulestore_instance=create_modulestore_instance, mappings=mappings, **self.options ) self.addCleanup(self.store.close_all_connections)
VerificationStatus.add_status_from_checkpoints( checkpoints=[self.first_checkpoint, self.second_checkpoint], user=self.user, status=status )
with self.store.bulk_operations(course.id, emit_signals=False):
get_request_dict = {CapaFactory.input_key(): '3.14'} result = module.save_problem(get_request_dict)
if i == 9: return True else: return False
COMPREHENSIVE_THEME_DIR = ""
super(DraftModuleStore, self).clone_course(source_course_id, dest_course_id, user_id, fields)
#html_style = 'default.css' html_theme = 'solar' html_theme_path = ["./themes"]
self._original_iterator = None self._pre_dispatch_amount = 0
tree = self._compute_metadata_inheritance_tree(course_id)
return Date().to_json(datetime_obj)
world.create_user('robot', 'test') user = User.objects.get(username='robot')
plt.figure(1, figsize=(3, 2.2)) plt.imshow(face, cmap=plt.cm.gray, vmin=vmin, vmax=256)
return CourseUserGroup.objects.get( course_id=course_key, group_type=CourseUserGroup.COHORT, id=cohort_id )
n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)
pred = Y_proba > .5 assert_array_equal(pred, Y_pred_sprs.toarray())
city_label = _(u"City")
return getattr(cls.Meta, 'read_only_fields', '') + getattr(cls.Meta, 'explicit_read_only_fields', '')
input_formula = "x + y" self.assert_grade(problem, input_formula, "incorrect")
return (super(StaticTab, cls).validate(tab_dict, raise_error) and key_checker(['name', 'url_slug'])(tab_dict, raise_error))
from __future__ import unicode_literals
del self.map[key]
if 'parent_id' not in data: data["parent_id"] = None
kwargs = {} if cls.grading_policy is not None: kwargs['grading_policy'] = cls.grading_policy cls.course = CourseFactory.create(**kwargs)
cost = None
if len(self.costs) > 1: output = self._get_samples_from_model(model, data)
return create_xblock_info( modulestore().get_item(location), include_child_info=True, include_children_predicate=ALWAYS, course_outline=True )
with mock_create_refund(status=200, response=[1, 2, 3]): self.send_signal() self.assertTrue(mock_send_notification.called) self.assertTrue(mock_log_warning.called)
[self.shape[i] for i in (2, 0, 1)])
cid = cid if cid > 0 else self.ID return reverse_course_url( 'group_configurations_detail_handler', self.course.id, kwargs={'group_configuration_id': cid}, )
pass
assert_almost_equal(loss_interp + 0.5 * (w[-1] ** 2), loss)
sh("i18n_tool transifex push")
self.assertEqual(response.status_code, 302)
self.assertEqual(len(self.certificates_page.certificates), 1)
self.assertTrue(section.release_date) self.assertFalse(section.due_date) self.assertFalse(section.policy)
return wrap_fragment( frag, render_to_string( "edit_unit_link.html", {'frag_content': frag.content, 'edit_link': edit_link} ) )
assert handlers == logger.handlers assert level == logger.getEffectiveLevel()
for label in np.unique(labels): assert_equal(len(np.unique(folds[labels == label])), 1)
def test_barycenter_kneighbors_graph(): X = np.array([[0, 1], [1.01, 1.], [2, 0]])
self.assertTrue(component.has_validation_error) self.assertEqual(component.validation_error_text, self.VALIDATION_ERROR_LABEL) self.assertEqual([self.VALIDATION_ERROR_MESSAGE], component.validation_error_messages)
self.setup_cohorts(self.course)
self._build_data_specs()
cauth = EmbargoedCourse(course_id=course_id, embargoed=True) cauth.save()
expected_info = [ 'created', 'sent_to', 'email', 'number_sent', 'requester', ] return {info: None for info in expected_info}
self.course.start = _LAST_WEEK self.assertTrue(self.course.has_started()) self.course.start = _NEXT_WEEK self.assertFalse(self.course.has_started())
selector_query = self.q(css=self._bounded_selector(self.content_group_selector_css)) return [ option.text for option in get_options(selector_query) if option.text != "Not selected" ]
#epub_show_urls = 'inline'
doc = func.__doc__
return self.source_from(self, **kwargs)
for lang, transcript_url in bumper_settings.get('transcripts', {}).items(): bumper_settings['transcripts'][lang] = transcript_url.replace("/static/", "")
weights_format = ('v', 'h')
return not self == edit_info
return len(self.q(css='section.updates section article').results)
return self.q(css="button[data-url='accomplishments']").visible
self.correct_responses[name] = self.COMPUTED_ANSWER_CORRECT self.incorrect_responses[name] = self.COMPUTED_ANSWER_INCORRECT
yield check_estimators_nan_inf
return BlockUsageLocator(course_key, 'course', course_key.run)
msg = "Wait for status to be {}".format(message) self.wait_for_element_visibility(status_selector, msg)
use_cache = credential_configuration.is_cache_enabled and not user.is_staff cache_key = credential_configuration.CACHE_KEY + '.' + user.username if use_cache else None
dashboard_tracking_code = models.TextField(default="", blank=True)
config.toggle() config.edit() config.groups[2].remove() config.save()
assert_raises_regexp = assert_raises_regex
self.assertEquals(preview.latex_preview('3.1415'), '3.1415')
past_due_date = CapaFactory.create(showanswer='past_due', max_attempts="1", attempts="0", due=self.yesterday_str) self.assertTrue(past_due_date.answer_available())
if expected is None: self.assertEqual(expected, constructed) else: self.assertTrue(constructed.startswith(notes_url))
inner_varname = Word(alphas + "_", alphanums + "_") varname = Group(inner_varname)("variable") varname.setParseAction(self.variable_parse_action)
enable_jquery_animations(page) enable_css_animations(page)
assert isinstance(model.hidden_layers[-1], Softmax) layer_to_clamp[model.hidden_layers[-1]] = True layer_to_pos_samples[model.hidden_layers[-1]] = Y hid = model.hidden_layers[:-1]
W_list = [None] + W_list
mode, is_active = CourseEnrollment.enrollment_mode_for_user(self.user, self.course_key) self.assertTrue(is_active) self.assertEqual(mode, 'verified')
sort_order = 'name' topics = get_alphabetical_topics(course)
modulestore().update_item(self.problem_in_course, self.user.id) self.problem_in_course = modulestore().get_item(self.problem_in_course.location)
response = requests.post(self.launch_uri, data=self.payload) self.assertIn('This is LTI tool. Success.', response.content)
assert_allclose(np.sort(g.weights_), np.sort(rand_data.weights), rtol=0.1, atol=1e-2)
response = self.client.get( "/", HTTP_X_FORWARDED_FOR=request_ip, REMOTE_ADDR=request_ip )
iy,ix = N.array((ky,kx)) - topleft col = iy*inshp[2]+ix +\
self._check_grade_response(callback_url, expected_header, json.dumps(response_content))
transformers = BlockStructureTransformers() if user is not None: transformers += COURSE_BLOCK_ACCESS_TRANSFORMERS + [ProctoredExamTransformer()] transformers += [ BlocksAPITransformer( block_counts, student_view_data, depth, nav_depth ) ]
folds = np.zeros(n_samples) for i, (_, test) in enumerate(lkf.split(X, y, labels)): folds[test] = i
try: latest = cls.objects.filter(course_key=course_key).latest() except cls.DoesNotExist: return False else: return latest.enabled
options = re.sub(r"([a-zA-Z])('|\\')([a-zA-Z])", r"\1&#39;\3", options)
new_data = new_data.reshape((4, 11, -1)) real_data = digits.data[:44].reshape((4, 11, -1))
self.context.update({ 'response_id': self.id,
if new_weight == 1.: self.new_weight.set_value(.01)
exclude_patterns = ['build', 'links.rst']
self.assertOLXIsDraftOnly(block_list_to_revert) with self.assertRaises(InvalidVersionError): self.revert_to_published(block_list_to_revert)
with patch_edxnotes_api_settings("http://example.com"): self.assertEqual("http://example.com/some_path/", get_endpoint_function("some_path/"))
split_test = self._update_partition_id(0)
empty_distribution = grades.answer_distributions(self.course.id)
xblock_info = create_xblock_info(xblock, include_ancestor_info=is_unit_page)
store = self._verify_modulestore_support(location.course_key, 'delete_item') return store.delete_item(location, user_id=user_id, **kwargs)
badge_class = BadgeClass.get_badge_class( slug='new_slug', issuing_component='new_component', description=None, criteria=None, display_name=None, image_file_handle=None, create=False ) self.assertIsNone(badge_class)
if shuffle: X, y = util_shuffle(X, y, random_state=generator)
call_command('force_publish', unicode(self.course.id), '--commit')
error_message=_('Expected a <choice> or <compoundhint> tag; got {given_tag} instead').format( given_tag=choice.tag )
product = self.batch_size * self.num_batches if product > self._dataset_size: return self.batch_size * (self.num_batches - 1) else: return product
XA_checked, XB_checked = check_pairwise_arrays(XA, XB.astype(np.float)) assert_equal(XA_checked.dtype, np.float) assert_equal(XB_checked.dtype, np.float)
X, y = util_shuffle(X, y, random_state=generator)
(True, True), (True, False),
abstract = True
self.prev_floatX = config.floatX config.floatX = 'float64'
final_alpha = 1e-5 low_reg_model = ElasticNet(alpha=final_alpha).fit(X, y)
super(CertificatesDetailHandlerTestCase, self).setUp('contentstore.views.certificates.tracker')
for dirpath, _dirnames, filenames in os.walk(directory): for filename in filenames: yield (filename, dirpath)
Xt = X for name, transform in self.steps[:-1]: Xt = transform.transform(Xt) return self.steps[-1][-1].predict(Xt)
multi_device_support = False
self.cohort_management_page.select_discussion_topic(self.inline_key)
self.assertFalse(self.video.is_error_message_shown)
default_encoded_video = {}
self.user_preference.delete() self.assert_user_setting_event_emitted(setting=self.TEST_KEY, old=self.TEST_VALUE, new=None)
item_list_generator = _generate_items_for_subtask( item_querysets, item_fields, total_num_items, items_per_task, total_num_subtasks, entry.course_id, )
grad[:n_features] += alpha * 2. * w
if self.target_id: assert len(self.xml_module_store.modules) == 1
for prefix in sorted(self._prefix_registry, reverse=True): if key.startswith(prefix): return self._prefix_registry[prefix]
created_enrollments.append(data.create_course_enrollment( self.user.username, unicode(course.id), 'honor', True ))
with self.assertRaises(UnsupportedRevisionError): self.store.get_items( self.course_locations[self.MONGO_COURSEID].course_key, revision=ModuleStoreEnum.RevisionOption.draft_preferred )
r = int(np.sqrt(m)) c = m // r while r * c < m: c += 1 return (r, c)
self.assertEquals(2, len(response_results)) self.assertEquals(True, response_max_exceeded)
only_courses = [self.courses[0].id, self.courses[1].id] self._run_command(self.TEST_ORG, only_courses=only_courses)
store = self._verify_modulestore_support(location.course_key, 'publish') return store.publish(location, user_id, **kwargs)
for xblock in all_blocks: for __, field in xblock.fields.iteritems(): if field.is_set_on(xblock): __ = field.read_from(xblock)
if not cleaned_data.get('all_blocks', None): raise ValidationError({'username': ['This field is required unless all_blocks is requested.']})
return StudentModule.objects.get( student=self.user, course_id=self.course_key, module_state_key=location ).state
secret = secret or self.JWT_SECRET_KEY token = jwt.encode(payload, secret) return token
children = np.array(children)[:, ::-1]
value = dateutil.parser.parse(value)
resp = self.client.get_json( get_url('xblock_view_handler', self.vert_loc, kwargs={'view_name': 'container_preview'}) ) self.assertEqual(resp.status_code, 200)
self.assertEqual(result_dict['value'], "pong")
n_jobs, n_estimators, starts = _partition_estimators(self.n_estimators, self.n_jobs)
else: return provider_respond(server, openid_request, server.handleRequest(openid_request), {})
original_problem = module.lcp
if opts.use_hashing: feature_names = None else: feature_names = vectorizer.get_feature_names()
course_key = CourseKey.from_string(course_id) with modulestore().bulk_operations(course_key): return _progress(request, course_key, student_id)
self.assertEquals(self.draft_store.get_all_asset_metadata(course.id, 'asset'), [])
X = self._validate_for_predict(X) X = self._compute_kernel(X)
self._donate(self.DONATION_AMOUNT, course_id=self.course.id)
self._iter_mode = resolve_iterator_class('sequential') self._iter_topo = False self._iter_targets = False self._iter_data_specs = (self.X_space, 'features')
self.assert_enrollment_status(as_server=True)
return self.q(css='.join-team .join-team-message').present
test_cov = empirical_covariance( X_test - self.location_, assume_centered=True) res = log_likelihood(test_cov, self.get_precision())
return self.enabled and self.enable_studio_authoring
lr = LogisticRegression(C=1., solver='lbfgs')
dtype = np.float64
return self.is_enabled(self.PREVIOUS_PAGE_BUTTON_CSS)
datasetCache = cache.datasetCache filename = datasetCache.cache_file(filename)
if (name not in (MULTIOUTPUT_METRICS + THRESHOLDED_MULTILABEL_METRICS + MULTILABELS_METRICS)): assert_raises(ValueError, metric, y1_row, y2_row)
out += ['.. autosummary::', ''] out += autosum
scaler_batch = StandardScaler(with_std=False).fit(X)
self.assertEqual(len(response['results']), 0)
redirect_url = reverse( 'embargo_blocked_message', kwargs={ 'access_point': access_point, 'message_key': 'default' } ) yield redirect_url
container = self.go_to_nested_container_page() verify_ordering(self, container, expected_ordering)
from .aws import * import os from django.core.exceptions import ImproperlyConfigured
assert_raises(ValueError, lshf.radius_neighbors, X[0])
user_preference = kwargs["instance"] user_preference._old_value = get_changed_fields_dict(user_preference, sender).get("value", None)
call_command('reindex_course_team', self.team1.team_id) mock_index.assert_called_once_with(self.team1) mock_index.reset_mock()
for _ in range(2): utils.get_programs(staff_user)
if not suffix: url = url.rstrip('/')
module = CapaFactory.create() self.assertTrue(module.should_show_check_button())
return textwrap.dedent("\n".join(lines)).split("\n")
doc_topic_distr /= doc_topic_distr.sum(axis=1)[:, np.newaxis] return doc_topic_distr
inner_img = inner_img.reshape(len(output), -1) end_idx = start_idx + inner_img.shape[1] output[:, start_idx: end_idx] = inner_img
block_structure.request_xblock_fields('hide_from_toc')
enrollment_mode = request.GET.get('enrollment_mode', 'honor')
cost = SumOfCosts([SumOfParams(), (0., DummyCost())])
return InheritingFieldData( inheritable_names=InheritanceMixin.fields.keys(), kvs=kvs, )
d = self._decision_function(X) y_pred = self.classes_.take(d.argmax(1)) return y_pred
y_pred = clf.predict(xx)
attempt = SoftwareSecurePhotoVerification.objects.create(user=user)
assert_bad({})
config = BrandingApiConfig(enabled=enabled) config.save()
self.event_collection.drop() self.start_time = datetime.now()
with self.assertNumQueries(1): all_deadlines = VerificationDeadline.deadlines_for_courses(course_keys) self.assertEqual(all_deadlines, {})
this_yaml = test_yaml_which_set % {'which_set': 'train'} trainer = yaml_parse.load(this_yaml) trainer.main_loop()
try: os.makedirs(directory) except OSError as exc: if exc.errno == errno.EEXIST: pass else: raise
config.save()
grad[-1] = n_samples grad[-1] -= n_sw_outliers * epsilon ** 2 grad[-1] -= squared_loss / sigma
call_command('seed_permissions_roles', unicode(cls.course_id))
return self._get_xblocks(".is-inactive ")
if self.child_descriptor is None: return [] return [self.child_descriptor]
'debug': False
if self.q(css=".submission-success").visible: return self.q(css=".submission-success h4").text
_pre_compute = self._pre_compute_svd _errors = self._errors_svd _values = self._values_svd
ENABLED = True
return self.data_specs
upload_file = request.FILES['file'] filename = upload_file.name mime_type = upload_file.content_type size = get_file_size(upload_file)
return "<CourseFixture: org='{org}', number='{number}', run='{run}'>".format(**self._course_dict)
return CourseUserGroup.objects.get( course_id=course_key, group_type=CourseUserGroup.COHORT, name=name )
return len(self.aes) + 1
self.assertEqual(new_version.location, target_location)
with remove_ccx(xblock) as (xblock, restore): return restore(self._modulestore.update_item( xblock, user_id, allow_not_found=allow_not_found, **kwargs ))
self.xmin = xlim[0] self.xmax = xlim[1] self.delta_x = (self.xmax-self.xmin)/float(self.cols-1)
course_id = CourseKeyField(max_length=255, db_index=True)
self.assertRaises( ValidationError, CourseCompleteImageConfiguration(mode='test2', icon=get_image('unbalanced')).full_clean )
input_space = VectorSpace(1) class DummyDBM(object): def __init__(self): self.rng = rng layer.set_dbm(DummyDBM()) layer.set_input_space(input_space)
xml_centric_courselike_key = self.get_key() adapt_references(courselike, xml_centric_courselike_key, export_fs) courselike.add_xml_to_node(root)
path = self.path(name) return FileSystemStorage(path).open(path, mode)
VISIBLE_CONTENT = [ ['class=&#34;problems-wrapper'], ['Some HTML for group 1'] ]
iris = datasets.load_iris() perm = rng.permutation(iris.target.size) iris.data = iris.data[perm] iris.target = iris.target[perm]
context['document_title'] = _("{partner_short_name} {course_number} Certificate | {platform_name}").format( partner_short_name=context['organization_short_name'], course_number=context['course_number'], platform_name=platform_name )
all_assets = SortedAssetList(iterable=course_assets.get(asset_type, []), key=key_func)
from safe_lxml import defuse_xml_libs defuse_xml_libs()
return self.retried_nomax + self.retried_withmax
mailchimp = MailSnake(api_key) result = mailchimp.ping() log.debug(result) return mailchimp
class1_1 = [pr[0, 0] for pr in probas] class2_1 = [pr[0, 1] for pr in probas]
self.check_response('done_0', 'done-unmarked') self.check_response('done_1', 'done-marked')
if credit_service: credit_state = credit_service.get_credit_state(user_id, course_id) if credit_state: context.update({ 'credit_state': credit_state })
for the_input in self.inputs.values(): if hasattr(the_input, 'ungraded_response'): the_input.ungraded_response(xqueue_msg, queuekey)
if isinstance(obj, XBlock): return _has_access_descriptor(user, action, obj, course_key)
model = SelectFromModel(clf, prefit=True) assert_raises(ValueError, model.fit, data, y)
train_with_monitoring_datasets( train_dataset=dataset3, monitoring_datasets=no_monitoring_datasets, model_force_batch_size=False, train_iteration_mode='sequential', monitor_iteration_mode='sequential')
'openedx.core.djangoapps.user_api', 'django_openid_auth',
return self.q(css=self.get_selector(css=css_selector))
clf = svm.OneClassSVM(nu=0.1, kernel="rbf", gamma=0.1) clf.fit(X_train)
target_user = self.get_user(email) target_user.click_delete() self.wait_for_page()
for line in installed_list_file: l=line.rstrip().split(' ') if l: self.installed_packages_list[l[0]]=\ this_package=self.package_info(
with open(dquality_dir / "diff_quality_pep8.html", "w") as f: f.write(_pep8_output(count, violations_list, is_html=True))
self.client.login(username=self.user.username, password="password")
self.navigate_to_video() self.video.show_captions()
),
safe_cookie_data_2 = SafeCookieData.parse(serialized_value) self.assertTrue(safe_cookie_data_2.verify(user_id))
EmptyPromise(options_selected, "Option is selected").fulfill()
LogoutPage(self.browser).visit() StudioAutoAuthPage( self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id, staff=True ).visit()
with ignore_warnings(): estimator = Estimator()
self.assertFalse(self.user.is_active)
self.check_group('radiotextgroup', 'choice', 'radio')
filtered_list = list(cls.FILTERED_LIST)
test_model = CourseMetadata.fetch(self.fullcourse) self.assertIn('giturl', test_model)
train_score = Perceptron().fit(X_kpca, y).score(X_kpca, y) assert_equal(train_score, 1.0)
pass
notes = [] for component in self.components: notes.extend(component.notes) return notes
self.mock_programs_api() self.mock_credentials_api(self.student, data=self.CREDENTIALS_API_RESPONSE, reset_url=False)
return ''.join(self.fed)
chapter = self.store.create_item( self.user_id, test_course.id, 'chapter', block_id='vertical_container' )
W = rng.uniform(-self.irange, self.irange, (input_dim, self.dim * 3))
im = im.convert('RGB')
response = self._generate( course_key=self.EXISTED_COURSE_KEY_2, username=self.STUDENT_USERNAME ) self.assertEqual(response.status_code, 400)
self._original = dict((data, _zero_pad( data.get_topological_view().astype('float32'), self._pad_randomized)) for data in randomize_now)
y_pred = self.init_.predict(X) begin_at_stage = 0
exif_dict = piexif.load(exif) return exif_dict['0th'].get(piexif.ImageIFD.Orientation)
return ((storage_used + storage_need) < (storage_total * max_disk_usage))
super(CourseRerunTest, self).setUp(is_staff=True) self.dashboard_page = DashboardPage(self.browser)
resp = self.client.put(self.exam_url) self.assertEqual(resp.status_code, 405)
add_user_with_status_unrequested(self.admin) self.assertIsNone(get_course_creator_status(self.admin))
assert_extra_field_error()
clf = QuadraticDiscriminantAnalysis(reg_param=0.1) with ignore_warnings(): clf.fit(X5, y5) y_pred5 = clf.predict(X5) assert_array_equal(y_pred5, y5)
if settings.FEATURES.get('ENABLE_READING_FROM_MULTIPLE_HISTORY_TABLES'): history_entries += StudentModuleHistory.objects.prefetch_related('student_module').filter( student_module__in=student_modules ).order_by('-id')
clf = GradientBoostingClassifier(n_estimators=100, random_state=1)
response = self._regenerate(course_key=self.CERT_COURSE_KEY) self.assertEqual(response.status_code, 400)
settings_button = world.browser.find_by_css('.settings-button') if len(settings_button) > 0: world.css_click('.settings-button')
return queryset.order_by('-created')
if hasattr(self, 'vae'): return self.vae else: return None
raise NotImplementedError()
self.wait_for( lambda: self.team_capacity_text == self.format_capacity_text(num_members, max_size), description="Team capacity text is not correct" )
relname = path(pathname).basename()
return '{}_{}'.format(block_type, block_ref)
self.assertFalse(self.creator_admin.has_delete_permission(self.request))
assert_raises(ValueError, precision_recall_fscore_support, y_true, y_pred, pos_label=2, average='macro')
number_part = Word(nums) inner_number = (number_part + Optional("." + Optional(number_part))) | ("." + number_part) inner_number = Combine(inner_number)
xblock = self.store.create_item( self.user_id, test_course.id, 'vertical', block_id='test_vertical' )
course = self._create_course("verified", sku='nonempty-sku') self._enroll(course.id)
return getattr(obj, methodname)(*args, **kwargs)
error_msg = u"Superterrible error happened: ☠" module.lcp.get_html = Mock(side_effect=Exception(error_msg))
self.lc_block.max_count = 50 self.lc_block.refresh_children() result = self.lc_block.validate()
instructor_task = cls( course_id=course_id, task_type=task_type, task_id=task_id, task_key=task_key, task_input=json_task_input, task_state=QUEUING, requester=requester ) instructor_task.save_now()
self.assert_login_response_before_pipeline_looks_correct(self.client.get('/login'))
certificate_template_asset.asset = SimpleUploadedFile('picture1.jpg', 'file contents') certificate_template_asset.save() self.assertEqual(certificate_template_asset.asset, 'certificate_template_assets/1/picture1.jpg')
try: return getattr(self, descriptor.cache_name) except AttributeError: pass
y = np.array([3, 3, -1, -1, 3])
pred_entropies = stats.distributions.entropy( lp_model.label_distributions_.T)
module = CapaFactory.create(rerandomize=rerandomize, done=True)
raise NotImplementedError()
word_cloud = ItemFactory.create(parent_location=parent.location, category="word_cloud", display_name="untitled") del word_cloud.data self.assertEquals(word_cloud.data, '')
cls.clear_caches()
if tab_types: return [{'tab_type': tab_type} for tab_type in tab_types.split(',')] else: return []
try: float(slug) except ValueError: return False return True
django_settings.MIDDLEWARE_CLASSES += _MIDDLEWARE_CLASSES
X = [[1., 2.], [3., 4.]]
response = self.client.get(self.dashboard_url) self.assertContains(response, attempt.expiration_datetime.strftime("%m/%d/%Y"))
self.check_import(root_dir, content_store, course_id)
with no_stdout_stderr(): TheilSenRegressor(verbose=True, random_state=0).fit(X, y) TheilSenRegressor(verbose=True, max_subpopulation=10, random_state=0).fit(X, y)
axis = self.view_converter.axes.index('b') return axis
self.context['debug'] = self.capa_system.DEBUG
if example_range: ex_range = slice(example_range[0], example_range[1]) else: ex_range = slice(None)
least_squares, info = solve_cholesky(L[:n_active, :n_active], sign_active[:n_active], lower=True)
self.assertTrue(self.cohort_management_page.is_save_button_disabled(key))
rho = evals[:, n_components:].sum(1) / evals[:, :n_components].sum(1) eta = np.median(rho)
if isinstance(instance, Invoice): InvoiceHistory.save_invoice_snapshot(instance) elif hasattr(instance, 'invoice'): InvoiceHistory.save_invoice_snapshot(instance.invoice)
layer_to_state = dbm.make_layer_to_state(1) v_state = layer_to_state[v] y_state = layer_to_state[y]
huge = 2 ** (n_bits + 1) clf = DecisionTreeClassifier(splitter='best', max_leaf_nodes=huge) assert_raises(Exception, clf.fit, X, y)
CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] ).install()
VERIFY_STUDENT["SOFTWARE_SECURE"] = { "API_ACCESS_KEY": "BBBBBBBBBBBBBBBBBBBB", "API_SECRET_KEY": "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC", }
create_account(self.USERNAME, self.PASSWORD, self.EMAIL)
i = begin_at_stage for i in range(begin_at_stage, self.n_estimators):
self._track_reverification_events('edx.bi.reverify.started', user.id, course_id, checkpoint.checkpoint_name)
MKTG_URL_LINK_MAP.update(ENV_TOKENS.get('MKTG_URL_LINK_MAP', {}))
calibrated_clf.fit(X_train, y_train) probs_without_sw = calibrated_clf.predict_proba(X_test)
resp = self.client.get(reverse('activate', kwargs={'key': activation_key})) return resp
return {key: val for key, val in self.session.cookies.items()}
split_test = self._update_partition_id(0) self.assertEqual(2, len(split_test.children)) self.assertEqual(initial_group_id_to_child, split_test.group_id_to_child)
X = X[:, np.newaxis]
with DefaultStorage().open(task_input['file_name']) as f: total_assignments = 0 for _line in unicodecsv.DictReader(UniversalNewlineIterator(f)): total_assignments += 1
reports_dir = Env.REPORT_DIR.makedirs_p() clean_dir(reports_dir)
signal_handler = getattr(self, "signal_handler", None) if signal_handler and bulk_ops_record.has_publish_item: signal_handler.send("pre_publish", course_key=course_id)
survey = self._create_test_survey() self.assertIsNotNone(survey) self.assertEquals(unicode(survey), self.test_survey_name)
self._user_info = None
self.assertEqual(response.status_code, 404)
X = np.ones(17) y = [0] * 3 + [1] * 14
self.n_observations = 0 self.minibatch_index = 0
from pylearn2.utils.rng import make_np_rng
block_structure.request_xblock_fields('graded', 'format', 'display_name', 'category')
response = self.client.ajax_post(LIBRARY_REST_URL, data) self.assertEqual(response.status_code, 400)
module = descriptor
return self.q(css='.cohorts-state-section').visible or self.q(css='.new-cohort-form').visible
self.assertContains(response, "<td>Professional</td><td>2</td>")
return self.location.course_key
return self.runtime.service(self, 'library_tools')
L = np.empty((max_features, max_features), dtype=X.dtype)
xWlist = [W.lmul(x,T).flatten(2) for W in self._Wlist] rval = tensor.join(1, *xWlist)
self.submission = "a=1" + self.unique_id[0:5]
token_query = dop_models.AccessToken.objects.select_related('user') return token_query.filter(token=access_token).first()
LMS_SEGMENT_KEY = os.environ.get('SEGMENT_KEY')
page_kwarg = self.kwargs.get(self.paginator.page_query_param) page_query_param = self.request.query_params.get(self.paginator.page_query_param) return page_kwarg or page_query_param or 1
cart = Order.get_cart_for_user(request.user) try: cart_items = cart.find_item_by_course_id(course_registration.course_id)
self.logout() self.login(self.global_staff_user) self.assertTrue(self.enroll(self.course))
n_components, labels = connected_components(connectivity)
config = {} for key, value in settings.MICROSITE_CONFIGURATION.iteritems(): config[key] = value return config
with modulestore().default_store(ModuleStoreEnum.Type.mongo): self.course = CourseFactory.create()
Y = np.vstack((y_diabetes, y_diabetes)).T
self.lcp = self.new_lcp(None) self.set_state_from_lcp()
{key_field: 'fake'}, {key_field: getattr(locator, key_field) + 'X'}, {key_field: 'X' + getattr(locator, key_field)},
BACKEND.clear()
next_cart = Order.get_cart_for_user(user=self.user) self.assertNotEqual(cart, next_cart) self.assertEqual(next_cart.status, 'cart')
link_cohort_to_partition_group( test_cohort, self.user_partition.id, self.groups[0].id, ) add_user_to_cohort(test_cohort, self.student.username) self.assert_student_in_group(self.groups[0])
student_module.save(force_update=True)
return Response(status=400, data=form_errors)
from codecs import lookup, BOM_UTF8 import re from io import TextIOWrapper, open cookie_re = re.compile("coding[:=]\s*([-\w.]+)")
initialize_permissions(new_course.id, user) return new_course
if LOCAL_DEBUG: print msg if output_type == 'html': f.write(msg + '\n<br>\n')
grid_search = GridSearchCV(km, param_grid=dict(n_clusters=[2, 3, 4])) grid_search.fit(X) assert_equal(grid_search.best_params_["n_clusters"], 4)
self.expect = contextualize_text(xml.get('expect') or xml.get('answer'), self.context)
'ENABLE_CONTENT_LIBRARIES': True,
if has_expected: break
tps = np.r_[0, tps] fps = np.r_[0, fps] thresholds = np.r_[thresholds[0] + 1, thresholds]
user = UserFactory.create() self.assert_user_has_object_permission(user, False)
errstring = "Invalid course key." with self.assertRaisesRegexp(CommandError, errstring): call_command('force_publish', 'TestX/TS01')
return True
return { field: course['metadata'][field] for field in CourseSummary.course_info_fields if field in course['metadata'] }
return self.state != 'buffering'
self.create_credentials_config() self.create_programs_config()
data_y = data_y[MNISTPlus.idx[which_set]]
return
pass
self._verify_unit_warning( self.UnitState(is_released=False, publish_state=self.PublishState.PUBLISHED, is_locked=True), self.STAFF_ONLY_WARNING )
clf = DecisionTreeClassifier(max_depth=3) clf.fit(X, y_degraded)
assert_true(X_scaled is not X)
self.navigate_to_video()
problem_location = re.sub(r'[:/]', '_', problem_location) csv_name = 'student_state_from_{}'.format(problem_location) upload_csv_to_report_store(rows, csv_name, course_id, start_date)
self.assertEqual(google_provider.id, google_state.provider.id) self.assertEqual(self.user, google_state.user)
from openedx.core.djangoapps.credit import api, tasks
return self.best_estimator_.predict(X)
return self.q(css=BUTTON_SELECTORS['handout_download']).visible
test_svm.test_dense_liblinear_intercept_handling(svm.LinearSVC)
self.Ut = numpy.zeros([self.n_eigen, self.n_dim])
print_monitor_cv.main(filename, all=True)
url(r'^list_financial_report_downloads$', 'instructor.views.api.list_financial_report_downloads', name="list_financial_report_downloads"),
cipher = aes_cipher_from_key(key) padded_data = pad(data) return cipher.encrypt(padded_data)
text_content_first = email_payload_first[0]._payload[0]._payload self.assertIn( 'credit from Hogwarts School of Witchcraft and Wizardry for', text_content_first )
self.assertEqual(node.tag, 'sequential')
urlpatterns += patterns( 'contentstore.views',
compressed_pickled_data = zlib.compress(pickled_data, 1) tagger.measure('compressed_size', len(compressed_pickled_data))
from edx_proctoring.api import get_all_exams_for_course
self.course_ids = [unicode(e.course_id) for e in enrollments]
return self.prior.sample_from_p_z(num_samples, **kwargs)
pass
if not hasattr(self, 'rng'): self.setup_rng()
from edxval.api import copy_course_videos
return self.find_css(css).first.text[0]
clf = QuadraticDiscriminantAnalysis() with ignore_warnings(): y_pred = clf.fit(X2, y6).predict(X2) assert_true(np.any(y_pred != y6))
if created: manual_cohorts = CourseUserGroup.objects.filter( course_id=course.id, group_type=CourseUserGroup.COHORT ).exclude(name__in=course.auto_cohort_groups) for cohort in manual_cohorts: CourseCohort.create(course_user_group=cohort)
self._mock_ecommerce_courses_api(self.course_key, self.COURSE_API_RESPONSE) response_providers = get_credit_provider_display_names(self.course_key) self.assertListEqual(self.PROVIDERS_LIST, response_providers)
clf.sparsify() assert_array_equal(pred, clf.predict(iris.data)) sp_clf.sparsify() assert_array_equal(pred, sp_clf.predict(iris.data))
im_path = serial.preprocess(im_path) label_path = serial.preprocess(label_path)
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) attempt.mark_ready() attempt.submit() attempt.approve()
self._auto_auth(self.STAFF_USERNAME, self.STAFF_EMAIL, True) self.course_outline.visit() self.course_outline.start_reindex() self.course_outline.wait_for_ajax()
indices = self.get_indices(i) return tuple(len(i) for i in indices)
return len(self.q(css=".forum-nav-thread").results) == thread_count
super(CourseTeamMembership, self).delete(*args, **kwargs) self.team.reset_team_size()
self.assertEqual(new_version.test_content_field, 'default value') self.assertEqual(new_version.test_settings_field, 'default value')
CourseRerunState.objects.succeeded(course_key=self.course_key) self.expected_rerun_state.update({ 'state': CourseRerunUIStateManager.State.SUCCEEDED, }) rerun = self.verify_rerun_state()
from ...search_indexes import CourseTeamIndexer
self._set_opt_in_pref(self.user, self.TEST_ORG, True) self._set_opt_in_pref(self.user, "org_alias", False)
_step.given('I have uploaded subtitles "{}"'.format(sub_id))
lib1 = LibraryFactory.create()
ids = set(ids) return self.db_connection.find_course_blocks_by_id(list(ids))
self.user = UserFactory(is_staff=True) self.client = AjaxEnabledTestClient() self.client.login(username=self.user.username, password='test')
self.assertFalse(hasattr(draft_open_assessment, "xml_attributes"))
return v[::-1], W[:, ::-1]
X, y, X_test, y_test = build_dataset(n_samples=200, n_features=100, n_informative_features=100) max_iter = 150
DELAY = 0.5
y = np.array([[y_i] for y_i in y]) assert min(y) == 0 assert max(y) == 2
self.assertEqual(course_date, expected_course_date)
kwargs.update(kwargs.pop('metadata', {})) default_store_override = kwargs.pop('default_store', None)
response = self.client.get( '/verify_student/software-secure-fake-response' ) self.assertEqual(response.status_code, 404)
for path in [DATA_HOME, LOAD_FILES_ROOT]: _remove_dir(path)
create_collection_index(self.collection, '_id.revision', background=True)
clf.set_params(scale=True) X_score, Y_score = clf.fit_transform(X_s, Y_s) assert_array_almost_equal(X_s_score, X_score) assert_array_almost_equal(Y_s_score, Y_score)
labels = -np.ones(X.shape[0], dtype=np.intp)
return v
return {"course": unicode(normalized_structure_key), "org": normalized_structure_key.org}
wa = CountVectorizer(ngram_range=(1, 2), encoding='ascii').build_analyzer() assert_raises(UnicodeDecodeError, wa, text_bytes)
self._grading_policy['RAW_GRADER'] = value self.grading_policy['GRADER'] = value
EXPECTED_ITEMS = ['Test Problem 1', 'Test Problem 2', 'Test HTML']
response = self._submit_photos(self.course_key, self.reverification_location, self.IMAGE_DATA) self.assertEquals(response.status_code, 400)
assert_false(hasattr(SequenceDescriptor, attribute))
spmatrix = spmatrix.astype(dtype)
algorithm = "full"
pred = np.array([l.argmax() for l in Y_proba]) assert_false((pred - Y_pred).any())
for tab in course.tabs: if tab.type == 'discussion' or tab.type == 'external_discussion': return tab return None
response = self._load_dashboard() self.assertNotContains(response, "credit-eligibility-msg") self.assertNotContains(response, "purchase-credit-btn")
CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] ).install()
super(FakePaymentPage, self).__init__(browser) self._course_id = course_id
course_masquerade = get_course_masquerade(user, course_key) return bool(course_masquerade and course_masquerade.user_name)
self.assert_grade(problem, answer, "correct") self.assert_grade(problem, answer.lower(), "correct")
np.subtract(S, Y[:, None], tmp) tmp[ind, I] = S[ind, I] - Y2
Y = np.dot(D, X)
survey = None exists = SurveyForm.objects.filter(name=name).exists() if exists: survey = SurveyForm.objects.get(name=name) elif throw_if_not_found: raise SurveyFormNotFound() return survey
log.warning( "Could not retrieve information from VAL for Bumper edx Video ID: %s.", video.bumper['edx_video_id'] ) return []
response = self._submit_photos(expected_status_code=400, face_image=self.IMAGE_DATA) self.assertEqual( response.content, "Photo ID image is required if the user does not have an initial verification attempt." )
X_composite = mlp_composite.get_input_space().make_theano_batch() X_first_part = mlp_first_part.get_input_space().make_theano_batch() X_second_part = mlp_second_part.get_input_space().make_theano_batch()
course_mode_info = self._enrollment_with_complete_course(enrollment_mode) self.assertFalse(course_mode_info['show_upsell']) self.assertIsNone(course_mode_info['days_for_upsell'])
return self.pk_with_subclass, set([])
self.assertEquals(self.request.safe_cookie_verified_user_id, self.user.id)
self.delete_item(store, self.html_unit1.location) self.reindex_library(store) response = self.search() self.assertEqual(response["total"], 1)
weight = np.ones(classes.shape[0], dtype=np.float64, order='C')
self.created_by = created_by self.created_by_email = created_by_email self.created_on = created_on or now self.fields = fields or {}
CreditRequirementStatus.remove_requirement_status( username, req_to_remove )
assert_equal(sum(all_folds), 300)
problem = CapaFactory.create() self.assertFalse(problem.answer_available())
self.fake_payment_page.submit_payment()
best_optimal_theta = [] best_optimal_rlf_value = [] best_optimal_par = []
world.browser.driver.execute_script(script, str(text)) world.wait_for_ajax_complete()
TEMPLATE_NAME = None
category = xblock.category if category == 'course': return 'chapter' elif category == 'chapter': return 'sequential' elif category == 'sequential': return 'vertical' return None
for whitelist_country in whitelist: CountryAccessRule.objects.create( rule_type=CountryAccessRule.WHITELIST_RULE, restricted_course=self.restricted_course, country=Country.objects.get(country=whitelist_country) )
block_structure.request_xblock_fields(*cls.FIELDS_TO_COLLECT) cls._collect_max_scores(block_structure)
self.attempt_login(200)
course_object, course_key, error_code, http_status = get_valid_course(course_id, is_ccx) self.check_object_permissions(self.request, course_object) return course_object, course_key, error_code, http_status
section_descriptor = modulestore().get_item(section_key, depth=3)
course_image_asset_key = StaticContent.compute_location(course.id, course.course_image) course_image_content = StaticContent(course_image_asset_key, image_name, 'image/png', image_buff) contentstore().save(course_image_content)
#needs_sphinx = '1.0'
length = arr.size if hasattr(arr, 'size') else len(arr) return np.nan if length == 0 else np.mean(arr, *args, **kwargs)
source_lines = list(islice(source_file_obj, first_line - 1, None))
self.assertEqual(len(httpretty.httpretty.latest_requests), 1)
self.assertEqual(course.edited_by, "testassist@edx.org") self.assertDictEqual(course.grade_cutoffs, {"Pass": 0.45})
TEST_RUNNER = 'openedx.core.djangolib.nose.NoseTestSuiteRunner'
assert isinstance(library_id, LibraryLocator) for library in self.get_courses(**kwargs): if library.location.library_key == library_id: return library return None
#html_split_index = False
sale_dict = dict((feature, getattr(invoice, feature)) for feature in sale_features)
partitions.append({ "id": p.id, "name": p.name, "scheme": p.scheme.name, "groups": groups, })
self.assertEqual(len(response.redirect_chain), 1) self.assertIn(302, response.redirect_chain[0]) self.assertEqual(len(outbox), outbox_count) if send_email:
return True
with self.assertNumQueries(1): with self.assertRaises(ObjectDoesNotExist): api.get_bookmark(user=self.other_user, usage_key=self.vertical_1.location)
return getattr(request, 'is_from_logout', False)
context['company_tos_urltext'] = _("Terms of Service &amp; Honor Code")
assert_equal(v_measure_score(true_labels, labels), 1.0) assert_greater(km.inertia_, 0.0)
resp_data = json.loads(response.content) user_message_url = get_absolute_url(user_message_path) self.assertEqual(resp_data['user_message_url'], user_message_url)
FACEBOOK_API_VERSION = AUTH_TOKENS.get("FACEBOOK_API_VERSION") FACEBOOK_APP_SECRET = AUTH_TOKENS.get("FACEBOOK_APP_SECRET") FACEBOOK_APP_ID = AUTH_TOKENS.get("FACEBOOK_APP_ID")
MOBILE_STORE_URLS = ENV_TOKENS.get('MOBILE_STORE_URLS', MOBILE_STORE_URLS)
nkfd_form = unicodedata.normalize('NFKD', s) return nkfd_form.encode('ASCII', 'ignore').decode('ASCII')
unbalanced_X = iris.data[:125] unbalanced_y = iris.target[:125] sample_weight = compute_sample_weight("balanced", unbalanced_y)
if not np.any(Y_ == i): continue plt.scatter(X[Y_ == i, 0], X[Y_ == i, 1], .8, color=color)
self.wait_for( lambda: "Add a New Cohort" in self.q(css=self._bounded_selector(".form-title")).text, "Create cohort form is visible" )
assert is_flat_specs(data_specs)
model.set_params(warm_start=True) model.fit(X, y) n_iter_warm_start = model.n_iter_ assert_equal(n_iter_warm_start, 1)
pass
world.wait_for_visible('.mce-window')
command = self.command.Command() return command.handle(*args, **kwargs)
FEATURES['EMBARGO'] = True
re.compile(r'^Pages \|'): [ 'js/models/explicit_url', 'coffee/src/views/tabs', 'xmodule', 'coffee/src/main', 'xblock/cms.runtime.v1' ],
return 0
return self.q(css=self.type_filter_element).present
self.client.logout() response = self.client.get(url)
if not hasattr(cls, "_plugins"): plugins = {}
try: exec_fn( code_prolog + LAZY_IMPORTS + code, globals_dict, python_path=python_path, extra_files=extra_files, slug=slug, ) except SafeExecException as e: emsg = e.message else: emsg = None
self.assertTrue(self.video.downloaded_transcript_contains_text('txt', 'Welcome to edX.'))
CMS_SEGMENT_KEY = AUTH_TOKENS.get('SEGMENT_KEY')
serializer_context = { 'request': request, 'block_structure': blocks, 'requested_fields': requested_fields or [], }
self._initialize_mixed(mappings={})
post_login_handler = _finish_auth_url(params) js_success_var = 'var nextUrl = "{}";'.format(post_login_handler) self.assertContains(response, js_success_var)
'limits': { 'CPU': 1, },
raise CommandError( _( 'Invalid group name: "{group_name}". {messages}' ).format( group_name=group_name, messages=exc.messages[0] ) )
pass
if (X.dtype == X_checked.dtype and X.format == X_checked.format): assert_true(X is X_checked)
export_course_to_xml(self.store, content_store, course_id, root_dir, 'test_export')
return msg.strip()
if serialized_block['type'] == 'html': self.assertIn('student_view_multi_device', serialized_block) self.assertTrue(serialized_block['student_view_multi_device'])
response = self.send_get(client, query_parameters='view=shared') self._verify_private_account_response( response, requires_parental_consent=True, account_privacy=PRIVATE_VISIBILITY )
'INDIVIDUAL_DUE_DATES': False,
self.assertEqual(len(encoded_unexpected_from_addr), 318) self.assertEqual(len(escaped_encoded_unexpected_from_addr), 324) self.assertEqual(len(unexpected_from_addr), 137)
THIRD_PARTY_AUTH_BACKENDS = ["google-oauth2", "facebook"] THIRD_PARTY_AUTH_PROVIDERS = ["Google", "Facebook"]
self.notes_page.wait_for_ajax() note = self.notes_page.notes[0] assert_page(note, self.raw_note_list[4]['usage_id'], "Recent Activity")
for mode in ["honor", "verified"]: CourseModeFactory.create(mode_slug=mode, course_id=self.course.id)
return cart.has_items()
self.store.publish(item_location, self.user_id) item = self.store.get_item(item_location) self.assertTrue(self.store.has_published_version(item))
if text_message is None: text_message = html_to_text(html_message)
registration = world.RegistrationFactory(user=user) registration.register(user) registration.activate() CourseEnrollment.enroll(user, course_key)
use = zipped[1:]
if func_code.co_flags & 0x08: index = pos_count + keyword_only_count if func_code.co_flags & 0x04: index += 1
element = self.q(css=".inline-error").first if element and self.is_error_visible: return element.text[0] else: return None
X = np.arange(100).reshape(10, 10) y = np.array([0] * 5 + [1] * 5)
warnings.simplefilter("ignore", RuntimeWarning)
self.fitted = False
clf_weights = svm.SVC() clf_weights.fit(X, y, sample_weight=sample_weight_last_ten)
if fit_intercept: grad[-2] = -2. * np.sum(weighted_non_outliers) / sigma grad[-2] -= 2. * epsilon * np.sum(sw_outliers)
cls.supplemental_index_information(modulestore, structure)
team_list = self.get_teams_list(user=user, expected_status=200, data=course_two_data) self.assertEqual(team_list['count'], 0)
clf = DecisionTreeClassifier(max_depth=3, min_samples_split=2) clf.fit(X, y)
self.wait_for_field(field_id) query = self.q(css='.u-field-{} .u-field-message'.format(field_id)) return query.text[0] if query.present else None
P = noise + X_dense P = theano.tensor.switch(P > 0, 1, 0) P = tensor.cast(P, theano.config.floatX)
staff_access = False errored_courses = {} if has_access(user, 'staff', 'global'): staff_access = True errored_courses = modulestore().get_errored_courses()
if self.instance and self.instance.get("pinned") is None: self.instance["pinned"] = False
task_key = hashlib.md5(task_key_stub).hexdigest()
self.assertIn(self.student_name, self.certificates_section.last_certificate_invalidation.text) self.assertIn(notes, self.certificates_section.last_certificate_invalidation.text)
g.precisions_init = precisions_bad_shape[covar_type] assert_raise_message(ValueError, "The parameter '%s precision' should have " "the shape of" % covar_type, g.fit, X)
HTTPServer.shutdown(self)
return self.event[u'current_tab'] == 1
rng = np.random.RandomState(42)
from __future__ import unicode_literals
return StaticContent.ASSET_URL_RE.match(path_string) is not None
note = self.filter_by_id(self.notes, note_id) if note: index = self.notes.index(note[0]) self.notes.pop(index) return True else: return False
self._test_dropdown_field( u'pref-lang', u'Language', u'English', [u'Dummy Language (Esperanto)', u'English'], reloads_on_save=True, )
h = .02
with transaction.atomic(): (user, profile, registration) = _do_create_account(form, custom_form)
self.assertEqual(params['access_key'], '0123456789012345678901') self.assertEqual(params['profile_id'], 'edx')
is_secure_default = request.is_secure request.is_secure = lambda: False try: yield finally: request.is_secure = is_secure_default
self.request.session[LANGUAGE_SESSION_KEY] = 'en' set_user_preference(self.user, LANGUAGE_KEY, 'eo') self.middleware.process_request(self.request)
centers = [[1, 1], [-1, -1], [1, -1]] X, labels_true = make_blobs(n_samples=300, centers=centers, cluster_std=0.5, random_state=0)
classifier.fit(X_train, Y_train)
ar1 = np.asarray(ar1).ravel() ar2 = np.asarray(ar2).ravel()
y_true = [1, 2, 3, 3] y_pred = [1, 2, 3, 1] y_true_bin = [0, 1, 1] y_pred_bin = [0, 1, 0]
EXPECTED_SECTIONS = { 'Test Section': ['Test Subsection'], 'Test Section 2': ['Test Subsection 2', 'Test Subsection 3'] }
out *= .5 np.tanh(out, out) out += 1 out *= .5
result_map = {} for key in key_list: index = self._get_index_of(key) val = get_codemirror_value(self, index) result_map[key] = val return result_map
node_depth = np.zeros(shape=n_nodes) is_leaves = np.zeros(shape=n_nodes, dtype=bool)
from __future__ import unicode_literals
return self.q(css=self._bounded_selector(self.VALIDATION_SELECTOR)).present
while length != self.batch_size: batch = self._base_iterator.next()
if current_node not in yield_results:
coupon = Coupon(code=code, description='testing code', course_id=course_key, percentage_discount=self.percentage_discount, created_by=self.user, is_active=is_active) coupon.save()
try: response_data = api.baskets.post({ 'products': [{'sku': default_enrollment_mode.sku}], 'checkout': True, })
gsu = model.get_sampling_updates updates, layer_to_chains = gsu(layer_to_chains, self.theano_rng, num_steps=self.num_gibbs_steps, return_layer_to_updated=True)
self.assertTrue(payload.get('success'))
iris = datasets.load_iris() X = iris.data y = iris.target
course_item.tabs = new_tab_list modulestore().update_item(course_item, request.user.id)
if patches.shape[-1] == 1: return patches.reshape((n_patches, p_h, p_w)) else: return patches
p_idx = rng.randint(num_p)
self.validate_xblock_info_consistency(xblock_info, has_child_info=has_child_info)
role = CourseCcxCoachRole(self.course.id) role.add_users(self.coach)
expected = 'You can now <a href="' + reverse('login') + '">login</a>.' self.assertIn(expected, resp.content)
_ = lambda text: text
self._install_course_fixture() self._navigate_to_courseware_video_and_render()
course_listing = self.q(css=".course").filter(lambda el: course_name in el.text).results
self.verify_show_answer_present(True)
total_amount = PaidCourseRegistration.get_total_amount_of_purchased_item(course_key=self.course_key) self.assertEqual(total_amount, 0.00)
leaf_weights = node_weights[node_weights != 0] assert_greater_equal( np.min(leaf_weights), total_weight * est.min_weight_fraction_leaf, "Failed with {0} " "min_weight_fraction_leaf={1}".format( name, est.min_weight_fraction_leaf))
for mode in cls.VERIFIED_MODES: if mode in course_mode_dict: return True return False
X, y_bin = iris.data, iris.target.copy() y_bin[y_bin == 2] = 0
pass
curr_logprob, z = self.score_samples(X)
print(metrics.classification_report(y_test, y_predicted, target_names=dataset.target_names))
E = (np.diag(A) + np.diag(R)) > 0 e[:, it % convergence_iter] = E K = np.sum(E, axis=0)
return self.q(css=".inline-error").visible
try: intercepted_function(raise_error=FakeInputException) except FakeOutputException as ex: self.assertEqual(ex.message, expected_log_msg)
return self.page.q(css=self._bounded_selector(selector))
centerer = KernelCenterer() K_fit_centered = np.dot(X_fit_centered, X_fit_centered.T) K_fit_centered2 = centerer.fit_transform(K_fit) assert_array_almost_equal(K_fit_centered, K_fit_centered2)
input_dict = {'1_2_1': '-999', '1_2_2': '2', '1_2_3': '3'} correct_map = problem.grade_answers(input_dict)
response = external_auth.views.redirect_with_get('root', request.GET)
to_process_non_drafts = super(DraftModuleStore, self)._query_children_for_cache_children(course_key, items)
self.course = CourseFactory.create() self.checkpoint_location = u'i4x://{org}/{course}/edx-reverification-block/first_uuid'.format( org=self.course.id.org, course=self.course.id.course )
self.assertEqual(len(mail.outbox), 1)
add_user_with_status_granted(self.admin, self.user) self.assertEqual('unrequested', get_course_creator_status(self.user))
image_index[0] = min(image_index[0], len(row_indices))
if not (allow_not_found and exception.args[0] == xblock.location): raise
url(r'^api/bookmarks/', include('openedx.core.djangoapps.bookmarks.urls')),
course_key_string = request.query_params.get('course_id', None) if not course_key_string: raise ValidationError('course_id is required.')
if not issubclass(clz, APIView): msg = ( u"{clz} is not a Django Rest Framework APIView subclass." ).format(clz=clz) LOGGER.warning(msg) return clz
'debug_toolbar_mongo',
self.lc_block.source_library_id = "" result = self.lc_block.validate()
self._sample_switch = True
assert_array_almost_equal(my_X, X)
self.wait_for( lambda: self._is_element_visible(".MathJax_SVG"), description="MathJax Preview is rendered" )
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_key_string) get_course_with_access(request.user, 'staff', course_key)
certificate_invalidation.deactivate()
GRADES_DOWNLOAD_ROUTING_KEY = HIGH_MEM_QUEUE
colors = cycle(['navy', 'turquoise', 'darkorange', 'cornflowerblue', 'teal']) lw = 2
X, _, _, _, _ = _preprocess_data(X, y, True, True)
self.define_option_problem(PROBLEM_URL_NAME) self._test_run_with_task(task_class, action_name, 0)
for i in xrange(1, len(self.aes)): assert (self.aes[i].weights.get_value().shape[0] == self.aes[i - 1].nhid)
return {"course": unicode(normalized_structure_key), "org": normalized_structure_key.org}
preferences_api.set_user_preference(user, LANGUAGE_KEY, get_language())
REQUIRE_BASE_URL = "./"
REQUIRED_PARAMETERS = [ 'roles', 'context_id', 'oauth_version', 'oauth_consumer_key', 'oauth_signature', 'oauth_signature_method', 'oauth_timestamp', 'oauth_nonce', 'user_id' ]
xblocks = list(xblock_descriptor.children) for child in xblock_descriptor.children: xblocks.extend(self._get_nested_xblocks(child)) return xblocks
return reverse("get_token", kwargs={ "course_id": unicode(course_id), })
activate_account(activation_key) account = get_account_settings(request) self.assertTrue(account['is_active'])
library = LibraryFactory.create() expected_url = u'/library/{}'.format(unicode(library.location.library_key)) self.assertEqual(xblock_studio_url(library), expected_url)
self.assertEqual(google_provider.id, google_state.provider.id) self.assertEqual(self.user, google_state.user) self.assertEqual(user_social_auth_google.id, google_state.association_id)
return euclidean_distances(X, self.cluster_centers_)
super(DonationTest, self).setUp() self.user = UserFactory.create() self.cart = Order.get_cart_for_user(self.user)
return datetime.now(UTC()) <= self.start
PREVIEW_VIEWS = [STUDENT_VIEW, AUTHOR_VIEW]
try: milestone_paths = get_course_milestones_fulfillment_paths( unicode(course.id), serialize_user(user) ) except InvalidMilestoneRelationshipTypeException: return required_content
assert_almost_equal(s[:k], sap, decimal=3)
element = self.q(css="#content .container-footer .course-license") if element.is_present(): return element.text[0] return None
scalers = [StandardScaler(with_mean=False, with_std=False), MinMaxScaler(), MaxAbsScaler()]
mako_middleware_process_request(self.request) self.request.user = self.user
folders_list_in_path.extend(['data', 'uploads', file_name])
instructor_courses = UserBasedRole(self.user, CourseInstructorRole.ROLE).courses_with_role() staff_courses = UserBasedRole(self.user, CourseStaffRole.ROLE).courses_with_role() all_courses = (instructor_courses | staff_courses)
self.outline.visit()
email_params = get_email_params(course, auto_enroll=True, course_key=ccx_id, display_name=ccx.display_name) enroll_email( course_id=ccx_id, student_email=request.user.email, auto_enroll=True, email_students=True, email_params=email_params, )
pred = grid_search.fit(train_data, target_train).predict(test_data) assert_array_equal(pred, target_test)
if isinstance(precompute, six.string_types) and precompute == 'auto': precompute = (n_samples > n_features)
self.go_to_tab_and_assert_problem(1, self.problem1_name) problem1_content_after_coming_back = self.problem_page.problem_content self.assertEqual(problem1_content_before_switch, problem1_content_after_coming_back)
self.q(css='div.problem button.check').click() self.wait_for_ajax()
key = safe_key(key, '', '')
self._raise_unless_scope_is_allowed(key)
X, y = datasets.make_hastie_10_2(n_samples=12000, random_state=1) _, n_features = X.shape
microsite.clear() domain = request.META.get('HTTP_HOST', None) microsite.set_by_domain(domain) return None
expected_p, expected_h = h1.mf_update( state_below = v.upward_state(v_state), state_above = h2.downward_state(h2_state), layer_above = h2)
self.assertTrue(self.user.roles.filter(name="Student", course_id=self.course_key))
estimators = [DecisionTreeClassifier(max_depth=2), DecisionTreeRegressor(max_depth=2)] sets = [datasets.load_iris(), datasets.load_boston()]
course_key = CourseLocator(org="mockx", course="100", run="2015") return BlockUsageLocator(course_key, block_type='mock_type', block_id="mock_id")
data_y = None if label_type is not None: data_y = data[label_type].reshape(-1, 1)
return self.is_enabled(self.NEXT_PAGE_BUTTON_CSS)
urlpatterns += ( url(r'^survey/', include('survey.urls')), )
axes = ['b', 0, 1, 'c'] random.shuffle(axes) axes = tuple(axes) print('axes:', axes)
return self.runtime.get_published_by(self)
return self._asides
self.store.delete_course(course_id, self.user.id)
world.css_click(css_selector='.chapter', index=1) subsection_css = 'a[href*="Test_Subsection_2/"]'
self.log_dir.makedirs_p() self.har_dir.makedirs_p() self.report_dir.makedirs_p()
version_guids, id_version_map = self.collect_ids_from_matching_indexes(branch, **kwargs) if not version_guids: return for entry in self.find_course_blocks_by_id(version_guids): for course_index in id_version_map[entry['_id']]: yield entry, course_index
return
parent = self.get_a_block(usage_id="parent") parent.inherited = "Changed!" self.assertEqual(parent.inherited, "Changed!")
return self.q(css='#fileupload .error-block').visible
CourseEnrollmentFactory(user=self.student, course_id=self.course.id)
self.wait_for_element_visibility('div.problem section.inputtype div .status', 'wait for status icon')
if 'current_time' in self.event: self.event['currentTime'] = self.event.pop('current_time')
mock_create_subtask_fcn_args = mock_create_subtask_fcn.call_args_list self.assertEqual(len(mock_create_subtask_fcn_args[0][0][0]), 3) self.assertEqual(len(mock_create_subtask_fcn_args[1][0][0]), 3) self.assertEqual(len(mock_create_subtask_fcn_args[2][0][0]), 5)
action_name = ugettext_noop('generating_enrollment_report') task_fn = partial(upload_enrollment_report, xmodule_instance_args) return run_main_task(entry_id, task_fn, action_name)
return _check_range_and_return('lighting', label, -1, 5, -1)
from django.core import mail return mail.outbox
EmptyPromise( lambda: unit.is_browser_on_page(), "loaded page {!r}".format(unit), timeout=30 ).fulfill()
return dict(zip(('request', 'user', 'course_key', 'course_mode', 'amount'), patched_create_order.call_args[0]))
BlockDepthTransformer.collect(block_structure) BlockNavigationTransformer.collect(block_structure) block_structure._collect_requested_xblock_fields()
if this_package in installed_packages_list:
assert library.location.library_key.version_guid is not None return library.location.library_key.version_guid
if root_name == COURSE_ROOT: if courselike_module.entrance_exam_enabled: remove_entrance_exam_milestone_reference(request, courselike_key) log.info( "entrance exam milestone content reference for course %s has been removed", courselike_module.id )
return self.q(css=self.auto_enroll_upload_button_selector).is_present()
return BACKEND.get_value_for_org(org, val_name, default)
self.assertIsNone(self.do_email_change(self.user, user1_new_email)) self.assertIsNone(self.do_email_change(user2, user2_new_email))
course = self.set_up_course(due_date_display_format=u"") text = self.get_text(course) self.assertNotIn("due ", text)
xpath = "//div[@class='block']/p/b" self.assert_has_text(xml, xpath, 'HTML')
el = course_listing[0]
self.q(css='input.save').click() self.wait_for_ajax()
if next_usage.block_type == "course": path = (next_usage, path) return flatten(path) elif parent is None: return None
STUDIO_BASE_URL = os.environ.get('studio_url', 'http://localhost:8031')
return len(self.q(css=self.section_selector))
certificates[0]['is_active'] = False self.store.update_item(self.course, self.user.id)
losses[losses <= 0] = 0 return np.average(losses, weights=sample_weight)
X = check_array(X, copy=False, ensure_2d=False, warn_on_dtype=True, dtype=FLOAT_DTYPES) original_ndim = X.ndim
logout_url = reverse('logout') response = self.client.post(logout_url)
h_mean = self.mean_h_given_v(v) h_mean_shape = (batch_size, self.nhid) h_sample = rng.binomial(size=h_mean_shape, n = 1, p = h_mean, dtype = h_mean.dtype)
super(TFD, self).__init__(X=data_x, y=data_y, y_labels=y_labels, view_converter=view_converter)
return self.rescore_submission_button.is_present()
time.sleep(0.01) continue
if draft_as_non_draft_loc in to_process_dict: to_process_dict[draft_as_non_draft_loc] = draft
if center and scale: data_x -= 127.5 data_x /= 127.5 elif center: data_x -= 127.5 elif scale: data_x /= 255.
self.notes_page.go_to_page(2) self._verify_pagination_info( notes_count_on_current_page=1, header_text='Showing 26-26 out of 26 total', previous_button_enabled=True, next_button_enabled=False, current_page_number=2, total_pages=2 )
CourseEnrollmentFactory.create(user=self.user, course_id=self.course.id, is_active=True)
response = self._get_reverify_page() self.assertContains(response, "reverify-blocked")
send_user_notification = Signal(providing_args=["user", "state"])
g = GaussianMixture(n_components=n_components, n_init=1, max_iter=5, reg_covar=0, random_state=random_state, warm_start=False, tol=1e-6) h = GaussianMixture(n_components=n_components, n_init=1, max_iter=5, reg_covar=0, random_state=random_state, warm_start=True, tol=1e-6)
self.assertEqual(item.name, old_name) item.change_name(new_name) self.assertFalse(item.in_editable_form()) self.assertEqual(item.name, expected_name)
return self.status_message == 'Contains staff only content' if self.has_status_message else False
ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3, color=c) ax.plot([1], [1], [1], color=c, label=label)
mid = int(numpy.floor(kernel_shape / 2.)) centered_X = X - convout[:, mid:-mid, mid:-mid, :]
clf.intercept_scaling = 1000 clf.fit(X, y) intercept2 = clf.intercept_ assert_array_almost_equal(intercept1, intercept2, decimal=2)
votes = np.round(ovo_decision) normalized_confidences = ovo_decision - votes
LogoutPage(self.browser).visit() AutoAuthPage(self.browser, username=username, email=email, staff=staff).visit()
answers = List(help="Poll answers from xml", scope=Scope.content, default=[])
msg = 'no signature found for builtin function {0!r}'.format(obj) raise ValueError(msg)
ItemFactory.create( parent=parent, category='discussion', display_name='released', start=self.now, )
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=random_state)
patcher = patch.object(api, 'api_enabled', Mock(return_value=True)) patcher.start() self.addCleanup(patcher.stop)
Y_neg = Y.copy() Y_neg[0, 0] = -1 assert_raises(ValueError, transform.transform, Y_neg)
initializable_fields = updatable_fields + ['thread_type', 'context']
def _mean_shift_single_seed(my_mean, X, nbrs, max_iter): bandwidth = nbrs.get_params()['radius']
def test_patch_unsupported_media_type(self): response = self.client.patch( self.url, json.dumps({}), content_type=self.unsupported_media_type ) self.assertEqual(response.status_code, 415)
return self._cohort_count( self._get_cohort_options().filter(lambda el: el.is_selected()).first.text[0] )
estimator.fit(X, y)
from __future__ import unicode_literals
course = self.store.get_course(course_id) self.assertGreater(len(course.textbooks), 0)
self.assertFalse(self._search_for_content(self.SEARCH_STRING))
_change_access(course, user, level, 'revoke', send_email)
self.expect_error_on_file_content( 'cohort\n', "The file must contain a 'username' column, an 'email' column, or both." )
self.course_outline_page.visit() self.assertEquals(self.course_outline_page.expand_collapse_link_state, ExpandCollapseLinkState.COLLAPSE) self.verify_all_sections(collapsed=False)
language = request.GET.get('language', translation.get_language())
input_dict = {'1_2_1': '0', '1_2_2': '0'} correct_map = problem.grade_answers(input_dict)
microsite.enable_microsites(log)
role, created = Role.objects.get_or_create(name=name, course_id=course_key) if created is False: role.course_id = course_key role.save() return role
module = CapaFactory.create(attempts=1)
@ignore_warnings(category=DeprecationWarning) def test_verbose_second_level(): X = rng.randn(30, 5) X[:10] += 2 g = mixture.GMM(n_components=2, n_init=2, verbose=2)
in_cart = False reg_then_add_to_cart_link = ""
with self.assertRaises(SpecificStudentIdMissingError): generate_certificates_for_students( self.create_task_request(self.instructor), self.course.id, student_set='specific_student', specific_student_id=None )
for student in students[2:5]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.error, mode='honor' )
self._mock_paver_needs = patch.object(pavelib.js_test.test_js, 'needs').start() self._mock_paver_needs.return_value = 0
lib_key_pacific = self._create_library(org="PacificX", library="libP") lib_key_atlantic = self._create_library(org="AtlanticX", library="libA")
module = CapaFactory.create(attempts=0, done=True)
c1 = TT.as_tensor_variable(c1) c2 = TT.as_tensor_variable(c2) maxiter = n_iters
ax1.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))
X1, y1 = load_svmlight_file(datafile)
mock_threads.return_value = CommentClientPaginatedResult(collection=[], page=1, num_pages=1)
draft_preferred = 'rev-opt-draft-preferred'
call_command("loaddata", "course_email_template.json")
else: self.generic_visit(node)
SignatureValidator.verify = MagicMock(return_value=True) self.consumer = models.LtiConsumer( consumer_name='consumer', consumer_key=LTI_DEFAULT_PARAMS['oauth_consumer_key'], consumer_secret='secret' ) self.consumer.save()
self.assertFalse(element_has_text( page=course_outline_page, css_selector='.add-item a.button-new', text='New Subsection' ))
if lang == 'en': return u'subs_{0}.srt.sjson'.format(subs_id) else: return u'{0}_subs_{1}.srt.sjson'.format(lang, subs_id)
assert max(pd.max(), hd.max()) < .17
with self.store.bulk_operations(dest_id): source_courselike, courselike, data_path = self.get_courselike(courselike_key, runtime, dest_id)
extract_dir_relative = path.relpath(extract_dir, settings.DATA_DIR)
return ['Test Section {}'.format(index), 'Test Subsection {}'.format(index), 'Test Problem {}'.format(index)]
n_samples_sizes = [5, 10, 20] n_features = 3 rng = np.random.RandomState(42)
this_labels = np.unique(this_labels, return_index=True)[1][this_labels] np.testing.assert_array_equal(this_labels, labels)
self.assertContains(resp, "Home") self.assertContains(resp, "Course")
for entry in toc: if entry['url_name'] == url_name: return entry return None
CertificateGenerationConfiguration(enabled=True).save()
self.assertTrue(allowance_section.is_add_allowance_button_visible)
resp = self._login(email, password) data = parse_json(resp) self.assertTrue(data['success']) return resp
AUTH_BASE_URL = os.environ.get('test_url', 'http://localhost:8031')
return self.q(css='.page-header .page-title')[0].text
self.wait_for_element_visibility( self._bounded_selector(self.ADDER_SELECTOR), "Adder is visible." )
non_editable_fields.extend([LibraryContentFields.mode, LibraryContentFields.source_library_version]) return non_editable_fields
resp = json.loads(self.call_event('export_resources', {}).content)
raise NotImplementedError
rerun_state = CourseRerunState.objects.update_state( course_key=rerun_course_key, new_state=state, allow_not_found=True ) CourseRerunState.objects.update_should_display( entry_id=rerun_state.id, user=user2, should_display=should_display )
self.user = user
username = self.cleaned_data.get('username') return username or ''
X, y = datasets.make_hastie_10_2(n_samples=100, random_state=1) for Cls in [GradientBoostingRegressor, GradientBoostingClassifier]: est = Cls(n_estimators=100, max_depth=1) est.fit(X, y)
X_transformed = Nystroem(n_components=X.shape[0]).fit_transform(X) K = rbf_kernel(X) assert_array_almost_equal(np.dot(X_transformed, X_transformed.T), K)
#latex_font_size = '10pt'
_write_metric(metrics_str, metrics_report) sh("cat {metrics_report}".format(metrics_report=metrics_report), ignore_error=True)
return self.q(css=self.get_selector(css=css_selector))
self.q(css=self._bounded_selector(self.TAG_SELECTOR)).filter(lambda el: tag_name in el.text).click()
n_samples_per_fold = np.zeros(self.n_folds)
if not has_course_author_access(request.user, item.location.course_key): raise PermissionDenied()
for mode_slug in course_modes: CourseModeFactory.create( course_id=self.course.id, mode_slug=mode_slug, mode_display_name=mode_slug, )
parent = self.get_a_block(usage_id="parent") parent.not_inherited = "Changed!" self.assertEqual(parent.not_inherited, "Changed!")
ROOT_EXTRA_FIELDS = 'root_extra_fields'
self.code_book_ = random_state.random_sample((n_classes, code_size_)) self.code_book_[self.code_book_ > 0.5] = 1
cm = confusion_matrix(y_true, y_pred) assert_array_equal(cm, [[19, 4, 1], [4, 3, 24], [0, 2, 18]])
group_a_item_1_delete_index = 1 self.delete_and_verify(group_a_item_1_delete_index, expected_ordering)
select_option_by_value(self.settings_page.pre_requisite_course_options, self.pre_requisite_course_id) self.settings_page.save_changes()
self.q(css=self._bounded_selector(".annotator-delete")).first.click() self.wait_for_notes_invisibility("Note is removed.") self.wait_for_ajax() return self
indexed_count = cls.index(modulestore, structure_key) if indexed_count: cls._track_index_request(cls.INDEX_EVENT['name'], cls.INDEX_EVENT['category'], indexed_count) return indexed_count
assert_less_equal(call_count, maximum_calls)
if text == "There was a problem with the staff answer to this problem.": text = "TRANSLATED!" return text
graders = { 'edc': self.grade_via_every_decision_counts, 'halves': self.grade_via_halves, 'false': self.grade_without_partial_credit }
self.q(css='.form-create.create-user .user-email-input').fill(email)
self._mock_ecommerce_courses_api(self.course_key, self.COURSE_API_RESPONSE) CreditProvider.objects.all().update(active=False) self.assertEqual(get_credit_provider_display_names(self.course_key), [])
X, Y = make_blobs(n_samples=50, centers=2, random_state=0, cluster_std=0.60)
return
draft, split = range(2)
'cms.lib.xblock.tagging',
field_errors = {}
if tolerates is None: return cls.default() else: return tolerates
return self._decision_function(X)
library_fixture.add_children( XBlockFixtureDesc("html", "Html1"), XBlockFixtureDesc("html", "Html2"), XBlockFixtureDesc("html", "Html3"), )
if last_touch: time_since_last_activity = utc_now - last_touch
log.warning('Unable to find group named %s for Zendesk ticket with ID %s.', group_name, ticket_id)
n_samples, n_features = X.shape _, n_targets = y.shape
if self._is_training_data(X): return 2. - float(self.train_sizes) / self.n_max_train_sizes else: return float(self.train_sizes) / self.n_max_train_sizes
return self.profile_image_uploaded_at is not None
pass
analytics_patcher = patch('lms.djangoapps.verify_student.views.analytics') self.mock_tracker = analytics_patcher.start() self.addCleanup(analytics_patcher.stop)
assert_false(hasattr(MLPClassifier(algorithm='l-bfgs'), 'partial_fit'))
for name in SYMMETRIC_METRICS: metric = ALL_METRICS[name] assert_almost_equal(metric(y_true, y_pred), metric(y_pred, y_true), err_msg="%s is not symmetric" % name)
self._disallow_censor_updates()
K_test = np.dot(X_[180:], X_[:180].T) y_test = y_[180:]
return self
return six.next(six.iterkeys(obj))
STATICFILES_STORAGE = 'pipeline.storage.NonPackagingPipelineStorage'
return (arg.dtype is not None and str(arg.dtype).startswith('complex'))
Donation.add_to_order(cart, amount, course_id=course_id)
if photo_id_image is not None: initial_verification = None
'post_params_success': post_params_success,
if self.due is None: return False return datetime.now(UTC()) > self.due
self.signal_handler.send("course_published", course_key=course_key.for_branch(None))
mode = CourseMode(mode_slug=slug) self.assertEqual(self.course.get_mode_display_name(mode), expected_display_name)
return " ".join([self.MODAL_SELECTOR, selector])
pass
assert max(pd.max(), hd.max()) < .17
assert_warns(RuntimeWarning, mb_k_means.fit, X)
staff = set(CourseStaffRole(course_key).users_with_role()).union(instructors)
PARENTAL_CONSENT_AGE_LIMIT = 13
success = False num_attempts = 0 while (not success) and num_attempts < MAX_VALID_BROWSER_ATTEMPTS:
clf = ForestClassifier(class_weight=1, random_state=0) assert_raises(ValueError, clf.fit, X, _y)
return ups
if name == 'ROOT': return settings.MKTG_URLS.get('ROOT') return settings.MKTG_URLS.get('ROOT') + settings.MKTG_URLS.get(name)
survey.save_user_answers(self.student, self.student_answers_update, self.course_id)
return reverse_func(view_name, args=[unicode(course.id), index])
registration_code_redemption = RegistrationCodeRedemption.registration_code_used_for_enrollment( course_enrollment) paid_course_reg_item = PaidCourseRegistration.get_course_item_for_user_enrollment( user=user, course_id=course_id, course_enrollment=course_enrollment )
classifier = svm.SVC(kernel='linear', C=0.01) y_pred = classifier.fit(X_train, y_train).predict(X_test)
with self.assertRaises(Http404): self.get_form(expected_valid=False)
for key in locations: self.assertFalse(self._has_changes(locations[key]))
'edxmako', 'pipeline', 'static_replace', 'require',
REQUIREMENTS_DISPLAY_MODES = CourseMode.CREDIT_MODES + [CourseMode.VERIFIED]
FEATURES['LICENSING'] = True
self.profile.meta = {u'foo': u'bar'} self.profile.save() self.assert_no_events_were_emitted()
self.assert_no_xss(response, xss_content)
self.assertTrue(self.video.select_language('zh'))
unicode_text = "好 各位同学".decode('utf-8') self.assertIn(unicode_text, self.video.captions_text)
assert self.prefix is not None return "-".join((self.prefix, ) + tuple(getattr(self, field) for field in self.KEY_FIELDS))
self._create_test_survey() with self.assertRaises(SurveyFormNameAlreadyExists): self._create_test_survey()
if self.mode != mode and mode is not None: self.mode = mode mode_changed = True
X, y = _boston_subset()
config.delete() self.assertEqual(len(self.page.experiment_group_configurations), 0)
self.verify_pdf_certificate()
y += 0.01 * np.random.normal((n_samples,))
self.client.logout() response = self.client.get(self.path, content_type=JSON_CONTENT_TYPE) self.assertEqual(response.status_code, 401)
predictions = cross_val_predict(clf, X_sparse, multioutput_y) assert_equal(predictions.shape, (150, 2))
t_start = datetime.now() sampling(n_population, n_samples) delta = (datetime.now() - t_start) time = compute_time(t_start, delta) return time
monitoring_dataset = DenseDesignMatrix(X=X)
train = TFD(which_set='train') topo = train.get_batch_topo(1) assert topo.ndim == 4
from __future__ import unicode_literals
T = column_or_1d(T) return 1. / (1. + np.exp(self.a_ * T + self.b_))
X = csc_matrix(iris.data, dtype=dtype) y = iris.target assert_array_equal(est.fit(X, y).predict(X), y)
return ( 'split_test' in ADVANCED_COMPONENT_TYPES and 'split_test' in course.advanced_modules )
X2 = rng.randint(5, size=(6, 100)) y2 = np.array([1, 1, 2, 2, 3, 3])
raise NotImplementedError
if len(self.estimators_) > 1: self.estimators_.pop(-1) return None, None, None
with self._mock_geoip('US'): result = embargo_api.check_course_access(self.course.id, user=self.user, ip_address='0.0.0.0')
if n_useless > 0: X[:, -n_useless:] = generator.randn(n_samples, n_useless)
clf = PassiveAggressiveClassifier().fit(X, y) assert_array_equal(clf.classes_, np.unique(y))
self.assertEquals( response_data["content"], strip_none(make_mock_thread_data(course=self.course, text=text, thread_id=thread_id, num_children=1)) ) mock_request.assert_called_with( "get",
SOCIAL_SHARING_SETTINGS = ENV_TOKENS.get('SOCIAL_SHARING_SETTINGS', SOCIAL_SHARING_SETTINGS)
for c in range(1, n_clusters): rand_vals = random_state.random_sample(n_local_trials) * current_pot candidate_ids = np.searchsorted(closest_dist_sq.cumsum(), rand_vals)
export_course_to_xml( self.store, self.contentstore, self.course.id, self.root_export_dir, self.export_dir, )
element = self.q(css='.setting-replace')[0] ActionChains(self.browser).move_to_element(element).click(element).perform()
'ADDITIONAL_OPTIONS': { 'trashcan': { 'bucket': 'trash_fs' } }
response = self.client.put(self.path, json.dumps(expected), content_type=JSON_CONTENT_TYPE)
return cls.read_data_file('{}.pub'.format(key_name))
COUNTRIES_OVERRIDE = { "TW": "Taiwan", 'XK': _('Kosovo'), }
for module in cls._iter_scorable_xmodules(block_structure): cls._collect_max_score(block_structure, module)
verification_statuses = cache_values.get(verification_status_cache_key) if verification_statuses is None: verification_statuses = VerificationStatus.get_all_checkpoints(user.id, course_key) cache.set(verification_status_cache_key, verification_statuses)
profile_page.visit()
try: result = super(StringOrDate, self).to_json(value) except: return value if result is None: return value else: return result
click_css(page, component_css, 0)
self.video.click_player_button('play') self.video.wait_for_position('0:03') self.video.click_player_button('pause')
raise ValueError("Cannot use a custom kernel function. " "Precompute the kernel matrix instead.")
URLCONF_MODULES = ['myapp.url']
CREDIT_NOTIFICATION_CACHE_TIMEOUT = 5 * 60 * 60
return _('TBD')
K_gradient = np.empty((X.shape[0], X.shape[0], 0)) return K, K_gradient
users_state_before_fail = self._get_users_state()
for name, scorer in SCORERS.items(): repr(scorer)
staff = UserFactory.create(password="test") role = CourseStaffRole(self.course.id) role.add_users(staff) return staff
clf = QuadraticDiscriminantAnalysis().fit(X6, y6) assert_true(not hasattr(clf, 'covariances_'))
self.find_css('button.action-add-group').first.click()
return any( access_role.role == role and access_role.course_id == course_id and access_role.org == org for access_role in self._roles )
self.set_call_count += 1 self.map[key] = val self.timeout_from_last_call = timeout
if not iboost == self.n_estimators - 1: sample_weight *= np.exp(estimator_weight * incorrect * ((sample_weight > 0) | (estimator_weight < 0)))
for i in range(0, 4): np.testing.assert_allclose(fl.get_params()[i].eval(), mlp_composite.get_params()[i].eval())
return { cls.STRING_PAYLOAD, cls.ROOT_EXTRA_FIELDS, cls.CONTEXT_EXTRA_FIELDS, }
return self.course.id.make_usage_key('problem', problem_url_name)
y = np.zeros((10, 3)) y[5:, 0] = 1 y[:, 1] = 1 y[:, 2] = 1
self.assert_enrollment_status( as_server=True, mode=None, is_active='foo', expected_status=status.HTTP_400_BAD_REQUEST )
self.affinity_matrix_ = 0.5 * (self.affinity_matrix_ + self.affinity_matrix_.T) return self.affinity_matrix_
self.assert_request_status_code(302, reverse('logout'))
if not whitelist_countries: whitelist_countries = cls.ALL_COUNTRIES
assert_greater(len(estimators), 0)
if not user_must_complete_entrance_exam(request, user, course): required_content = [content for content in required_content if not content == course.entrance_exam_id]
self.assertFalse('<h2>Enrollment Information</h2>' in response.content)
if status is not None: days_until_deadline = None
content_location = StaticContent.compute_location( location.course_key, asset_name ) try: contentstore().find(content_location) except NotFoundError: return False else: return True
est = DummyRegressor(strategy="median") est.fit(X_learn, y_learn) y_pred_learn = est.predict(X_learn) y_pred_test = est.predict(X_test)
response = self.client.get(reverse('sysadmin_courses')) self.assertNotRegexpMatches(response.content, table_re)
init = getattr(estimator.__init__, 'deprecated_original', estimator.__init__)
alternate_course = self.create_course( org=md5(self.course.org).hexdigest() )
cohort = cohorts.get_cohort_by_id(course_key, int(cohort_id))
self.course_outline_page.visit() self.course_outline_page.wait_for_page()
keys, values_lists = zip(*sorted(sub_grid.items())[::-1]) sizes = [len(v_list) for v_list in values_lists] total = np.product(sizes)
partitions = self._get_partition_info() self.assertEqual(len(partitions), 1) self.assertEqual(partitions[0]["scheme"], "cohort")
SEARCH_ENGINE = "search.tests.mock_search_engine.MockSearchEngine"
instructor = self.make_instructor() self.assertTrue(CourseInstructorRole(self.course.id).has_user(instructor))
gp = GaussianProcess(corr='absolute_exponential', theta0=1e-4, thetaL=1e-12, thetaU=1e-2, nugget=1e-2, optimizer='Welch', regr="linear", random_state=0)
response = self._regenerate( course_key=self.CERT_COURSE_KEY, username=self.STUDENT_USERNAME ) self.assertEqual(response.status_code, 400)
response['X-XRDS-Location'] = get_xrds_url('identity', request) return response
get_parents=None, get_children=get_children, filter_func=filter_func,
pass
self.assertInCourseListing(existent_course_key)
iris = datasets.load_iris() y_true, y_pred, _ = make_prediction(dataset=iris, binary=False)
one_class = np.array([0, 0, 0, 0]) lb = LabelBinarizer().fit(one_class)
raise NotImplementedError()
#html_sidebars = {}
EDXNOTES_PUBLIC_API = 'http://localhost:8120/api/v1' EDXNOTES_INTERNAL_API = 'http://localhost:8120/api/v1'
CELERYD_PREFETCH_MULTIPLIER = 1
del DEFAULT_FILE_STORAGE MEDIA_ROOT = "/edx/var/edxapp/uploads"
self.page = LibraryUsersPage(self.browser, self.library_key) self.page.visit()
for field_name in self.EXTRA_FIELDS: if self._is_field_visible(field_name): self.field_handlers[field_name]( form_desc, required=self._is_field_required(field_name) )
self.assertEqual(result['success'], 'incorrect')
if "TRACKING_IGNORE_URL_PATTERNS" in ENV_TOKENS: TRACKING_IGNORE_URL_PATTERNS = ENV_TOKENS.get("TRACKING_IGNORE_URL_PATTERNS")
return self.find_css(css).first.text[0]
parameters = {'alpha': alphas} fit_params = {'sample_weight': sample_weight} gs = GridSearchCV(Ridge(), parameters, fit_params=fit_params, cv=cv) gs.fit(X, y)
return {'xqueue_callback_url_prefix': 'dummy_value', 'request_info': {}, }
dest_usage_key = source_item.location.replace(name=uuid4().hex) category = dest_usage_key.block_type
answer_objs = SurveyAnswer.objects.filter( user=self.student, form=self.survey )
block.fields.update(definition.get('fields')) block.definition_loaded = True
with self.assertRaisesRegexp(CommandError, unicode(GitExportError.URL_BAD)): call_command('git_export', 'foo/bar/baz', 'silly', stderr=StringIO.StringIO())
STATIC_URL = '/static/' + EDX_PLATFORM_REVISION + "/" STATIC_ROOT = ENV_ROOT / "staticfiles" / EDX_PLATFORM_REVISION
self.assertTrue(res_json['success'])
self.assertEqual(len(httpretty.httpretty.latest_requests), 1)
elif len(self.subclusters_) < self.branching_factor: self.append_subcluster(subcluster) return False
for key, val in original_values_map.iteritems(): self.assertEquals( self.advanced_settings.get(key), val, 'Undoing Should revert back to original value' )
self.assertEqual(response.status_code, 200) self.assertIn('Financial Assistance Application', response.content)
else: self.append_subcluster(subcluster) return True
return unicode(self.id)
assert unsup_counter.get_value() == train_batches assert sup_counter.get_value() == train_batches
config = CertificateHtmlViewConfiguration(enabled=enabled, configuration=configuration_string) config.save() return config
if is_feature_enabled(): BACKEND.enable_microsites(log)
request = CreditRequest.objects.get(username=username, course__course_key=course_key) self.assertEqual(request.status, 'pending')
return [self._filters]
course_id = _get_course_id(self.store, test_course_data) delete_course_and_groups(course_id, self.user.id) with self.assertRaises(ItemNotFoundError): are_permissions_roles_seeded(course_id)
X = StandardScaler().fit_transform(X)
clf = TreeClassifier(class_weight='the larch', random_state=0) assert_raises(ValueError, clf.fit, X, y) assert_raises(ValueError, clf.fit, X, _y)
self.assertParentReferences( element, course_key, **kwargs )
if attr == self.ASSET_TYPE_ATTR: value = self.asset_id.asset_type elif attr == self.ASSET_BASENAME_ATTR: value = self.asset_id.path else: value = getattr(self, attr)
response = self.client.get(reverse(url_name)) self.assertRedirects(response, reverse("dashboard"))
block_bits = width if (not max_bits or width < max_bits) else max_bits block_size = 2 ** block_bits
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id) if has_instructor_access_for_class(request.user, course_key): try: data = dashboard_data.get_d3_section_grade_distrib(course_key, section)
if course_id is None: course_id = self.course.id return CourseEnrollment.enroll(self.user, course_id, mode='honor')
if correct: self.problem_page.click_choice("choice_2") else: self.problem_page.click_choice("choice_1")
self._verify_unit_warning( self.UnitState(is_released=False, publish_state=self.PublishState.PUBLISHED, is_locked=False), None )
self.assertEqual(draft_version, new_draft_version) self.assertNotEqual(published_version, new_published_version)
if rank < n_negative: return data[rank] if rank - n_negative < n_zeros: return 0 return data[rank - n_zeros]
course_key = CourseKeyField(max_length=255, db_index=True, null=True)
y = multioutput_estimator_convert_y_2d(name, y)
ECOMMERCE_PUBLIC_URL_ROOT = None ECOMMERCE_API_URL = None ECOMMERCE_API_SIGNING_KEY = None ECOMMERCE_API_TIMEOUT = 5 ECOMMERCE_SERVICE_WORKER_USERNAME = 'ecommerce_worker'
if not hasattr(xblock, '_published_by'): self.modulestore.compute_published_info_internal(xblock) return getattr(xblock, '_published_by', None)
STATIC_URL = '/static/' STATIC_ROOT = ENV_ROOT / "staticfiles"
tmp = np.zeros((n_samples, n_samples))
self.team_size = CourseTeamMembership.objects.filter(team=self).count() self.save()
for svd in svds: assert_array_less(0.0, svd.explained_variance_ratio_)
dquality_dir = (Env.REPORT_DIR / "diff_quality").makedirs_p()
x = np.dot(x, np.arange(x.shape[1] ** 2).reshape(x.shape[1], x.shape[1]))
with self.assertNumQueries(len(kv_dict)): self.kvs.set_many(kv_dict) for key in kv_dict: self.assertEquals(self.kvs.get(key), kv_dict[key])
git_import.add_repo(self.TEST_REPO, repo_dir / 'edx4edx_lite', self.TEST_BRANCH) def_ms = modulestore() self.assertIsNotNone(def_ms.get_course(self.TEST_BRANCH_COURSE))
self.add(metadata_to_insert)
if not self.is_user_authorized(request, content, loc): return HttpResponseForbidden('Unauthorized')
'ENABLE_READING_FROM_MULTIPLE_HISTORY_TABLES': True,
NPM_VENDOR_DIRECTORY.mkdir_p()
ax[0, 0].hist(X[:, 0], bins=bins, fc='#AAAAFF', normed=True) ax[0, 0].text(-3.5, 0.31, "Histogram")
cv_score -= cv_score[0] cv_best_iter = x[np.argmin(cv_score)]
resp = self.create_xblock(parent_usage_key=self.seq_usage_key, category='problem', boilerplate='multiplechoice.yaml') self.problem_usage_key = self.response_usage_key(resp)
cohort_list[0].users.add(*user_list) assert_events("added", user_list, cohort_list[:1]) mock_tracker.reset_mock()
resp = self.create_xblock(parent_usage_key=chap_usage_key, category='vertical') vert_usage_key = self.response_usage_key(resp)
TestCase._enter_atomics = enter_atomics_wrapper(TestCase._enter_atomics) TestCase._rollback_atomics = rollback_atomics_wrapper(TestCase._rollback_atomics)
self.chapter = self.store.get_item(self.chapter.location)
decorator `django.utils.decorators.decorator_from_middleware(middleware_class)`
state = models.TextField(null=True, blank=True)
clf = GradientBoostingClassifier(n_estimators=100, random_state=1, subsample=1.0) clf.fit(X, y) assert_raises(AttributeError, lambda: clf.oob_improvement_)
with disable_overrides(): original_due_date = getattr(unit, 'due', None)
log.info("Send-email task %s for email %s: returning status %s", current_task_id, email_id, new_subtask_status) return new_subtask_status.to_dict()
pass
batch_size = v.shape[0]
self.assertEqual(course_id, str(course.id))
self.assertEqual(certificate_exception['user_email'], self.user.email) self.assertEqual(certificate_exception['user_name'], self.user.username)
raise NotImplementedError()
rng = check_random_state(0)
call_task('pavelib.quality.run_safelint', options={"thresholds": '{"total": 5}'})
if os.path.isfile(join(dirname(abspath(__file__)), 'private.py')):
return self.__tokdict.keys()
if extracted: self.users.add(*extracted) for user in self.users.all(): CohortMembership.objects.create( user=user, course_user_group=self, )
self._verify_unit_warning( self.UnitState(is_released=True, publish_state=self.PublishState.PUBLISHED, is_locked=True), self.STAFF_ONLY_WARNING )
template = self.cleaned_data["html_template"] self._validate_template(template) return template
mono_shape = shape[:s_index] + (1, ) + shape[(s_index + 1):]
for partition_id, group_id in user_partition_groups.iteritems(): user_partition_groups[partition_id] = self.groups[group_id - 1]
X_dense[3, :] = 0.0
context['show_homepage_promo_video'] = microsite.get_value('show_homepage_promo_video', False)
le = LabelEncoder() Y_multi = le.fit_transform(y)
return d.iteritems() if hasattr(d, "iteritems") else d.items()
INVOICE_CORP_ADDRESS = "Please place your corporate address\nin this configuration" INVOICE_PAYMENT_INSTRUCTIONS = "This is where you can\nput directions on how people\nbuying registration codes"
mlp_model = MLP( layers=[mlp_nonlinearity(dim=output_channels, layer_name='mlp', irange=1.0)], batch_size=batch_size, nvis=nvis )
assert_almost_equal(np.cov(clf.transform(scatter).T), np.eye(2))
X_test = np.arange(0.0, 5.0, 0.01)[:, np.newaxis] y_1 = regr_1.predict(X_test) y_2 = regr_2.predict(X_test)
execfile
self.wait_for_ajax()
N_per_side = 5 Npts = N_per_side ** 2 n_neighbors = Npts - 1
self.assertNotIn('proctoring', section_actual)
assert_greater(clf.score(X_test, y_test), 0.99)
K_train = np.dot(X_[:180], X_[:180].T) y_train = y_[:180]
return self.background_task_history_button.is_present()
self.assertNotIn("\"/static/", response.content)
req_to_remove = CreditRequirement.get_course_requirements(course_key, namespace=req_namespace, name=req_name)
assert_equal(ransac_estimator.inlier_mask_.shape[0], n_samples)
self._setup_mode_and_enrollment(self.PAST, "verified")
self.assertTrue(tab.validate(dict_tab)) if invalid_dict_tab: with self.assertRaises(xmodule_tabs.InvalidTabsException): tab.validate(invalid_dict_tab)
m = "'init' must be 'pca', 'random' or a NumPy array" assert_raises_regexp(ValueError, m, TSNE, init="not available")
print_filename = True
FEATURES['MILESTONES_APP'] = True
dictionary = _update_dict(dictionary, B, A, verbose=verbose, random_state=random_state)
self.refresh_course()
mock_key.side_effect = mock_key_instances + [Mock()]
TEST_DIR = path(__file__).dirname() PLATFORM_ROOT = TEST_DIR.parent.parent.parent.parent.parent.parent TEST_DATA_ROOT = PLATFORM_ROOT / TEST_DATA_DIR COURSE_DATA_DIR = TEST_DATA_ROOT / COURSE_NAME
if child.location in prob_grade_distrib:
status = InstructorTaskModuleTestCase.get_task_status(instructor_task.task_id) self.assertEqual(status['message'], expected_message)
ROLE = 'instructor' def __init__(self, *args, **kwargs): super(CourseInstructorRole, self).__init__(self.ROLE, *args, **kwargs)
all_assets, __ = content_store.get_all_content_for_course(course.id) self.assertGreater(len(all_assets), 0)
self.assert_grade( two_choice_two_input, self._make_answer_dict([(True, ["Platypus"])]), "correct" )
set_random_state(lda, 3) set_random_state(tree, 3) assert_equal(tree.random_state, 3)
sample_indices = _generate_sample_indices(random_state, n_samples) sample_counts = bincount(sample_indices, minlength=n_samples) unsampled_mask = sample_counts == 0 indices_range = np.arange(n_samples) unsampled_indices = indices_range[unsampled_mask] return unsampled_indices
SOCIAL_MEDIA_FOOTER_NAMES = [ "facebook", "twitter", "youtube", "linkedin", "google_plus", "reddit", ]
if instance_guid and not consumer.instance_guid: consumer.instance_guid = instance_guid consumer.save() return consumer
from __future__ import unicode_literals
verify_group_id_always_present(profiled_user=self.student, pass_group_id=True) verify_group_id_always_present(profiled_user=self.student, pass_group_id=False) verify_group_id_always_present(profiled_user=self.moderator, pass_group_id=True) verify_group_id_always_present(profiled_user=self.moderator, pass_group_id=False)
u"The name that will identify you in your courses - " u"{bold_start}(cannot be changed later){bold_end}"
self.the_cmathml = self.GetContentMathML(self.asciimath, pmathml) return self.the_cmathml
pass
return '/api/badges/v1/assertions/user/{}/'.format(self.user.username)
answer_id = "1_2_1_choiceinput_{index}_numtolerance_input_{ind}".format( index=index, ind=ind ) answer_dict[answer_id] = answer
course = modulestore().get_course(course_id) if course is None: return None return course.enrollment_domain
clf = svm.SVC(class_weight={1: 0.1}) clf.fit(X, Y) assert_array_almost_equal(clf.predict(X), [2] * 6)
self.estimators_ = [] self.estimators_samples_ = [] self.estimators_features_ = []
world.wait(1) continue
mouse_hover_action = ActionChains(self.browser).move_to_element(element) mouse_hover_action.perform()
cohort_management_section.wait_for_ajax() cohort_management_section.wait_for_page() return cohort_management_section
self.assertEquals(set(child_usage_ids), set(child.scope_ids.usage_id for child in block.get_children()))
user_partititons = self.course.user_partitions self.assertEqual(len(user_partititons), 2) self.assertEqual(user_partititons[0].name, 'Name 0')
validation = self.store.get_item(self.video_location).validate() self.assertEqual(len(validation.messages), 0)
for X, y in datasets: X = StandardScaler().fit_transform(X) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.4)
return microsite.get_template_path(relative_path, **kwargs)
response = self.client.get( self._url(), HTTP_ACCEPT="text/plain", ) self.assertEqual(response.status_code, 406)
validate = URLValidator() try: validate(url) return True except ValidationError: return False
self.assertEqual("original_get_html", self.problem.get_html())
for logger in loggers: logger.setLevel(logging.NOTSET) logger.removeHandler(import_log_handler)
self.sigma = 0
self.fit_transform(X) return self
response = client.patch(self.url, data=json.dumps(json_data), content_type=content_type) self.assertEqual(expected_status, response.status_code) return response
rng = np.random.RandomState(seed) X = rng.randn(10, 10) Xcsr = csr_matrix(X)
@ignore_warnings(category=DeprecationWarning) def score(self, g, X): return g.score(X).sum()
}
if param_name not in PARAMETERS: param_name = 'custom_' + param_name
'COURSES_ARE_BROWSABLE': True,
n_classes_ = [n_classes_] classes_ = [classes_] class_prior_ = [class_prior_] constant = [constant]
unicode_text = "好 各位同学".decode('utf-8') self.assertTrue(self.video.downloaded_transcript_contains_text('srt', unicode_text))
value = anonymous_id_for_user(data['user'], None) return value
key = world.css_value(KEY_CSS, index=i) if key == expected_key: return i
for row in db_query: row_loc = course_id.make_usage_key_from_deprecated_string(row['module_state_key']) if row_loc not in prob_grade_distrib: prob_grade_distrib[row_loc] = { 'max_grade': 0, 'grade_distrib': [], }
thresholds_option=thresholds_option
module = __name__.replace('.video_module', '', 2)
discussion_item = self.store.create_item(self.user.id, course.id, 'discussion', 'new_component')
DEFAULT_USER_MESSAGE = ugettext_noop(u'An error has occurred. Please try again.')
config.add_subpackage('linear_model') config.add_subpackage('utils')
with remove_ccx(parent_usage_key) as (parent_usage_key, restore): return restore(self._modulestore.create_child( user_id, parent_usage_key, block_type, block_id=block_id, fields=fields, **kwargs ))
self.validate_xblock_info_consistency(xblock_info, has_child_info=has_child_info)
'django_nose',
for mode_slug in course_modes: CourseModeFactory.create( course_id=self.course.id, mode_slug=mode_slug, mode_display_name=mode_slug, )
try: structure = CourseStructure.objects.get(course_id=course_key) structure.discussion_id_map_json = None structure.save() except CourseStructure.DoesNotExist: pass
APP.config_from_object('django.conf:settings') APP.autodiscover_tasks(lambda: settings.INSTALLED_APPS)
draft_video = self.store.get_item(course_id.make_usage_key('video', self.DRAFT_VIDEO)) self.assertTrue(getattr(draft_video, 'is_draft', False))
with warnings.catch_warnings(record=True): estimator_1 = Estimator() estimator_2 = Estimator() set_testing_parameters(estimator_1) set_testing_parameters(estimator_2) set_random_state(estimator_1) set_random_state(estimator_2)
for iteration_idx in range(n_iter): minibatch_indices = random_state.randint( 0, n_samples, self.batch_size)
to_json_val = super(StaticTab, self).to_json() to_json_val.update({'url_slug': self.url_slug}) return to_json_val
module.reset_problem({})
enrollment = _get_fake_enrollment(student_id, course_id) if enrollment and mode is not None: enrollment['mode'] = mode if enrollment and is_active is not None: enrollment['is_active'] = is_active return enrollment
data_x = data['images'][set_indices] data_x = np.cast['float32'](data_x) data_x = data_x[ex_range] data_x = data_x.reshape(data_x.shape[0], image_size ** 2)
dis = cosine_distances(X)
user_partitions = UserPartitionList( help=_("The list of group configurations for partitioning students in content experiments."), default=[], scope=Scope.settings )
course.delete() with self.assertNumQueries(1): CountryAccessRule.check_country_access(course_id, 'NZ')
reload_the_page(step)
if not has_studio_write_access(request.user, usage_key.course_key): raise PermissionDenied()
y_wrong = y_[:-1] assert_raises(ValueError, clf.fit, X, y_wrong)
if rerandomize == RANDOMIZATION.NEVER: self.assertEqual(seed, 1, msg="Seed should always be 1 when rerandomize='%s'" % rerandomize)
if len(locs) != n: return False hit = np.zeros(n, bool) hit[locs] = True if not np.all(hit): return False return True
pass
updated_time = models.DateTimeField(auto_now=True)
self.assertIsNotNone(get_template_request_context())
'django_comment_common',
self.assertEquals( preview.latex_preview('2/3*4/5*6'), r'\frac{2}{3}\cdot \frac{4}{5}\cdot 6' )
save_hashes(hashes, HASH_FILE)
self.store.publish(problem.location, self.user.id)
self.wait_for_element_visibility(upload_btn_selector, 'upload button is present')
self.assertEqual(should_exist, validator_data["storage"].exists(validator_data["filename"]))
if len(self._flat_data_specs[1]) == 0: X = () self.run_prereqs(X, d) a(*X)
mock_create_subtask_fcn_args = mock_create_subtask_fcn.call_args_list self.assertEqual(len(mock_create_subtask_fcn_args[0][0][0]), 3) self.assertEqual(len(mock_create_subtask_fcn_args[1][0][0]), 3) self.assertEqual(len(mock_create_subtask_fcn_args[2][0][0]), 2)
n_samples_values = np.logspace(np.log10(n_samples_min), np.log10(n_samples_max), n_steps).astype(np.int)
if not settings.FEATURES.get('MILESTONES_APP', False): return False return bool( get_course_milestones_fulfillment_paths(course_id, {"id": user_id}) )
updates_by_type = {} for asset_type, assets in assets_by_type.iteritems(): updates_by_type[self._make_mongo_asset_key(asset_type)] = assets.as_list()
configuration = self.get_configuration() return val_name in configuration
wtf_numpy = np.zeros((n_classes,)) for i in xrange(n_classes): wtf_numpy[i] = probs[i] probs = wtf_numpy
for mode in ('audit', 'honor', 'verified'): CourseModeFactory.create(mode_slug=mode, course_id=self.course.id)
return self.get_transformer_data(transformer, TRANSFORMER_VERSION_KEY, 0)
for block_hierarchy in course_hierarchy: self.build_xblock(block_hierarchy, block_map, parent=None)
assert_array_almost_equal(dist1, dist2)
min_indices = d_chunk.argmin(axis=1) min_values = d_chunk[np.arange(chunk_x.stop - chunk_x.start), min_indices]
test_course = self.store.get_course(test_course.id.version_agnostic()) self.assertIn(test_chapter.location, test_course.children)
out = np.packbits((projected > 0).astype(int)).view(dtype=HASH_DTYPE) return out.reshape(projected.shape[0], -1)
certificates_display_behavior = TextField(null=True) certificates_show_before_end = BooleanField(default=False) cert_html_view_enabled = BooleanField(default=False) has_any_active_web_certificate = BooleanField(default=False) cert_name_short = TextField() cert_name_long = TextField()
#html_favicon = None
enrollment_message = _create_recent_enrollment_message( course_enrollments, course_modes_by_course )
if force_must_retry: attempt.status = 'must_retry'
cv = _covar_mstep_diag(*args) return np.tile(cv.mean(axis=1)[:, np.newaxis], (1, cv.shape[1]))
self.course_id = course_entry.course_key self.lazy = lazy self.module_data = module_data self.default_class = default_class self.local_modules = {} self._services['library_tools'] = LibraryToolsService(modulestore)
factory = RequestFactory() request = factory.get('ccx_coach_dashboard') request.user = MagicMock() return request
return RequestFactory().post('/', {'client_id': client_id})
asset_location = StaticContent.get_location_from_path('/c4x/edX/toy/asset/sample_static.txt') content = contentstore().find(asset_location) self.assertEqual(content.locked, locked)
np.testing.assert_equal(list(KFold(3).split(X)), list(cv.split(X)))
QUEUING = 'QUEUING' PROGRESS = 'PROGRESS'
if self.y is None: return self.X else: return (self.X, self.y)
class_priority = ['video', 'problem']
plt.figure() for i in xrange(self.n_colors): plt.plot(x, plots[i], color=self.colors_rgb[i], alpha=.5)
return course_key
self.api_response(data={"last_visited_module_id": unicode(initial_unit.location)})
course_policy_dir_name = courselike.url_name
EMAIL_MIN_LENGTH = 3 EMAIL_MAX_LENGTH = 254
ROLE = "course_creator_group" def __init__(self, *args, **kwargs): super(CourseCreatorRole, self).__init__(self.ROLE, *args, **kwargs)
timestr = datetime.strftime(time, dateformat) return {'key': key, 'time': timestr}
for store in self.modulestores: if store.get_modulestore_type() == modulestore_type: return store return None
PARTNER_SUPPORT_EMAIL = ENV_TOKENS.get('PARTNER_SUPPORT_EMAIL', PARTNER_SUPPORT_EMAIL)
assert_true(np.all(K > 0)) assert_true(np.all(K - np.diag(np.diag(K)) < 1))
return
resp = self.client.get(reverse('dashboard')) self.assertNotContains(resp, 'Robot_Super_Course') self.assertContains(resp, 'Robot_Course_Outside_Microsite')
base_estimator = Lasso() ransac_estimator = RANSACRegressor(base_estimator) assert_raises(ValueError, ransac_estimator.fit, X, y, weights)
CreditProvider.objects.create( provider_id="ASU", enable_integration=True, provider_url="https://credit.example.com/request", )
#epub_tocdepth = 3
item2 = PaidCourseRegistration.objects.get(id=item2.id) self.assertIsNotNone(item2.course_enrollment) self.assertEqual(item2.course_enrollment.course_id, self.testing_course.id)
'shoppingcart',
digits = load_digits() X, y = digits.data, digits.target
if user is not None: for role in [CourseInstructorRole, CourseStaffRole]: role(course_id).add_users(user)
block = modulestore().get_course(course.id, depth=None) for __ in range(depth - 1): children = block.get_children() block = children[-1]
self.reset_tracker()
go_to_section("data_download")
url += '?payment-order-num={order_num}'.format(order_num=order.id) return HttpResponseRedirect(url)
OAuth2AuthenticationAllowInactiveUser, SessionAuthenticationAllowInactiveUser,
sfm = SelectFromModel(clf, threshold=0.25) sfm.fit(X, y) n_features = sfm.transform(X).shape[1]
try: return cls.objects.get( user=user, course_id=course_key ) except cls.DoesNotExist: return None
clf = MultinomialNB() clf.fit(X_train, y_train, sw_train) prob_pos_clf = clf.predict_proba(X_test)[:, 1]
trainer = yaml_parse.load(design_matrix_yaml % {'filename': filename}) trainer.main_loop()
page = StaffPage(self.browser, self.course_id) EmptyPromise(page.is_browser_on_page, 'Browser is on staff page in LMS').fulfill() return page
self._configure_credit()
copy_cov = False cov = np.dot(dictionary, X.T)
action_name = ugettext_noop('cohorted') task_fn = partial(cohort_students_and_upload, xmodule_instance_args) return run_main_task(entry_id, task_fn, action_name)
self.should_fetch_course = False
relative_path = 'just_a_test.jpg' absolute_path = base_url + relative_path
actual_url = staticfiles_storage.url(path_overrides[module])
non_editable_fields = super(VerticalBlock, self).non_editable_metadata_fields non_editable_fields.extend([ self.fields['due'], ]) return non_editable_fields
response = self.post_with_bearer_token('/oauth2-test/', token=self.refresh_token.token) self.check_error_codes( response, status_code=status.HTTP_401_UNAUTHORIZED, error_code=authentication.OAUTH2_TOKEN_ERROR_NONEXISTENT )
'statici18n',
problem = new_loncapa_problem(xml_str)
provider = generics.get_object_or_404(CreditProvider, provider_id=provider_id)
return HttpResponse()
return True
courses_list_by_groups, __ = _accessible_courses_list_from_groups(self.request)
script = "correct = ['correct' if 'test' in submission[0] else 'incorrect']" problem = self.build_problem(answer=script)
context = get_ccx_creation_dict(course) messages.error(request, context['use_ccx_con_error_message']) return render_to_response('ccx/coach_dashboard.html', context)
print "Couldn't uninstall unwanted Python packages!" return
script = "raise Exception('test')" problem = self.build_problem(answer=script)
self.wait_for_ajax() caption_state_selector = self.get_element_selector(CSS_CLASS_NAMES['captions']) return self.q(css=caption_state_selector).visible
sparse_results = sparse_classifier.predict_proba(X_test_sparse) dense_results = dense_classifier.predict_proba(X_test) assert_array_equal(sparse_results, dense_results)
for user_partition in self.user_partitions: if user_partition.id == user_partition_id: return user_partition raise NoSuchUserPartitionError("could not find a UserPartition with ID [{}]".format(user_partition_id))
courses = ['toy', 'simple', 'simple_with_draft', 'test_unicode']
axis0 = 'sample' axis1 = 'label' if average == 'samples': axis0, axis1 = axis1, axis0
pass
response_element = etree.Element("customresponse")
for email in ["", "a"]: params["email"] = email assert_email_error("A properly formatted e-mail is required")
BULK_EMAIL_INFINITE_RETRY_CAP = 1000
return self.q(css='#content .container section.course-content .sequential-status-message')
Q = random_state.normal(size=(A.shape[1], size))
CACHE_TIMEOUT = 0
gmm = mixture.GaussianMixture(n_components=n_components, covariance_type=cv_type) gmm.fit(X) bic.append(gmm.bic(X)) if bic[-1] < lowest_bic: lowest_bic = bic[-1] best_gmm = gmm
rp2 = RandomProjection(random_state=0, eps=0.5) projected_3 = rp2.fit_transform(data) assert_array_equal(projected_1, projected_3)
super(TestLTIModuleListing, self).setUp()
current_enrollment, __ = CourseEnrollment.enrollment_mode_for_user(self.user, self.course_key) self.assertEquals('verified', current_enrollment)
return self.find_css("#start_time").present
profile = self.user.profile.__class__.objects.get(user=self.user) self.assertEqual(profile.has_profile_image, has_profile_image)
P /= self.early_exaggeration opt_args['n_iter'] = self.n_iter opt_args['it'] = it + 1 params, error, it = _gradient_descent(obj_func, params, **opt_args)
Q, _ = linalg.qr(safe_sparse_dot(A, Q), mode='economic') return Q
if len(image.shape) == 3 and image.shape[2] == 1: image = image[:, :, 0]
assert_raises(ValueError, _inverse_binarize_thresholding, y=np.array([[1, 2, 3], [2, 1, 3]]), output_type="binary", classes=[1, 2, 3], threshold=0)
if auth.user_has_role(user, CourseInstructorRole(course_id)): return 'instructor' else: return 'staff'
if not validate_trust_root(openid_request): return default_render_failure(request, "Invalid OpenID trust root")
if "pinned" not in thread: thread["pinned"] = False
import warnings
block_wrappers.append(partial(replace_course_urls, course_id))
__all__ = [ CodeResponse, NumericalResponse, FormulaResponse, CustomResponse, SchematicResponse, ExternalResponse, ImageResponse, OptionResponse, SymbolicResponse, StringResponse, ChoiceResponse, MultipleChoiceResponse, TrueFalseResponse, JavascriptResponse, AnnotationResponse, ChoiceTextResponse, ]
return self._cache_key_for_kvs_key(kvs_key) in self._cache
ref_inlier_mask = np.ones_like(ransac_estimator.inlier_mask_ ).astype(np.bool_) ref_inlier_mask[outliers] = False
self.courses.append([CourseFactory().location.course_key for _i in range(3)])
#latex_use_parts = False
assert_raises_regexp(ValueError, ".*loss='l3' is not supported.*", svm.LinearSVC(loss="l3").fit, X, y)
export_course_to_xml(self.store, content_store, course_id, root_dir, 'test_export')
Xt = X for name, transform in self.steps[:-1]: Xt = transform.transform(Xt) return self.steps[-1][-1].predict_proba(Xt)
if mean is None: mean = X.mean(axis=0) X = X - mean
if _mini_batch_convergence( self, iteration_idx, n_iter, tol, n_samples, centers_squared_diff, batch_inertia, convergence_context, verbose=self.verbose): break
kf = cval.KFold(300, 3) check_cv_coverage(kf, expected_n_iter=3, n_samples=300)
strip_filenames(initial_course) strip_filenames(exported_course)
self.assertFalse(self.get_dashboard_enrollment_message() in response.content)
self.unit_page.xblocks[1].save_settings()
y_hat = sum(all_y_hat) / self.n_estimators
if not activation_key: activation_key = uuid.uuid4().hex
child_to_move_location = self.problem_x1a_1 new_parent_location = self.vertical_y1a old_parent_location = self.vertical_x1a
return sum(estimator.predict(X[:, features]) for estimator, features in zip(estimators, estimators_features))
ROLE = LibraryUserRole.ROLE def __init__(self, *args, **kwargs): super(OrgLibraryUserRole, self).__init__(self.ROLE, *args, **kwargs)
if hasattr(self, 'vae'): return self.vae else: return None
if self.runtime.user_is_staff: msg = u"Staff debug info: {tb}".format(tb=cgi.escape(traceback.format_exc()))
max_scores_cache.fetch_from_remote(field_data_cache.scorable_locations)
return self.make_call( reverse('teams_detail', args=[team_id]), expected_status, 'patch', json.dumps(data) if data else None, 'application/merge-patch+json', **kwargs )
inner_img = img[:, ring_w:img.shape[1] - ring_w, ring_w:img.shape[2] - ring_w]
self.fake_payment_page.submit_payment()
np.random.seed(12345)
self.wait_for_ajax() self.wait_for_element_absence(btn_selector, 'Wait for the XBlock to finish reloading')
response = self._change_password(email=self.NEW_EMAIL)
self.assertIn('Welcome to edX.', self.video.captions_text)
resp = self.client.get(get_url('xblock_handler', handouts.location))
n_samples, self.n_features_ = X.shape
fresh = modulestore().get_course(self.course.id) test_model = CourseMetadata.fetch(fresh)
footer_el = footer_nav.find_element_by_xpath('..') return 'hidden' not in footer_el.get_attribute('class').split()
return settings.FEATURES.get(cls.ENABLE_INDEXING_KEY, False)
rng = check_random_state(404) y_pred = rng.rand(10)
html_domain_indices = False
update_creator_state = Signal(providing_args=["caller", "user", "state"])
resp = self.client.post( self.postback_url, self.student_answers ) self.assertEquals(resp.status_code, 200) self._assert_no_redirect(self.course)
X_bernoulli = [[1, 100, 0], [0, 1, 0], [0, 100, 1]] X_multinomial = [[0, 1], [1, 3], [4, 0]]
self.course.enable_subsection_gating = True self.save_course()
if ( transcripts_presence['youtube_diff'] and transcripts_presence['youtube_local'] and
msg = name + ' is non deterministic on 32bit Python' raise SkipTest(msg)
log.debug(message) response['status'] = message return JsonResponse(response, status_code)
return settings.FEATURES.get('ENABLE_COURSEWARE_INDEX', False)
enrolled_course_keys = [enrollment.course_id for enrollment in course_enrollments] course_deadlines = VerificationDeadline.deadlines_for_courses(enrolled_course_keys)
if features is not None: valid_set = valid_set[:, features] test_set = test_set[:, features]
dataname = mldata_filename(dataname)
train, test = slice(None, None, 2), slice(1, None, 2) probas_pred = clf.fit(X[train], y[train]).predict_proba(X[test])
key = lambda course: course.sorting_score courses = sorted(courses, key=key)
value = np.zeros_like(X.data)
self._initialize_mixed(contentstore=contentstore, mappings={})
body = self.q(css=selector)[0] ActionChains(self.browser).move_to_element(body).perform() return self
try: modulestore().get_course(course_key) except ItemNotFoundError: logging.error("Could not find course: %s", course_key) return HttpResponseBadRequest()
problem_state = json.loads(studentmodule.state) problem_state["attempts"] = 0
test_model = CourseMetadata.fetch(self.fullcourse) self.assertNotIn('giturl', test_model)
return contentstore().find(Transcript.asset_location(location, filename))
cache.delete(CreditProvider.CREDIT_PROVIDERS_CACHE_KEY)
return self.hidbias + tensor.dot(x, self.weights)
regr_1 = DecisionTreeRegressor(max_depth=2) regr_2 = DecisionTreeRegressor(max_depth=5) regr_1.fit(X, y) regr_2.fit(X, y)
from crum import get_current_request
try: fans = my_sympify(str(ans), matrix=do_matrix, do_qubit=do_qubit) except Exception, err: fans = None
NOT_STUDIO_EDITABLE = ( PollDescriptor, )
return 4.0 / (max_squared_sum + int(fit_intercept) + 4.0 * alpha_scaled)
self.login(email, password)
bookmark = Bookmark.objects.get(user=user, usage_key=usage_key) bookmark.delete() _track_event('edx.bookmark.removed', bookmark)
self.user = User.objects.get_by_natural_key(self.user.natural_key()[0])
rem_vers = kwargs.pop('remove_version', True) rem_branch = kwargs.pop('remove_branch', True)
self.certificates_section.wait_for_certificate_invalidations_section()
fmt = CustomFormatter() handler = CustomStreamHandler(stdout=stdout, stderr=stderr, formatter=fmt) top_level_logger.addHandler(handler)
self.course_outline_page.visit() self.assertEquals(self.course_outline_page.expand_collapse_link_state, ExpandCollapseLinkState.MISSING)
return T.switch(x < 0., 0., x)
attr = getattr(student, feature) try: DjangoJSONEncoder().default(attr) return attr except TypeError: return unicode(attr)
rhobar1 = sqrt(rhobar**2 + damp**2) cs1 = rhobar / rhobar1 sn1 = damp / rhobar1 psi = sn1 * phibar phibar = cs1 * phibar
'ENABLE_DISCUSSION_SERVICE': True, 'ENABLE_TEXTBOOK': True, 'ENABLE_STUDENT_NOTES': True,
ir = IsotonicRegression(increasing='auto', out_of_bounds="nan") ir.fit(x, y)
self.load_courses()
for username in userlist: self.check_state(username, descriptor, 0, 1, 2)
if photo_verifications: return photo_verifications[0].expiration_datetime.strftime(date_format)
if fast_dot is np.dot: return
self.X -= union.mean(axis=0, dtype='float64') std = union.std(axis=0, dtype='float64') std[std < 1e-3] = 1e-3 self.X /= std
if self.transcript_language == 'en':
block_structure.set_transformer_block_field( block_key, cls, cls.MERGED_VISIBLE_TO_STAFF_ONLY, ( all_parents_visible_to_staff_only or block_structure.get_xblock(block_key).visible_to_staff_only ) )
coffee_file_path = os.path.dirname(__file__) + "/test_files/js/*.coffee" os.system("node_modules/.bin/coffee -c %s" % (coffee_file_path))
return ACCESS_GRANTED
FINANCIAL_ASSISTANCE_MIN_LENGTH = 800 FINANCIAL_ASSISTANCE_MAX_LENGTH = 2500
xml = etree.fromstring(expr) xml = self.formulaInstance.preprocess_pmathml(xml) test = etree.tostring(xml)
if "MultiTask" in name: return np.reshape(y, (-1, 1)) return y
return self.q(css='{} input[name=skip-entrance-exam]'.format(self.EE_CONTAINER))
courses, failed_export_courses = export_courses_to_output_path(self.temp_dir) self.assertEqual(len(courses), 2) self.assertEqual(len(failed_export_courses), 0)
reg_code = CourseRegistrationCode.objects.get(code=reg_code.code) self.assertEqual(reg_code.is_valid, True)
for pool_size in [1, 2, 5]: do_test(pool_size)
for student in students[:7]: CertificateWhitelistFactory.create(user=student, course_id=self.course.id, whitelist=True)
assert_equal(n_splits[i], cv.get_n_splits(X, y, labels))
user_partitions = UserPartitionList( help=_("The list of group configurations for partitioning students in content experiments."), default=[], scope=Scope.settings )
for pool_size in [1, 2, 5]: n = num_pools * pool_size
before_activation = model.reconstruct_without_dec_acti(X, P)
return self.best_estimator_.decision_function(X)
X_dense[3, :] = 0.0
module = CapaFactory.create(rerandomize=RANDOMIZATION.ALWAYS)
n_topics, X = _build_sparse_mtx() prior = 1. / n_topics lda_1 = LatentDirichletAllocation(n_topics=n_topics, doc_topic_prior=prior, topic_word_prior=prior, random_state=0) lda_2 = LatentDirichletAllocation(n_topics=n_topics, random_state=0)
xblock_partition_access = set(xblock_group_access.get(partition.id) or []) or None
X = sp.csr_matrix(X, copy=copy)
if val_video_data: encoded_videos = val_video_data.get('profiles', {})
return dict(kernels=self.kernels)
return self
switch_user(request, lti_user, lti_consumer)
return UserFactory()
centers = _init_centroids(X, n_clusters, init, random_state=random_state, x_squared_norms=x_squared_norms) if verbose: print("Initialization complete")
self.assertEqual( [len(courses_list), len(courses_list_by_groups), len(courses_summary_list)], [0, 0, 0] )
course.set_grading_policy(course.grading_policy) grade_summary = course.grader.grade(totaled_scores, generate_random_scores=settings.GENERATE_PROFILE_SCORES)
print("Computing embedding") X_red = manifold.SpectralEmbedding(n_components=2).fit_transform(X) print("Done.")
self._validate(is_numeric, batch) return 0
return JsonResponse( { 'success': False, 'message': _('Invalid data, generate_for must be "new" or "all".'), }, status=400 )
for child, parents in enumerate(self.get_parents_map(children_map)): self.assertSetEqual(set(block_structure.get_parents(child)), set(parents))
self.import_page.upload_tarball('funny_cat_video.mp4') self.import_page.wait_for_filename_error()
return json.dumps({ k: v.encode('utf-8') if isinstance(v, basestring) else v for k, v in post_dict.items() })
Xtrans = Xtrans.toarray() Xtrans2 = mkchi2(k=2).fit_transform(Xsp, y).toarray() assert_equal(Xtrans, Xtrans2)
self.assertEqual(len(self.lib_page.xblocks), 1) problem_block = self.lib_page.xblocks[0] self.assertIn("Laura Roslin", problem_block.author_content)
self.input_space = VectorSpace(dim=self.nvis) self.input_source = 'features' self.latent_space = VectorSpace(dim=self.nhid)
return self.user
UserProfile.objects.exists() return HttpResponse(mock_render_to_string(template_name, context))
print('=' * 80) print("Elastic-Net penalty") results.append(benchmark(SGDClassifier(alpha=.0001, n_iter=50, penalty="elasticnet")))
self.assertFalse(self.cohort_management_page.is_category_selected())
before = attempt.created_at - timedelta(seconds=1) query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(before, query) self.assertIs(result, None)
est = DummyRegressor(strategy="quantile", quantile=0.5) est.fit(X_learn, y_learn) y_pred_learn = est.predict(X_learn) y_pred_test = est.predict(X_test)
if not settings.FEATURES['ADVANCED_SECURITY']: return False min_days_pw_reset = settings.ADVANCED_SECURITY_CONFIG.get( 'MIN_DAYS_FOR_STUDENT_ACCOUNTS_PASSWORD_RESETS' ) return min_days_pw_reset
self.assertEqual(response.status_code, 302)
_before, _blankline, after = text.partition('\n\n') return after
return cls.objects.filter(order__isnull=False, course_id=course_id)
if node_string[-2:] == '\\n': node_string = node_string[:-2] if node_string[-5:] == '<br/>': node_string = node_string[:-5]
for (user, token) in self.tokens.items(): UserPreference.objects.create(user=user, key=NOTIFICATION_PREF_KEY, value=token)
cm = metrics.confusion_matrix(y_test, y_predicted) print(cm)
from sklearn import datasets, svm, pipeline from sklearn.kernel_approximation import (RBFSampler, Nystroem) from sklearn.decomposition import PCA
for i in xrange(len(p)): assert p[i] == precision[i], (i, p[i], precision[i]) assert recall[i] == recall[i]
if must_answer_survey(self.course, self.effective_user): raise Redirect(reverse('course_survey', args=[unicode(self.course.id)]))
assert_raises(ValueError, cls().partial_fit, X2, y2)
'external_auth', 'django_openid_auth',
if self.weight == 0: return None
return CourseMode.objects.get_or_create( course_id=self.course.id, mode_display_name=mode_name, mode_slug=mode_slug, min_price=min_price, suggested_prices=suggested_prices, currency=currency, _expiration_datetime=expiration_datetime, )
self.check_groups(group_permissions.keys()) for group_name, permission_codenames in group_permissions.items(): self.check_permissions(group_name, permission_codenames)
self.reload_course() new_tab_ids = [tab.tab_id for tab in self.course.tabs] self.assertEqual(new_tab_ids, tab_ids + [removed_tab]) self.assertNotEqual(new_tab_ids, orig_tab_ids)
class_ = load_function(engine) if issubclass(class_, ModuleStoreDraftAndPublished): options['branch_setting_func'] = lambda: ModuleStoreEnum.Branch.draft_preferred return class_( doc_store_config=doc_store_config, contentstore=contentstore, signal_handler=signal_handler, **options )
response = self._submit_photos(self.course_key, self.reverification_location, self.IMAGE_DATA) self.assertEqual(response.status_code, 400)
selector = RFE(estimator, step=5) sel = selector.fit(X, y) assert_equal(sel.support_.sum(), n_features // 2)
angle = np.arctan(u[1] / u[0])
CourseModeFactory.create( course_id=self.course_key, mode_display_name="Honor No Expiration", mode_slug="honor_no_expiration", expiration_datetime=None )
return strategy.storage.user.user_model().objects.get(email=email)
course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id) if has_instructor_access_for_class(request.user, course_key): try: data = dashboard_data.get_d3_problem_grade_distrib(course_key)
if 0 in classes_k: class_prior_k[classes_k == 0] += zeros_samp_weight_sum
assert element.value.strip() == expected
space, source = data_specs if not isinstance(source, tuple): source = (source,)
self.wait_for_element_absence(self.upload_image_popup_window_selector, 'upload dialog is hidden')
set_input_value(self, self.COURSE_RUN_INPUT, value)
result = staticfiles.finders.find('images/favicon.ico') self.assertEqual(result, settings.REPO_ROOT / 'lms/static/images/favicon.ico')
super(DenseMulticlassSVM, self).fit(X, y) return self
assign_default_role(course_key, user_who_created_course)
self.cost_from_X_data_specs()[0].validate(data) X, Y = data Y_hat = self.fprop(X) return self.cost(Y, Y_hat)
response = self.client.get(test_url) self.assertIn(str(self.cert.verify_uuid), response.content)
self.assertEqual(len(site_configuration_history), 1)
self.assertEqual(response.status_code, 200) msg = Messages.NO_ECOM_API.format(username=self.user.username, course_id=self.course.id) self.assertResponseMessage(response, msg)
'ENABLE_STUDENT_HISTORY_VIEW': True,
assert_warns(UserWarning, BaggingClassifier(base_estimator=base_estimator, n_estimators=1, bootstrap=True, oob_score=True, random_state=rng).fit, X_train, y_train)
return self.provider_id
CountryAccessRule.objects.get_or_create( restricted_course=restricted_course, country=country, rule_type='blacklist' )
django_settings.FIELDS_STORED_IN_SESSION = _FIELDS_STORED_IN_SESSION
return (user, None)
log.exception( u"%s in Range header: %s for content: %s", exception.message, header_value, unicode(loc) )
providers_string = _("{first_provider} and {second_provider}").format( first_provider=providers[0], second_provider=providers[1] )
return fn(*args, **kwargs)
if n_classes == 2: proba[:, 0] = 1. - proba[:, 1] else: proba /= np.sum(proba, axis=1)[:, np.newaxis]
init = getattr(cls.__init__, 'deprecated_original', cls.__init__) if init is object.__init__: return []
django_settings.SOCIAL_AUTH_STRATEGY = 'third_party_auth.strategy.ConfigurationModelStrategy'
self.logout() self.login(self.student_user.email, 'test')
prefix = self.lti_consumer_key + ":" return self.backend_name == social_auth.provider and social_auth.uid.startswith(prefix)
all_thumbnails = content_store.get_all_content_thumbnails_for_course(course.id) self.assertGreater(len(all_thumbnails), 0)
credit_state = self.service.get_credit_state(self.user.id, self.course.id) self.assertEqual(credit_state['credit_requirement_status'][0]['status'], None)
shifted_gaussian = np.random.randn(n_samples, 2) + np.array([20, 20])
course_overview = self._assert_image_urls_all_default(modulestore_type, fake_course_image)
try: return ( self.backend_name == pipeline['backend'] and self.lti_consumer_key == pipeline['kwargs']['response'][LTI_PARAMS_KEY]['oauth_consumer_key'] ) except KeyError: return False
return PushNotificationConfig.is_enabled()
django_user_service = DjangoXBlockUserService(self.user) xb_user = django_user_service.get_current_user() self.assertTrue(xb_user.is_current_user) self.assert_xblock_user_matches_django(xb_user, self.user)
from nose.plugins.skip import SkipTest from theano import config from theano import function from theano.sandbox import cuda from theano import tensor as T
assert_raises(ValueError, cv.fit, K_train.tolist(), y_train)
authentication_classes = []
assert_raises(ValueError, plot_partial_dependence, clf, X, [-1])
self._create_certificate(CourseMode.NO_ID_PROFESSIONAL_MODE) self._check_can_download_certificate_no_id()
self.white_label_course_mode.min_price = 0 self.white_label_course_mode.suggested_prices = ''
'contentstore', 'contentserver', 'course_creators', 'external_auth',
kernel_svm = svm.SVC(gamma=.2) linear_svm = svm.LinearSVC()
if conf.get('normalize', True): return sharedX(data_x, borrow=True) else: return theano.shared(theano._asarray(data_x), borrow=True)
url(r'^search/', include('search.urls')),
sampling_algorithm["custom-pool"] = \ lambda n_population, n_samples, random_state=None: \ sample_without_replacement(n_population, n_samples, method="pool", random_state=random_state)
if self._is_training_data(X): return 2. - float(self.train_sizes) / self.n_max_train_sizes else: return float(self.train_sizes) / self.n_max_train_sizes
self.q(css=".register-button").click()
DEFAULT_REASON = ugettext_noop("UNKNOWN REASON")
TESTABLE_BLOCK_TYPES = set(DIRECT_ONLY_CATEGORIES) TESTABLE_BLOCK_TYPES.discard('course')
CourseEnrollment.enroll(self.user, self.course.id) self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course.id))
if subtitles: self.assets.append('subs_{}.srt.sjson'.format(subtitle_id)) self.navigate_to_course_unit()
self.assertIn('<button class="{} inactive progress-0 nav-item"'.format(self.ICON_CLASSES[user_tag]), content) for tooltip in self.TOOLTIPS[user_tag]: self.assertIn(tooltip, content)
return '<math ' in self.expr
team.add_user(self.student)
self.assert_grade(problem, 'choice_3', 'incorrect')
#self.assertIn("3 matching components", library_block.author_content)
for block in [component, child, sibling]: check_node(block.location, None, after_create, self.user_id, None, after_create, self.user_id)
try: evaluator(dict(), dict(), answer) return True except (StudentInputError, UndefinedVariable): return False
self.visbiasX = sharedX( numpy.zeros(nvisx), name='vbX', borrow=True )
for parameter, default in PARAMETERS.iteritems(): PARAMETERS[parameter] = request.GET.get(parameter, default)
pass
self.assertEqual(len(utils.get_accessible_discussion_modules(course, self.user)), 1)
instructor_task = InstructorTask.objects.get(id=instructor_task.id) instructor_task.task_state = PROGRESS instructor_task.save()
assert expected_mutual_information(np.array([[70000]]), 70000) <= 1
'packages': ('openassessment',),
dist_matrix[dist_matrix != 0] = 1
url( r'^user/(?P<user_id>[^/]*)/course/{course_id}'.format(course_id=settings.COURSE_ID_PATTERN), views.render_html_view, name='html_view' ),
read_from_file(os.path.join(dataset_conf_path,"installed.lst"))
def __init__(self, course_descriptor): self.graders = [ CourseGradingModel.jsonize_grader(i, grader) for i, grader in enumerate(course_descriptor.raw_grader)
sections.append(_section_analytics(course, access))
self.stub_api() self.auth(enroll=False) self.listing_page.visit() self.assertTrue(self.listing_page.is_sidebar_present) self.assertFalse(self.listing_page.are_cards_present)
response = api.add_enrollment(username, unicode(course_id), mode=mode, is_active=is_active)
_change_access(course, user, level, 'allow', send_email)
students = self._create_students(10)
self.assertTrue(self.video.select_transcript_format('txt'))
return "/".join([BASE_URL, self.url_path, unicode(self.locator)])
expected = [(o, o) for o in options] self.assertEqual(f(input), expected)
return ''
elif isinstance(get_mixed_stores(module_store_setting), dict): warnings.warn( "Using a dict for the Stores option in the MixedModuleStore is deprecated. Please use a list instead.", DeprecationWarning )
url( r'^v1/blocks/{}'.format(settings.USAGE_KEY_PATTERN), BlocksView.as_view(), name="blocks_in_block_tree" ),
return self.save_asset_metadata_list([asset_metadata, ], user_id, import_only)
"original_usage_version": None, "descendants": [],
if country not in cls.ALL_COUNTRIES: return True
log.exception('Error occurred while sending payment confirmation email')
attempts_left_open = CapaFactory.create(showanswer='finished', max_attempts="1", attempts="0", due=self.tomorrow_str) self.assertFalse(attempts_left_open.answer_available())
return [note for note in data if note.get(field_name) == value]
component = self.store.publish(component.location, self.user_id) self.assertFalse(self.store.has_changes(component))
import matplotlib.pyplot as plt from itertools import cycle
payment_info = json.loads(response.content) self.assertEqual(payment_info["payment_url"], "/shoppingcart/payment_fake")
) DIRECT_MS_SETUPS_SHORT = ( 'mongo', #'split', ) MODULESTORE_SETUPS = DIRECT_MODULESTORE_SETUPS + MIXED_MODULESTORE_SETUPS MODULESTORE_SHORTNAMES = DIRECT_MS_SETUPS_SHORT + MIXED_MS_SETUPS_SHORT SHORT_NAME_MAP = dict(zip(MODULESTORE_SETUPS, MODULESTORE_SHORTNAMES))
kpca = KernelPCA(kernel="rbf", n_components=2, fit_inverse_transform=True, gamma=2.) X_kpca = kpca.fit_transform(X)
export_course_to_xml(self.store, content_store, course_id, root_dir, 'test_export')
country_label = _(u"Country") error_msg = _(u"Please select your Country.")
return (field_object.usage_id.map_into_course(self.course_id), field_object.field_name)
self.video.verify_speed_changed('1.0x')
if self.whitelist == '': return [] return self.IPFilterList([addr.strip() for addr in self.whitelist.split(',')])
self.assertEqual(self.import_page.header_text, 'Course Import')
self.assertEqual( actual_url, '/static/default_{size}.png'.format(size=expected_pixels) )
return abs(student_complex - instructor_complex) <= tolerance
exams = get_all_exams_for_course(course_key)
pass
return int(r_hash.hexdigest()[:7], 16) % NUM_RANDOMIZATION_BINS
clf = PassiveAggressiveClassifier(class_weight="balanced") assert_raises(ValueError, clf.partial_fit, X, y, classes=np.unique(y))
microsite.set_by_domain(self.microsite.site.domain) self.assertTrue(microsite.has_override_value('platform_name'))
'course_id': u'edX/toy/2012_Fall',
import_library_from_xml( self.store, 'test_user', self.export_dir, ['exported_source_library'], static_content_store=contentstore(), target_id=source_library2_key, load_error_modules=False, raise_on_failure=True, create_if_not_present=True, )
course_about = get_course_about_section(self.request, self.course, 'short_description') self.assertEqual(course_about, "A course about toys.")
parameters["signature"] = signature(parameters, shared_secret_key)
flops = kerns[1] * kerns[2] * 2 #nb flops by output image flops *= out[1] * out[2] flops *= images[0] * kerns[3] * images[3] return flops
self.added_tags.extend(kwargs.items())
X[0, 0] = 0 X[2, 1] = 0 X[4, 3] = 0 X_lil = sp.lil_matrix(X) X_lil[1, 0] = 0 X[1, 0] = 0
key = signature.get_shared_secret_key("asu") self.assertIs(key, None)
if not verify_assets: if other_langs: translations = list(other_langs) if not translations or sub: translations += ['en'] return translations
from config_models.models import cache from embargo.models import IPFilter from embargo.forms import RestrictedCourseForm, IPFilterForm
self._set_opt_in_pref(self.user, "org_alias", False)
html_short_title = 'scikit-learn'
queue = [(usage_key, ())] while len(queue) > 0:
FEATURES['ENABLE_OAUTH2_PROVIDER'] = True
self.assertDictEqual(json.loads(response.content), data)
self._create_course_modes(course_modes) enrollment = data.create_course_enrollment( self.user.username, unicode(self.course.id), enrollment_mode, True )
self.video.click_player_button('fullscreen')
lc_block = self._add_library_content_block(course, self.lib_key) lc_block = self._refresh_children(lc_block) self.assertEqual(len(lc_block.children), 2)
AUTH_TOKENS = convert_tokens(AUTH_TOKENS)
width = self.ext.config['dailymotion_width'][0] height = self.ext.config['dailymotion_height'][0] return flash_object(url, width, height)
return run_multi_processes([cmd], out_log=out_log, err_log=err_log)
num_braces = 0
if kwargs: for key, value in kwargs.iteritems(): setattr(state_object, key, value)
obj = obj.astimezone(UTC)
attempt = SoftwareSecurePhotoVerification.objects.create(user=self.user) self._assert_course_verification_status(VERIFY_STATUS_NEED_TO_VERIFY)
content = contentstore('trashcan').find(asset_key, throw_on_not_found=False) self.assertIsNotNone(content)
n_iter_ = max(n_iter_) if n_iter_ >= max_iter and verbose > 0: warnings.warn("Liblinear failed to converge, increase " "the number of iterations.", ConvergenceWarning)
if self.signal_handler and bulk_ops_record.has_library_updated_item: self.signal_handler.send("library_updated", library_key=library_id) bulk_ops_record.has_library_updated_item = False
pls_2 = pls_.PLSRegression(n_components=X.shape[1]) pls_2.fit(X, Y)
msg = _('All ok!')
return self._certificate_data
cls.audit_course = CourseFactory.create() CourseModeFactory.create(course_id=cls.audit_course.id, mode_slug=CourseMode.AUDIT)
#html_split_index = False
instructor = UserFactory.create(username="instructor", email="instructor@e.com", password="test") role = CourseInstructorRole(self.course_limited.id) role.add_users(instructor)
return self.q(css='.advance-modules-remove-text').text[0]
for trainer in self.trainers: for extension in trainer.extensions: extension.on_save(trainer.model, trainer.dataset, trainer.algorithm)
with self.assertNumQueries(6): override_field_for_ccx(self.ccx, chapter, 'start', ccx_start)
cache.clear()
self._assert_can_reverify()
self.assertFalse(self.course.teams_enabled)
monitoring_dataset = DenseDesignMatrix(X=X)
self.mlp.modify_updates(updates)
out = -np.sum(sample_weight * log_logistic(yz)) + .5 * alpha * np.dot(w, w)
self.prefix = os.path.join(self.RESOURCE_PREFIX, module)
self.publish(block_list_parents_to_publish)
CourseUserGroup.objects.create( name="TestOtherGroupType", course_id=self.course_key, group_type="dummy" ) self.assertFalse(mock_tracker.called)
return { "has_access": self.has_access, "error_code": self.error_code, "developer_message": self.developer_message, "user_message": self.user_message }
for field in ('client_type', 'client_secret', 'client_id', 'authorization_grant_type'): form.fields.pop(field)
ind = np.logical_and(y_pred < n_labels, y_true < n_labels) y_pred = y_pred[ind] y_true = y_true[ind] sample_weight = sample_weight[ind]
_, _, traceback_obj = sys.exc_info() raise ResponseError(err.message, traceback_obj)
cmap_light = ListedColormap(['#FFAAAA', '#AAFFAA', '#AAAAFF']) cmap_bold = ListedColormap(['#FF0000', '#00FF00', '#0000FF'])
raise NotImplementedError
self.create_programs_config(program_listing_enabled=True) response = self.client.get(path=self.view_path) self.assertContains(response, '<li class="tab-nav-item">')
resp = self.client.get(course_wiki_page, follow=False, HTTP_REFERER=referer) self.assertEqual(resp.status_code, 302)
key = safe_key('test', '', version)
self.staff = StaffFactory.create(course_key=self.course.id)
_upload_sjson_file(good_sjson, self.item_descriptor.location)
self.assertEqual(response.status_code, 200) self.assertEqual(len(mail.outbox), 1)
COMMENTS_STUB_URL = os.environ.get('comments_url', 'http://localhost:4567')
credit_api.set_credit_requirement_status( self.user.username, self.course.id, "grade", "grade", status="satisfied", reason={"final_grade": 0.95} )
return self.keys
silhouette_avg = silhouette_score(X, cluster_labels) print("For n_clusters =", n_clusters, "The average silhouette_score is :", silhouette_avg)
max_value_length = settings.TRACK_MAX_EVENT / 4
if whiten: assert_almost_equal(s_, np.dot(np.dot(mixing_, k_), m))
STATIC_URL = STATIC_URL_BASE.encode('ascii') if not STATIC_URL.endswith("/"): STATIC_URL += "/" STATIC_URL += EDX_PLATFORM_REVISION + "/"
self.assertTrue(self.cart.has_items(item_type=Donation)) self.assertEqual(self.cart.total_cost, unit_cost)
about_path = reverse('about_course', kwargs={'course_id': unicode(course_key)}) return u'{}{}'.format(site_prefix(), about_path)
#latex_show_urls = False
self.assertEqual(len([r for r in httpretty.httpretty.latest_requests if r.method == 'PATCH']), 0)
'ENABLE_VIDEO_BUMPER': False,
self.logout()
plt.subplot(1, 2, i + 1)
self.store.convert_to_draft(self.problem.location, self.user.id)
self._setup_mode_and_enrollment(self.PAST, "verified")
ir = IsotonicRegression() assert_array_equal(ir.fit_transform(np.ones(len(x)), y), np.mean(y))
for student in students[:2]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.downloadable, mode='honor', grade=default_grade )
start_match = quote_regex.search(template, start_index, end_index) if start_match is None: return None else: return start_match.start()
]
resp = self.client.ajax_post( self.seq2_update_url, data={'children': [unicode(unit_1_key), unicode(unit_2_key)]} ) self.assertEqual(resp.status_code, 200)
invoice = models.ForeignKey(Invoice, null=True) invoice_item = models.ForeignKey(CourseRegistrationCodeInvoiceItem, null=True)
item = OrderItem(user=self.user, order=Order.get_cart_for_user(self.user)) with self.assertRaises(NotImplementedError): item.purchased_callback()
tables = None
X_var *= X.shape[0] X_std = np.sqrt(X_var, X_var) del X_var X_std[X_std == 0] = 1 inplace_column_scale(X, 1. / X_std)
assert_equals(len(base64.urlsafe_b64encode(encrypted_aes_key)), 344)
return { 'qty': self.qty, 'unit_price': unicode(self.unit_price), 'currency': self.currency }
self.assertEqual(cart.status, 'purchased')
self.q(css=subsection_css).first.click() self._on_section_promise(section_title, subsection_title).fulfill()
microsite.clear() return response
random_state = check_random_state(0)
CreditProvider.objects.create( provider_id=self.PROVIDER_ID, display_name=self.PROVIDER_NAME, provider_status_url=self.PROVIDER_STATUS_URL, enable_integration=True, )
for name, penalty in (('unreg', 1), ('reg', 0.05)):
MESSAGE = _('Unable to get git log')
is_eligible = api.is_user_eligible_for_credit("staff", credit_course.course_key) self.assertFalse(is_eligible)
'EDITABLE_SHORT_DESCRIPTION': True,
self.browser.execute_script("window.scrollTo" + str(self.coordinates_for_scrolling(MANUAL_BUTTON_SELECTOR))) self.q(css=MANUAL_BUTTON_SELECTOR).click()
refund_cutoff_date = self.refund_cutoff_date() if refund_cutoff_date and datetime.now(UTC) > refund_cutoff_date: return False
n_samples, n_features = iris.data.shape
self.assertIsNotNone(problem_block.markdown) self.assertIsNone(problem_block_course.markdown)
self.assertEqual(html, "<div>Test Template HTML</div>")
with super(FollowedThreadsUnicodeTestCase, cls).setUpClassAndTestData(): cls.course = CourseFactory.create()
for sec_index, sec_title in enumerate(section_titles):
self.submit_question_answer('p1', {'2_1': u'Correct'}) self.submit_question_answer('p2', {'2_1': u'Correct'})
km = KMeans(precompute_distances="wrong") assert_raises(ValueError, km.fit, X)
world.staff = StaffFactory(course_key=world.course_key) world.enroll_user(world.staff, world.course_key)
return self.q(css=self.COURSE_RUN_INPUT).text[0]
this_tar_file=tarfile.open(tar_filename,"r:bz2")
self.assertEqual(self.user1.course_groups.count(), 1) self.assertEqual(CohortMembership.objects.filter(user=self.user1).count(), 1)
method = None
self.assertIn('html', result) self.assertEqual(result['html'], "<div>Test HTML</div>")
self.wait_for_field(field_id) query = self.q(css='.u-field-link-title-{}'.format(field_id)) return query.text[0] if query.present else None
selector = self.get_element_selector(CSS_CLASS_NAMES['video_container']) auto_play = json.loads(self.q(css=selector).attrs('data-metadata')[0])['autoplay'] return auto_play
url = reverse('dashboard')
element = self.q(css=selector).results[0] return element.size
self.assertEqual(html.count("</script>"), 1)
assert_raises(ValueError, rp.transform, data[:, 1:5])
return dict(dic1.items() + dic2.items())
self.login_and_enroll(course_id)
from __future__ import unicode_literals from datetime import timedelta
students_to_gradesets = {} students_to_errors = {} for student, gradeset, err_msg in iterate_grades_for(course_id, students): students_to_gradesets[student] = gradeset if err_msg: students_to_errors[student] = err_msg return students_to_gradesets, students_to_errors
last_valid_score = self.validation_scores_[-1]
EDX_PLATFORM_REVISION = 'unknown'
self.addCleanup(self.cleanup_scheme_extensions)
grade_status = CreditRequirementStatus.objects.get( username=self.USER_INFO['username'], requirement__namespace="grade", requirement__name="grade" ) grade_status.reason = {} grade_status.save()
clf = GradientBoostingClassifier(n_estimators=100, random_state=1) assert_raises(ValueError, clf.fit, X, y + [0, 1])
def default(self, noDefaultEncodingObj): return noDefaultEncodingObj.value.replace("<script>", "sample-encoder-was-here")
raise NotImplementedError
if url_name is None or url_name == "": url_name = fallback_name()
self.assertEqual(result['order'].bill_to_ccnum, '####')
check_arguments_for_rescoring(usage_key)
programs = get_programs(self.client.user) self.run_modes = self._flatten(programs)
self.best_cost = self.coeff * np.inf self.best_model = None
course = modulestore().get_course(course_key, depth=2)
tag = match.group(0) if ( ALLOWED_BASIC_TAG_PATTERN.match(tag) or ALLOWED_A_PATTERN.match(tag) or ALLOWED_IMG_PATTERN.match(tag) ): return tag else: return ""
def __init__(self, *args, **kwargs): super(OrgStaffRole, self).__init__('staff', *args, **kwargs)
return SequenceDatasetIterator(self, data_specs, subset_iterator, return_tuple=return_tuple)
y_predicted = clf.predict(docs_test)
structure['blocks'][block_key] = content
self.purchased_callback() self.status = 'purchased' self.fulfilled_time = datetime.now(pytz.utc) self.save()
degrees_of_freedom = max(self.n_components - 1.0, 1) n_samples = X.shape[0] k = min(n_samples - 1, int(3. * self.perplexity + 1))
with self.assertNumQueries(24): self.client.get(self.teams_url)
'overall_message': overall_message,
self._assertOLXBase(block_list, draft=True, published=False)
raise NotImplementedError("Specific Modulestores must implement get_definition_id")
idx = np.argsort(np.sum((X - mean[np.newaxis, :]) ** 2, axis=1)) X = X[idx, :]
self.assertEqual(num_children, len(reverted_parent.children))
self.unit_page = self.outline.section('Test Section').subsection('Test Subsection').expand_subsection().unit( 'Test Unit').go_to()
all_courses = modulestore().get_courses() orgs_lowercase = [org.lower() for org in org_aliases] return [ course.id for course in all_courses if course.id.org.lower() in orgs_lowercase ]
context_dictionary = {}
max_scores_cache.fetch_from_remote([location_to_cache]) self.assertIsNone(max_scores_cache.get(location_to_cache)) self.check_grade_percent(0.33)
self.assertEquals(3, self.response.content.count('grade_C'))
request = RequestFactory().post('unused_url') request.user = self.user request.META['HTTP_HOST'] = "aGenericValidHostName" self.append_allowed_hosts("aGenericValidHostName")
#pylint: skip-file from __future__ import unicode_literals
if lti_key in lti_params and lti_params[lti_key]: details[details_key] = lti_params[lti_key]
module_store_setting['default']['OPTIONS']['stores'] = convert_old_stores_into_list( get_mixed_stores(module_store_setting) ) assert isinstance(get_mixed_stores(module_store_setting), list)
if not settings.FEATURES['AUTH_USE_CERTIFICATES']: return HttpResponseForbidden()
locator = course.location.map_into_course(CourseLocator(version_guid=previous_version)) self.assertTrue( modulestore().has_item(locator), "couldn't find in %s" % previous_version )
tstart = datetime.now() clf = DecisionTreeClassifier() clf.fit(X, Y).predict(X) delta = (datetime.now() - tstart)
return self.tracker.backends['mem']
first_checkpoint.add_verification_attempt(SoftwareSecurePhotoVerification.objects.create(user=self.user)) self.assertEqual(first_checkpoint.photo_verification.count(), 2)
return self._get_element_text(".response-display-count")
usage_key = self._map_revision_to_branch(usage_key, revision=revision) return super(DraftVersioningModuleStore, self).get_item(usage_key, depth=depth, **kwargs)
self.browser.refresh() self.wait_for_page()
super(BaggingRegressor, self)._validate_estimator( default=DecisionTreeRegressor())
self.payment_and_verification_flow.next_verification_step(self.immediate_verification_page)
return self.bias.get_value()
DEBUG = True SITE_NAME = 'localhost:{}'.format(LETTUCE_SERVER_PORT)
return context["cc_requester"]["id"] == cc_content["user_id"]
oob_best_iter = x[np.argmin(cumsum)]
if self.read_committed is True: if connection.vendor == 'mysql': cursor = connection.cursor() cursor.execute("SET TRANSACTION ISOLATION LEVEL READ COMMITTED")
if dependencies[0] != "jquery": dependencies.insert(0, "jquery")
clf = self.factory(alpha=0.01, n_iter=5, shuffle=False) clf.fit(X, Y) assert_true(hasattr(clf, "coef_"))
X, y = make_hastie_10_2(n_samples=20, random_state=1)
AutoAuthPage(self.browser, username=self.USERNAME, email=self.EMAIL, course_id=self.course_id, staff=False).visit()
self.testing_course.enrollment_start = self.tomorrow self.testing_course.enrollment_end = self.nextday self.testing_course = self.update_course(self.testing_course, self.user.id)
for n, (name, estimator) in enumerate(estimators): y_predict = np.zeros((n_test, n_repeat))
self.course_key = course_key
X -= X.min() - .1 this_X = NotAnArray(X) this_y = NotAnArray(np.asarray(y)) _check_transformer(name, Transformer, this_X, this_y)
return LibraryLocator.from_string(self.source_library_id)
dest_structure['blocks'][new_parent_block_key].fields['children'] = new_children
yield dec
with remove_ccx(usage_key) as (usage_key, restore): return restore( self._modulestore.get_item(usage_key, depth, **kwargs) )
if self.request_cache is not None: self.request_cache.data.setdefault('course_cache', {})[course_version_guid] = system return system
AutoAuthPage(self.browser, username=username, email=email, course_id=self.course_id, staff=staff).visit()
MAX_BOOKMARKS_PER_COURSE = 100
block_structure.request_xblock_fields('is_proctored_enabled') block_structure.request_xblock_fields('is_practice_exam')
path = urlparse.urlparse(self.path).path if path.endswith('/'): return path[:-1] else: return path
with self.assertRaises(CreditRequestNotFound): api.update_credit_request_status("invalid_uuid", self.PROVIDER_ID, "approved")
block = store.create_child( user_id, parent_loc, block_info.category, block_id=block_info.block_id, fields=block_info.fields, ) for tree in block_info.sub_tree: create_sub_tree(block.location, tree)
if 'extensions' not in d: self.extensions = []
sale_order_dict = dict((feature, getattr(purchased_course.order, feature)) for feature in sale_order_features)
monitoring_dataset = DenseDesignMatrix(X=X, y=Y)
function = Group(inner_varname + Suppress("(") + expr + Suppress(")"))("function") function.setParseAction(self.function_parse_action)
return unicode(repr(self))
user = User.objects.get(email=self.enrolled_student.email) self.assertFalse(CourseEnrollment.is_enrolled(user, self.course.id))
state = models.CharField(max_length=50)
pass
self.assertFalse(result['success']) self.assertIn(u"you have cancelled this transaction", result['error_html'])
store.save(content)
resp_params = PaymentFakeView.response_post_params(post_params) self.assertEqual(resp_params.get('decision'), 'ACCEPT')
resp = self._change_enrollment('unenroll') self.assertEqual(resp.status_code, 400)
response.data["current_page"] = self.page.number
if is_active and (enrollment_mode in CourseMode.VERIFIED_MODES + [CourseMode.NO_ID_PROFESSIONAL_MODE]): return redirect(reverse('dashboard'))
pipe2 = clone(pipe) assert_false(pipe.named_steps['svc'] is pipe2.named_steps['svc'])
self.wait_for_element_visibility(email_selector, 'Email field is visible') self.q(css=email_selector).fill(email)
self.assertRolledBack() self.assertFalse(email_user.called)
accuracy.plot([64, 64], [0.7, 1], label="n_features")
callback_url = request.build_absolute_uri( reverse("shoppingcart.views.postpay_callback") )
return self._extra_fields_setting.get(field_name) == "required"
input_msg = correctmap.get_msg('1_2_1') self.assertEqual(input_msg, "Test Message")
assert key.user_id == self.user.id
self.problem_page.click_choice('choice_choice_1') self.problem_page.click_save() self.problem_page.wait_for_expected_status('div.capa_alert', 'saved')
self.labels = np.array(labels, copy=True) self.unique_labels = np.unique(labels) self.n_unique_labels = len(self.unique_labels)
assert_equal(rp.n_components, 'auto') assert_equal(rp.n_components_, 110)
config = microsite.values return config.get(val_name, default)
return self.q(css='{} .section-name input'.format(parent_css)).present
assert_array_almost_equal(x_loadings_sign_flip, x_weights_sign_flip, 4) assert_array_almost_equal(np.abs(x_loadings_sign_flip), 1, 4) assert_array_almost_equal(np.abs(x_weights_sign_flip), 1, 4)
clf = RandomForestClassifier(n_estimators=20)
self.assertTrue(BulkEmailFlag.feature_enabled(course_id))
self.course.visible_to_staff_only = True self.store.update_item(self.course, self.user.id)
return "start_date"
world.auto_capture_screenshots = False
if block_type == 'course': block_id = self.DEFAULT_ROOT_COURSE_BLOCK_ID elif block_type == 'library': block_id = self.DEFAULT_ROOT_LIBRARY_BLOCK_ID new_usage_key = course_key.make_usage_key(block_type, block_id)
certificate.click_edit_certificate_button() certificate.course_title = "Updated Course Title Override 2" self.assertEqual(certificate.get_text('.action-primary'), "Save") certificate.click_save_certificate_button()
response = self._auto_auth({ 'username': 'test', 'course_id': course_id, 'redirect': True, 'staff': 'true', }, status_code=302)
return Image.fromarray(arr.reshape(os, os) * 255.)
return False
assert np.all(dist < 5 * bandwidth)
config = CourseEventBadgesConfiguration.current().enrolled_settings enrollments = user.courseenrollment_set.filter(is_active=True).count() award_badge(config, enrollments, user)
if publish == 'make_public': modulestore().publish(xblock.location, user.id)
self.q(css='.action-remove-member').first.click()
response['X-XRDS-Location'] = get_xrds_url('xrds', request) return response
global tmpdir tmpdir = tempfile.mkdtemp() os.makedirs(os.path.join(tmpdir, 'mldata'))
proj_grad_W = squared_norm(gradW * np.logical_or(gradW < 0, W > 0)) proj_grad_H = squared_norm(gradH * np.logical_or(gradH < 0, H > 0))
cart.purchase() cart.purchase() self.assertEquals(len(mail.outbox), 1)
return get_instructions(xmltree)
obj.admin = request.user obj.save()
assert_greater_equal(call_count, minimum_calls)
from sklearn.linear_model import Lasso
for row in rows: yield [unicode(item).encode('utf-8') for item in row]
Donation.add_to_order(cart, 10.0, None) cart.purchase(first='FirstNameTesting123', street1='StreetTesting123') self.orderid_courseless_donation = cart.id
from __future__ import unicode_literals
if not isinstance(xblock.location, LibraryUsageLocator): modulestore().has_changes(modulestore().get_course(xblock.location.course_key, depth=None))
self._setup_mode_and_enrollment(self.PAST, "verified")
if space.axes != self.axes: batch = _undo_op(batch, 'DimShuffle', strict=True)
'user_message': _(u"The ordering {ordering} is not supported").format(ordering=order_by_input),
with patch('xmodule.capa_module.CapaModule.closed') as mock_closed: mock_closed.return_value = True
enable_course_home_improvements = BooleanField( default=False, verbose_name=_("Enable course home page improvements.") )
xblocks = (blocks[ref] for ref in refs) return set([xblock.location for xblock in xblocks])
return uuid.uuid4().hex
__, __, re_course = self.load_test_import_course(target_id=course.id, module_store=module_store)
self.assertEqual(response.status_code, 403)
if enrollment_mode is None: self.assertFalse(CourseEnrollment.is_enrolled(self.user, self.course.id))
return
return _click_edit(self, '.edit-button', '.xblock-studio_view')
response = confirm_email_change(self.request, self.key) self.assertEquals( mock_render_to_response(expected_template, expected_context).content, response.content )
s = f.read(4) s_array = numpy.fromstring(s, dtype='int32') return s_array.item()
programs_config = self.create_programs_config(cache_ttl=cache_ttl) self.assertEqual(programs_config.is_cache_enabled, is_cache_enabled)
scoring = self.default_scoring correct_points = scoring.get('correct') return dict([(inputfield.get('id'), correct_points) for inputfield in self.inputfields])
if req["namespace"] == old_req.namespace and req["name"] == old_req.name: found_flag = True break
if len(y) == 0: words = generator.randint(n_features, size=n_words) return words, y
request = CreditRequest.objects.get(uuid=uuid) self.assertEqual(request.status, expected_status)
self.assertEqual(len(self.library.children), 2)
return 1.0 / (max_squared_sum + int(fit_intercept) + alpha_scaled)
return {key: val for key, val in self.session.cookies.items()}
self.split_test_module.user_partition_id = 999
instructor = self.make_instructor() self.assertTrue(CourseInstructorRole(self.course.id).has_user(instructor))
n_inliers_best = n_inliers_subset score_best = score_subset inlier_mask_best = inlier_mask_subset X_inlier_best = X_inlier_subset y_inlier_best = y_inlier_subset
self.assertEqual(self.video.speed, '2.0x')
_context.update({ 'base_asset_url': StaticContent.get_base_url_path_for_course_assets(self.location.course_key), 'enable_latex_compiler': self.use_latex_compiler, 'editor': self.editor }) return _context
node = mock.Mock(due=2, extended_due=1) self.assertEqual(self.call_fut(node), 2)
for part_svc in [ps_shared_cache_1, ps_shared_cache_2, ps_diff_cache]: self.assertEqual( first_group.id, part_svc.get_user_group_id_for_partition(user_partition_id) )
self.video.hide_closed_captions() self.video.wait_for_closed_captions_to_be_hidden() self.video.reload_page() self.video.wait_for_closed_captions_to_be_hidden()
DEBUG = False SESSION_COOKIE_SECURE = False SESSION_SAVE_EVERY_REQUEST = False SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'
if score is None: self.clear_user_module_score(real_user) return Response(status=200)
n_features = 501 n_relevant_features = 3 noise_level = .2 coef_min = .2 n_samples = 25 block_size = n_relevant_features
self.context = self._extract_context(self.tree)
self.assert_enrollment_status(as_server=True)
context['company_about_description'] = _("{platform_name} offers interactive online classes and MOOCs.").format( platform_name=platform_name)
MODULE_DOCS = __doc__
normalizers[normalizers < min_divisor] = 1.
self.assertFalse( CourseEnrollment.is_enrolled(self.ext_user, self.course.id), 'Did not expect ext_user to be enrolled in course' )
SplitModuleTest.modulestore = None
all_items = self.sequence_items
resp = self.client.get('/copyright') self.assertEqual(resp.status_code, 404)
return str(obj)
all_messages = [] for msg_group in self.NOTIFICATION_MESSAGES.values(): all_messages.extend(msg_group)
GeneratedCertificateFactory.create( user=self.user, course_id=self.course.id, status=CertificateStatuses.downloadable, mode='honor' )
assert correctness in ['correct', 'incorrect'] assert problem_type in PROBLEM_DICT answer_problem(world.scenario_dict['COURSE'].number, problem_type, correctness)
#
return self.length
_ = lambda text: text
return EmptyPromise( lambda: self.link_title_for_link_field(field_id) == expected_title, "Link field with link title \"{0}\" is visible.".format(expected_title) ).fulfill()
MODULESTORE = convert_module_store_setting_if_needed(MODULESTORE)
mb_k_means = MiniBatchKMeans(n_clusters=3, init=test_init, random_state=42).fit(X_csr) _check_fitted_model(mb_k_means)
shutil.rmtree(self._output_dir, ignore_errors=True)
hw_section = next(section for section in sections_list if section.get('url_name') == hw_url_name) return [s.earned for s in hw_section['scores']]
definition = LicenseMixin.parse_license_from_xml(definition, xml_object)
language = UserPreference.get_value(data['user'], LANGUAGE_KEY)
return 'assets.{}'.format(asset_type)
import matplotlib.pyplot as plt from itertools import cycle
@ignore_warnings(category=DeprecationWarning) def test_aic(): n_samples, n_dim, n_components = 50, 3, 2 X = rng.randn(n_samples, n_dim)
from __future__ import unicode_literals
self.course.edxnotes = False self.assertFalse(has_notes_tab(self.user, self.course))
ith_cluster_silhouette_values = \ sample_silhouette_values[cluster_labels == i]
'ENABLE_SERVICE_STATUS': False,
_mbce = MeanBinaryCrossEntropy() reconstruction_cost = lambda a, b: _mbce.cost(a, b) / ds.X.shape[1]
region_str = "[[[10,10], [20,10], [20, 30]], [[100,100], [120,100], [120,150]]]"
_ = lambda text: text
estimators = all_estimators(include_meta_estimators=True)
assert_equal(iterations, expected_n_iter) if n_samples is not None: assert_equal(collected_test_samples, set(range(n_samples)))
pass
inheriting_settings = inherited_settings_map[block_key].copy() block_fields = block_data.fields for field_name in inheritance.InheritanceMixin.fields: if field_name in block_fields: inheriting_settings[field_name] = block_fields[field_name]
parents = block_structure.get_parents(block_key) min_all_parents_start_date = min( cls.get_merged_start_date(block_structure, parent_key) for parent_key in parents ) if parents else None
return course_id in [ item.course_id for item in order.orderitem_set.all().select_subclasses("paidcourseregistration") if isinstance(item, cls) ]
assert_false(hasattr(SequenceDescriptor, 'attempts'))
return ( course1['org'] == course2['display_organization'] and course1['number'] == course2['display_coursenumber'] and course1['run'] == course2['run'] )
return [tuple(map(int, score.split('/'))) for score in text_scores]
params = self._signed_callback_params(self.order.id, self.COST, self.COST, signature="invalid!") result = process_postpay_callback(params)
if weight is None or raw_total == 0: return (raw_correct, raw_total) return (float(raw_correct) * weight / raw_total, float(weight))
base_url = AssetBaseUrlConfig.get_base_url() excluded_exts = AssetExcludedExtensionsConfig.get_excluded_extensions() url = StaticContent.get_canonicalized_asset_path(course_id, rest, base_url, excluded_exts)
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course_key): self.assertTrue(self.store.has_item(problem_location)) assertProblemNameEquals(problem_original_name)
DEBUG = True
return [t.value for t in TagAvailableValues.objects.filter(category=self)]
predictions = np.array([ est.predict(X) for est in self.estimators_[:limit]]).T
if entry_needs_updating: instructor_task.task_state = result_state if task_output is not None: instructor_task.task_output = task_output
for key, value in mappings.iteritems(): setattr(self, key, value)
microsite.clear() with patch('django.conf.settings.MICROSITE_CONFIGURATION', False): self.assertEqual( microsite.get_all_orgs(), set() )
self.q(css='#course-index-tabs .programs-tab a').click() self.wait_for_element_visibility("div.programs-tab.active", "Switch to programs tab")
self.assert_requirement_status(grade, due_date, None)
resource = {"id": self.resource_id, 'event': test_case['event']} self.check_event_response_by_key('handle_vote', resource, 'newVotes', test_case['new_votes'])
response = self.client.get(self.url) expected_html = ( 'Enable Student-Generated Certificates' if is_enabled else 'Disable Student-Generated Certificates' ) self.assertContains(response, expected_html)
else:
return { 'email': self._attach_email_claim, 'profile': self._attach_profile_claim }
theta0 = self.theta0
if 2 in pdp_lim: Z_level = np.linspace(*pdp_lim[2], num=8)
return self._active_count == 1
separator = u' <b>{}</b> '.format(_('or')) return {self.answer_id: separator.join(self.correct_answer)}
ROLE = 'sales_admin' def __init__(self, *args, **kwargs): super(CourseSalesAdminRole, self).__init__(self.ROLE, *args, **kwargs)
return self.q(css='.wrapper-content ' + self.certficate_css + ' .no-content a.new-button').text[0]
if isinstance(authored_data, LmsFieldData):
self.bulk._end_bulk_operation(self.course_key)
n_samples = 1500 noise = 0.05 X, _ = make_swiss_roll(n_samples, noise) X[:, 1] *= .5
suff_stats = np.zeros(exp_topic_word_distr.shape) if cal_sstats else None
page_size = TOPICS_PER_PAGE
remove_user_from_cohort(cohorts[cohort_index], self.user.username)
X.setflags(write=False) X_df_readonly = pd.DataFrame(X) with warnings.catch_warnings(record=True): X_df_ro_indexed = safe_indexing(X_df_readonly, inds)
params = [('course_id', self.course_id)] response = self.client.get(self.url, params)
unavailable_certificates = \ [cert for cert in generated_certificates if cert.status == CertificateStatuses.unavailable and cert.grade == default_grade]
y = np.zeros((10, 10)) y[:5, :5] = 1 y[5:, 5:] = 1
return arrow
is_x_old_in_X = int(mask.sum() < X.shape[0])
return self._get_dot_token(access_token) or self._get_dop_token(access_token)
for student in students[:2]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.downloadable, mode='honor' )
error_msg = _(u"You must agree to the {platform_name} {terms_of_service}.").format( platform_name=get_themed_value("PLATFORM_NAME", settings.PLATFORM_NAME), terms_of_service=terms_link )
for i in fxs: l.append(feature_names[i]) names.append(l)
self.courseware_page.start_timed_exam()
self._create_course_unit_with_handout('textbook.pdf', save_settings=False) self.assertEqual(self.video.download_handout('application/pdf', is_editor=True), (True, True))
LibraryExportManager(modulestore, contentstore, library_key, root_dir, library_dir).export()
next_url = None if self.page.has_next(): next_url = replace_query_param(self.base_url, "page", self.page.next_page_number()) return next_url
assert (niter > 1) == (len(dbm.hidden_layers) > 1)
generated_certificate = GeneratedCertificate.eligible_certificates.get( user=self.enrolled_user_1, course_id=self.course.id, ) self.assertFalse(generated_certificate.is_valid())
with mock.patch('commerce.signals.refund_seat') as mock_refund_seat: self.send_signal() self.assertFalse(mock_refund_seat.called)
self.verbose_mod *= 10
return OverrideFieldData.wrap(TESTUSER, self.course, DictFieldData({ 'foo': 'bar', 'bees': 'knees', }))
course_key = CourseKey.from_string(course_id) course = modulestore().get_course(course_key)
return tab
self.assertEqual( len(CourseEnrollment.objects.filter(mode='honor', user_id__in=user_ids)), 0 )
groups = [] for g in p.groups:
perf_test = True
from __future__ import unicode_literals
clf = SGDClassifier(loss="hinge", alpha=0.01, n_iter=200, fit_intercept=True) clf.fit(X, Y)
return course_metadata_utils.display_name_with_default(self)
rendered_html = etree.XML(problem.get_html())
xblock.runtime.wrappers.append(partial( wrap_xblock, 'StudioRuntime', usage_id_serializer=unicode, request_token=request_token(request), ))
def get(self, _key): return None def set(self, key, value, timeout=None): pass
event = self.handle_callback_and_get_context_info(mock_tracker, problem_display_name) return event['module']
if settings != DEFAULT_SETTINGS: collect_assets(['lms'], asset_settings_lms) collect_assets(['studio'], asset_settings_cms)
n_responses = 3 y = rng.randn(n_samples, n_responses) r.fit(x, y) assert_equal(r.cv_values_.shape, (n_samples, n_responses, n_alphas))
if "face_image" not in params: msg = _("Missing required parameter face_image") return None, HttpResponseBadRequest(msg)
self._add_simple_content_block() with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
[arrayfuncs.cholesky_delete(L[:n_active, :n_active], ii) for ii in idx]
response = self.send_patch(client, {field: ""}) self.assertEqual("", response.data[field])
self.check_event_response_by_key('handle_vote', resource, 'newVotes', test_case['new_votes'])
if isinstance(y_pred, list): y_pred = np.vstack(p for p in y_pred).T
self._fit(X, compute_sources=False) return self
if status == "satisfied" and not eligible_before_update: is_eligible, eligibility_record_created = CreditEligibility.update_eligibility(reqs, username, course_key) if eligibility_record_created and is_eligible: try: send_credit_notifications(username, course_key)
FEATURES['ENABLE_DISCUSSION_SERVICE'] = False
self.dashboard_page.visit()
if ccxs.exists(): return ccxs[0] return None
text_document = self._white_spaces.sub(" ", text_document)
assert len(state) == 2 assert isinstance(coeffs, float) _, state = state state = [state] coeffs = [coeffs]
X = [[-2, -1], [-1, -1], [-1, -2], [1, 1], [1, 2], [2, 1]]
cm = confusion_matrix(y_true, y_pred, labels=[2, 1]) assert_array_equal(cm, [[18, 2], [24, 3]])
self.assertEqual( {c.id for c in CourseOverview.get_all_courses(org='TEST_ORG_1')}, {c.id for c in org_courses[1]}, )
block_data.edit_info.source_version = None
REQUEST_CACHE.data = {} REQUEST_CACHE.request = None
self._run_command(course_key_list=[ unicode(self.courses[0].id), unicode(self.courses[1].id) ])
system = self.get_system() descriptor = system.process_xml(xml_str_in)
self.verify_success_on_file_content( 'username,email,cohort\rfoo_username,bar_email,baz_cohort', mock_store_upload, mock_cohort_task )
import pickle
page.browser.execute_script("jQuery.fx.off = false;")
if not course: course = modulestore().get_course(course_overview.id)
self.q(css=self.search_bar_selector + ' input[type="text"]').fill(text)
plt.matshow(cm) plt.title('Confusion matrix of the %s classifier' % name) plt.colorbar()
grid_search_no_score.fit(X, y)
with remove_ccx(xblock) as (xblock, restore): return restore(self._modulestore.has_published_version(xblock))
if self.credit_type[0] not in graders: raise LoncapaProblemError('partial_credit attribute should be one of: ' + ','.join(graders))
accept = parse_accept_header(request.META.get("HTTP_ACCEPT", "")) return media_type in [t for (t, p, q) in accept]
return xblock._edited_by
n_samples = len(digits.images) data = digits.images.reshape((n_samples, -1))
self.assertEquals(serializer.data['root'], unicode(self.block_structure.root_block_usage_key))
self.assertEqual(f(None), "0")
for exception_class in [StudentInputError, LoncapaProblemError, ResponseError]:
return 1
if terminal_converter is None: return node else: return terminal_converter(node)
self.assertFalse(self.post.called) self.assertTrue(logger.error.called)
expected_classes = ['Abdelatif Smith', 'Abhati Kepler', 'Onur Lopez'] assert_array_equal(lfw_people.target_names, expected_classes)
return modulestore().db_connection.get_structure( course.location.as_object_id(course.location.version_guid) )
ir = IsotonicRegression(increasing='auto', out_of_bounds="clip") ir.fit(x, y)
cmap_light = ListedColormap(['#FFAAAA', '#AAFFAA', '#AAAAFF']) cmap_bold = ListedColormap(['#FF0000', '#00FF00', '#0000FF'])
assert x.ndim == 4 axes = self.input_space.axes assert len(axes) == 4
queryset = self.model.objects.current_set()
render_args, _ = module.system.render_template.call_args context = render_args[1] self.assertIn(error_msg, context['problem']['html'])
return [ credentials_factories.UserCredential( id=1, username='test', credential=credentials_factories.ProgramCredential() ), credentials_factories.UserCredential( id=2, username='test', credential=credentials_factories.ProgramCredential() ) ]
initial_status = "submitted" VerificationStatus.add_verification_status( checkpoint=self.first_checkpoint, user=self.user, status=initial_status ) VerificationStatus.add_verification_status( checkpoint=self.second_checkpoint, user=self.user, status=initial_status )
assert_array_equal(out, sw_out)
display_name=_("Certificate Web/HTML View Overrides"), help=_("Enter course-specific overrides for the Web/HTML template parameters here (JSON format)"), scope=Scope.settings,
self.register_page = CombinedLoginAndRegisterPage(self.browser, start_page="register") self.dashboard_page = DashboardPage(self.browser)
theano_rng = MRG_RandomStreams(2013*5*4) cost_weights = theano_rng.normal(size=output_conv2d.shape, dtype=output_conv2d.dtype) cost = (cost_weights * output).sum()
verify_name(self.seq_usage_key, self.chapter_usage_key, "customized name", display_name="customized name")
if num_violations > violations_limit > -1: raise BuildFailure( "JSHint Failed. Too many violations ({count}).\nThe limit is {violations_limit}.".format( count=num_violations, violations_limit=violations_limit ) )
ind -= total
return self._grade_answers(None)
DIRECT_ONLY_CATEGORIES = ['course', 'chapter', 'sequential', 'about', 'static_tab', 'course_info']
'cache_toolbox.middleware.CacheBackedAuthenticationMiddleware', 'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
reset_queries()
sample_weight = compute_sample_weight(None, y) assert_array_almost_equal(sample_weight, [1., 1., 1., 1., 1., 1., 1.])
REQUIRE_STANDALONE_MODULES = {}
brc4 = Birch(threshold=10000.) assert_warns(UserWarning, brc4.fit, X)
X_homo = X + sigma * rng.randn(n_samples, n_features)
with self.assertNumQueries(0): self._assert_group_assignment(user, VerificationPartitionScheme.ALLOW)
clf = MockClassifier() grid_search = GridSearchCV(clf, {'foo_param': [1]}) grid_search.fit(X, y) assert_true(hasattr(grid_search, "grid_scores_"))
assert_array_equal(est.oob_improvement_[-10:] == 0.0, np.zeros(10, dtype=np.bool))
reload(sklearn.qda) return sklearn.qda
assert x.ndim == 4 axes = self._input_space.axes assert len(axes) == 4
for name in ALL_TREES: yield check_min_weight_fraction_leaf, name, "iris"
self.params_on_monitor = np.asarray(model.get_param_values())
request = api.create_credit_request(self.course_key, self.PROVIDER_ID, self.USER_INFO["username"]) self.assertEqual(request["parameters"]["user_country"], "")
with self.store.branch_setting(ModuleStoreEnum.Branch.draft_preferred, course.id): course.enrollment_domain = domain self.store.update_item(course, self.test_user_id)
site_configuration_history = SiteConfigurationHistory.objects.filter( site=site_configuration.site, ).all()
rval = np.transpose(rval, tuple(self.axes.index(axis) for axis in ('b', 0, 1, 'c')))
return self._folds[0][-1].get_output_space()
pass
Y = np.clip(y_pred, eps, 1 - eps)
self.assertEqual(XBlockDisableConfig.disabled_create_block_types(), ['poll', 'survey'])
ADVANCED_SECURITY_CONFIG = {}
import argparse import gc import logging import os
if not settings.FEATURES.get('EMBARGO'): raise MiddlewareNotUsed()
with warnings.catch_warnings(record=True): regressor_1 = Regressor() regressor_2 = Regressor() set_testing_parameters(regressor_1) set_testing_parameters(regressor_2) set_random_state(regressor_1) set_random_state(regressor_2)
params_wrong_amt = params.copy() params_wrong_amt['ccAuthReply_amount'] = '1.00' with self.assertRaises(CCProcessorWrongAmountException): payment_accepted(params_wrong_amt)
sparse_results = sparse_classifier.predict(X_test_sparse) dense_results = dense_classifier.predict(X_test) assert_array_equal(sparse_results, dense_results)
self.assertNotIn(self.student_name, self.certificates_section.last_certificate_invalidation.text) self.assertNotIn(notes, self.certificates_section.last_certificate_invalidation.text)
'ENABLE_VIDEO_BUMPER': False,
if xmodule_runtime is None: xmodule_runtime = ModuleSystemFactory() self.xmodule_runtime = xmodule_runtime
self.course_nav.q(css='select option[value="{}"]'.format('blue')).first.click()
return self.metric == 'precomputed'
AssetBaseUrlConfig.objects.create(enabled=True, base_url='fakecdn.edx.org') expected_cdn_url = "//fakecdn.edx.org" + expected_path_start
CourseEnrollment.enroll(self.user, self.course_key, mode="verified")
EmptyPromise( lambda: cohort_name == cohort_management_page.get_selected_cohort(), "Waiting for new cohort" ).fulfill() cohort_management_page.add_students_to_selected_cohort([student])
fig = plt.figure(figsize=(9, 8))
response = requests.get(self._get_url("api/v1/search")) self.assertEqual(response.status_code, 400)
return self.q(css='.bookmarks-results-header').text[0]
input_box = self.student_email_input.first.results[0] input_box.send_keys(email_addres)
pass
return 'is-disabled' not in self.q(css=css).attrs('class')[0]
print('Loading model...') model = serial.load(model_path) model.set_batch_size(m) return model
X = (X - self.X_mean) / self.X_std
return self._is_element_visible(".response_{} .edit-post-body".format(response_id))
purchased_callback.assert_called_with()
assert (niter > 1) == (len(dbm.hidden_layers) > 1)
output['texture_id'][i] = textid output['texture_pos'][i] = (px, py)
return self.delete_student_state_button.click()
if not kwargs.get('no_django', False): kwargs['lookup'] = edxmako.LOOKUP['main'] super(Template, self).__init__(*args, **kwargs)
value = int(value)
title = ugettext_noop("Textbooks") is_collection = True is_default = False
return self.q(css='input[name=problem-grade-report]')
return remove_root(root, sorted(glob2.glob('{root}/{glob}'.format(root=root, glob=glob))))
cat = [True, True, True] _check_one_hot(X, X2, cat, 5)
leaf_indices = clf.apply(X) assert_equal(leaf_indices.shape, (len(X), clf.n_estimators))
return super(PaymentFakeView, self).dispatch(*args, **kwargs)
__, encoded_from_addr = forbid_multi_line_headers('from', from_addr, 'utf-8')
lookup_tag = inputtypes.registry.get_class_for_tag
for _ in range(3): uninstalled = False frozen = sh("pip freeze", capture=True)
resp = self.create_xblock(parent_usage_key=self.seq_usage_key, category='problem', boilerplate='multiplechoice.yaml') self.problem_usage_key = self.response_usage_key(resp)
complex_value_list = [] v_value = value while isinstance(v_value, dict): v_key = v_value.keys()[0] v_value = v_value.values()[0] complex_value_list.append(v_key)
n_leaves = n_samples children = [c[::-1] for c in children]
raise NotImplementedError()
assert choice_type in group_element_names group_element = etree.Element(group_element_names[choice_type])
group_id = get_cohort_id(request.user, course_key)
url_path = "settings/grading" def is_browser_on_page(self): return self.q(css='body.grading').present
resource = {"id": resource_id} edited_recommendations = { key: value + " edited" for key, value in self.test_recommendations[self.resource_id].iteritems() } resource.update(edited_recommendations) return resource
X = np.sort(5 * np.random.rand(40, 1), axis=0) y = np.sin(X).ravel()
query = self.q(css='.ui-loading-indicator') return query.present and 'is-hidden' not in query.attrs('class')[0].split()
trainer = yaml_parse.load(test_yaml_layer0 % {'layer0_filename': layer0_filename}) trainer.main_loop()
n, p, k = 10, 5, 3 rng = np.random.RandomState(0)
if not user.is_authenticated(): return HttpResponseForbidden()
C = np.array([[0., -0.7], [3.5, .7]]) stretched_gaussian = np.dot(np.random.randn(n_samples, 2), C)
if not is_configured("python"): raise SkipTest
return dataset.y.mean(axis=0)
if block.fields[field_name].is_set_on(block): return getattr(block, field_name) else: return default_value
self.assertFalse(mock_push_update.called)
X -= X.min() - .1 y_names = np.array(["one", "two", "three"])[y]
n_expected = combinations(n_population, n_samples, exact=True)
valid_file = TemporaryFile() test_file = TemporaryFile()
whitelist = self.cleaned_data["whitelist"] return self._valid_ip_addresses(whitelist)
return ContainerPage(self.browser, self.locator).visit()
if dot_models.Application.objects.filter(client_id=self._get_client_id(request)).exists(): return self.dot_adapter else: return self.dop_adapter
mathjax_container = self.q(css="div.problem p .MathJax_SVG") return mathjax_container.visible and mathjax_container.present
for static_dir in STATICFILES_DIRS: try: _, data_dir = static_dir except ValueError: data_dir = static_dir
FEATURES['ENABLE_TEAMS'] = True
self.assertEqual(response.status_code, 404) if error_type: self.assertEqual(response.data, error_type.to_json())
'config_models',
'openedx.core.djangoapps.api_admin',
with self.assertRaises(ValueError): self.runtime.service(self.mock_block, 'user_tags').set_tag('fake_scope', self.key, set_value)
return xblock._edit_info.get('edited_on')
def from_json(self, value): if value in ("", "true"): return RANDOMIZATION.ALWAYS elif value == "false": return RANDOMIZATION.PER_STUDENT return value to_json = from_json
assets, count = content_store.get_all_content_for_course(course.id) self.assertEqual(count, 2)
self.assertNotIn(REG_STR, resp.content)
if use_svd: v = svd(Xi, full_matrices=True)[0] else: Ci = np.dot(Xi, Xi.T) v = eigh(Ci)[1][:, ::-1]
mock_model_log_exception.assert_called_once_with( 'Error sending API user notification email for request [%s].', self.api_access_request.id ) self.assertEqual(self.api_access_request.status, ApiAccessRequest.APPROVED)
if self.restricted.filter(user=student).exists(): cert.status = status.restricted cert.save()
return self.child_at(index)
self.assertEqual( info['blocks'], [[reverse_usage_url('container_handler', vertical2.location), 'notes problem in vert2']] )
self.all_verticals = [] self.all_units = []
LOGGER.info(u"Retrieved {num_rows} records.".format(num_rows=row_count))
raise AccessListFallback
attempt_3.mark_ready() assert_equals(attempt_3, SoftwareSecurePhotoVerification.active_for_user(user))
world.css_click(".mce-i-none")
X, y = iris.data, iris.target.astype(np.float64) n_samples, n_features = X.shape n_classes = len(np.unique(y))
return course_metadata_utils.course_start_date_is_default( self.start, self.advertised_start, )
user_country_from_ip = _country_code_from_ip(ip_address)
params = { 'enrollment_action': 'enroll', 'course_id': unicode(self.course.id) } self.client.post(reverse('change_enrollment'), params)
self.q(css=self._bounded_selector(".check-all-inline-discussions")).first.click()
BULK_EMAIL_JOB_SIZE_THRESHOLD = 100
response = self.client.post(self.send_mail_url, test_email) self.assertEquals(json.loads(response.content), self.success_content)
for module in module_store.modules[course_id].itervalues(): if module.location.category == parent_category: parents.append(module)
X = [[0, 1], [1, 0]] for n_components in [-1, 0, .99, 3]: assert_raises(ValueError, IncrementalPCA(n_components, batch_size=10).fit, X)
payload = json.dumps({ 'children': None, 'data': handouts_html, 'id': self._handouts_loc, 'metadata': dict(), })
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(message)s')
if correct: style = QUESTION_HINT_CORRECT_STYLE else: style = QUESTION_HINT_INCORRECT_STYLE
edx_user = User(username=self.edx_user_id) edx_user.save() lti_user = LtiUser( lti_consumer=self.lti_consumer, lti_user_id=self.lti_user_id, edx_user=edx_user ) lti_user.save() return lti_user
authentication_classes = (OAuth2Authentication, SessionAuthentication) permission_classes = (permissions.IsAuthenticated,) serializer_class = CourseTeamSerializer
if not organizations_enabled(): return None from organizations import api as organizations_api from organizations.exceptions import InvalidOrganizationException try: return organizations_api.get_organization_by_short_name(organization_short_name) except InvalidOrganizationException: return None
sh("NO_EDXAPP_SUDO=1 EDX_PLATFORM_SETTINGS_OVERRIDE={settings} /edx/bin/edxapp-migrate-{system} --traceback --pythonpath=. {fake}".format( settings=settings, system=system, fake=fake))
if self.algorithm not in ('SAMME', 'SAMME.R'): raise ValueError("algorithm %s is not supported" % self.algorithm)
assert_raises(ValueError, neighbors.NearestNeighbors, algorithm='blah')
return None if self._is_anonymous(obj) else obj["username"]
mock_init.side_effect = Exception response = get_credit_provider_display_names(self.course_key) self.assertTrue(mock_init.called) self.assertEqual(response, None)
redirect_url = answers['_redirect_url'] if '_redirect_url' in answers else reverse('dashboard')
MIGRATION_MODULES = { 'social.apps.django_app.default': 'social.apps.django_app.default.south_migrations' }
x_weights = np.dot(X.T, y_score) / np.dot(y_score.T, y_score)
templates_path = ['.templates']
self.assertIn("Error", resp.content)
assert_greater(clf.score(X_test, y_test), 0.99)
log.error('PhotoVerification: Error parsing this error message: %s', self.error_msg) return _("There was an error verifying your ID photos.")
for i, A in enumerate(Z.transpose(0, 2, 1)):
trainset = ToyDataset() testset = ToyDataset() return trainset, testset
self.blank_lines += 1 del self.tokens[0]
SurveyAnswer.objects.filter(form=self, user=user).delete()
greek.append('hbar')
course_honor_mode = CourseMode.mode_for_course(self.course.id, 'honor')
self.assertFalse(self._is_location_published(self.problem_usage_key))
for field_name in ["display_name", "weight"]: self.problem_in_course.fields[field_name].delete_from(self.problem_in_course)
context = self._get_sample_plain_context() context['course_image_url'] = "/location/of/course/image/url" return context
self.Xt = numpy.zeros([self.n_eigen + self.minibatch_size, self.n_dim])
space, source = data_specs if isinstance(space, CompositeSpace): sub_spaces = space.components sub_sources = source else: sub_spaces = (space,) sub_sources = (source,)
self.wait_for_field(field_id) query = self.q(css='.u-field-{} .u-field-title'.format(field_id)) return query.text[0] if query.present else None
if not organizations_enabled(): return None from organizations import api as organizations_api return organizations_api.add_organization(organization_data=organization_data)
provider = None
mock_problem_key = Mock(return_value=u'') mock_problem_key.course_key = self.course_key with patch.object(UsageKey, 'from_string') as patched_from_string: patched_from_string.return_value = mock_problem_key
if isinstance(module, DiscussionDescriptor) and 'discussion_id' not in items: items['discussion_id'] = module.discussion_id
X = X.copy('F')
task_type = 'detailed_enrollment_report' task_class = enrollment_report_features_csv task_input = {} task_key = "" return submit_task(request, task_type, task_class, course_key, task_input, task_key)
self.row_uncovered[:] = True self.col_uncovered[:] = True
self.assert_enrollment_activation(False, CourseMode.VERIFIED)
def f(x): x = x.ravel()
item = self.cart.orderitem_set.all().select_subclasses()[0] self.assertEquals(item.unit_cost, self.get_discount(self.cost))
assert_array_equal(clf.predict([[0.2, -1.0]]), np.array([-1]))
cost = sum(costs) model_terms = sum([param.sum() for param in model.get_params()]) cost = cost * model_terms return cost
EmptyPromise( lambda: cohort_name == cohort_management_page.get_selected_cohort(), "Waiting for new cohort" ).fulfill() cohort_management_page.add_students_to_selected_cohort([student])
copy_X = self.copy_X and self.fit_intercept
return False
assert_roundtrip("12345678901234561234567890123456123456789012345601") assert_roundtrip("")
if 'custom_check' in self.text_customization:
asset_deprecated = None ssck_deprecated = None
([TestTransformer1(), TestTransformer2()], []),
course_id = self.course.id self.assertRaises(ValueError, update_course_structure, course_id)
if 'chapters' in textbook: for entry in textbook['chapters']: entry['url'] = remap_static_url(entry['url'], course)
if request.content_type != MergePatchParser.media_type: raise UnsupportedMediaType(request.content_type) return Response(update_thread(request, thread_id, request.data))
'METADATA_URL': 'www.googleapis.com/youtube/v3/videos/',
self.assertEqual(response.status_code, 200)
X = iris.data[:, pair] y = iris.target
x_s = x2[:,offset:offset+size] xWlist.append( W.lmul( x_s.reshape( (n_rows,)+W.col_shape()), T)) offset += size
repr(slo)
UNKNOWN_TASK_ID = 'unknown-task_id' FILTERED_OUT_ROLES = ['staff', 'instructor', 'finance_admin', 'sales_admin'] UPDATE_STATUS_SUCCEEDED = 'succeeded' UPDATE_STATUS_FAILED = 'failed' UPDATE_STATUS_SKIPPED = 'skipped'
grouping_tag = grouping_tags[test_conditions['input_type']] self.assert_no_xpath(xml, "//{0}[@class='choicetextgroup_incorrect']".format(grouping_tag), self.context)
call_command('manage_group', TEST_GROUP) self.check_groups([TEST_GROUP]) self.check_permissions(TEST_GROUP, [])
used_all_attempts = CapaFactory.create(showanswer='past_due', max_attempts="1", attempts="1", due=self.tomorrow_str) self.assertFalse(used_all_attempts.answer_available())
metadata_translations = { 'slug': 'url_name', 'name': 'display_name', }
ccx = CcxFactory(course_id=self.course.id, coach=self.coach) ccx_locator = CCXLocator.from_course_locator(self.course.id, unicode(ccx.id))
w, h, d = original_shape = tuple(china.shape) assert d == 3 image_array = np.reshape(china, (w * h, d))
CourseUserGroupPartitionGroup( course_user_group=cohort, partition_id=partition_id, group_id=group_id, ).save()
self.check_event_response_by_key( 'handle_vote', resource, 'newVotes', test_case['new_votes'], self.XBLOCK_NAMES[1] )
notes = deepcopy(self.notes) notes.reverse() return notes
ORA2_FILE_PREFIX = ENV_TOKENS.get("ORA2_FILE_PREFIX", ORA2_FILE_PREFIX)
detached_locations = [ course_id.make_usage_key('static_tab', 'StaticTab'), course_id.make_usage_key('course_info', 'updates'), ]
get_request_dict = {CapaFactory.input_key(): '3.14'} result = module.check_problem(get_request_dict)
self.assertEquals(3, self.response.content.count('grade_B'))
output = f(np.transpose(self.image, map_to_another_axes)) output_def = np.array(f_def(self.image)) output = np.transpose(output, map_to_default)
FEATURES = { 'DISPLAY_DEBUG_INFO_TO_STAFF': True,
transcripts_utils.generate_subs_from_source(youtube_subs, 'SRT', srt_filedata, self.course)
store_outcome_parameters(params, request.user, lti_consumer)
if settings.DEBUG or settings.FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'): admin.autodiscover()
from __future__ import unicode_literals
'django.contrib.admin',
enrolled = CourseEnrollment.objects.users_enrolled_in(course_id=course_id).values_list('email', flat=True) return CourseEnrollmentAllowed.objects.filter(course_id=course_id).exclude(email__in=enrolled)
self.__manager = None
self._assertion_errors.append(formatted_exc)
world.browser.driver.get(url) assert_equal(world.css_text('body'), expected_text)
return _vote_or_unvote(request, course_id, cc.Thread.find(thread_id), undo_vote=True)
MIGRATION_MODULES = {}
self.assertEqual(result['success'], 'correct')
if val_video_urls["youtube"]: youtube_streams = "1.00:{}".format(val_video_urls["youtube"])
return u''.join(filter(None, parts))
env_fail_fast_set = ( 'TESTS_FAIL_FAST' in os.environ and os.environ['TEST_FAIL_FAST'] )
group = RandomUserPartitionScheme.get_group_for_user( self.MOCK_COURSE_ID, self.user, self.user_partition, assign=False )
from openedx.core.lib.block_structure.factory import BlockStructureFactory from xmodule.modulestore.tests.django_utils import ModuleStoreTestCase from xmodule.modulestore.tests.factories import SampleCourseFactory
form = self.FORM_CLASS(self.form_data, initial=getattr(self, 'initial', None)) self.assertEqual(form.is_valid(), expected_valid) return form
with self.assertRaisesRegexp(ValueError, r"(?i)course not found"): perform_delegate_email_batches(entry.id, course_id, task_input, "action_name")
raise NotImplementedError
likelihood = (i * likelihood + x_likelihood) / (i + batch_size0)
course_id = serializers.CharField(source='id', read_only=True)
zero = sympy.Symbol('dotzero') identity = sympy.Symbol('dotidentity')
response['Accept-Ranges'] = 'bytes' response['Content-Type'] = content.content_type
verbose_name_plural = "Microsite histories"
@ddt.data(*flatten(CONTAINER_XMODULES))
self.assertFalse(utils.ancestor_has_staff_lock(self.orphan))
return OrderItemSubclassPK(type(self), self.pk)
chisq = f_obs chisq -= f_exp chisq **= 2 chisq /= f_exp chisq = chisq.sum(axis=0) return chisq, special.chdtrc(k - 1, chisq)
response = self._regenerate( course_key=self.CERT_COURSE_KEY, username=self.STUDENT_USERNAME ) self.assertEqual(response.status_code, 200)
cloned = clone(self) cloned.theta = theta return cloned
xml = etree.fromstring(expr) xml = self.formulaInstance.preprocess_pmathml(xml) test = etree.tostring(xml)
if not organizations_enabled(): return [] from organizations import api as organizations_api return organizations_api.get_course_organizations(course_id)
sh("i18n_tool transifex pull")
self.pdf.drawString(horizontal_padding_from_border, y_pos,
self.assertEquals( preview.latex_preview('-x+2-3+4', variables=['x']), '-x+2-3+4' )
if 0 < passed_index <= len(course_update_items): course_update_item = course_update_items[passed_index - 1] course_update_item["status"] = CourseInfoModule.STATUS_DELETED course_update_items[passed_index - 1] = course_update_item
self.cohort_management_page.select_discussion_topic(self.inline_key)
self.assertTrue(EmbargoedCourse.is_embargoed(course_id)) self.assertEquals( unicode(cauth), u"Course '{course_id}' is Embargoed".format(course_id=course_id) )
packages_sources={} installed_packages_list={}
thread_context = getattr(thread, "context", "course") if thread_context == "course" and not utils.discussion_category_id_access(course, request.user, discussion_id): raise Http404
P3P_HEADER = 'CP="Open EdX does not have a P3P policy."'
if self.key_betas is not None and \ ki < len(self.key_betas) and \ bp1 == self.key_betas[ki]:
matched_buttons = [btn for btn in buttons if btn.text == component_type]
try: WindowsError except NameError: WindowsError = None
return self.design_mat_to_topo_view(design_mat)
('defunct-paying', 'defunct-paying'),
columns_index = [8, 7, 2, 3, 4, 5, 6, 1, 0] cal_housing = cal_housing[:, columns_index] joblib.dump(cal_housing, filepath, compress=6)
self.assertTrue(mock_audit_log.called)
cluster_ids, mu = milk.kmeans(X, k)
if mp is not None: try: from multiprocessing.context import assert_spawning except ImportError: from multiprocessing.forking import assert_spawning else: assert_spawning = None
self.submit_question_answer('H1P1', {'2_1': 'Correct', '2_2': 'Incorrect'})
assert_less(np.sqrt(np.mean((X_iso - X_iso2) ** 2)), 2 * noise_scale)
DEFAULT_DELAY_SEC = 0.5
cls.coach = AdminFactory.create()
from pylearn2.utils import utlc
self._credit_provider_callback(request_uuid, 'approved') self._assert_request_status(request_uuid, "approved")
func = with_comprehensive_theme(EDX_THEME_DIR)(func)
before_finders = list(settings.STATICFILES_FINDERS) before_dirs = list(settings.STATICFILES_DIRS)
assert_array_almost_equal(np.sum(tf, axis=1), [1.0] * n_train)
return json.loads(response.content)
if username is None: username = requesting_user.username try: existing_user = User.objects.get(username=username) except ObjectDoesNotExist: raise UserNotFound() _check_authorized(requesting_user, username, allow_staff) return existing_user
le = LabelEncoder() if isinstance(class_weight, dict) or multi_class == 'multinomial': class_weight_ = compute_class_weight(class_weight, classes, y) sample_weight *= class_weight_[le.fit_transform(y)]
assert_array_almost_equal(x_rotations_sign_flip, x_weights_sign_flip) assert_array_almost_equal(np.abs(x_rotations_sign_flip), 1, 4) assert_array_almost_equal(np.abs(x_weights_sign_flip), 1, 4)
self._check_grade_response(callback_url, expected_header, json.dumps(response_content))
model1 = clf.fit(X, Y[:, 0]).coef_ model2 = clf.fit(X, Y[:, :1]).coef_ assert_array_almost_equal(model1, model2)
attempt = SoftwareSecurePhotoVerification.objects.get(user=self.user) self.assertEqual(attempt.status, "submitted")
rng = np.random.RandomState(0) n_features = 5 n_samples = 4 X = rng.randn(n_samples, n_features)
if isinstance(course.id, CCXLocator): return False
with patch('capa.correctmap.CorrectMap.is_correct') as mock_is_correct: mock_is_correct.return_value = False
assert_array_equal(X, Xdigits)
actual_events = self.wait_for_events(event_filter={'event_type': event_type}, number_of_matches=1) self.assert_events_match(event_data, actual_events)
response = self.client.get(choose_track_url) self.assertRedirects(response, reverse('dashboard'))
return self.load_item(usage_id, for_parent=for_parent)
pass
self.cohort_management_page.select_cohort_some_inline_discussion()
self._assert_num_requests(1)
self.user_partition.scheme.current_group = groups[0] group1 = self.partition_service.get_group(self.user_partition) self.assertEqual(group1, groups[0])
testing.assert_array_equal(F.transform(X), np.around(X, decimals=1))
fraction_mode_ever = True position = "denominator"
msg = "0 feature(s) (shape=(1, 0)) while a minimum of 1 is required." assert_raise_message(ValueError, msg, check_array, [[]])
self.assert_enrollment_status()
response = self._load_dashboard() self.assertContains(response, "credit-request-pending-msg")
element_css = self.BOTTOM_ADD_SECTION_BUTTON if click_child_icon: element_css += " .fa-plus" click_css(self, element_css)
assert_raise_message(NotFittedError, "This GaussianMixture instance is not fitted " "yet. Call 'fit' with appropriate arguments " "before using this method.", g.predict, X)
self.add_team_configuration(max_team_size=4, topics=[self.make_topic()]) self.assertTrue(self.course.teams_enabled)
user_partititons = self.course.user_partitions self.assertEqual(len(user_partititons), 1) self.assertEqual(user_partititons[0].name, 'Name 1')
y_true, pred, probas_pred = make_prediction(binary=True)
return self.client.post(url, post_args)
assert_raises(ValueError, sel.transform, np.array([[1], [2]]))
if all((ky,kx) >= topleft) and all((ky,kx) < botright):
HOSTNAME_MODULESTORE_DEFAULT_MAPPINGS = { 'preview\.': 'draft-preferred' }
updated_deadline = VerificationDeadline.deadline_for_course(self.course.id) self.assertEqual(updated_deadline, new_deadline)
for field in InheritanceMixin.fields.values(): if field.is_set_on(descriptor): parent_metadata[field.name] = field.read_json(descriptor)
good_lines = [line for line in text.split('\n') if not _QUOTE_RE.search(line)] return '\n'.join(good_lines)
clusterer = KMeans(n_clusters=n_clusters, random_state=10) cluster_labels = clusterer.fit_predict(X)
copy = copy if copy is not None else self.copy X = check_array(X, accept_sparse='csr') return normalize(X, norm=self.norm, axis=1, copy=copy)
'track', 'eventtracking.django.apps.EventTrackingConfig',
return upload_file.size
y_true, y_pred, _ = make_prediction(binary=True)
return Fragment(self.get_html())
return getattr(problem_class, 'human_name', problem_class.__name__)
user1_new_email = "valid_user1_email@example.com" user2_new_email = "valid_user2_email@example.com"
with check_mongo_calls(0): CourseOverview.get_from_id(course.id)
max_scores_cache.push_to_remote()
text = "J'ai mang\xe9 du kangourou ce midi, c'\xe9tait pas tr\xeas bon." text_bytes = text.encode('utf-8')
return cache_and_return(Location._from_deprecated_son(parents[0]['_id'], location.course_key.run))
assert_raises(ValueError, plot_partial_dependence, clf, X, ['foobar'])
if context is None: context = self.serializer_context return BlockDictSerializer( context['block_structure'], many=False, context=context, )
if len(all_assets) > 0: self.store.save_asset_metadata_list(all_assets, all_assets[0].edited_by, import_only=True)
for block_key_string, serialized_block in serializer.data['blocks'].iteritems(): self.assertEquals(serialized_block['id'], block_key_string) self.assert_basic_block(block_key_string, serialized_block)
block = self.store.get_item(block_location) self.assertEqual(block.merged_group_access, expected_dict)
subject = ''.join(subject.splitlines()) from_address = theming_helpers.get_value( 'email_from_address', settings.DEFAULT_FROM_EMAIL )
weight_cdf = sample_weight[sorted_idx].cumsum() percentile_idx = np.searchsorted( weight_cdf, (percentile / 100.) * weight_cdf[-1]) return array[sorted_idx[percentile_idx]]
clf = NearestCentroid() clf.fit(X_csr.tocoo(), y) assert_array_equal(clf.predict(T_csr.tolil()), true_result)
lazy.invalidate(library_descriptor, '_unwrapped_field_data') library_descriptor._field_data = inheriting_field_data(InheritanceKeyValueStore(init_dict))
COMPONENT_TYPES = ['discussion', 'html', 'problem', 'video']
bt1_pyfunc = BallTree(X, metric=dist_func, leaf_size=1, p=2)
request = args[0] request.META['CROSS_DOMAIN_CSRF_COOKIE_USED'] = True
self.configuration = GroupConfiguration.parse(json_string) self.course = course self.assign_id(configuration_id) self.assign_group_ids() self.validate()
CourseEnrollment.unenroll(self.student, self.CERT_COURSE_KEY)
X_, y_ = make_classification(n_samples=200, n_features=100, random_state=0)
delete_course_and_groups(course_id, self.user.id)
response = self.client.get(self.url) self.assertNotIn(self.email_modal_link, response.content)
return self._generate_cert(cert, course, student, grade_contents, template_pdf, generate_pdf)
self.assertAlmostEqual( -0.28, calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False), delta=1e-3 )
self.assertEqual(self.cohort1.name, response_dict.get("name"))
self.kvs = kvs self.session = session self.session_data = session.setdefault(MASQUERADE_DATA_KEY, {})
return has_studio_write_access(self._user, course_key)
module = get_module( user, request, problem.scope_ids.usage_id, field_data_cache, )._xmodule module.system.publish(problem, 'grade', grade_dict)
validator_data["storage"] = storage validator_data["filename"] = filename verify_file_presence(True)
ForestClassifier = FOREST_CLASSIFIERS[name]
for library in store.get_libraries(**kwargs): library_id = self._clean_locator_for_mapping(library.location) if library_id not in libraries: libraries[library_id] = library
X = make_low_rank_matrix(n_samples=n_samples, n_features=n_features, effective_rank=rank, tail_strength=1.0, random_state=0) assert_equal(X.shape, (n_samples, n_features))
if n_iter > 0: ss = ((prev_alpha[0] - alpha_min) / (prev_alpha[0] - alpha[0])) coef[:] = prev_coef + ss * (coef - prev_coef) alpha[0] = alpha_min
with self.assertRaises(ItemNotFoundError): self.store.get_item(self.writable_chapter_location)
problem = self.build_problem( choice_type='checkbox', choices=[False, False, True, True], credit_type='edc' )
trainer = yaml_parse.load(load_all_yaml % {'filename': filename}) trainer.main_loop()
([
n_estimators_per_job = (n_estimators // n_jobs) * np.ones(n_jobs, dtype=np.int) n_estimators_per_job[:n_estimators % n_jobs] += 1 starts = np.cumsum(n_estimators_per_job)
if len(User.objects.filter(username=uname)) > 0: return
store = self._get_modulestore_for_courselike(course_key) if hasattr(store, method): return store else: raise NotImplementedError(u"Cannot call {} on store {}".format(method, store))
result = symmath_check(expected_str, input_str, dynamath=[dynamath]) self.assertTrue('ok' in result and result['ok'])
y_subsample = y[indices, k] classes_subsample = np.unique(y_subsample)
return self._num_batches
cookie = self.client.cookies[settings.EDXMKTG_USER_INFO_COOKIE_NAME] user_info = json.loads(cookie.value)
self._make_draft_content_different_from_published()
assert len(course_assets['assets']) == 0 self.asset_collection.update( {'_id': doc_id}, {'$set': {'assets': {}}} )
return StudentModule.objects.get(pk=self.student_module_id)
self.assert_enrollment_status(as_server=True, mode=selected_mode)
draft_xblock = self.store.get_item( self.vertical_x1a, revision=ModuleStoreEnum.RevisionOption.draft_only ) self.assertIsNotNone(draft_xblock)
if block_type == 'html': self.assertElementAttrsSubset(element, {'filename': filename})
self.browser.refresh() profile_page.wait_for_page() self.verify_profile_page_is_public(profile_page)
self._load_page(access_point, 'default')
result = defaultdict(dict) for field in xblock.fields.itervalues(): if field.is_set_on(xblock): result[field.scope][field.name] = field.read_from(xblock) return result
redirect_uri = super(ExceptionMiddleware, self).get_redirect_uri(request, exception)
func_code_h = hash(getattr(self.func, '__code__', None)) return id(self.func), hash(self.func), func_code_h
y = 0.5 * X.ravel()
errstring = "Invalid location string" with self.assertRaisesRegexp(CommandError, errstring): self.command.handle("foo", "bar")
raise NotImplementedError( "get_html() must be provided by specific modules - not present in {0}" .format(self.__class__))
dtype = dtype[0]
n_labels = 15 n_samples = 1000 n_folds = 5
attach_file(filename, sub_path) modal_css = 'div.wrapper-modal-window-assetupload' button_css = '{} .action-upload'.format(modal_css) world.css_click(button_css)
dataset = datasets.load_iris() X = dataset.data
self.student_answers = convert_files_to_filenames(answers) return self._grade_answers(answers)
return self.q(css=self.search_results_selector)
TEST_DIR = path(__file__).dirname() TEST_DATA_DIR = 'common/test/data/' PLATFORM_ROOT = TEST_DIR.parent.parent.parent.parent TEST_DATA_ROOT = PLATFORM_ROOT / TEST_DATA_DIR
tid = random.choice(string.digits) + tid
assert_raise_message(ValueError, msg, check_X_y, X, y, ensure_min_features=3, allow_nd=True)
#html_logo = 'images/theano_logo-200x67.png' #html_logo = 'images/theano_logo_allblue_200x46.png'
self.t_ = None
if settings.FEATURES.get('ENABLE_OAUTH2_PROVIDER'): urlpatterns += ( url( r'^oauth2/login/$', auth_exchange.views.LoginWithAccessTokenView.as_view(), name="login_with_access_token" ), )
if self.backward: self.setup_response_backward() return
modulestore = MockModulestore() modulestore.set_blocks({ block_key: MockXBlock(block_key, children=children, modulestore=modulestore) for block_key, children in enumerate(children_map) }) return modulestore
self.get_readlock(local_name) self.release_writelock()
import warnings import operator import sys import time
about = branding_api.get_about_url() if about != branding_api.EMPTY_URL: data.update({'company_about_url': about})
if name == 'due': return None if name == 'start' and block.category != 'course': return None
if not _contents_of_verticals: _contents_of_verticals = [[{'display_name': 'Video', 'metadata': self.metadata}]]
param_grid = ParameterGrid(self.param_distributions) grid_size = len(param_grid)
y[::5] += 1 * (0.5 - np.random.rand(8))
decisions = sum(all_decisions) / self.n_estimators
reqs = CreditRequirement.get_course_requirements(course_key)
VERSION = 0
sample_weight = sample_weight * sample_mask.astype(np.float64)
htmlhelp_basename = 'edxdoc'
return self.q(css='#tabpanel-browse ' + CARD_TITLE_CSS).map(lambda e: e.text).results
resp = self.client.get(self.url_unlocked, HTTP_RANGE=header_value) self.assertEqual(resp.status_code, 200) self.assertNotIn('Content-Range', resp)
return _ENROLLMENT_ATTRIBUTES
time_lapse = time.time() - self.start_time full_msg = "%s: %.2fs, %.1f min" % (msg, time_lapse, time_lapse / 60)
if not is_request_in_microsite(): return return TEMPLATES_BACKEND.get_template(uri)
else: eligibility_status = "partial_eligible"
(['honor', 'verified', 'audit']),
merged_parent_group_ids = set()
module = CapaFactory.create(rerandomize=rerandomize, attempts=0, done=True)
def __init__(self): self.val_record = []
from __future__ import unicode_literals
assert_equal(train.intersection(test), set())
mode = models.CharField(max_length=100, default='', blank=True) image = models.ImageField(upload_to='badge_classes', validators=[validate_badge_image])
ip_address = get_ip(request) if ip_address is not None: return ip_address else: return ''
iris = datasets.load_iris() perm = rng.permutation(iris.target.size) iris.data = iris.data[perm] iris.target = iris.target[perm]
with self.assertRaises(CourseOverview.DoesNotExist): self.store.delete_course(course.id, ModuleStoreEnum.UserID.test) CourseOverview.get_from_id(course.id)
copy = self.get_json(obj["url"]) self.assertEqual(obj, copy)
y_true, y_pred, _ = make_prediction(binary=False)
course = CourseFactory.create( org=org, number=course_number, run=course_run, display_name=display_name, default_store=ModuleStoreEnum.Type.split )
dt = out_array.dtype if output_pixel_vals: dt = 'uint8' out_array[:, :, i] = np.zeros(out_shape, dtype=dt) + \ channel_defaults[i]
self.verify_lists_expected_cohorts([])
_upload_file(en_translation, self.item_descriptor.location, en_translation_filename)
y = 0.5 * X.ravel()
base_json_obj['resultScore'] = round(self.module_score, 2) base_json_obj['comment'] = self.score_comment return Response(json.dumps(base_json_obj), content_type=LTI_2_0_JSON_CONTENT_TYPE)
while stack:
part = dtime.strftime(code)
self.assertTrue(self._search_for_content(self.SEARCH_STRING))
for student in students[:2]: GeneratedCertificateFactory.create( user=student, course_id=self.course.id, status=CertificateStatuses.downloadable, mode='honor', grade=default_grade )
giturl = "" data_dir = ""
results = (course for course in results if course.scope_ids.block_type == 'course')
self.make_course(textbooks=[IMAGE_BOOK]) with self.assertRaises(NoReverseMatch): self.make_url('book', book_index='fooey')
assert X.ndim == 4 return T.nnet.softmax(X.reshape((X.shape[0], self.dim)) * self.P)
request.view_name = view_func.__name__
unrestricted_country, __ = self._setup_embargo()
if self.structure_json: return json.loads(self.structure_json) return None
DonationConfiguration(enabled=True).save()
ishfts = 1 self.mode = mode self.iparam[0] = ishfts self.iparam[2] = maxiter self.iparam[3] = 1 self.iparam[6] = mode
if self.transcripts: for language in self.transcripts.keys(): _update_transcript_for_index(language)
for format in ["binary", "multiclass", "multilabel-indicator"]: for y in EXAMPLES[format]: unique_labels(y)
else: with closing(_gen_open(f)) as f: actual_dtype, data, ind, indptr, labels, query = \ _load_svmlight_file(f, dtype, multilabel, zero_based, query_id)
fake_key = SlashSeparatedCourseKey('a', 'b', 'c') self.assertRaises(Http404, lambda: cohorts.is_course_cohorted(fake_key))
label_to_row_indices = _make_label_to_row_indices(dataset.y)
course_fix = CourseFixture( self.course_info['org'], self.course_info['number'], self.course_info['run'], self.course_info['display_name'] )
if key.field_name not in aside_fields: self._load_definition()
self._each_parens(r'\left[x^y\right]', 'x^y', '[', tall=True)
duration = video_data.get('duration', None) size = default_encoded_video.get('file_size', 0)
self.fed.append(data)
MESSAGE = _( 'Non usable git url provided. Expecting something like:' ' git@github.com:mitocw/edx4edx_lite.git' )
admin = AdminFactory()
new_course_key = self.course_key.replace(course=self.course_key.course.upper()) resp = self._create_course_with_given_location(new_course_key) self.assertEqual(resp.status_code, 200)
eligibilities = api.get_eligibilities_for_user("staff") self.assertEqual(eligibilities, [])
pass
self.wait_for( lambda: len(self.q(css='.team-card')) == expected_count, description="Expected number of teams is wrong" )
def naive_log_logistic(x): return np.log(1 / (1 + np.exp(-x)))
pred = sum(_samme_proba(estimator, n_classes, X) for estimator in self.estimators_)
C = 1. fit_intercept = True tol = 1.0e-14
if parents.issubset(to_delete): next_tier.add(child_block_key)
self.solar_team.add_user(self.users[user])
add_problem_to_course(world.scenario_dict['COURSE'].number, problem_type, problem_settings)
m = Memory(cachedir=lfw_home, compress=6, verbose=0) load_func = m.cache(_fetch_lfw_pairs)
XBLOCK_SETTINGS = { "VideoDescriptor": { "licensing_enabled": True } }
attempt = self.create_and_submit() assert_equals(attempt.status, "submitted")
'openedx.core.djangoapps.theming',
pass
if isinstance(space, VectorSpace) and space.sparse: del kwargs["batch_size"]
new_block.graceperiod = timedelta(1) self.store.update_item(new_block, self.user.id)
raise NotImplementedError('Not implemented in _PCABase. Use a ' + 'subclass (and implement it there).')
self._export_import_course_round_trip( self.store, contentstore, source_course_key, self.export_dir )
try: manual_enrollment = cls.objects.filter(enrollment=enrollment).latest('time_stamp') except cls.DoesNotExist: manual_enrollment = None return manual_enrollment
return False
key = self.q(css=KEY_CSS).nth(i).text[0] if key == expected_key: return i
donation = Donation.objects.get(pk=donation.id) self.assertEqual(donation.status, "purchased")
if isinstance(obj, Promise): return force_text(obj) super(LocalizedJSONEncoder, self).default(obj)
info_log.assert_called_with('email sent to new created user at %s', 'test_student@example.com')
return ''
X = check_array(X, accept_sparse=['csr', 'csc', 'coo'], ensure_min_features=2, estimator=self) return AgglomerativeClustering.fit(self, X.T, **params)
server_thread = threading.Thread(target=self.serve_forever) server_thread.daemon = True server_thread.start()
result = first.copy() result.update(second) return result
assert_raises(ValueError, clf.fit, X, np.ones(len(X)))
from lms.envs.dev import (WIKI_ENABLED)
self.state = state
elem = self.get_setting_element(label) select = Select(elem) select.select_by_value(value)
plt.fill_between(alphas, scores + std_error, scores - std_error, alpha=0.2)
self.wait_for_element_visibility( 'div.certificate-invalidation-container', 'Certificate invalidations section is visible.' ) self.wait_for_element_visibility('#invalidate-certificate', 'Invalidate Certificate button is visible')
for svd in svds: assert_array_less(svd.explained_variance_ratio_.sum(), 1.0)
return Response(status=status.HTTP_204_NO_CONTENT)
above_cutoff = (abs(s) > cond * np.max(abs(s))) psigma_diag = np.zeros_like(s) psigma_diag[above_cutoff] = 1.0 / s[above_cutoff]
num_certs = 0 for cert in refunded_certs: num_certs += 1 self.assertEqual(num_certs, 2)
return self.q(css='.choose-file-button').present
with modulestore().default_store(ModuleStoreEnum.Type.split): course = CourseFactory.create()
global DenseMulticlassSVM skip_if_no_sklearn() skip_if_no_data() import pylearn2.models.svm DenseMulticlassSVM = pylearn2.models.svm.DenseMulticlassSVM
model.dataset = dataset
assert_array_equal(rfe.get_support(), rfe_svc.get_support())
label_to_fold = np.zeros(len(unique_labels))
if opts.all_categories: categories = None else: categories = [ 'alt.atheism', 'talk.religion.misc', 'comp.graphics', 'sci.space', ]
self.get_courseware_page() self.assertEqual(self.get_progress_detail(), u'2/2')
if self.advertised_start: return self.advertised_start elif self.start != DEFAULT_START_DATE: return defaultfilters.date(self.start, "DATE_FORMAT") else: return None
button_classes = self.q(css=BROWSE_BUTTON_CSS).attrs('class') if len(button_classes) == 0: return False return 'is-active' in button_classes[0]
cache_key = self._cache_key_for_kvs_key(kvs_key) return ( cache_key in self._cache and kvs_key.field_name in self._cache[cache_key] )
settings.STATICFILES_DIRS.append( (u'themes/{}'.format(settings.THEME_NAME), theme_root / 'static') )
mixing = rng.randn(6, 2) m = np.dot(mixing, s)
student = User.objects.prefetch_related("groups").get(id=student.id)
self.video.reload_page()
try: uid_int = base36_to_int(uidb36) user = User.objects.get(id=uid_int) user.is_active = True user.save() except (ValueError, User.DoesNotExist): pass
return re.sub(r'(;;|;_)', _unquote_slashes, text)
self.correct_responses[name] = expect self.incorrect_responses[name] = self.CUSTOM_RESPONSE_INCORRECT
y_true, y_pred, _ = make_prediction(binary=False)
self.assertTrue('Coupon Code List' in response.content)
([], 'honor'),
return [XBlock.tags, XBlock.name]
** blas_info)
course_outline = self.api_response().data course_outline[0]['summary'].pop("id") self.assertEqual(course_outline[0]['summary'], expected_output)
rng = np.random.RandomState(0) x = rng.randint(10, size=(10, 5)) weights = np.ones(x.shape)
assert_almost_equal(s_, np.dot(np.dot(mixing_, k_), m))
with mock_create_refund(status=403): refund_seat(self.course_enrollment, UserFactory()) self.assertTrue(mock_log_warning.called)
if self.optimizer == 'Welch' and self.theta0.size == 1: self.optimizer = 'fmin_cobyla'
self.navigate_to_video() self.assertFalse(self.video.is_button_shown('transcript_button'))
user = cc.User.from_django_user(request.user) thread = cc.Thread.find(thread_id) user.unfollow(thread) return JsonResponse({})
self.assertEqual(len(mail.outbox), 0)
if timed_exam.is_proctored_exam and not timed_exam.is_practice_exam: try: update_review_policy( exam_id=exam_id, set_by_user_id=timed_exam.edited_by, review_policy=timed_exam.exam_review_rules ) except ProctoredExamReviewPolicyNotFoundException:
new_structure = self._lookup_course(xblock.location.course_key).structure
dict(safe_zip(range(5), range(5))),
return graders[self.credit_type[0]]( student_answers=student_answers )
axes = ['b', 0, 1, 'c'] random.shuffle(axes) axes = tuple(axes) print('axes:', axes)
self._upload_file('auto_reg_enrollment_errors_warnings.csv')
avg_weights = None
return self._batch_size(is_numeric=False, batch=batch)
self.get_selector('#generate-exception-certificates').click()
is_valid, errors, updated_data = CourseMetadata.validate_and_update_from_json( course_module, request.json, user=request.user, )
for sys in systems: sh(django_cmd(sys, settings, "collectstatic --noinput > /dev/null")) print("\t\tFinished collecting {} assets.".format(sys))
clf3 = self.factory(alpha=0.01, eta0=0.01, n_iter=5, shuffle=False, warm_start=True, learning_rate=lr) clf3.fit(X, Y)
skip_if_no_sklearn() mapping = {'dataset_iterator': 'StratifiedDatasetKFold'} test_yaml = test_yaml_dataset_iterator % mapping trainer = yaml_parse.load(test_yaml) trainer.main_loop()
return numpy.arccosh(1. / val)
return StaffFactory(course_key=self.course.id)
def argpartition(a, kth, axis=-1, kind='introselect', order=None): return np.argsort(a, axis=axis, order=order)
self.assertTrue(self.video.is_aligned(False))
return self.count
V = rng.rand(n_features, n_features) VI = np.dot(V, V.T)
self.chapter1 = ItemFactory.create( parent_location=self.course.location, category='chapter', display_name='untitled chapter 1' )
published_only = 'rev-opt-published-only'
rval = transform(raw_batch)
wait_for( func=lambda _: css_visible(css_selector, index), timeout=timeout, timeout_msg="Timed out waiting for {} to be visible.".format(css_selector) )
with check_mongo_calls(max_find.pop(0), max_send): with self.assertRaises(ItemNotFoundError): self.store.get_item(self.fake_location)
return transformer.transform(X) * transformer_weights[name]
module.system.user_is_staff = False
parent = self._get_raw_parent_location(as_published(location), ModuleStoreEnum.RevisionOption.draft_preferred) if parent: self._update_single_item(parent, update) self._update_ancestors(parent, update)
chapter = ItemFactory.create(parent_location=self.course.location, display_name=TEST_SECTION_NAME)
self.request.user = self.effective_user
donation_type = models.CharField(max_length=32, default="general", choices=DONATION_TYPES)
self._create_a_timed_exam_and_attempt()
return False
self.assertFalse(self._search_for_content(self.EDITED_SEARCH_STRING))
self.certificates_page.visit() self.assertEqual(len(self.certificates_page.certificates), 0)
[{0: 'a', 1: 'b'}, {0: 'a'}],
self.restricted_course.enroll_msg_key = 'embargo' self.restricted_course.access_msg_key = 'embargo' self.restricted_course.save()
user = UserFactory() user.name = 'mock_user' user.is_staff = is_staff user.is_enrolled = is_enrolled user.is_authenticated = lambda: is_authenticated return user
clf = GradientBoostingRegressor(n_estimators=10, random_state=1) clf.fit(boston.data, boston.target)
FEATURES['MILESTONES_APP'] = True
return grade_request['xqueue_header']
pass
return redirect_with_get('login', request.GET, False)
self.assertEqual( self.course.clean_id(), "course_ORSXG5C7N5ZGOL3UMVZXIX3DN52XE43FF52GK43UL5ZHK3Q=" ) self.assertEqual( self.course.clean_id(padding_char='$'), "course_ORSXG5C7N5ZGOL3UMVZXIX3DN52XE43FF52GK43UL5ZHK3Q$" )
if course_user_group is None: course_user_group, __ = CourseUserGroup.create(cohort_name, course_id) course_cohort, __ = cls.objects.get_or_create( course_user_group=course_user_group, defaults={'assignment_type': assignment_type} ) return course_cohort
self.assertTrue(self.settings_detail.entrance_exam_field)
out = self._str_indent(out,indent) return '\n'.join(out)
self._make_eligible()
self._configure_message_timeout(10000) DonationConfiguration(enabled=True).save()
MISSING = 0 COLLAPSE = 1 EXPAND = 2
self.assertEqual(k_args, tuple()) self.assertEqual( k_kwargs.get('url'), urlparse.urljoin(self.course.ccx_connector, ccxconapi.CCXCON_COURSEXS_URL) )
has_access.return_value = True response = views.all_sequential_open_distrib(self.request, 'test/test/test') self.assertEqual(json.dumps(self.simple_data), response.content)
raise NotImplementedError()
func.__doc__ = doc
CohortFactory(course_id=course.id, name="ManualCohort") CohortFactory(course_id=course.id, name="ManualCohort2")
self.assertTrue(provider_redirect_url.startswith(TESTSHIB_SSO_URL)) return self.client.post( self.complete_url, content_type='application/x-www-form-urlencoded', data=self.read_data_file('testshib_response.txt'), )
filename = sanitize_filename(' '.join(tooltip.split(' ')[3:]))
return "original_get_html"
url( r'^account/', include('student_account.urls') ),
self.assert_field_type(load_video_event, 'time', datetime.datetime) del load_video_event['time']
return self.cleaned_data['return_type'] or 'dict'
self.assertRaises(ItemNotFoundError, lambda: self.draft_store.get_all_asset_metadata(course_key, 'asset')[:1])
self.assertIn( "<script type=\"text/javascript\">function(){}</script>", etree.tostring(rendered_html) )
X = make_low_rank_matrix(n_samples=n_samples, n_features=n_features, effective_rank=rank, tail_strength=0.1, random_state=0) assert_equal(X.shape, (n_samples, n_features))
self._send_handler_response("DELETE")
raw_path = script.get('system_path', '').split(":") + DEFAULT_PATH
bytes_to_pad = AES.block_size - len(data) % AES.block_size return data + (bytes_to_pad * chr(bytes_to_pad))
self.access_token.delete() response = self.post_with_bearer_token('/oauth2-test/') self.check_error_codes( response, status_code=status.HTTP_401_UNAUTHORIZED, error_code=authentication.OAUTH2_TOKEN_ERROR_NONEXISTENT )
if position is not None: try: position = int(position) except (ValueError, TypeError): log.exception('Non-integer %r passed as position.', position) position = None
return ThreadSerializer(thread, context=get_context(self.course, self.request)).data
lr = LogisticRegression() gnb = GaussianNB() svc = LinearSVC(C=1.0) rfc = RandomForestClassifier(n_estimators=100)
product = partial(reduce, operator.mul) return sum(product(len(v) for v in p.values()) if p else 1 for p in self.param_grid)
if course_key.for_branch(None) in self._active_bulk_ops.records: del self._active_bulk_ops.records[course_key.for_branch(None)]
METRICS_WITH_POS_LABEL = [ "roc_curve",
self.update_masquerade(role='student') self.verify_show_answer_present(False)
TEST_DATA_SPLIT_MODULESTORE = functools.partial( mixed_store_config, mkdtemp_clean(), {}, store_order=[StoreConstructors.split, StoreConstructors.draft] )
layer_to_state = dbm.make_layer_to_state(1) v_state = layer_to_state[v] y_state = layer_to_state[y]
instructor_dashboard_page = self.visit_instructor_dashboard() allowance_section = instructor_dashboard_page.select_special_exams().select_allowance_section()
if not any(r for r in trusted_roots if fnmatch.fnmatch(trust_root, r)): log.error('non-trusted root') return False
return self.q(css='.discussion-module .new-post-btn').present
MUTABLE = False
languages_data_folder = sys.argv[1] dataset = load_files(languages_data_folder)
if (not course_enrollment.refundable()) or skip_refund: return
self.client.logout()
print "video {0} url_name: {1}".format(i, video.url_name)
for block_data in block_list: (block_type, block_id) = block_data self.assertOLXMissing(block_type, block_id, draft=True) self.assertOLXMissing(block_type, block_id, draft=False)
return BASE_URL + "/u/" + self.username
lshf = LSHForest(min_hash_match=31) ignore_warnings(lshf.fit)(X_train)
iter_labels = labels if self.multi_class == 'multinomial': iter_labels = [None]
if not all(user_groups.get(partition.id) in groups for partition, groups in partition_groups): return ACCESS_DENIED
#'pointsize': '10pt',
verify_name(self.seq_usage_key, self.chapter_usage_key, "Duplicate of sequential")
safe_cookie_data = SafeCookieData.create( cookies[settings.SESSION_COOKIE_NAME].value, user_id, )
boston = datasets.load_boston() perm = rng.permutation(boston.target.size) boston.data = boston.data[perm] boston.target = boston.target[perm]
return self.build_problem( choices=choices, type=in_type, script=script )
max_scores_cache.fetch_from_remote([location_to_cache]) self.assertIsNotNone(max_scores_cache.get(location_to_cache)) self.check_grade_percent(0.33)
self.mean_ = np.mean(X, axis=0) X -= self.mean_
wtf_numpy = np.zeros((pool_size_1,)) for i in xrange(pool_size_1): wtf_numpy[i] = on_probs[i] on_probs = wtf_numpy
self.go_to_tab_and_assert_problem(1, self.problem1_name)
for course_mode in CourseMode.objects.filter(course_id=self.course.id): course_mode.sku = None course_mode.save()
n_samples = 12 n_features = 2 n_iter = 10 rng = np.random.RandomState(42) X = rng.rand(n_samples, n_features)
def fit(self, X, y): super(CustomSVR, self).fit(X, y) self.data_type_ = type(X) return self
response = self.client.post(update_url, post_data) self.assertEquals(response.status_code, 302)
self.assertTrue(self.open_assessment.has_score)
self.assertIn( 'test_content_field', new_version.get_explicitly_set_fields_by_scope(scope=Scope.content) ) self.assertIn( 'test_settings_field', new_version.get_explicitly_set_fields_by_scope(scope=Scope.settings) )
self.assertFalse(self._has_changes(published_xblock.location))
if status is not None: if status in self.NOTIFICATION_MESSAGES: found_msg = False for message in self.NOTIFICATION_MESSAGES[status]: if message in response.content: found_msg = True break
score = sub_api.get_score(student_item) self.assertIs(score, None)
priority = None
clf = BayesianRidge(compute_score=True) clf.fit(X, y)
details = api.get_course_enrollment_details(self.COURSE_ID)
self.settings_detail.refresh_page() self.settings_detail.wait_for_prerequisite_course_options() self.assertTrue(is_option_value_selected( browser_query=self.settings_detail.pre_requisite_course_options, value='' ))
if not (has_forum_admin or has_instructor_access): return HttpResponseBadRequest( "Operation requires staff & forum admin or instructor access" )
with self.assert_logged('SafeCookieData not created due to invalid value for session_id'): yield
n_iter = 4 n_iter_specified = False
conditional_probs = T.nnet.sigmoid(conditional_params[0]) return self.theano_rng.uniform( size=(num_samples, self.ndim), dtype=theano.config.floatX ) < conditional_probs
selector = self.get_element_selector(CSS_CLASS_NAMES['error_message']) return self.q(css=selector).visible
version = 'dev' release = 'dev'
the_dir = tempfile.mkdtemp(suffix=suffix, prefix=prefix, dir=dir) atexit.register(cleanup_tempdir, the_dir) return the_dir
self.submit_rescore_all_student_answers('instructor', problem_url_name)
INSTALLED_APPS += ('openedx.core.djangoapps.api_admin',)
after_created = attempt.created_at + timedelta(seconds=1) query = SoftwareSecurePhotoVerification.objects.filter(user=user) result = SoftwareSecurePhotoVerification.verification_for_datetime(after_created, query) self.assertEqual(result, attempt)
X, y = make_hastie_10_2(n_samples=20, random_state=1) X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=43)
plt.figure(figsize=(10, 6)) plt.subplots_adjust(left=0.02, right=0.98)
url = reverse('course_modes_choose', args=[unicode(self.course.id)]) response = self.client.get(url)
BODY_SELECTOR = "#structure-panel" TAB_SELECTOR = ".tab#view-course-structure" CHILD_SELECTOR = ".note-group" CHILD_CLASS = EdxNotesChapterGroup
partitions_service = self.runtime.service(self, 'partitions') if not partitions_service: return None return partitions_service.get_user_group_id_for_partition(self.user_partition_id)
current_node = stack.pop()
self.service.set_credit_requirement_status( self.user.id, self.course.id, 'grade', 'grade' )
self.assertEqual(component.edited_by, self.user_id) old_edited_on = component.edited_on
if "tags" in kwargs: kwargs["tags"] = _clean_tags(kwargs["tags"]) dog_stats_api.increment(metric_name, *args, **kwargs)
self.client.login(username=self.user.username, password="password")
index = 0
expected_body = json.dumps({'correct': True, 'score': 1, 'msg': '<div></div>'}) self._check_grade_response(callback_url, expected_header, expected_body)
current_commit_id = get_commit_id(def_ms.courses[reload_dir]) log.debug('commit_id="%s"', commit_id) log.debug('current_commit_id="%s"', current_commit_id)
config.delete() self.assertEqual(len(self.group_configurations_page.content_groups), 0)
user = self.create_user_and_enroll('verified')
mp = int(os.environ.get('JOBLIB_MULTIPROCESSING', 1)) or None if mp: try: import multiprocessing as mp import multiprocessing.pool except ImportError: mp = None
self.assertIn("example_source.mp4", self.item_descriptor.render(STUDENT_VIEW).content)
X = np.arange(100).reshape(10, 10) y = np.array([0] * 5 + [1] * 5)
X, y = datasets.samples_generator.make_s_curve(n_samples, random_state=0)
url(r'^api/profile_images/', include('openedx.core.djangoapps.profile_images.urls')),
self._do_create_preference_test(True)
return _("{profile_name} URL").format(profile_name=profile)
n_samples = 100 x = np.random.uniform(size=n_samples) > 0.5
ranks = np.ravel(ranks)
reviewing_user = models.ForeignKey( User, db_index=True, default=None, null=True, related_name="photo_verifications_reviewed" )
os.remove(filename)
sequential_position_css = '#sequence-list #tab_{0}'.format(sequential_position - 1) self.q(css=sequential_position_css).first.click()
self.q(css='.create-team .action-primary').first.click() self.wait_for_ajax()
scaler = StandardScaler(with_mean=False).fit(X) scaler_incr = StandardScaler(with_mean=False)
self.assertTrue(self.reset_password_page.is_form_visible())
course_id = CourseKeyField.Empty
model = linear_model.LinearRegression() model.fit(X, y)
if created: return
for k in xrange(n_samples, n_nodes): while True: edge = heappop(inertia) if used_node[edge.a] and used_node[edge.b]: break i = edge.a j = edge.b
self.check_tab_equality(tab, dict_tab)
return bool( settings.DEBUG or has_access(user, CourseStaffRole.ROLE, course) or has_access(user, CourseInstructorRole.ROLE, course) )
FEATURES['AUTOMATIC_VERIFY_STUDENT_IDENTITY_FOR_TESTING'] = True
httpretty.register_uri( httpretty.POST, "{}/baskets/".format(TEST_API_URL), body=json.dumps({'payment_data': expected_payment_data}), content_type="application/json", )
if not os.path.isdir(self.git_repo_dir / 'edx4edx'): os.mkdir(self.git_repo_dir / 'edx4edx')
resp = self._build_and_run_request(user, fields) self.assertEqual(resp.status_code, 200)
self.upgrade_page.indicate_contribution()
y = np.mod(np.arange(len(y)), 3)
pass
pow_term = atom + ZeroOrMore("^" + atom) pow_term = Group(pow_term)("power")
clf = AdaBoostRegressor(random_state=0) clf.fit(X, y_regr) assert_array_equal(clf.predict(T), y_t_regr)
StudentViewTransformer.collect(self.block_structure) self.block_structure._collect_requested_xblock_fields()
tracker.emit( SETTING_CHANGE_INITIATED, { "setting": "password", "old": None, "new": None, "user_id": request.user.id, } )
self._fit_transform(X) return self
random_state = check_random_state(est.random_state) seed = random_state.randint(0, np.iinfo(np.int32).max)
selectable_modes = CourseMode.modes_for_course_dict(self.course_key) self.assertItemsEqual(selectable_modes.keys(), expected_selectable_modes)
else: return func(self, *args, **kwargs)
code_length = getattr(settings, 'REGISTRATION_CODE_LENGTH', 8) return generate_random_string(code_length)
T = sp.lil_matrix((3, 1)) T[0, 0] = 2 T[1, 0] = 3 T[2, 0] = 4
tab = tab_class(tab_dict=dict_tab)
parser = PDFParser(pdf_buffer) document = PDFDocument(parser, password)
self._test_view('about', 'text/html')
mlp.fit(X, y)
m = Memory(cachedir=lfw_home, compress=6, verbose=0) load_func = m.cache(_fetch_lfw_people)
empty = ParameterGrid({}) assert_equal(len(empty), 1) assert_equal(list(empty), [{}]) assert_grid_iter_equals_getitem(empty) assert_raises(IndexError, lambda: empty[1])
myiterator = d.iterator(mode=i, batch_size=b, num_batches=n, data_specs=self._flat_data_specs, return_tuple=True, rng=sd)
if cls.test_course_key not in [c.id for c in courses]: import_course_from_xml( store, ModuleStoreEnum.UserID.mgmt_command, DATA_DIR, XML_COURSE_DIRS, create_if_not_present=True )
key = unichr(unicode_char)
X, y = make_blobs(n_samples=80, centers=5, random_state=0) X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
retval = self.service.set_credit_requirement_status( 0, self.course.id, 'grade', 'grade' ) self.assertIsNone(retval)
self.certificates_section.fill_certificate_invalidation_user_name_field("") self.certificates_section.click_invalidate_certificate_button() self.certificates_section.wait_for_ajax()
monitor_lr2 = MonitorBasedLRAdjuster(channel_name=dummy)
world.mongo_client.fsync()
scaler_batch = StandardScaler().fit(X)
bookmark_service = BookmarksService(self.other_user) with self.assertNumQueries(1): self.assertFalse(bookmark_service.is_bookmarked(usage_key=self.sequential_1.location))
microsite.set_by_domain(self.microsite_subdomain) configs = microsite.get_all_config() self.assertEqual(len(configs.keys()), 3)
raise NotImplementedError()
with check_mongo_calls(num_finds.pop(0), num_sends): path = path_to_location(self.store, location) self.assertEqual(path, expected)
return bool(user and has_access(user, 'staff', course, course.id))
X = np.arange(100)[:, np.newaxis] y = np.ones(100) y[:50] = 0.0
import contracts contracts.disable_all()
([]),
return [Badge(element, self.browser) for element in self.q(css=".badge-display:not(.badge-placeholder)")]
response = render_to_response(path, context) response.mako_context = context response.mako_template = path return response
self.assertNotIn('user', constructed)
CoursewareSearchIndexer.do_course_reindex(modulestore(), self.course.id)
try: return data.get('code', None) except AttributeError: return None
X = check_array(X, accept_sparse=['csr', 'csc'])
codeparam = self.xml.find('codeparam') assert codeparam is not None, "Unsupported old format! <coderesponse> without <codeparam>" self._parse_coderesponse_xml(codeparam)
newrelic.agent.add_custom_parameter('course_id', unicode(course_key)) newrelic.agent.add_custom_parameter('org', unicode(course_key.org))
if self._annotation is not _empty: formatted = '{0}:{1}'.format(formatted, formatannotation(self._annotation))
self.factory(coef_init=np.zeros((3,))).fit(X, Y)
return {'xml': True}
'html5_sources': ['http://www.example.com/source.mp4'], 'data': ''
return (np.where([True, True, False, False, True])[0], np.where([False, False, True, True])[0])
D = fa C = fpa db = b - a * one
urlpatterns += url(r'^template/(?P<template>.+)$', 'openedx.core.djangoapps.debug.views.show_reference_template'),
namespace_dirs = {namespace: list(look.directories) for namespace, look in LOOKUP.items()}
with filesystem.open('grading_policy.json', 'r') as grading_policy: on_disk = loads(grading_policy.read()) self.assertEqual(on_disk, course.grading_policy)
#html_file_suffix = ''
if is_list_of_files(answer): new_answers[answer_id] = [f.name for f in answer] else: new_answers[answer_id] = answers[answer_id]
layer_to_chains = model.sampling_procedure.sample( layer_to_chains, self.theano_rng, num_steps=self.num_gibbs_steps )
self.client.logout() response = self.client.get(self.path) self.assertEqual(response.status_code, 401)
class_name = class_name.encode('utf-8')
def __init__(self): super(_RequestCache, self).__init__() self.data = {} self.request = None
self.check_event_response_by_key('flag_resource', resource, 'reason', '')
lib_page.a11y_audit.config.set_rules({ "ignore": [
node = mock.Mock(due=None, extended_due=1) self.assertEqual(self.call_fut(node), None)
doc_store_config = { 'host': HOST, 'port': PORT, 'db': DB, 'collection': COLLECTION, } cls.add_asset_collection(doc_store_config)
AWS_QUERYSTRING_AUTH = AUTH_TOKENS.get('AWS_QUERYSTRING_AUTH', True)
print('=' * 80) print("NearestCentroid (aka Rocchio classifier)") results.append(benchmark(NearestCentroid()))
if generate_translation: for lang, filename in item.transcripts.items(): item.transcripts[lang] = os.path.split(filename)[-1]
n_samples, n_features, n_classes = 50, 20, 3 X, y = make_classification(n_samples=n_samples, n_features=n_features, n_informative=10, n_classes=n_classes, random_state=0)
af = AffinityPropagation(affinity="euclidean") assert_raises(ValueError, af.predict, X)
return self.q(css=self._bounded_selector('span.message-text a')).first.text[0]
usage_key = usage_key.replace(course_key=modulestore().fill_in_run(usage_key.course_key))
resp = self.client.get(url) self.assertEqual(resp.status_code, 200) self.assertIn("Course is full", resp.content)
super(IndexSpace, self)._validate_impl(is_numeric, batch)
chapter = self._find_url_name(toc, chapter_url_name) if chapter: return self._find_url_name(chapter['sections'], sequential_url_name) return None
old_center_buffer = np.zeros(0, np.double)
raise NotImplementedError(str(type(self))+" does not implement " + "continue_learning.")
if layer_to_clamp is None: layer_to_clamp = OrderedDict()
if data.get('essential'): return super(IDTokenHandler, self).claim_staff_courses(data) else: return None
self.assertOLXIsDraftOnly(block_list_to_unpublish) with self.assertRaises(ItemNotFoundError): self.unpublish(block_list_to_unpublish)
observer.schedule(self, 'common/lib/xmodule/', recursive=True)
k1_dims = self.k1.n_dims self.k1.theta = theta[:k1_dims] self.k2.theta = theta[k1_dims:]
if course_key is not None: CourseEnrollment.enroll(user, course_key, mode=enrollment_mode)
self.assert_enrollment_status(username='fake-user', expected_status=status.HTTP_404_NOT_FOUND, as_server=False) self.assert_enrollment_status(username='fake-user', expected_status=status.HTTP_406_NOT_ACCEPTABLE, as_server=True)
return (load, (filename, self._mmap_mode))
grandkids = [] for descendant in descendants: grandkids.extend(descendant.children)
n_samples = int(X.shape[0]) rs = check_random_state(self.random_state)
return predictions[np.arange(X.shape[0]), median_estimators]
admin = User.objects.get(username=username, email=email)
DEPRECATED_ADVANCED_COMPONENT_TYPES = []
provider_url = reverse('openid-provider-login') factory = RequestFactory() request = factory.request() abs_provider_url = request.build_absolute_uri(location=provider_url)
self.enrollment = CourseEnrollmentFactory( user=self.user,
assert np.all((ps == 0) + (ps == 1)) assert np.all((hs == 0) + (hs == 1))
response = self.client.get(self.url) self.assertFalse(self.email_modal_link in response.content)
check_node(sibling.location, None, after_create, self.user_id, None, after_create, self.user_id)
INSTALLED_APPS += ('django_extensions',)
K = self.kernel_(self.X_train_) K[np.diag_indices_from(K)] += self.alpha
scheme_id = UserPartition.VERSION_1_SCHEME
'LICENSING': False,
modal.release_date = '3/12/1972' modal.release_time = '04:01' modal.due_date = '7/21/2014' modal.due_time = '23:39' modal.policy = 'Lab'
return self._folds[0].get_input_space()
num_fields_updated = max(0, len(state) - num_new_fields_set) self._ddog_histogram(evt_time, 'set_many.fields_updated', num_fields_updated)
wiki_courses = self.store.get_courses_for_wiki('999') self.assertEqual(len(wiki_courses), 0)
for asset in assets: self.assertEquals(asset['displayname'], expected_displayname)
self.cohort_management_page.select_cohort_some_inline_discussion()
self._test_visible_to_students(False, 'public_unreleased', self.future, publish=True)
auto_auth = AutoAuthPage(self.browser).visit() user_info = auto_auth.user_info LogoutPage(self.browser).visit() return user_info
def __init__(self): pass
return self.backend.award(self, user, evidence_url=evidence_url)
self._assert_output(output, (self.user, self.courses[0].id, True))
total_student_count[curr_problem] = total_student_count.get(curr_problem, 0) + row['count_grade']
EXPORTED_ASSET_DIR = 'assets'
self.assertRegexpMatches(html, r'&#34;group_name&#34;: &#34;student_cohort&#34;')
if sample_weight_sum <= 0: break
log_prob_x = logsumexp(jll, axis=1) return jll - np.atleast_2d(log_prob_x).T
super(MakoTemplateLinter, self).__init__() self.javascript_linter = JavaScriptLinter() self.python_linter = PythonLinter()
try: iter(update_callbacks) self.update_callbacks = update_callbacks except TypeError: self.update_callbacks = [update_callbacks]
y_i_all_argmax = np.flatnonzero(y_data_repeated_max == y.data)
raise ItemNotFoundError(definition_locator)
self.assertIn("EXCEPTION!", get_processor_exception_html(CCProcessorException()))
if err is not None: raise FixtureError("Could not create course {0}. Error message: '{1}'".format(self, err))
if not diff_quality_percentage_pass: raise BuildFailure("Diff-quality failure(s).")
try: manual_enrollment = cls.objects.filter(enrolled_email=email).latest('time_stamp') except cls.DoesNotExist: manual_enrollment = None return manual_enrollment
parameters = {'n_estimators': (1, 2), 'base_estimator__C': (1, 2)}
group_id_to_child = ReferenceValueDict( help=_("Which child module students in a particular group_id should see"), scope=Scope.content )
max_squared_sum = get_max_squared_sum(X) step_size = get_auto_step_size(max_squared_sum, alpha, "log", fit_intercept)
self.assertEqual(course_mode, enrollment['mode']) self.assertEqual(is_active, enrollment['is_active'])
self.upgrade_page.proceed_to_payment()
if rate_limiter.is_rate_limit_exceeded(request): log.info(u"Bad request rate limit exceeded for update example certificate end-point.") return HttpResponseForbidden("Rate limit exceeded")
config_course_cohorts(self.course1, is_cohorted=True, auto_cohorts=["Course1AutoGroup1", "Course1AutoGroup2"])
self.assertFalse(library_container.has_validation_error) self.assertFalse(library_container.has_validation_warning)
assert_raises(ValueError, lshf.kneighbors, X[0])
scores = cross_val_score(reg, X, y, cv=5) assert_array_almost_equal(scores, [0.94, 0.97, 0.97, 0.99, 0.92], 2)
dashboard = DashboardPage(self.browser) dashboard.wait_for_page() return dashboard
resp = self.client.put( '/shoppingcart/payment_fake', data="success", content_type='text/plain' ) self.assertEqual(resp.status_code, 200)
return response.set_cookie_wrapped_func( key, value, max_age=max_age, expires=expires, path=path, domain=domain, secure=secure, httponly=httponly )
save_path.replace('\\', r'\\')
return self.q(css=".license-value").first.text[0]
colors = [color_map[y] for y in y_train] plt.scatter(X[:, 0], X[:, 1], c=colors, cmap=plt.cm.Paired)
func_or_class.authentication_classes = ( OAuth2AuthenticationAllowInactiveUser, SessionAuthenticationAllowInactiveUser ) func_or_class.permission_classes = () if is_authenticated: func_or_class.permission_classes += (IsAuthenticated,) if is_user: func_or_class.permission_classes += (IsUserInUrl,) return func_or_class
check_arguments_for_rescoring(usage_key)
return total / len(model_output)
dt = X.dtype if output_pixel_vals: dt = 'uint8' out_array = np.zeros(out_shape, dtype=dt)
raise NotImplementedError()
from sklearn.neighbors import KNeighborsClassifier
if isinstance(decision_tree, _tree.Tree): recurse(decision_tree, 0, criterion="impurity") else: recurse(decision_tree.tree_, 0, criterion=decision_tree.criterion)
VERSION_1_SCHEME = "random"
header_row = OrderedDict([('id', 'Student ID'), ('email', 'Email'), ('username', 'Username')])
try: response_msg_div = etree.XML('<div>%s</div>' % str(response_msg))
self.profile.year_of_birth = year_of_birth self.profile.save()
MODULESTORE = TEST_DATA_MONGO_MODULESTORE __test__ = True
url = reverse('verify_student_upgrade_and_verify', kwargs={'course_id': unicode(course_id)}) self.assertRedirects(response, url)
return HttpResponseBadRequest(u'The field {} is required.'.format(err.message))
y_pred = clf.classes_.take(y_proba.argmax(axis=1), axis=0) assert_array_equal(y_pred, true_result)
from __future__ import unicode_literals
self.xmodule_runtime = xmodule_runtime
n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1
cls.partial_fit(X_train, y_train, classes=all_classes)
assert_true(ocur == X.shape[1])
problem = self.store.get_item(problem.location)
mappings = getattr(settings, 'HOSTNAME_MODULESTORE_DEFAULT_MAPPINGS', None)
page.wait_for_element_visibility('.new-component-html', 'HTML component menu is visible')
content = contentstore().find(asset_key, throw_on_not_found=False) self.assertIsNone(content)
invalid_cdn_url = 'http://http://fakecdn.com/' self.assertIsNone(rewrite_video_url(invalid_cdn_url, self.original_video_url))
return Bunch(data=pairs.reshape(len(pairs), -1), pairs=pairs, target=target, target_names=target_names, DESCR="'%s' segment of the LFW pairs dataset" % subset)
from defusedxml.lxml import parse, fromstring, XML
if isinstance(value, UsageKey): return value return course_key.make_usage_key_from_deprecated_string(value)
user_partititons = self.course.user_partitions
from .index import * from .certificate import * from .enrollments import * from .refund import * from .programs import IssueProgramCertificatesView
existing_answers = survey.get_answers(user=user).get(user.id, {})
center_id = random_state.randint(n_samples) if sp.issparse(X): centers[0] = X[center_id].toarray() else: centers[0] = X[center_id]
axes = self.output_axes assert len(axes) == 4
return MatchFirst( [ parseElementClass(sym) for sym in symbols ] )
update_email_opt_in(user, org, is_opted_in)
raise NotImplementedError(str(self.__class__) + " does not implement " "sample_from_p_z.")
pass
metadata_translations = { 'slug': 'url_name', 'name': 'display_name', }
VerificationStatus.add_verification_status( checkpoint=self.first_checkpoint, user=self.user, status=status )
get_request_dict = {CapaFactory.input_key(): '0'} result = module.check_problem(get_request_dict)
response_file = response_obj["files"][i] self.assertEqual(response_file["file_name"], file_info["file_name"]) self.assertEqual(response_file["upload_url"], mock_key_instance.generate_url())
'oauth2_provider',
self.set_user_module_score(real_user, score, self.max_score(), comment) return Response(status=200)
if self.themed(name): base = self.theme_location else: base = self.location path = safe_join(base, name) return os.path.normpath(path)
try: year_str = self.cleaned_data["year_of_birth"] return int(year_str) if year_str is not None else None except ValueError: return None
self.assertIn(SplitTestDescriptor.user_partition_id.name, editable_metadata_fields)
pvals = T.alloc(1.0 / num_classes, num_classes) one_hot = self.s_rng.multinomial(size=(num_examples,), pvals=pvals)
if os.path.isfile(path_item): with open(path_item, "rb") as file_handle: hasher.update(file_handle.read())
this_scores = cross_val_score(clf, X, y, n_jobs=1) score_means.append(this_scores.mean()) score_stds.append(this_scores.std())
raise NotImplementedError()
user_partition_values = [] no_partition_selected = {'display_name': _("Not Selected"), 'value': -1}
self.assertTrue(CourseEnrollment.is_enrolled(self.user, self.course_key)) self.assertTrue(self.user.roles.filter(name="Student", course_id=self.course_key))
self.__dict__['_modulestore'] = modulestore
if estimator_error <= 0: return sample_weight, 1., 0.
if not show_explanation or not self.done: continue
survey.save_user_answers(self.student, self.student_answers_update2, self.course_id)
errstring = "No user found identified by 99" with self.assertRaisesRegexp(CommandError, errstring): self.command.handle("org/course/name", "99")
return etree.parse(file_object, parser=EDX_XML_PARSER).getroot()
if "tags" in kwargs: kwargs["tags"] = _clean_tags(kwargs["tags"]) dog_stats_api.histogram(metric_name, *args, **kwargs)
real_user = self.runtime.get_real_user(self.runtime.anonymous_student_id) return real_user
ddof = 1
enable_spectral_norm = False
pass
block_structure = block_structure_cls(root_block_usage_key=0)
XBlockDisableConfig.objects.create( disabled_create_blocks=xblocks, enabled=True ) self.assertEqual( XBlockDisableConfig.disabled_create_block_types(), expected_result )
course_query = self._course_key_to_son(course_key) self.collection.remove(course_query, multi=True) self.delete_all_asset_metadata(course_key, user_id)
assert_array_equal(clf.apply(X), clf_2.apply(X))
delete_course_and_groups(self.course_key, self.user.id) resp = self._create_course_with_given_location(self.course_key) self.assertEqual(resp.status_code, 200)
warnings.warn(premature, RuntimeWarning, stacklevel=3) break
for topic_id in range(self.NUM_TOPICS): team = CourseTeamFactory.create( name=u"Team for topic {}".format(topic_id), course_id=self.course.id, topic_id=topic_id, )
log_loss_scorer = make_scorer(log_loss, greater_is_better=False, needs_proba=True)
self.assertFalse(self.video.is_autoplay_enabled)
instructor_task = self._create_success_entry() instructor_task.task_output = None succeeded, message = get_task_completion_info(instructor_task) self.assertFalse(succeeded) self.assertEquals(message, "No status information available")
print('Failed to save %s to .npy file:\n%s' % ( type(obj), traceback.format_exc()))
microsite.enable_microsites_pre_startup(log)
response = self.client.post(url) self.assertEquals(response.status_code, 403)
gp_fix = GaussianProcessClassifier(kernel=1.0 * RBF(length_scale=1.0), optimizer=None) gp_fix.fit(X[:train_size], y[:train_size])
self.set_select_value(self.LIBRARY_LABEL, library_name) EmptyPromise(lambda: self.library_name == library_name, "library_name is updated in modal.").fulfill()
self.profile.year_of_birth = year_of_birth self.profile.save()
self.server.cleanup() self.respond()
print colorize('green', "Generating optimized static assets...") sh("paver update_assets --settings=test_static_optimized")
value = self.cleaned_data["following"] if value is False: raise ValidationError("The value of the 'following' parameter must be true.") else: return value
y = np.array([3, 7, 5, 9, 8, 7, 10]) x = np.arange(len(y))
block = self.course
del dgamma1, dgamma2, sd
'ADDITIONAL_OPTIONS': { 'trashcan': { 'bucket': 'trash_fs' } }
split_test = self._update_partition_id(0)
try: return CourseKey.from_string(arg) except InvalidKeyError: return SlashSeparatedCourseKey.from_deprecated_string(arg)
from __future__ import unicode_literals
site_configuration_history = SiteConfigurationHistory.objects.filter( site=site_configuration.site, ).all()
if not organizations: raise Exception( 'Configuration error. Microsite {key} does not have any ORGs mapped to it!'.format( key=microsite_object.key ) )
resp = self.client.get('/') self.assertEqual(resp.status_code, 200) self.assertContains(resp, 'footer-edx-v3')
return beta_from_design(dataset.y, **kwargs)
#`clean_warning_registry()` is called internally by assert_warns class TestWarns(unittest.TestCase): def test_warn(self): def f(): warnings.warn("yo") return 3
USER_RESPONSE_DATA = None
handle_course_cert_awarded(**self.signal_kwargs) self.assertEqual(mock_is_certification_enabled.call_count, 1) self.assertEqual(mock_task.call_count, 0)
self._assert_redirects_to_instructor_dash(response)
return ACCESS_GRANTED if descriptor.mobile_available else MobileAvailabilityError()
K = check_array(K, dtype=FLOAT_DTYPES) n_samples = K.shape[0] self.K_fit_rows_ = np.sum(K, axis=0) / n_samples self.K_fit_all_ = self.K_fit_rows_.sum() / n_samples return self
grads = coef_grads + intercept_grads self._optimizer.update_params(grads)
CSRF_COOKIE_AGE = 60 * 60 * 24 * 7 * 52 CSRF_COOKIE_SECURE = False
cov = ShrunkCovariance() cov.fit(X) assert_array_almost_equal( shrunk_covariance(empirical_covariance(X)), cov.covariance_, 4)
payload = {self._pattern: json.dumps(self._response_dict)} response = requests.put(url, data=payload)
pass
tree = etree.Element('span')
REQUIRE_BASE_URL = "./"
django_args.append('--help')
data_lst = np.array(data.data, dtype=object) data_lst = data_lst[indices] data.data = data_lst.tolist()
import_course_from_xml( draft_store, 999, DATA_DIR, ['test_import_course'], static_content_store=content_store, do_import_static=False, verbose=True )
INVOICE_CORP_ADDRESS = ENV_TOKENS.get('INVOICE_CORP_ADDRESS', INVOICE_CORP_ADDRESS) INVOICE_PAYMENT_INSTRUCTIONS = ENV_TOKENS.get('INVOICE_PAYMENT_INSTRUCTIONS', INVOICE_PAYMENT_INSTRUCTIONS)
est = TreeEstimator() assert_raises(NotFittedError, est.predict, T)
CourseMode( course_id=self.xss_course_key, mode_slug=CourseMode.HONOR, mode_display_name="honor cert", min_price=self.cost ).save()
user.set_password(password) user.save() history = PasswordHistory() history.create(user)
return cache_and_return(Location._from_deprecated_son(found_id, location.course_key.run))
clf = svm.SVC(kernel='precomputed') assert_raises(ValueError, clf.fit, X, Y)
world.browser.execute_script("jQuery.fx.off = true;")
self.assertEqual(certificate_exception['user_email'], self.user.email) self.assertEqual(certificate_exception['user_name'], self.user.username)
#epub_fix_images = False
return a * b / fr.gcd(a, b)
filter_func = filter_func or (lambda __: True)
sqrt_alpha = np.sqrt(alpha)
if self.edx_video_id: video_profile_names = context.get("profiles", ["mobile_low"])
self._block_relations = defaultdict(_BlockRelations)
X = [np.nan, 5, 6, 7, 8] assert_raises_regex(ValueError, "Input contains NaN, infinity or a value too large", scale, X)
courses2 = import_course_from_xml( self.store, self.user_id, self.export_dir, source_dirs=[top_level_export_dir], static_content_store=contentstore, target_id=dest_course_key2, create_if_not_present=True, raise_on_failure=True, )
html_parent = self.store.get_parent_location(html.location) self.assertEquals(unicode(html_parent), unicode(vertical1.location))
modules_to_update = StudentModule.objects.filter(course_id=course_id, module_state_key__in=usage_keys)
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
self.assertTrue(payment_accepted(params)['accepted'])
X = np.arange(100).reshape(10, 10) y = np.array([0] * 5 + [1] * 5)
CourseEnrollment.enroll(self.user, self.course.id, mode="honor")
response = self.client.get(self.url) self.assertFalse(self.email_modal_link in response.content)
n_samples = 100 n_features = 300
Cov -= gamma_ * corr_eq_dir
if not settings.FEATURES.get('MILESTONES_APP', False): return None from milestones import api as milestones_api return milestones_api.remove_content_references(content_id)
if self.xml.get('inline', ''): tree.set('class', 'inline')
xblock_info = create_xblock_info( xblock, data=data, metadata=own_metadata(xblock), include_ancestor_info=include_ancestor_info ) if include_publishing_info: add_container_page_publishing_info(xblock, xblock_info) return xblock_info
team_list = self.get_teams_list(user=user, expected_status=200, data=course_one_data) self.assertEqual(team_list['count'], 0)
if amount < decimal.Decimal('0.01'): return HttpResponseBadRequest("Amount must be greater than 0")
uniform_batch_size = True
self.base_extauth_bypass_sending_activation_email(False)
if upgrade_deadline is not None and verification_deadline < upgrade_deadline: raise serializers.ValidationError( 'Verification deadline must be after the course mode upgrade deadlines.')
"redirect_url": redirect_url,
raise NotImplementedError
M = M.T
X_sparse_pruned = sparse.csr_matrix(X_dense)
#latex_appendices = []
module = CapaFactory.create(force_save_button="true", rerandomize=RANDOMIZATION.ALWAYS, done=True) self.assertTrue(module.should_show_save_button())
enrollment = CourseEnrollment.get_enrollment(student, course_key) if enrollment and enrollment.mode not in REQUIREMENTS_DISPLAY_MODES: return None
eps_range = np.linspace(0.01, 0.99, 100)
if on_rtd: os.environ['DJANGO_SETTINGS_MODULE'] = 'lms' else: os.environ['DJANGO_SETTINGS_MODULE'] = 'lms'
if response is None: response = HttpResponse(content.stream_data()) response['Content-Length'] = content.length
if symbolic: activations[idx] = T.switch(clamp, initial, activations[idx]) else: activations[idx] = np.switch(clamp, initial, activations[idx])
test_invalid_token("AAAAAAAAAAAAAAAAAAAAANRGw8HDEmlcLVFawgY9wI8=", "padding")
DEFAULT_COURSE_ABOUT_IMAGE_URL = ENV_TOKENS.get('DEFAULT_COURSE_ABOUT_IMAGE_URL', DEFAULT_COURSE_ABOUT_IMAGE_URL)
X[:, j] = np.hstack((v, z, p))
with remove_ccx(usage_key) as (usage_key, restore): orig_key, version = self._modulestore.get_block_original_usage(usage_key) return restore(orig_key), version
assert not world.is_css_present('iframe', wait_time=0)
self.assertEquals( block_structure_result, i in expected_accessible_blocks, "block_structure return value {0} not equal to expected value for block {1} for user {2}".format( block_structure_result, i, user.username ) )
f = plt.figure(figsize=(7, 5)) for index, image_index in enumerate(uncertainty_index): image = images[image_index]
make_asset_xml(num_assets, ASSET_XML_PATH) validate_xml(ASSET_XSD_PATH, ASSET_XML_PATH)
_ = lambda text: text
#default_role = None
pred = Y_proba > .5 assert_array_equal(pred, Y_pred)
self.assertEqual(self._get_enrollments(), [])
indent[depth] = start[1]
FIELD_OVERRIDE_PROVIDERS = tuple(ENV_TOKENS.get('FIELD_OVERRIDE_PROVIDERS', []))
score += _loglikelihood(topic_word_prior, self.components_, dirichlet_component_, n_features)
for mode in [CourseMode.DEFAULT_MODE_SLUG, CourseMode.VERIFIED]: CourseModeFactory.create( course_id=self.course.id, mode_slug=mode, mode_display_name=mode, )
p, h = prob_max_pool_c01b(z, (pool_rows, pool_cols) ) func = function([z], [p, h], mode = mode_with_gpu)
return T.nnet.sigmoid(conditional_params[0])
if self._is_grade_request():
self.update_enrollment(is_active=True)
kde = grid.best_estimator_
self.client.login(username=self.user.username, password="password")
graph_matrix = self._build_graph()
K1 = pairwise_kernels(X, Y=X, metric=metric, **kwds) K2 = rbf_kernel(X, Y=X, **kwds) assert_array_almost_equal(K1, K2)
return datetime.fromtimestamp(os.path.getatime(self.path(name)))
if false_discovery_rate != 0: assert_greater(false_discovery_rate, alpha / 10)
return {'username': username, 'team_id': team}
rng = check_random_state(0) X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=rng)
hashes[clean_path(full_cython_path)] = current_hash
response = self.ajax_request('bad_answer', {}) self.assertDictEqual(response, {'error': 'Unknown Command!'})
self.assertIn('timestamp', parameters) parsed_date = from_timestamp(parameters['timestamp']) self.assertLess(parsed_date, datetime.datetime.now(pytz.UTC))
notes = deepcopy(notes[start:end])
self.iterator(mode='shuffled_sequential', batch_size=batch_size, num_batches=None) return self.next()
y1 = ir.predict([min(x) - 10, max(x) + 10]) assert_equal(sum(np.isnan(y1)), 2)
print(metrics.classification_report(y_test, y_predicted, target_names=dataset.target_names))
for byte_range_string in byte_ranges_string.split(','): byte_range_string = byte_range_string.strip()
error = mean_absolute_error(y_true, y_pred) assert_almost_equal(error, (1. / 3 + 2. / 3 + 2. / 3) / 4.)
Language = namedtuple('Language', 'code name')
course = CourseFactory.create(course_image=u'things_stuff.jpg', static_asset_path="foo") self.assertEquals( course_image_url(course), '/static/foo/things_stuff.jpg' )
MESSAGE = _('Unable to run import command.')
self._update_release_dates(self.date_one, self.date_two, self.date_two) self._verify_release_date_source(self.vertical, self.sequential)
self.cmap.set_overall_message(None) self.assertEqual(self.cmap.get_overall_message(), "")
modulestore().update_item(course, ModuleStoreEnum.UserID.test)
clf = BernoulliNB(alpha=1.0) clf.fit(X, Y)
FEATURES['ENABLE_EDXNOTES'] = True
sampling_algorithm["custom-reservoir-sampling"] = \ lambda n_population, n_samples, random_state=None: \ sample_without_replacement(n_population, n_samples, method="reservoir_sampling", random_state=random_state)
topleft = N.array([kshp[0]-1,kshp[1]-1])
return self.feature_names_
self._create_test_file( 'test_include.xml', '<test>Test include</test>' )
response = self.client.get(reverse('branding.views.courses')) self.assertEqual(response.status_code, 200)
sim = np.array([[0, 5, 9, 4], [5, 0, 2, 2], [4, 2, 1, 0]])
iris = datasets.load_iris()
for system in ['lms', 'cms']: sh(django_cmd(system, DEFAULT_SETTINGS, 'compilejsi18n'))
return [ CourseKey.from_string(course_overview['id']) for course_overview in CourseOverview.objects.values('id') ]
self.assertEqual(response.status_code, 400) res_json = json.loads(response.content)
category = item['location']['category'] apply_cached_metadata = category not in DETACHED_XBLOCK_TYPES and \ not (category == 'course' and depth == 0) return apply_cached_metadata
if (not hasattr(estimator, "decision_function") and not hasattr(estimator, "predict_proba")): raise ValueError("The base estimator should implement " "decision_function or predict_proba!")
if chapter.hide_from_toc or local_hide_from_toc: continue
self.assert_logged_in_cookie_redirect(actions.do_complete(
self.set_logged_in_cookies(request)
help_text=_( u"Badge images must be square PNG files. The file size should be under 250KB." ), upload_to='course_complete_badges', validators=[validate_badge_image]
self.factory(alpha=-.1)
X = check_array(X, accept_sparse='csr') return self
for n, color in enumerate(colors): data = X_test[y_test == n] plt.scatter(data[:, 0], data[:, 1], marker='x', color=color)
train_composite = Train(shared_dataset, mlp_composite, SGD(0.1, batch_size=5, monitoring_dataset=shared_dataset)) train_composite.algorithm.termination_criterion = EpochCounter(1) train_composite.main_loop()
self.assertNotEqual(original_problem, module.lcp)
X = X_2d[:100, :]
'CERTIFICATES_HTML_VIEW': False,
def __init__(self, location, msg): super(SerializationError, self).__init__(msg) self.location = location
if ApiAccessConfig.current().enabled: return view_func(view_obj, *args, **kwargs) return HttpResponseNotFound()
if request is not None and hasattr(request, 'META') and header_name in request.META: return request.META[header_name] else: return default
return struct.calcsize('P') * 8 == 32
GEOIP_PATH = REPO_ROOT / "common/static/data/geoip/GeoIP.dat" GEOIPV6_PATH = REPO_ROOT / "common/static/data/geoip/GeoIPv6.dat"
outline_response = self.client.get(link.get("href"), {}, HTTP_ACCEPT='text/html') self.assertEqual(outline_response.status_code, 200)
pass
elif (name in CROSS_DECOMPOSITION or name in ['LinearSVC', 'LogisticRegression']): continue
def __init__(self, value): self.value = value
monitoring_dataset = DenseDesignMatrix(X=X)
if state == {}: state = None
return reverse_func(self.type, args=[course.id.to_deprecated_string(), self.url_slug])
assert_policy_entries( [ADVANCED_MODULES_KEY, DISPLAY_NAME_KEY, "Show Calculator"], ["[]", DISPLAY_NAME_VALUE, "false"])
self.assertTrue(self._has_changes(parent.location)) self.assertTrue(self._has_changes(child.location))
SOCIAL_AUTH_PIPELINE_TIMEOUT = ENV_TOKENS.get('SOCIAL_AUTH_PIPELINE_TIMEOUT', 600)
if logo_image: notification_msg.attach(logo_image)
return self.q(css='.nav-actions a.new-program-button').present
for v in (v1, v2): counts_test = v.transform(test_data) if hasattr(counts_test, 'tocsr'): counts_test = counts_test.tocsr()
world.css_click('.mce-primary')
output = self._run_command(self.TEST_ORG, query_interval=4)
self.assert_grade(problem, "Second", "correct") self.assert_grade(problem, "second", "correct")
for cookie_name in [settings.EDXMKTG_LOGGED_IN_COOKIE_NAME, settings.EDXMKTG_USER_INFO_COOKIE_NAME]: response.delete_cookie( cookie_name.encode('utf-8'), path='/', domain=settings.SESSION_COOKIE_DOMAIN ) return response
if return_distance: dist, neigh_ind = results else: neigh_ind = results
return self._require_oauth_field("client_id")
for i in range(max_iter): centers_old = centers.copy() labels, inertia = \ _labels_inertia(X, x_squared_norms, centers, precompute_distances=precompute_distances, distances=distances)
module.data = rewrite_nonportable_content_links( source_course_id, dest_course_id, module.data )
RegistrationFactory(user=self.user)
responder.update_score(score_msg, cmap, queuekey)
global tables if tables is None: import tables
test_user = UserFactory() self.register_with_redemption_code(test_user, course_registration_code.code)
n_samples = X.shape[0]
for child in children: self._block_relations[child].parents.remove(usage_key)
STANDALONE = 'standalone' COURSE = 'course'
return NAMESPACE_CHOICES
return cls.current().platform_key if cls.is_enabled() else ''
assert_raises( AssertionError, monitor.update_channels, [] )
return 0
self.wait_for_ajax() return self.q(css='#u-field-message-account_privacy').text[0]
self.q(css='.dropdown-menu li a').nth(1).click()
def add_node_as_child(self, block, node, id_generator): child_block = self.process_xml(etree.tostring(node)) block.children.append(child_block.scope_ids.usage_id)
student_module.save(force_update=True)
self.send_get(self.anonymous_client, expected_status=401) self.send_patch(self.anonymous_client, {}, expected_status=401)
return self.default
self._create_course_unit(subtitles=True) self.edit_component() self.video.upload_transcript('english_single_transcript.srt')
mock_get.return_value.content = "Error" self.assertRaises(EdxNotesParseError, helpers.get_notes, self.request, self.course)
epoch_num = 5
label_spread = label_propagation.LabelSpreading(kernel='knn', alpha=1.0) label_spread.fit(X, labels)
response_dict = self.request_add_users_to_cohort("", self.cohort1, self.course) self.verify_added_users_to_cohort( response_dict, self.cohort1, self.course, expected_added=[], expected_changed=[], expected_present=[], expected_unknown=[] )
idf = np.log(float(n_samples) / df) + 1.0 self._idf_diag = sp.spdiags(idf, diags=0, m=n_features, n=n_features)
EDXMKTG_LOGGED_IN_COOKIE_NAME = ENV_TOKENS.get('EDXMKTG_LOGGED_IN_COOKIE_NAME', EDXMKTG_LOGGED_IN_COOKIE_NAME) EDXMKTG_USER_INFO_COOKIE_NAME = ENV_TOKENS.get('EDXMKTG_USER_INFO_COOKIE_NAME', EDXMKTG_USER_INFO_COOKIE_NAME)
return ( request.path.startswith('/' + XASSET_LOCATION_TAG + '/') or request.path.startswith('/' + AssetLocator.CANONICAL_NAMESPACE) )
course_overviews = CourseOverview.objects.all()
def __init__(self): self.items = []
attempt = SoftwareSecurePhotoVerification(user=user) attempt.status = 'submitted' attempt.save()
fut = duedate.get_extended_due_date return fut(node)
repo_dir = os.path.abspath(git_export_utils.GIT_REPO_EXPORT_DIR) os.mkdir(repo_dir) self.addCleanup(shutil.rmtree, repo_dir)
version.append(x)
data = {} if email: data['email'] = email return self.client.post(path=reverse('password_change_request'), data=data)
if options is None: options = '' do_matrix = 'matrix' in options do_qubit = 'qubit' in options do_numerical = 'numerical' in options
self.assertEqual(self.store.get_modulestore_type( SlashSeparatedCourseKey('foo', 'bar', '2012_Fall')), default_ms )
student_answers = self.lcp.student_answers answer_ids = student_answers.keys()
if attr == 'parent_sequential_url': attr = 'parent_url' xml_attrs[attr] = val
pass
return np.log(self.predict_proba(X))
for asset in assets: self.assertEquals(asset['displayname'], asset_displayname)
call_command('post_cohort_membership_fix')
self._params = {}
config = {} candidates = Microsite.objects.all() for microsite in candidates: values = microsite.values config[microsite.key] = values return config
if should_force_account_creation(): return dispatch_to_register() return dispatch_to_login()
if self.edx_video_id and edxval_api: try: val_profiles = ["youtube", "desktop_webm", "desktop_mp4"] val_video_urls = edxval_api.get_urls_for_profiles(self.edx_video_id, val_profiles)
return urlencode({ 'next': '/account/finish_auth?{}'.format(urlencode(params)) })
custom_form = get_registration_extension_form()
kwargs['choice_type'] = 'multiple' return ResponseXMLFactory.choicegroup_input_xml(**kwargs)
from pylearn2.space import (SimplyTypedSpace, VectorSpace, Conv2DSpace, CompositeSpace, VectorSequenceSpace, IndexSequenceSpace, IndexSpace, NullSpace, is_symbolic_batch) from pylearn2.utils import function, safe_zip
self._auto_auth(self.STAFF_USERNAME, self.STAFF_EMAIL, True) self.course_outline.visit() section = self.course_outline.section_at(section_index) section.change_name(self.EDITED_CHAPTER_NAME)
self._create_course_unit(subtitles=True) self.video.show_captions() self.video.focus_caption_line(2) self.assertTrue(self.video.is_caption_line_focused(2))
transform = SkewedChi2Sampler(skewedness=c, n_components=1000, random_state=42) X_trans = transform.fit_transform(X) Y_trans = transform.transform(Y)
if not enable_contracts and not edx_args.contracts: contracts.disable_all()
result = _get_xblock_parent(self.vert1, 'unit') self.assertIsNone(result)
kwargs.setdefault('label_suffix', '') super(ApiAccessRequestForm, self).__init__(*args, **kwargs)
temp_dir_path = tempfile.mkdtemp() self.addCleanup(shutil.rmtree, temp_dir_path)
config_course_cohorts( course, is_cohorted=True, auto_cohorts=["AutoGroup"] )
def __init__(self, partitions, **kwargs): super(StaticPartitionService, self).__init__(**kwargs) self._partitions = partitions @property def course_partitions(self): return self._partitions
def assert_no_warnings(func, *args, **kw):
X, y = self._build_y(X, y, sample_weight)
md4 = hashlib.new("md4") md4.update(string) return md4.hexdigest()
n_classes = 1 if solver in ('liblinear', 'sag'): break
try: atomic_replace(temp_filename,local_dst) except Exception as e: raise IOError("[ac] %s %s --> %s" % (str(e),temp_filename,local_dst))
return self._get_xblocks()
if cert_mode == CourseMode.CREDIT_MODE: cert_mode = CourseMode.VERIFIED
assert_true(np.all(np.less_equal(sorted_dists_exact, sorted_dists_approx)))
default_enrollment_mode = audit_mode or honor_mode
if microsite_org: return courses
y = label_binarize(y, classes=[0, 1, 2]) n_classes = y.shape[1]
#if not sig_valid:
cohort_name = 'I AM A RANDOM COHORT' data = {'name': cohort_name, 'assignment_type': CourseCohort.RANDOM} response_dict = self.put_handler(self.course, data=data)
with check_mongo_calls(4, 2):
X = X / 255
textid = 14 while textid == 14: textid = rng.randint(1, 113)
self._smoothed_batch_duration = 0
CourseFinanceAdminRole(self.course.id).remove_users(self.instructor)
url = "i4x://MITx/999/chapter/notfound" with self.assertRaises(tools.DashboardError): tools.find_unit(self.course, url)
grid_search = GridSearchCV(pipeline, parameters, n_jobs=1)
self.find_css('.action-add-signatory').first.click()
self._data[key] = value
n_samples_range = np.logspace(2, 6, 5) colors = plt.cm.Blues(np.linspace(0.3, 1.0, len(n_samples_range)))
return cls.AUDIT in modes_dict or cls.HONOR in modes_dict
self.assert_json_success_response_looks_correct(student_views.login_user(strategy.request))
errstring = "Course with 'TestX/TS01/2015_Q7' key not found." with self.assertRaisesRegexp(CommandError, errstring): call_command('delete_course', 'TestX/TS01/2015_Q7')
CONFIG_ROOT = path(os.environ.get('CONFIG_ROOT', ENV_ROOT))
pass
return all([ self.child_test_passed('.child-counts-match'), self.child_test_passed('.child-values-match') ])
self.queue_len = 0 if self.status == 'incomplete': self.status = 'queued' self.queue_len = self.msg self.msg = self.submitted_msg
self.prev_floatX = config.floatX config.floatX = 'float64'
endpoint = get_xrds_url('login', request) if not endpoint: return default_render_failure(request, "Invalid OpenID request")
resp = self._login(self.email, self.pw) data = parse_json(resp) self.assertFalse(data['success'])
self.add_dropdown_to_section(vertical_1.location, 'H2P1_GROUP1', 1).location.html_id()
self.assertEquals(preview.latex_preview('2||3'), r'2\|3')
resp = self.client.get(reverse('view_survey', args=['NonExisting'])) self.assertEquals(resp.status_code, 302)
context['show_partners'] = microsite.get_value('show_partners', True)
for key, value in key_value_map.iteritems(): index = self._get_index_of(key) type_in_codemirror(self, index, value) self.save()
with warnings.catch_warnings(record=True) as w: warnings.simplefilter("always")
assert_raises(ValueError, precision_recall_curve, [0, 1, 2], [[0.0], [1.0], [1.0]])
multioutput_y = np.column_stack([y2, y2[::-1]]) scores = cross_val_score(clf, X_sparse, multioutput_y) assert_array_equal(scores, clf.score(X_sparse, multioutput_y))
sim = np.array([[0, 5, 3, 4], [5, 0, 2, 2], [3, 2, 0, 1], [4, 2, 1, 0]])
response_providers = get_credit_provider_display_names(self.course_key) self.assertListEqual(self.PROVIDERS_LIST, response_providers)
docs_train, docs_test, y_train, y_test = train_test_split( dataset.data, dataset.target, test_size=0.5)
if hasattr(settings, 'LMS_SEGMENT_KEY') and settings.LMS_SEGMENT_KEY: tracking_context = tracker.get_tracker().resolve_context() identity_args = [
#unused_docs = []
t1 = phi / rho t2 = -theta / rho dk = (1 / rho) * w
with self.assertRaises(SearchIndexingError): CoursewareSearchIndexer.do_course_reindex(modulestore(), self.course.id)