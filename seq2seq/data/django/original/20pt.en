    try,
    call the method self.configure_root with 2 arguments: root and boolean True.
    if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to configure root logger: %s' formated with e.
    if not,
    remove config dictionary element under 'disable_existing_loggers' key, if it exists substitute it for disable_existing, if not,
    disable_existing is boolean True.   call the method logging._handler.clear.
    delete logging._handlerList list.
    get config dictionary element under 'formatters' key, if it exists substitute it for formatters, if not, formatters is EMPTY_DICT.
    for every name in formatters,
    try,
    call the method self.configure_filter with an argument value under name key of formatters dictionary,
    substitute the result for formatters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to configure formatter %r: %s' formated with name and e.
    get config dictionary element under 'filters' key, if it exists substitute it for filters, if not, filters is EMPTY_DICT.
    for every name in filters,
    try,
    call the method self.configure_filter with an argument value under name key of filters dictionary,
    substitute the result for filters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to configure filter %r: %s' formated with name and e.
    get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
    sort elements of handlers, for every name in result,
    try,
    call the method self.configure_handler with an argument value under name key of handlers dictionary, substitute the result for handler.
    substitute name for handler.name.
    substitute handler for value under name key of handlers dictionary.
    if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
    substitute logging.root for root.
    convert root.manager.loggerDict into a list, substitute it for existing.
    sort elements of list existing.
    child_loggers is an empty list.
    get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
    for every name in loggers,
    if name is contained in existing,
    get the index of first occurrence of name in existing, substitute it for i.
    append '.' to name, substitute the result for prefixed.
    substitute length of prefixed for pflen.
    substitute length of existing for num_existing.
    increment i by integer 1, substitute the result for i.
    while i is lesser than num_existing and first pflen elements of i-th element of existing equals prefixed,
    append i-th element of existing to child_loggers.
    increment i by integer 1, substitute the result for i.
    remove name from existing.
    try,
    call the method self.configure_logger with 2 arguments: name and value under loggers dictionary key name.
    if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
    for every log in existing,
    get the value under log key of root.manager.loggerDict dictionary, substitute it for logger.
    if log is contained in child_loggers,
    substitute logging.NOTSET for logger.level.
    logger.handlers is an empty list.
    logger.propagate is boolean True.
    otherwise if disable_existing is true,
    logger.disabled is boolean True.
    get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
    if root is true,
    try,
    call the method self.configure_root with an argument root.
    if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string ''Unable to configure root logger: %s' formated with e.
    finally perform,
    call the method logging._releaseLock.
    define the method configure_formatter with 2 arguments: self and config.
    if string '()' is contained in config,
    substitute config dictionary value under '()' key for factory.
    try,
    call the method self.configure_custom with an argument config, substitute the result for result.
    if TypeError, renamed to te, exception is caught,
    if string "'format'" is not contained in e converted into a string,
    raise an exception.
    remove config dictionary entry under 'format' key, substitute it for value under 'fmt' key of config dictionary.
    substitute factory for value under '()' key of config dictionary.
    call the method self.configure_custom with an argument config, substitute the result for result.
    if not,
    get config dictionary element under 'format' key, if it exists substitute it for fmt, if not, fmt is None.
    get config dictionary element under 'datefmt' key, if it exists substitute it for dfmt, if not, dfmt is None.
    call the method logging.Formatter with 2 arguments: fmt and dfmt, substitute the result for result.
    return result.
    define the method configure_filter with 2 arguments: self and config.
    if string '()' is contained in config,
    call the method self.configure_custom with an argument config, substitute the result for result.
    if not,
    remove config dictionary element under 'name' key, if it exists substitute it for name, if not, name is an empty string.
    call the method logging.Filter with an argument name, substitute the result for result.
    return result.
    define the method add_filters with 3 arguments: self, filterer and filters.
    for every f in filters,
    try,
    get the value under f key of dictionary under 'filters' key of self.config dictionary,
    use the result as an argument for the call to the method filterer.addFilter.   if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to add filter %r: %s' formated with f and e.
    define the method configure_handler with 2 arguments: self and config.
    remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
    if formatter is true,
    try,
    get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
    if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
    remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
    remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
    if string '()' is contained in config,
    remove config dictionary element under '()' key, substitute it for c.
    if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
    call the method self.resolve with an argument c, substitute the result for c.
    substitute c for factory.
    if not,
    remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
    substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
    try,
    get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
    under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
    formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
    call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
    substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
    call the method self.as_tuple with an argument value under 'address' key of config dictionary,
    substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
    kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
    for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
    call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
    if TypeError, renamed to te, exception is caught,
    if "'stream'" is not contained in te converted into a string,
    raise an exception.
    remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
    call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
    if formatter is true,
    call the method result.setFormatter with an argument formatter.
    if level is not None,
    call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
    if filters is true,
    call the method self.add_filters with 2 arguments: result and filters.
    return result.
    define the method add_handlers with 3 arguments: self, logger and handlers.
    for every h in handlers,
    try,
    call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
    if StandardError, renamed to e, exception is caught,
    raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
    define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
    get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
    if level is not None,
    call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
    if incremental is true,
    for every h in elements of logger.handlers list,
    call the method logger.removeHandler with an argument h.
    get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
    if handlers is true,
    call the method self.add_handlers with 2 arguments: logger and handlers.
    get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
    if filters is true,
    call the method self.add_filters with 2 arguments: logger and filters.
    define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
    call the method logging.getLogger with an argument name, substitute the result for logger.
    call the method self.common_logger_config with 3 arguments: logger, config and incremental.
    get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
    if propagate is not None,
    substitute propagate for logger.propagate.
    define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
    call the method logging.getLogger, substitute the result for root.
    call the method self.common_logger_config with 3 arguments: root, config and incremental.
    substitute DictConfigurator for dictConfigClass.
    define the function dictConfig with an argument config.
    call the method dictConfigClass with an argument config, call the method configure on the result.
    from __future__ import unicode_literals into default name space.
    import module codecs.
    import module datetime.
    from decimal import Decimal into default name space.
    import module locale.
    from django.utils.functional import Promise into default name space.
    from django.utils import six into default name space.
    from django.utils.six.moves.urllib.parse import quote into default name space.
    derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
    define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
    assign obj to the obj field of self instance of this class.
    call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
    define the private method __str__, with self instance of this class as the only argument.
    call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
    in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
    and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
    if field PY2 of the module six is boolean True,
    if string '__str__' is not contained in __dict__ field of klass,
    raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
    "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
    define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
    str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
    define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
    if s is instance of a class Promise,
    return s.
    return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
    _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
    datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
    check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
    define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
    if s is the instance of the object six.text_type,
    return s.
    if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
    return s.
    try,
    if s is not an instance of the object six/string_types,
    if PY3 filed of six is boolean True,
    if s is an instance of object bytes,
    call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
    if not,
    call the function six.text_type with s as an argument, substitute the result for s.
    otherwise, if s has an attribute '__unicode__',
    call the function six.text_type with s as an argument, substitute result for s.
    if not,
    call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
    substitute the result for s.   if not,
    call the method s.decode with encoding and errors as the arguments, substitute the result for s.
    if an exception of the type UnicodeDecodeError, renamed to e, is caught,
    if s is not an instance of the object Exception,
    raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
    if not,
    for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
    join the result in a string separated by whitespaces, substitute it for s.   return s.
    define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
    if s is an instance of an object Promise.
    return s.
    evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
    define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
    if s is an instance of an object bytes.
    if encoding equals to string 'utf-8'.
    return s.
    if not,
    evaluate the method s.decode with string 'utf-8' and errors as the arguments,
    on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
    return s.
    if s is an instance of an object six.memoryview.
    evaluate the function bytes with the argument s, and return the result.
    if s is an instance of an object Promise.
    return six.text_type(s).encode(encoding, errors).
    if s is not an instance of the object six.string_types,
    try,
    if PY3 field of six is boolean True,
    evaluate the method six.text_type(s), on the result call the method encode with encoding as an argument, return the result.
    if not,
    evaluate the function bytes with the argument s, and return the result.
    if the UnicodeEncodeError exception is caught,
    if s is an instance of the subclass Exception,
    for every arg in s, evaluate the function force_bytes for the arguments arg, encoding, strings_only and errors,
    put the results in a list, join the list elements in a string separated by whitespace separator, return the string as the bytes string.   evaluate the method six.text_type(s), on the result call the method encode with the arguments encoding and errors, return the result.
    if not,
    evaluate the member method of s, encode with the encoding and errors as the arguments, return the result.
    if PY3 field of module six is boolean True,
    substitute smart_text for smart_str.
    substitute force_text for force_str.
    if not,
    substitute smart_bytes for smart_str.
    substitute force_bytes for force_str.
    substitute smart_text for smart_unicode.
    substitute force_text for force_unicode.
    define the function iri_to_uri with iri as an argument.
    if iri is not initialized,
    return iri.
    call the function quote with return value of the evaluated function force_bytes(iri),
    and with safe set to bytes string "/#%[]=:;$&()+,!?*@'~", return the result.   define function filepath_to_uri with path as the argument.
    if path is not initialized,
    return path.
    evaluate function force_bytes with path as the argument, replace all of the occurancies of the "\\" with "/" in the resulting string,
    call the function quote with the result and with the safe set to bytes string "/~!*()'", return the function result.   define the function get_system_encoding without the input arguments.
    try,
    evaluate the function getdefaultlocale from the module locale, if second element of return value exists assign it to encoding,
    otherwise assign string 'ascii' to encoding.   call the method lookup with the encoding as the argument.
    if the Exception exception is caught,
    substitute string 'ascii' for encoding.
    return encoding.
    evaluate the function get_system_encoding(), substitute the return vale for DEFAULT_LOCALE_ENCODING.
    from __future__ import unicode_literals into default name space.
    import module datetime.
    from django.utils.xmlutils import SimplerXMLGenerator into default name space.
    from django.utils.encoding import force_text and iri_to_uri into default name space.
    from django.utils import datetime_safe into default name space.
    from django.utils import six into default name space.
    from django.utils.six import StringIO into default name space.
    from django.utils.six.moves.urllib.parse import urlparse into default name space.
    from django.utils.timezone import is_aware into default name space.
    define the function rfc2822_date with an argument date.
    months is a tuple with 12 elements: strings 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov' and 'Dec'.
    days is a tuple with 7 elements: strings 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' and 'Sun'.
    call the method datetime_safe.new_datetime with an argument date, substitute the result for date.
    call the method date.weekday, use the result as an key to obtain the value from the days dictionary, substitute it for dow.
    decrement date.month by integer 1, use the result as an key to obtain the value from the months dictionary, substitute it for month.
    call the function date.strftime with an argument string '%s, %%d %s %%Y %%H:%%M:%%S ' formated with dow and month,
    substitute the result for time_str.   if six.PY2 is true,
    call the method time_str.decode with an argument string 'utf-8', substitute the result for time_str.
    call the function is_aware with an argument date, if it evaluates to true,
    call the method date.tzinfo.utcoffset with an argument date, substitute the result for offset.
    multiply offset.days, integer 24 and integer 60, sum the result with floored result of dividing offset.seconds by integer 60,
    substitute the result for timezone.   divide timezone by integer 60, substitute the quotient of the division for hour and reminder for minute.
    format string '%+03d%02d' with hour and minute, append it to time_str, return the result.
    if not,
    append string '-0000' to time_str, return the result.
    define the function rfc3339_date with an argument date.
    call the function datetime_safe.new_datetime with an argument date, substitute the result for date.
    call the function date.strftime with an argument string '%Y-%m-%dT%H:%M:%S', substitute the result for time_str.
    if six.PY2,
    call the method time_str.decode with an argument string 'utf-8', substitute the result for time_str.
    call the function is_aware with an argument date, if it evaluates to true,
    call the method date.tzinfo.utcoffset with an argument date, substitute the result for offset.
    multiply offset.days, integer 24 and integer 60, sum the result with floored result of division of offset.seconds,
    and integer 60, substitute the result for timezone.   divide timezone by integer 60, substitute the quotient of the division for hour and reminder for minute.
    format string '%+03d:%02d' with hour and minute, append it to time_str, return the result.
    if not,
    append 'Z' to time_str, return the result.
    define the function get_tag_uri with 2 arguments: url and date.
    call the method urlparse with an argument url, substitute the result for bits.
    d is an empty string.
    if date is not None,
    call the function datetime_safe.new_datetime with an argument date, on the result call the method strftime with an argument,
    string '%Y-%m-%d', convert the result into a string and append it to ',', substitute the result for d.   format string 'tag:%s%s:%s/%s' with bits.hostname, d, bits.path and bits.fragment, return it.
    derive the class SyndicationFeed from the object base class.
    define the method __init__ with 15 elements: self, title, link, description, language set to None, author_email set to None,
    author_name set to None, author_link set to None, subtitle set to None, categories set to None, feed_url set to None,   feed_copyright set to None, feed_guid set to None, ttl set to None and unpacked dictionary kwargs.   to_unicode is an lambda function with an argument s, result is the result of the function force_text,
    called with 2 arguments: s and string_only as boolean True.   if categories is true,
    categories is a list containing the results of the function force_text, called with an argument c, for every c in categories.
    if ttl is not None,
    call the function force_text with an argument ttl, substitute the result for ttl.
    self.feed is an dictionary with 13 initial entries, result of the function to_unicode called with an argument title for 'title',
    result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument language for 'language',   result of the function to_unicode called with an author_email description for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an argument author_link for 'author_link',   result of the function to_unicode called with an argument subtitle for 'subtitle',   if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function iri_to_uri called with an argument feed_url for 'feed_url',   result of the function to_unicode called with an argument feed_copyright for 'feed_copyright',   if true, feed_guid is value for 'id' key, if not, lik is value for 'id' key and ttl for 'ttl'.   update self.feed dictionary with kwargs.
    self.items is an empty list.
    define the method add_item with 17 arguments: self, title, link, description, author_email set to None, author_name set to None,
    to_unicode is an lambda function with an argument s, result is the result of the function force_text,
    called with 2 arguments: s and string_only as boolean True.   if categories is true,
    categories is a list containing the results of the function to_unicode, called with an argument c, for every c in categories.
    if ttl is not None,
    call the function force_text with an argument ttl, substitute the result for ttl.
    item is a dictionary with 15 initial entries: result of the function to_unicode called with an argument title for 'title',
    result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument author_email for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an author_link link for 'author_link', pubdate for 'pubdate',   updateddate for 'updateddate', result of the function to_unicode called with an comments author_name for 'comments',   result of the function to_unicode called with an argument unique_id) for 'unique_id)',   unique_id_is_permalink for 'unique_id_is_permalink', enclosure for 'enclosure',    if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function to_unicode called with an argument item_copyright for 'item_copyright', ttl for 'ttl'.   update dictionary item with an argument kwargs.
    append item to self.items.
    define the method num_items with an argument self.
    return length of self.items.
    define the method root_attributes with an argument self.
    return an empty dictionary.
    define the method add_root_elements with 2 arguments self and handler.
    do nothing.
    define the method item_attributes with 2 arguments self and item.
    return an empty dictionary.
    define the method add_item_elements with 2 arguments, handler self and item.
    do nothing.
    define the method write with 3 arguments self, outfile and encoding.
    raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
    define the method writeString with 2 arguments self and encoding.
    s is an instance of StringIO class.
    call the method self.write with 2 arguments: s and encoding.
    call the method s.getvalue, return the result.
    define the method latest_post_date with an argument self.
    latest_date is None.
    date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
    for every item in self.items,
    for every date_key in date_keys,
    get the value under the date_key key of the item dictionary, substitute it for item_date.
    if item_date is true,
    if latest_date is None or item_date is greater than latest_date,
    substitute item_date for latest_date.
    if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
    derive the class Enclosure from the object base class.
    define the method __init__ with 4 arguments: self, url, length and mime_type.
    substitute length and mime_type for self.length and self.mime_type.
    call the function iri_to_uri with an argument url, substitute the result for self.url.
    derive the class RssFeed from the SyndicationFeed base class.
    mime_type is a string 'application/rss+xml; charset=utf-8'.
    define the method write with 3 arguments: self, outfile and encoding.
    handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
    call the method handler.startDocument.
    call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
    call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
    call the method self.add_root_elements with an argument handler.
    call the method self.write_items with an argument handler.
    call the method self.endChannelElement with an argument handler.
    call the method handler.endElement with an argument string 'rss'.
    define the method rss_attributes with an argument self.
    return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
    define the method write_items with 2 arguments: self and handler.
    for every item in self.items,
    call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
    call the method self.add_item_elements with 2 arguments: handler and item.
    call the method handler.endElement with an argument string 'item'.
    define the method add_root_elements with 2 arguments: self and handler.
    call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
    if value under the 'feed_url' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
    value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
    for every cat in value under the 'categories' key of the self.feed dictionary.
    call the method handler.addQuickElement with 2 arguments: string "category" and cat.
    if value under the 'feed_copyright' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
    called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
    define the method endChannelElement with 2 arguments: self and handler.
    call the method handler.endElement with an argument string 'channel'.
    derive the class RssUserland091Feed from the RssFeed base class.
    _version is a string "0.91".
    define the method add_item_elements with 3 arguments: self, handler and item.
    call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
    if value under the 'description' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
    derive the class Rss201rev2Feed from the RssFeed base class.
    _version is a string "2.0".
    define the method add_item_elements with 3 arguments: self, handler and item.
    call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
    if value under the 'description' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
    if values under "author_name" and "author_email" keys of the item dictionary are both true,
    call the method handler.addQuickElement with an argument string "author", "%s (%s)",
    formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
    call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
    otherwise if value under the "author_name" key of the item dictionary is true,
    call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
    value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
    called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
    if value under the 'unique_id' key of the item dictionary is not None,
    guid_attrs is an empty dictionary.
    if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
    covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
    substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
    and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
    if value under the 'enclosure' key of the item dictionary is not None,
    call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
    field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
    call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
    derive the class Atom1Feed from the SyndicationFeed base class.
    mime_type is a string 'application/atom+xml; charset=utf-8'.
    ns is a string "http://www.w3.org/2005/Atom".
    define the method write with 3 arguments: self, outfile and encoding.
    handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
    call the method handler.startDocument.
    call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
    call the method self.add_root_elements with an argument handler.
    call the method self.write_items with an argument handler.
    call the method handler.endElement with an argument string 'feed'.
    define the method root_attributes with an argument self.
    if value under the 'language' key of the self.feed dictionary is not None,
    return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
    and self.ns for "xmlns".   if not,
    return a dictionary with an entry: self.ns for "xmlns".
    define the method add_root_elements with 2 arguments: self and handler.
    call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
    call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
    'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
    'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
    called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
    call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
    if value under the 'author_email' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
    if value under the 'author_link' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
    call the method handler.endElement with an argument string 'author'.
    if value under the 'subtitle' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
    for every cat in value under the 'categories' key of the self.feed dictionary.
    call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
    cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
    define the method write_items with 2 arguments: self and handler.
    for every item in self.items,
    call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
    called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
    call the method handler.endElement with an argument string 'entry'.
    define the method add_item_elements with 3 arguments: self, handler and item.
    call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
    call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
    value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
    called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
    called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
    call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
    call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
    if value under the 'author_email' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
    if value under the 'author_link' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
    call the method handler.endElement with an argument string 'author'.
    if value under the 'unique_id' key of the item dictionary is not None,
    substitute value under 'unique_id' key of item dictionary for unique_id.
    if not,
    call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
    call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
    if value under the 'description' key of the item dictionary is not None,
    call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
    and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
    call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
    "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
    call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
    cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
    call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
    substitute Rss201rev2Feed for DefaultFeed.
    from __future__ import absolute_ into default name space.
    import module decimal.
    import module datetime.
    from importlib import import_module into default name space.
    import module unicodedata.
    from django.conf import settings into default name space.
    from django.utils import dateformat, numberformat and datetime_safe into default name space.
    from django.utils.encoding import force_str into default name space.
    from django.utils.functional import lazy into default name space.
    from django.utils.safestring import mark_safe into default name space.
    from django.utils import six into default name space.
    from django.utils.translation import get_language, to_locale and check_for_language into default name space.
    _format_cache is an empty dictionary.
    _format_modules_cache is an empty dictionary.
    ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
    tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
    use global variables _format_cache and _format_modules_cache.
    _format_cache is an empty dictionary.
    _format_modules_cache is an empty dictionary.
    define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
    call the function check_for_language with an argument lang, if it evaluates to false,
    return nothing.
    if format_module_path is None.
    substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
    format_locations is an empty list.
    if format_module_path is true,
    if format_module_path is an instance of six.string_types,
    format_module_path is a list containing an element format_module_path.
    for every path in format_module_path,
    concatenate path and string '.%s', append the result to format_module_path.
    append string 'django.conf.locale.%s' to format_locations.
    call the function to_locale with an argument lang, substitute the result for locale.
    locales is a list with an element locale.
    if '_' is contained in locale,
    split locale by '_', append the first element of the result to locales.
    for every location in format_locations,
    for every loc in locales,
    try,
    call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
    yield the result.   if ImportError exception is caught,
    do nothing.
    define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
    if lang is None,
    call the function get_language, substitute the result for lang.
    call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
    iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
    reverse the order of modules elements, put them into a list, return it.
    return modules.s
    define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
    call the function force_str with an argument format_type, substitute the result for format_type.
    if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
    if lang is None,
    call the function get_language, substitute the result for lang.
    cache_key is a tuple with 2 argumetns: format_type and lang.
    try,
    substitute value under the cache_key key of the _format_cache dictionary for cached.
    if cached is not None,
    return cached.
    if not,
    get format_type attribute of the settings object, return it.
    if KeyError exception is caught,
    call the function get_format_modules with an argument lang, for every module in the result,
    try,
    get format_type attribute of module object, substitute the result for val.
    get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
    for every iso_input in the result,   if iso_input is not contained in val,
    if val is an instance of tuple,
    convert val to an list, substitute it for val.
    append iso_input to val.
    substitute val for the value under the cache_key key of the _format_cache dictionary.
    return val.
    if AttributeError exception is caught,
    do nothing.
    value under the cache_key key of the _format_cache dictionary is None.
    get format_type attribute of the settings object, return it.
    call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
    define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
    call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
    format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
    call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
    format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
    if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
    call the function get_language, substitute the result for lang.
    if not,
    lang is None.
    call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
    string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
    if value is an instance of bool.
    call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
    return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
    call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
    otherwise if value is an instance of datetime.datetime,
    call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
    otherwise if value is an instance of datetime.date,
    call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
    otherwise if value is an instance of datetime.time,
    call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
    if not,
    return value.
    define the function localize_input with 2 arguments value and default set to None.
    otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
    call the function number_format with an argument value, return the result.
    otherwise if value is an instance of datetime.datetime,
    call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
    call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
    get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
    otherwise if value is an instance of datetime.date,
    call the method datetime_safe.new_date with an argument value, substitute the result for value.
    call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
    get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
    otherwise if value is an instance of datetime.time,
    call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
    get_format called with an argument string 'TIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
    return value.
    define the function sanitize_separators with an argument value.
    if settings.USE_L10N is true and value is an instance of six.string_types,
    parts is an empty list.
    call the function get_format with an argument string 'DECIMAL_SEPARATOR', substitute the result for decimal_separator.
    if decimal_separator is contained in value,
    split value into two parts by decimal_separator, assign the result to value and decimals.
    append decimals to parts.
    if settings.USE_THOUSAND_SEPARATOR is true,
    call the function get_format with an argument string 'THOUSAND_SEPARATOR', substitute the result for thousand_sep.
    call the function unicodedata.normalize with 2 arguments: string 'NFKD' and thousand_sep, put the result and thousand_sep into a set,
    for every replacement in the resulting set,   replace every occurrence of replacement in value for an empty string, substitute the result for value.
    append value to parts.
    reverse order of parts, join them into a string, separated with '.', substitute the result for value.
    return value.
    import module copy.
    import module opera.
    from functools import wraps into default name space.
    import module sys.
    import module warnings.
    from django.utils import six into default name space.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    from django.utils.six.moves import copyreg into default name space.
    define the function curry with 3 arguments: _curried_func, unpacked list args and unpacked dictionary kwargs.
    define the function _curried with 2 arguments: unpacked list moreargs and unpacked dictionary morekwargs.
    call the function _curried_func with 2 arguments: list moreargs appended to args and unpacked,
    unpacked dictionary created with elements of morekwargs dictionary through the kwargs mapping, return the result.   return _curried.
    define the function memoize with 3 arguments: func, cache and num_args.
    call the function warnings.warn with 3 arguments:
    string "memoize wrapper is deprecated and will be removed in Django 1.9. Use django.utils.lru_cache instead.",   RemovedInDjango19Warning and stacklevel set to integer 2.   decorator function wraps with an argument func.
    define the function wrapper with an argument unpacked list args.
    mem_args is a list containing of first num_args elements of args list.
    if mem_args is contained in cache,
    get the value under the mem_args key of the cache dictionary, return it.
    call the function func with an argument unpacked list args, substitute the result for result.
    substitute result for value under the mem_args key of the cache dictionary.
    return result.
    return wrapper.
    derive the class cached_property from the object base class.
    define the method __init__ with 3 arguments: self, func and name set to None.
    substitute func for self.func.
    if name is true, substitute it for self.name, otherwise substitute func.__name__ for self.name.
    define the method __get__ with 3 arguments: self, instance and name type to None.
    if instance is None,
    return self.
    call the function self.func with an argument instance, substitute the result for res and value under the self.name key of the instance.__dict__ dictionary.
    return res.
    derive the class Promise from the object base class.
    do nothing.
    define the function lazy with 2 arguments: func and unpacked list resultclasses.
    decorator total_ordering,
    derive the class __proxy__ from the Promise base class.
    __dispatch is None.
    define the method __init__ with 3 arguments: self, args and kw.
    substitute args for self.__args.
    substitute kw for self.__kw.
    if self.__dispatch is None.
    call the method self.__prepare_class__.
    define the method __reduce__ with an argument self.
    return a tuple wit 2 elements: _lazy_proxy_unpickle and tuple with 3 elements: func, self.__args, self.__kw and resultclasses.
    classmethod decorator,
    define the method __prepare_class__ with an argument self.
    cls.__dispatch is an empty dictionary.
    for every resultclass in resultclasses,
    value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
    call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
    for every k and v in result of the call to the method type_.__dict__.items,
    call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
    if cls has an attribute k,
    skip this loop iteration,
    set k attribute of cls object to meth.
    if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
    if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
    if cls._delegate_bytes and cls._delegate_text are both false, raise an error, with an argument string "Cannot call lazy() with both bytes and text return types.".
    if cls._delegate_text is true,
    if six.PY3 is true,
    substitute cls.__text_cast for cls.__str__.
    if not,
    substitute cls.__text_cast for cls.__text_cast.
    otherwise if cls._delegate_bytes is true,
    if six.PY3 is true,
    substitute cls.__bytes_cast for cls.__bytes__.
    if not,
    substitute cls.__bytes_cast for cls.__str__.
    class method decorator,
    define the method __promise__ with 4 arguments: cls, klass, funcname and method.
    define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
    call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
    get the type of res, call the method mro on the result, for every t in the result,
    if t is contained in self.__dispatch,
    get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
    unpacked list args and unpacked dictionary kw, return the result.   raise an TypeError exception with an argument sting "Lazy object returned unexpected type.".
    if klass is not contained in cls.__dispatch,
    value under the klass key of the cls.__dispatch dictionary is an empty dictionary.
    substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch dictionary.
    return __wrapper__.
    define the method __text_cast with an argument self.
    call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
    define the method __bytes_cast with an argument self.
    call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw,
    use the result as an argument for the call to the function bytes, return the result.   define the method __cast with an argument self.
    if self._delegate_bytes is true,
    call the method self.__bytes_cast, return the result.
    otherwise if self._delegate_text is true,
    call the method self.__text_cast, return the result.
    if not,
    call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
    define the method __ne__ with 2 arguments: self and other.
    if other is an instance of Promise class,
    call the method other.__cast, substitute the result for other.
    call the method self.__cast, if the result doesnt equal to other, return boolean True, otherwise return boolean False.
    define the method __ne__ with 2 arguments: self and other.
    if other is an instance of Promise class,
    call the method other.__cast, substitute the result for other.
    call the method self.__cast, if the result equals other, return boolean True, otherwise return boolean False.
    define the method __lt__ with 2 arguments: self and other.
    if other is an instance of Promise,
    call the method other.__cast, substitute the result for other.
    call the method self.__cast, if the result is lesser than other, return boolean True, otherwise return boolean False.
    define the method __hash__ with an argument self.
    call the method self.__cast, return the hash value of the result.
    define the method __mod__ with 2 arguments: self and rhs.
    if self._delegate_bytes and six.PY2 are both true,
    call the function bytes with an argument self, divide the result with rhs and return the reminder of the division.
    otherwise if self._delegate_text is true,
    call the function six.text_type with an argument self, divide the result with rhs and return the reminder of the division.
    call the function sself.__cast with an argument self, divide the result with rhs and return the reminder of the division.
    define the method __deepcopy__ with 2 arguments: self and memo.
    get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
    return self.
    decorator function wraps with an argument func.
    define the function __wrapper__ with 2 arguments: unpacked list args and unpacked dictionary kw.
    call the function __proxy__ with 2 arguments: args and kw, return the result.
    return __wrapper__.
    define the function _lazy_proxy_unpickle with 4 arguments: func, args, kwargs and unpacked list resultclasses.
    call the function lazy with 2 arguments: func and unpacked list resultclasses, call the result with 2 arguments: unpacked list args,
    and unpacked dictionary kwargs.   define the function allow_lazy with 2 arguments: func and unpacked list resultclasses.
    decorator function wraps with an argument func.
    define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwargs.
    call the function six.itervalues with an argument kwargs, convert the result to a list and append it to a list containing args,
    for every arg in the result,   if arg is an instance of Promise class,
    break from the loop execution,
    if not,
    call the function func with 2 arguments: unpacked list args and unpacked dictionary kwargs.
    call the function lazy with 2 arguments: func and unpacked list resultclasses, call the result with 2 arguments: unpacked list args,
    and unpacked dictionary kwargs, return the result.   return wrapper.
    empty is an instance of object class.
    define the function new_method_proxy with an argument func.
    define the method inner with 2 arguments: self and unpacked list args.
    if self._wrapped is contained in empty,
    call the method self._setup.
    call the function func with 2 arguments: self._wrapped and unpacked list args.
    self._wrapped.
    derive the class LazyObject from the object base class.
    _wrapped is None.
    define the method __init__ with an argument self.
    substitute empty for self._wrapped.
    call the function new_method_proxy with an argument getattr, substitute the result for __getattr__.
    define the method __setattr__ with 3 arguments: self, name and value.
    if name equals string "_wrapped",
    substitute value under the "_wrapped" key of the self.__dict__ dictionary.
    if not,
    if self._wrapped is empty,
    call the method self._setup.
    set name attribute of self._wrapped object to value.
    define the method __delattr__ with 2 arguments self and name.
    if name equals string "_wrapped",
    raise an TypeError exception with an argument sting "can't delete _wrapped.".
    if self._wrapped is empty,
    call the method self._setup.
    delete name attribute from self._wrapped object.
    define the method _setup with an argument self.
    raise an NotImplementedError exception with an argument sting 'subclasses of LazyObject must provide a _setup() method'.
    define the method __getstate__ with an argument self.
    if self._wrapped is empty,
    call the method self._setup.
    return self._wrapped.__dict__.
    classmethod decorator,
    define the method __newobj__ with 2 arguments cls and unpacked list args.
    call the method cls.__new__ with 2 arguments: cls and unpacked list args.
    define the method __reduce_ex__ with 2 arguments self and proto.
    if proto is greater than or equal to integer 2,
    return a tuple with 3 elements: self.__newobj__, tuple with an element self.__class__ and result of the method self.__getstate__.
    if not,
    return a tuple with 3 elements: copyreg._reconstructor, tuple with 3 elements: self.__class__, object and None,
    and result of the method self.__getstate__.   define the method __deepcopy__ with 2 arguments self and memo.
    if self._wrapped is empty,
    get type of self, call it and substitute the result for result.
    get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
    return result.
    call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
    if six.PY3 is true,
    call the function new_method_proxy with an argument bytes, substitute the result for __bytes__.
    call the function new_method_proxy with an argument str, substitute the result for __str__.
    call the function new_method_proxy with an argument bool, substitute the result for __bool__.
    if not,
    call the function new_method_proxy with an argument str, substitute the result for __str__.
    call the function new_method_proxy with an argument unicode, substitute the result for __unicode__.
    call the function new_method_proxy with an argument bool, substitute the result for __nonzero__.
    call the function new_method_proxy with an argument dir, substitute the result for __dir__.
    cal the method operator.attrgetter with an argument string "__class__", use the result as an argument for the call to the function,
    new_method_proxy, __class__ is an property object created with previous result as an argument.   call the function new_method_proxy with an argument operator.eq, substitute the result for __eq__.
    call the function new_method_proxy with an argument operator.ne, substitute the result for __ne__.
    call the function new_method_proxy with an argument hash, substitute the result for __hash__.
    call the function new_method_proxy with an argument operator.getitem, substitute the result for __getitem__.
    call the function new_method_proxy with an argument operator.setitem, substitute the result for __setitem__.
    call the function new_method_proxy with an argument operator.delitem, substitute the result for __delitem__.
    call the function new_method_proxy with an argument len, substitute the result for __len__.
    call the function new_method_proxy with an argument operator.contains, substitute the result for __contains__.
    substitute super for _super.
    derive the class SimpleLazyObject from the LazyObject base class.
    define the method __init__ with 2 arguments self and func.
    substitute func for value under the '_setupfunc' key of the self.__dict__ dictionary.
    call the function _super with 2 arguments: class SimpleLazyObject and self, call the method __init__ on the result.
    define the method _setup with an argument self.
    call the method self._setupfunc, substitute the result for self._wrapped.
    define the method __repr__ with an argument self.
    if self._wrapped is empty,
    substitute self._setupfunc for repr_attr.
    if not,
    substitute self._wrapped for repr_attr.
    return a string '<%s: %r>', format it with __name__ field of the self class and repr_attr.
    define the method __deepcopy__ with 2 arguments self and memo.
    if self._wrapped is empty,
    result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
    get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
    return result.
    call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
    derive the class lazy_property from the property base class.
    define the method __new__ with 5 arguments: cls, fget set to None, fset set to None, fdel set to None and doc set to None.
    if fget is not None,
    decorator function wraps with an argument fget.
    define the function fget with 3 arguments: instance, instance_type set to None and name set to fget.__name__.
    get name attribute from the instance object, call it and return the result.
    if fset is not None,
    decorator function wraps with an argument fset.
    define the function fset with 3 arguments: instance, valse to None and name set to fset.__name__.
    get name attribute from the instance object, call it with an argument value and return the result.
    if fdel is not None,
    decorator function wraps with an argument fdel.
    define the function fdel with 2 arguments: instance and name set to fdel.__name__.
    get name attribute from the instance object, call it and return the result.
    return an property object with getter function fget, setter function fset, destructor fdel and documentation string doc.
    define the function partition with 2 arguments: predicate and values.
    results is a tuple with 2 elements, 2 empty lists.
    for every item in values,
    call the function predicate with an argument item, use it as a key to get results dictionary value, append item to it.
    return results.
    if sys.version_info is greater than or equal to a tuple with 3 elements: integers 2, 7 and 2, respectively,
    from functools import total_ordering.
    if not,
    define the function total_ordering with an argument cls.
    convert is a dictionary with 4 initial entries: list with 3 tuples: tuple with 2 elements: string '__gt__',
    and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other, for '__lt__',   list with 3 tuples: tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other,   or self is equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than or equal to other,   or self is not equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other, for '__le__',   list with 3 tuples: tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other, for '__gt__',   and list with 3 tuples: tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is not greater than or is not equal to other,   or self is equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than or not equal to other,   or self is not equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than or equal to other, for '__ge__',   convert cls to a dictionary, convert the result into a set and convert convert into a set, roots is a set of differences of the two previous sets.
    if roots is false,
    raise an ValueError exception with an argument string 'must define at least one ordering operation: < > <= >='.
    get maximal element from roots and substitute it for root.
    get the value under the root key of the convert dictionary, for every opname and opfunc in the result,
    if opname is not contained in roots,
    substitute opname for opfunc.__name__.
    get opname attribute from int object, substitute its field __doc__ for opfunc.__doc__.
    set opname attribute of cls object to opfunc.
    return cls.
    from __future__ import unicode_literals into default name space.
    import module re.
    import module sys.
    from django.utils.encoding import force_text and force_str into default name space.
    from django.utils.functional import allow_lazy into default name space.
    from django.utils.safestring import SafeData and mark_safe into default name space.
    from django.utils import six into default name space.
    from django.utils.six.moves.urllib.parse import quote, unquote, urlsplit and urlunsplit into default name space.
    from django.utils.text import normalize_newlines into default name space.
    from .html_parser import HTMLParser and HTMLParseError into default name space.
    TRAILING_PUNCTUATION is a list with 7 elements: '.', ',', ':', ';', '.)', '"' and '\''.
    WRAPPING_PUNCTUATION is a list with 6 elements: tuple with 2 elements: '(' and ')', tuple with 2 elements: '<' and '>',
    tuple with 2 elements: '[' and ']', tuple with 2 elements: '&lt' and '&gt', tuple with 2 elements: '"' and '"',   and tuple with 2 elements: '\'' and '\''.   DOTS is a list with 6 elements: strings '&middot;', '*', '\u2022', '&#149;', '&bull;' and '&#8226;'.
    call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for unencoded_ampersands_re.
    call the function re.compile with raw string '(\s+)', substitute the result for word_split_re.
    call the function re.compile with 2 arguments: raw string '^https?://\[?\w' and re.IGNORECASE, substitute the result for simple_url_re.
    call the function re.compile with 2 arguments: raw string '^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$',
    and re.IGNORECASE, substitute the result for simple_url_re.   call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for simple_email_re.
    call the function re.compile with raw string '(<a [^>]*?)target=[^\s>]+', substitute the result for link_target_attribute_re.
    call the function re.compile with 2 arguments:
    raw string '(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' and re.IGNORECASE,   substitute the result for html_gunk_re.   call the function re.compile with 2 arguments: raw string '((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)',
    formated with string created by joining elements of result of the function re.escape with an argument x, with separator '|',   for every x in DOTS, and re.DOTALL, substitute the result for hard_coded_bullets_re.   call the function re.compile with raw string '(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z', substitute the result for trailing_empty_content_re.
    define the function escape with an argument text.
    call the function force_text with an argument text, replace every occurrence of '&' in the result with '&amp;',
    every occurrence of '<' with '&lt;', every occurrence of '>' with '&gt;', every occurrence of '"' with '&quot;',   and every occurrence of "'" with '&#39;', call the function mark_safe with the previous result as an argument, return the result.   call the function allow_lazy with 2 arguments: escape, six.text_type, substitute the result for escape.
    _js_escapes is a dictionary with 11 initial entries: '\\u005C' for integer representation of string '\\',
    '\\u0027' for integer representation of string '\', '\\u0022' for integer representation of string '"',   '\\u003E' for integer representation of string '>', '\\u003C' for integer representation of string '<',   '\\u0026' for integer representation of string '%', '\\u003D' for integer representation of string '=',   '\\u002D' for integer representation of string '-', '\\u003B' for integer representation of string ';',   '\\u2028' for integer representation of string '\u2028' and '\\u2029' for integer representation of string '\u2029'.   for eery z in range of integers from 0 to 31, update _js_escapes dictionary with '\\u%04X' formated with z,
    for integer representation of z converted into a string.   define the function escapejs with an argument value.
    call the function force_text with an argument value, call the method translate on the result, with an argument _js_escapes,
    use the result as an argument for the call to the mark_safe function, return the result.   call the function allow_lazy with 2 arguments: escapejs, six.text_type, substitute the result for escapejs.
    define the function conditional_escape with an argument text.
    if text has an '__html__' attribute,
    call the method text.__html__, return the result.
    if not,
    call the function escape with an argument text, return the result.
    define the function format_html with 3 arguments: format_string, unpacked list args and unpacked dictionary kwargs.
    map elements from args through the function conditional_escape, substitute the result for args_safe.
    kwargs_safe is a dictionary created for every k and v in result of the function six.iteritems called with an argument kwargs,
    with value result of the conditional_escape function called with an argument v for key k.   call the method format_string.format with 2 arguments: unpacked list args_safe and unpacked dictionary kwargs_safe,
    use the result as an argument for the call to the function mark_safe, return the result.   define the function format_html_join with 3 arguments: sep, format_string and args_generator.
    join results of format_html called with 2 arguments: format_string and tuple with an element args, into a string,
    separated with result of the function conditional_escape with an argument sep, for every args in args_generator,   use the result as an argument for the call to the function mark_safe, return the result.   define the function linebreaks with 2 arguments: value and autoescape set to boolean False.
    call the function normalize_newlines with an argument value, substitute the result for value.
    call the method re.split with 2 arguments: string '\n{2,}' and value, substitute the result for paras.
    if autoescape is true,
    call the function escape with an argument p, replace every occurrence of '\n' in the result for '<br />',
    format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   if not,
    replace every occurrence of '\n' in p for '<br />',
    format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   join elements of paras into a string separated with '\n\n', return the result.
    call the function allow_lazy with 2 arguments: linebreaks, six.text_type, substitute the result for linebreaks.
    derive the class MLStripper from the HTMLParser base class.
    define the method __init__ with an argument self.
    if fist and second element of sys.version_info equals to integer 3 and 2, respectively,
    call the method HTMLParser.__init__ with 2 arguments: self and strict set to boolean False.
    if not,
    call the method HTMLParser.__init__ with an argument self.
    call the method self.reset.
    self.fed is an empty list.
    define the method handle_data with 2 arguments self and d.
    append d to self.fed.
    define the method handle_entityref with 2 arguments self and name.
    format string '&%s;' with name, append it to self.fed.
    define the method handle_charref with 2 arguments self and name.
    format string '&#%s;' with name, append it to self.fed.
    define the method get_data with an argument self.
    join elements of self.fed into a string, return the result.
    define the function _strip_once with an argument value.
    s is an instance of MLStripper class.
    try,
    call the method s.feed with an argument value.
    if HTMLParseError exception is caught,
    return value.
    try,
    close file descriptor s.
    if HTMLParseError or UnboundLocalError exceptions are caught,
    sum the result of the method s.get_data and s.rawdata, return the result.
    if not,
    call the method s.get_data, return the result.
    define the function strip_tags with an argument value.
    while '<' is contained in value and '>' is contained in value,
    call the function _strip_once with an argument value, substitute the result for new_value.
    if new_value equals value,
    break from the loop execution.
    substitute new_value for value.
    return value.
    call the function allow_lazy with an argument strip_tags, substitute the result for strip_tags.
    define the function remove_tags with 2 arguments: html and tags.
    tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
    join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
    call the function re.compile with 2 arguments: raw string '<%s(/?>|(\s+[^>]*>))' formated with tags_re and re.U,
    substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
    call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
    call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
    return html.
    call the function allow_lazy with 2 arguments: remove_tags, six.text_type, substitute the result for remove_tags.
    define the function strip_spaces_between_tags with an argument value.
    call the method re.sub with 3 arguments: raw string '>\s+<', string '><' and result of the function force_text,
    called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_spaces_between_tags, six.text_type, substitute the result for strip_spaces_between_tags.
    define the function strip_entities with an argument value.
    call the method re.sub with 3 arguments: raw string '&(?:\w+|#\d+);', empty string and result of the function force_text,
    called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_entities, six.text_type, substitute the result for strip_entities.
    define the function smart_urlquote with an argument url.
    try,
    call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
    try,
    call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
    substitute the result for netloc.   if UnicodeError exception is caught,
    do nothing.
    if not,
    call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
    if ValueError exception is caught,
    do nothing.
    call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
    call the function quote with 2 arguments: url and safe as bytes string '!*\'();:@&=+$,/?#[]~', substitute the result for url.
    call the function force_text with an argument url, return the result.
    define the function urlize with 4 arguments: text, trim_url_limit set to None, nofollow set to boolean False,
    define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
    if limit is None or length of x is lesser than or equal to limit,
    return x.
    return a string '%s...' formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit.
    if text is an instance of SafeData, safe_input is boolean True, otherwise is boolean False.
    call the function force_text with an argument text, split by it word_split_re, substitute it for words.
    for every i and word in enumerated iterable words,
    if '.' is contained in words or '@' is contained in word or ':' is contained in word,
    substitute empty string, word an empty string for lead, middle and trail, respectively.
    for every punctuation in TRAILING_PUNCTUATION,
    if middle ends with punctuation,
    substitute elements of middle from the beginning to the negative length of punctuation, for middle.
    sum punctuation and trail, substitute the result for trail.
    for every opening and closing in WRAPPING_PUNCTUATION,
    if middle starts with opening,
    substitute elements of middle from length of opening index to the end, for middle.
    sum lead and opening, substitute the result for lead.
    if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one,
    substitute elements of middle from the beginning to the negative length of closing, for middle.
    sum trail and closing, substitute the result for lead.
    url is None.
    if nofollow is true nofollow_attr is a string ' rel="nofollow"', otherwise nofollow_attr is an empty string.
    call the method simple_url_re.match with an argument middle, if it evaluates to true,
    call the function smart_urlquote with an argument middle, substitute the result for url.
    otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true,
    call the function smart_urlquote with an argument string 'http://%s' formated with an argument middle, substitute the result for url.
    otherwise if ':' is not contained in middle and result of the function simple_email_re.match called with an argument middle,
    evaluates to true,   split middle into two parts from the right by '@' character, assign the resulting parts to local and domain.
    try,
    call the method domain.encode with an argument string 'idna', call the method decode on the result with an argument string 'ascii',
    substitute the result for domain.   if UnicodeError exception is caught,
    skip this loop iteration.
    url is a string 'mailto:%s@%s' formated with local and domain.
    nofollow_attr is an empty string.
    if url is true,
    call the function trim_url with an argument middle, substitute the result for trimmed.
    if autoescape is true and safe_input is false,
    call the function escape with an argument lead, substitute the result for lead, call the function escape with an argument trail,
    substitute the result for trail.   call the function escape with an argument url, substitute the result for url, call the function escape with an argument trimmed,
    substitute the result for trimmed.   middle is a string '<a href="%s"%s>%s</a>' formated with url, nofollow_attr and trimmed.
    format string '<a href="%s"%s>%s</a>' with lead, middle and trail, use it as an argument for the call to the function mark_safe,
    substitute the result for i-th element of words.   if not,
    if safe_input is true,
    call the function mark_safe with an argument word, substitute the result for i-th element of words.
    otherwise if autoescape is true,
    call the function escape with an argument word, substitute the result for i-th element of words.
    otherwise if safe_input is true,
    call the function mark_safe with an argument word, substitute the result for i-th element of words.
    otherwise if autoescape is true,
    call the function escape with an argument word, substitute the result for i-th element of words.
    join elements of words into a string, return it.
    call the function allow_lazy with 2 arguments: urlize, six.text_type, substitute the result for urlize.
    define the function avoid_wrapping with an argument value.
    replace every occurrence of ' ' in value for '\xa0', return the result.
    from django.utils.six.moves import html_parser as _html_parse into default name space.
    import module re.
    import module sys.
    substitute version_info from module sys for surrent_version.
    set use_workaround to boolean True if current_version tuple elements are smaller than the tuple (2,7,3), respectively,
    or if current_version is greater than (3,0), but smaller than (3,2,3), otherwise set use_workaround to boolean False.   substitute HTMLParseError from the module _html_parser for HTMLParseError.
    if use_workaround is boolean False,
    if tuple current_version elements are greater or equal to (3, 4), respectively,
    derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
    define the initialization method __init__, with self instance of this class, convert_charrefs set to boolean False,
    and dictionary of arbitrary length **kwargs as arguments.   call the initialization method for the base class, _html_parser.HTMLParser.__init__ with self,
    convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments.   if not,
    substitute HTMLParser from the module _html_parser for HTMLParser.
    if not,
    compile a regular expression pattern string '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' into a regular expression object and assign it to tagfind.
    derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
    define initialization method __init__ with self instance of the class as an argument.
    call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
    set field cdata_tag for this class instance to None.
    define method set_cdata_mode, with self class instance and tag as the arguments.
    try,
    set field interesting for this class instance to interesting_cdata from module _html_parser.
    if AttributeError exception is caught,
    replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
    use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
    define method clear_cdata_mode, with self class instance as an argument.
    substitute _html_parser.interesting_normal for self.interesting.
    set self.cdata_tag to None.
    define method parse_starttag with self class instance and i as the arguments.
    set self.__starttag_text to None.
    call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
    if endpos is lesser than zero,
    return endpos.
    substitute self.rawdata for rawdata.
    slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
    attrs is a empty list.
    match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
    if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
    find the ending position of the regular expression match of the object match, substitute the result for k.
    find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
    as long k is smaller than endpos,
    match the rawdata from the position k, with attrfind pattern, assign the result to the m.
    if m is not False, None is considered False,
    breaks from the smallest enclosing loop.
    find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
    if rest is not False, None is considered False,
    set attrvalue to None.
    otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
    remove first and last character from the attrvalue, substitute it for attrvalue.
    if attrvalue is not an empty string,
    call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
    form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
    find the ending position of the regular expression match of the object match, substitute the result for k.
    slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
    if end is not a '>' or '/>' character,
    evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
    if self.__stattag_text contains newline character,
    increment the lineno by the count of the newlines in self.__starttag_text.
    find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
    substitute the result for offset.   if not,
    increment the offset by the length of self.__starttag_text.
    slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
    with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
    call the method self.handle_startendtag with tag and attrs as the arguments.
    if not,
    call the method self.handle_starttag, with tag and attrs as the arguments.
    if tag is contained in self.CDATA_CONTENT_ELEMENTS,
    call the method self.set_cdata_mode with tag as the argument.
    return endpos.
    define the method parse_endtag with self class instance and i as the arguments.
    substitute self.rawdata for rawdata.
    take two characters from the i-th element of rawdata, if they are not equal to the string '</',
    throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
    if there is no match,
    return integer -1.
    find the ending position of the regular expression match of the object match, substitute the result for j.
    match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
    if there is no match,
    if self.cdata_tag is not None,
    slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
    return j.
    slice the rawdata from i-th to the j-th element, replace with it '%r' in the string "bad end tag: %r", use it to call the method self.error.
    find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
    if self.cdata_tag is not None,
    convert tag to lowercase if it is not equal to self.cdata_tag,
    slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
    return j.
    convert tag to lowercase, use it as the argument for the call to the method self.handle_endtag.
    call the method self.clear_cdata_mode.
    return j.
    from __future__ import unicode_literals into default name space.
    import module base64.
    import module calendar.
    import module datetime.
    import module re.
    import module sys.
    from binascii import Error as BinasciiError into default name space.
    from email.utils import formatdate into default name space.
    from django.utils.datastructures import MultiValueDict into default name space.
    from django.utils.encoding import force_str and force_text into default name space.
    from django.utils.functional import allow_lazy into default name space.
    from django.utils import six into default name space.
    from django.utils.six.moves.urllib.parse import quote, quote_plus, unquote, unquote_plus, urlparse, urlencode as original_urlencode.
    call the function re.compile with an argument raw string '(?:W/)?"((?:\\.|[^"])*)"', substitute the result for ETAG_MATCH.
    MONTHS is a list with 12 elements: strings 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', and 'dec'.
    __D is a raw string '(?P<day>\d{2})'.
    __D2 is a raw string '(?P<day>[ \d]\d)'.
    __M is a raw string '(?P<mon>\w{3})'.
    __Y is a raw string '(?P<year>\d{4})'.
    __Y2 is a raw string '(?P<year>\d{2})'.
    __T is a raw string '(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'.
    call the function re.compile with an argument raw string '^\w{3}, %s %s %s %s GMT$' formated with __D, __M, __Y and __T,
    substitute the result for RFC1123_DATE.   call the function re.compile with an argument raw string '^\w{6,9}, %s-%s-%s %s GMT$' formated with __D, __M, __Y2 and __T,
    substitute the result for RFC850_DATE.   call the function re.compile with an argument raw string '^\w{3} %s %s %s %s$' formated with __M, __D2, __T and __Y,
    substitute the result for ASCTIME_DATE.   define the function urlquote with 2 arguments: url and safe set to '/'.
    call the function quote with 2 arguments: result of the function force_str called with an argument url,
    and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote and six.text_type, substitute the result for urlquote.
    define the function urlquote_plus with 2 arguments: url and safe set to an empty string.
    call the function quote_plus with 2 arguments: result of the function force_str called with an argument url,
    and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote_plus and six.text_type, substitute the result for urlquote_plus.
    define the function urlunquote with an argument quoted_url.
    call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote,
    use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote and six.text_type, substitute the result for urlunquote.
    define the function urlunquote with an argument quoted_url.
    call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote_plus,
    use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote_plus and six.text_type, substitute the result for urlunquote_plus.
    define the function urlencode with 2 arguments query and doseq set to integer 0.
    if query is an instance of MultiValueDict class,
    call the method query.lists, substitute the result for query.
    otherwise if query has an attribute 'items',
    call the method query.items, substitute the result for query.
    call the function original_urlencode with 2 arguments: list with 2 elements: result of the function force_str with an argument k,
    and list with results of the function force_str with an argument i, for every i in v, only if v is a list or a tuple,   otherwise second element is result of the function force_str with an argument v, for every k and v in query,   and doseq, return the result.   define the function cookie_date with an argument epoch_seconds set to None.
    call the function formatdate with an argument epoch_seconds, substitute the result for rfcdate.
    return a string '%s-%s-%s GMT', formated with: first 7 elements of rfcdate, elements of rfcdate from 8-th to the 11-th index,
    and elements of rfcdate from 12-th to the 25-th index.   define the function http_date with an argument epoch_seconds set to None.
    call the function formatdate with 2 arguments: epoch_seconds and usegmt set to boolean True, return the result.
    define the function parse_http_date with an argument date.
    for every regex in tuple with 3 elements: RFC1123_DATE, RFC850_DATE and ASCTIME_DATE,
    call the method regex.match with an argument date, substitute the result for m.
    if m is not None,
    break from the loop execution.
    if not,
    raise an ValueError exception with an argument string "%r is not in a valid HTTP date format" formated with date.
    try,
    call the method m.group with an argument string 'year', convert the result into a string, substitute it for year.
    if year is lesser than integer 100,
    if year is lesser than integer 70,
    increment year by integer 2000.
    if not,
    increment year by integer 1900.
    call the method m.group with an argument string 'mon', convert the result to lowercase, use it as an argument for the call to the,
    method MONTHS.index, increment the result by integer 1, substitute it for month.   call the method m.group with an argument string 'fay', convert the result into a string, substitute it for day.
    call the method m.group with an argument string 'hour', convert the result into a string, substitute it for hour.
    call the method m.group with an argument string 'min', convert the result into a string, substitute it for min.
    call the method m.group with an argument string 'sec', convert the result into a string, substitute it for sec.
    call the method MONTHS.index with 6 arguments: year, month, day, hour, min and sec, substitute the result for result.
    call the method result.utctimetuple, use the result as an argument for the call to the method calendar.timegm, return the result.
    if Exception exception is caught.
    call the function six.reraise with 3 arguments: ValueError, instance of a class ValueError, created with an argument string,
    "%r is not a valid date" formated with date and third element of the result of the function sys.exc_info.   define the function parse_http_date_safe an argument date.
    try,
    call the function parse_http_date with an argument date, return the result.
    if Exception exception is caught.
    do nothing.
    define the functionbase36_to_int with an argument s.
    if length of s is greater than integer 13,
    raise an ValueError exception with an argument string "Base36 input too large".
    convert s to integer of base 36, substitute it for value.
    if six.PY2 is true and value is greater than sys.maxint,
    raise an ValueError exception with an argument string "Base36 input too large".
    return value.
    define the function int_to_base36 with an argument i.
    digits is a string "0123456789abcdefghijklmnopqrstuvwxyz".
    factor is integer 0.
    if i is smaller than integer 0,
    raise an ValueError exception with an argument string "Negative base36 conversion input.".
    if six.PY2 is true,
    if i is not an instance of six.integer_types class,
    raise an TypeError exception with an argument string "Non-integer base36 conversion input.".
    if i is greater than sys.maxint,
    raise an ValueError exception with an argument string "Base36 conversion input too large.".
    endless loop,
    increment factor by one.
    bring integer 36 to the power of factor, if i is smaller than the result,
    decrement factor by one.
    break from the loop execution.
    base36 is an empty list.
    while factor is greater or equal to integer 0,
    bring integer 36 to the power of factor, substitute the result for j.
    floor the division of i by j, use it an an index to get the element of the digits list, append the result for base36.
    i is the reminder of the division of i by j.
    decrement factor by one.
    join elements of base36 into a string, return it.
    define the function urlsafe_base64_encode with an argument s.
    call the method base64.urlsafe_b64encode with an argument s, strip the result of the bytes string '\n=' from the right, return it.
    define the function urlsafe_base64_decode with an argument s.
    call the method s.encode with an argument string 'utf-8', substitute the result for s.
    try,
    left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4,
    pad the rest of the field with bytes string '=', use the result as an argument for the call to the method base64.urlsafe_b64decode,   return the result.   if LookupError or BinasciiError, renamed to e, exceptions are caught.
    raise an ValueError exception with an argument e.
    define the function parse_etags with an argument etag_str.
    call the method ETAG_MATCH.findall with an argument etag_str, substitute the result for etags.
    if etags is false,
    return a list with an element etag_str.
    for every e in etags call the method e.encode with an argument string 'ascii', call the method decode on the result with an argument,
    string 'unicode_escape', substitute the list of results for etags.   return etags.
    define the function quote_etag with an argument etag.
    return a string '"%s"' formated with etag, in which every occurrence of '\\' is replaced with '\\\\' and every occurrence of '"',
    is replaced with '\\"'.   define the function same_origin with 2 arguments url1 and url2.
    substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2.
    try,
    if p2.scheme, p2.hostname and p2.port equals p1.scheme, p1.hostname and p1.port, respectively, return boolean True, otherwise return boolean False.
    if ValueError exception is caught.
    return boolean False.
    define the function is_safe_url with 2 arguments url and host set to None.
    if url is false,
    return boolean False.
    replace every occurrence of '\\' in url with '/'.
    if url starts with '///',
    return boolean False.
    call the function urlparse with an argument url, substitute the result for url_info.
    if url_info.netloc is false and url_info.scheme is true,
    return boolean False.
    if url_info.netloc is false or url_info.netloc equals host, and if url_info.scheme is false or url_info.scheme equals,
    import module warnings.
    import module sys.
    from django.utils import six into default name space.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    call the function warnings.warn with 3 arguments: string "django.utils.importlib will be removed in Django 1.9.",
    RemovedInDjango19Warning and stacklevel set to integer 2.   define the function _resolve_name with 3 arguments: name, package and level.
    if package doesnt have an 'rindex' attribute,
    raise an ValueError with an argument string "'package' not set to a string".
    substitute length of package for dot.
    for every x is the range of integers from level to the integer 2, in the reversed order,
    try,
    call the method package.rindex with 3 arguments: string '.', integer 0 and dot, substitute the result for dot.
    if ValueError exception is caught,
    raise an ValueError with an argument string "attempted relative import beyond top-level package".
    return a string "%s.%s" formated with first dot package elements and name.
    if six.PY3 is true,
    from importlib import import_module.
    if not,
    define the function import_module with 3 arguments: name and package set to None.
    if name starts with an string '.',
    if package is false,
    raise an TypeError with an argument string "relative imports require the 'package' argument".
    level is an integer 0.
    for every character in name,
    if character is not equal to a string '.',
    break from the loop execution.
    increment level by one.
    call the function _resolve_name with 3 arguments: name list elements from the level index to the end, package and level,
    substitute the result for name.   call the function __import__ with an argument name.
    return sys.modules dictionary value under the name key.
    from django.core.exceptions import ValidationError into default name space.
    from django.utils.translation import ugettext_lazy as _ into default name space.
    from django.utils.six.moves import xrange into default name space.
    define the function clean_ipv6_address with 3 arguments: ip_str, unpack_ipv4 set to boolean False and error_message,
    best_doublecolon_start is an integer -1.
    best_doublecolon_len is an integer 0.
    doublecolon_start is an integer -1.
    doublecolon_len is an integer 0.
    call he function is_valid_ipv6_address with an argument ip_str, if it evaluates to false,
    raise an ValidationError exception with 2 arguments: error_message and code as a string 'invalid'.
    call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
    call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
    if unpack_ipv4 is true,
    call the function _unpack_ipv4 with an argument ip_str, substitute the result for ipv4_unpacked.
    if ipv4_unpacked is true,
    return ipv4_unpacked.
    split ip_str by ':', substitute the result for hextets.
    for every index in range of integers from 0 to length of hextets, not included,
    get the value under the index key of the hextets dictionary, remove the leading '0' characters,
    substitute the result for value under the index key of the hextets dictionary.   get the value under the index key of the hextets dictionary, if it is false,
    value under the index key of the hextets dictionary is a string '0'.
    if value under the index key of the hextets dictionary equals to string '0',
    increment doublecolon_len by integer 1,
    if doublecolon_start equals integer -1,
    substitute index for doublecolon_start.
    if doublecolon_len is greater than best_doublecolon_len,
    substitute doublecolon_len for best_doublecolon_len.
    substitute doublecolon_start for best_doublecolon_start.
    if not,
    doublecolon_len is integer 0.
    doublecolon_start is integer -1.
    if best_doublecolon_len is greater than integer 1,
    sum best_doublecolon_start and best_doublecolon_len, substitute the result for best_doublecolon_end,
    if best_doublecolon_end equals length of hextets,
    append an empty string to list hextets.
    replace hextets list from the best_doublecolon_start index to best_doublecolon_end index with an empty string.
    if best_doublecolon_start equals integer 0,
    prepend an empty string to hextets list.
    join elements of hextets into a string, separated with ':', substitute it for result.
    convert result to lowercase and return it.
    define the function _sanitize_ipv4_mapping with an argument ip_str.
    convert ip_str to lowercase, if it doesnt start with a string '0000:0000:0000:0000:0000:ffff:',
    return ip_str.
    split ip_str into parts by ':', substitute the result for hextets.
    if '.' is contained in last elements of hextets,
    return ip_str.
    ipv4_address is a string "%d.%d.%d.%d" formated with first 2 elements of seventh element of hextets converted into hexadecimal number,
    second 2 elements of seventh element of hextets converted into hexadecimal number,   first 2 elements of eight element of hextets converted into hexadecimal number,   second 2 elements of eight element of hextets converted into hexadecimal number.   join first 5 elements of hextets into a string, separated by ':', substitute the result for result.
    append ':' and ipv4_address to result.
    return result.
    define the function _unpack_ipv4 with an argument ip_str.
    convert ip_str to lowercase, if it doesnt start with a string '0000:0000:0000:0000:0000:ffff:',
    return None.
    split ip_str into 2 parts from right, return second element of the result.
    define the function is_valid_ipv6_address with an argument ip_str.
    from django.core.validators import validate_ipv4_address.
    if ':' is not contained in ip_str.
    return boolean False.
    if count of occurrence of '::' in ip_str is greater than integer 1,
    return boolean False.
    if string ':::' is contained in ip_str,
    return boolean False.
    if ip_str starts with ':, but it doesnt starts with '::', or if ip_str ends with ':, but it doesnt ends with '::',
    return boolean False.
    if count of occurrence of ':' in ip_str is greater than integer 7,
    return boolean False.
    if '::' is not contained in ip_str and number of occurrences of ':' in ip_str is not equal to integer 7,
    if count of occurrence of '.' in ip_str is not equal to integer 3,
    return boolean False.
    call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
    split ip_str into parts by ':', for every hextet in the result,
    if count of occurrence of '.' in ip_str is equal to integer 3,
    split ip_str by ':', if last element of the result is not equal to hextet.
    return boolean False.
    try,
    call the function validate_ipv4_address with an argument hextet.
    if ValidationError exception is caught,
    return boolean False.
    if not,
    try,
    if hextet converted to hexadecimal number is smaller than hexadecimal 0, or hextet converted to hexadecimal number is smaller than hexadecimal FFFF,
    return boolean False.
    if ValueError exception is caught.
    return boolean False.
    return boolean True.
    define the function _explode_shorthand_ip_string with an argument ip_str.
    call the function _is_shorthand_ip with an argument ip_str, if it evaluates to false,
    return ip_str.
    new_ip is an empty list,
    split ip_str by '::', substitute it for hextet.
    split ip_str into parts by ':', if '.' is contained in the last element of the result,
    fill_to is an integer 7.
    if not,
    fill_to is an integer 8.
    if length of hextet is greater than integer 1,
    split first and second element of hextet into parts by ':', sum their lengths, substitute the result for sep.
    split first element of hextet into parts by ':', append them to new_ip.
    for every __ in range of integers from 0 up to sep subtracted from fill_to,
    append string '0000' to new_ip.
    split second element of hextet into parts by ':', append them to new_ip.
    if not,
    split ip_str into parts by ':', substitute the result for new_ip.
    ret_ip is an empty list.
    for every hextet in new_ip,
    subtract length of hextet from 4, create a string with previous result number of character '0', append hextet to it,
    convert the result into a lowercase, append it to ret_ip.   join elements of ret_ip into a string separated with ':', return it.
    define the function _is_shorthand_ip with an argument ip_str.
    if count of occurrence of '::' in ip_str equals integer 1,
    return boolean True.
    split ip_str into parts by ':', for every x in the result, calculate length of x, if any is smaller than integer 4,
    return boolean True.
    return boolean False.
    define the function is_iterable with an argument x.
    try,
    create an iterator out of x.
    if TypeError exception is caught,
    return boolean False.
    if not,
    return boolean True.
    import module re.
    derive the class Tok from the object base class.
    num is an integer 0.
    define the method __init__ with 4 arguments: self, name, regex and next set to None.
    substitute Tok.num for self.id.
    increment Tok.num with an integer 1.
    substitute name for self.name.
    substitute regex for self.regex.
    substitute next for self.next.
    define the function literals with 3 arguments: choices, prefix set to an empty string and suffix set to an empty string.
    for every c in choices split into words, concatenate prefix, result of the function re.escape with an argument c and suffix,
    and join the results into a string, separated with '|' character, return the result.   derive the class Lexer from the object base class.
    define the method __init__ with 3 arguments self, states and first.
    self.regexes is an empty dictionary.
    self.tokens is an empty dictionary.
    call the method states.items, for every state and rules in the result,
    parts is an empty list.
    for every tok in rules,
    groupid is a string "t%d" formated with tok.id.
    substitute tok for value under the groupid key of the self.toks dictionary.
    format a string "(?P<%s>%s)" with groupid and tok.regex, append it to the parts.
    call the function re.compile with 2 arguments: elements of parts joined into a string, separated with '|',
    and result of bitwise OR performed on 2 operands: re.MULTILINE and re.VERBOSE,   substitute the result for value under the state key of the self.regexes dictionary.   substitute first for self.state.
    define the method lex with 2 arguments self and text.
    substitute length of text for end.
    substitute self.state for state.
    substitute self.regexes for regexes.
    substitute self.toks for toks.
    start is an integer 0.
    while start is lesser than end.
    get the value under the state key of the regexes dictionary, call the method finditer on the result with 2 arguments: text and start,
    for every match in the result,   substitute match.lastgroup for name.
    substitute value under the name key of the toks dictionary for tok.
    call the method match.group with an arugument name, substitute the result for toktext.
    increment start by length of toktext.
    yield a tuple with 2 elements: tok.name and toktext.
    if tok.next is true,
    substitute tok.next for state.
    break from the loop execution.
    substitute state for self.state.
    derive the class JsLexer from the Lexer base class.
    both_before is a list containing 14 elements, all of them are instances of Tok class, created with 2 arguments, a string and a raw string.
    both_after is an list with an element instance of Tok class, created with 2 arguments: string 'other' and raw string '.'.
    states is a dictionary with 2 arguments: appended list with an element instance of a class Tok, created with 3 arguments: "punct",
    result of the function literals called with an argument string "/= /" and next as a string 'reg', to the both_before,   appended both_after to the previous result, for 'div' and appended list with an element instance of a class Tok,   created with 3 arguments: string "regex",   raw string '/([^*\\/[]|\\.|\[(   [^\]\\]|   \\.)*\])(   [^\\/[]|   \\.|   \[(   [^\]\\]|   \\.)*\])*/[a-zA-Z0-9]*',   and next as a string 'div', to the both_before, appended both_after to the previous result for 'div'.   define the method __init__ with an argument self.
    call the method __init__ with 2 arguments: self.states and string 'reg' from the base class of the class JsLexer.
    define the function prepare_js_for_gettext with an argument js.
    define the function escape_quotes with an argument m.
    call the method m.group with an argument integer 0, substitute the result for s.
    if s equals a string '"',
    return an raw string '\"'.
    if not,
    return s.
    lexer is an instance of JsLexer class.
    c is an empty list.
    call the method lexer.lex with an arguments js, for every name and tok in the result,
    if name equals a string 'regex',
    tok is a string '"REGEX"',
    otherwise if name starts with a string 'string',
    if tok starts with "'",
    call the function re.sub with 3 arguments: raw string "\\.|.", escape_quotes and tok without the first and last element,
    substitute the result for guts.   concatenate string '"', guts and string '"', substitute the result for tok.
    otherwise if name equals a string 'id'.
    replace every occurrence of '\\' in tok with 'U', substitute the result for tok.
    append tok to c.
    join elements of c into a string, return it.
    import module logging.
    import module sys.
    import module warnings.
    from django.conf import settings into default name space.
    from django.core import mail into default name space.
    from django.core.mail import get_connection into default name space.
    from django.utils.deprecation import RemovedInNextVersionWarning into default name space.
    from django.utils.module_loading import import_string into default name space.
    from django.views.debug import ExceptionReporter and get_exception_reporter_filter into default name space.
    from logging import NullHandler.
    from logging.config import dictConfig.
    substitute logging.getLogger for getLogger.
    DEFAULT_LOGGING is a dictionary with 5 initial entries: 1 for 'version', False for 'disable_existing_loggers',
    and 3 additional pairs of dictionaries for string.   define the function configure_logging with 2 arguments: logging_config and logging_settings.
    if sys.warnoptions is false,
    call the method logging.captureWarnings with an argument boolean True.
    call the function warnings.simplefilter with 2 arguments: string "default" and RemovedInNextVersionWarning.
    if logging_config is true,
    call the function import_string with an argument logging_config, substitute the result for logging_config_func.
    call the function logging_config_func with an argument DEFAULT_LOGGING.
    if logging_settings is true,
    call the function logging_config_func with an argument logging_settings.
    derive the class AdminEmailHandler from logging.Handler base class.
    define the method __init__ with 3 arguments: self, include_html set to boolean False and email_backend set to None.
    call the method logging.Handler.__init__ with an argument self.
    substitute include_html for self.include_html.
    substitute email_backend for self.email_backend.
    define the method emit with 2 arguments: self and record.
    try,
    substitute record.request for request.
    subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
    of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
    call the method filter.get_request_repr with an argument request, format string '\n{0}' with the result, substitute the result for request_repr.
    if Exception exception is caught,
    subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
    request is None.
    request_repr is a string "unavailable".
    call the function self.format_subject with an argument subject, substitute the result for subject.
    if record.exc_info is true,
    substitute record.exc_info for exc_info.
    if not,
    exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
    message is an string "%s\n\nRequest repr(): %s"  formated with the result of the metod self.format with an argument record,
    and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
    unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
    otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
    and connection as the result of the method self.connection.   define the connection with an argument self.
    call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
    define the method format_subject with 2 arguments: self and subject.
    replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
    substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
    derive the class CallbackFilter from logging.Filter base class.
    define the method __init__ with 2 arguments: self and callback.
    substitute callback for self.callback.
    define the method filter with 2 arguments: self and record.
    call the method self.callback with an argument record, if the result evaluates to true,
    return integer 1.
    return integer 0.
    derive the class RequireDebugFalse from logging.Filter base class.
    define the method filter with 2 arguments: self and record.
    if settings.DEBUG is true, return boolean False, otherwise return boolean True.
    derive the class RequireDebugTrue from logging.Filter base class.
    define the method filter with 2 arguments: self and record.
    return settings.DEBUG.
    try,
    from functools import lru_cache.
    if ImportError exception is caught.
    from collections import namedtuple.
    from functools import update_wrapper.
    from threading import RLock.
    _CacheInfo is an instance of namedtuple class created with 2 arguments: string "CacheInfo" and a list with 4 elements: string 'hits',
    "misses", "maxsize" and "currsize".   derive class _HashedSeq from list base class.
    __slots__ is a string 'hashvalue'.
    define the method __init__ with 3 arguments: self, tup and hash set to hash.
    substitute tup for elements of self.
    get the hash value of the tup, substitute it for self.hashvalue.
    define the method __hash__ with an argument self.
    return self.hashvalue.
    define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
    substitute args for key.
    if kwds is true,
    sort elements of kwds, substitute the result for sorted_items.
    increment key by kwd_mark.
    for every item in sorted_items,
    increment key by item.
    if typed is true,
    create a tuple out of types of v, for every v in args, extend key tuple with the result.
    if kwds is true,
    create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
    otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
    return first element of key.
    return instance of _HashedSeq class, created with an argument key.
    define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
    define the function decorating_function with an argument user_function.
    cache is an empty dictionary.
    stats is an list with 2 elements: 2 integers 0.
    HITS and MISSES are integer 0 and 1, respectively.
    substitute _make_key for make_key.
    substitute cache.get for cache_get.
    substitute len for _len.
    lock is an instance of RLock class.
    root is an empty list.
    root is a list with elements: root, root, None and None.
    nonlocal_root is an list with an element root.
    substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
    if maxsize equals integer 0,
    define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
    call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
    increment stats dictionary value under the MISSES key by integer 1.
    return result.
    otherwise if maxsize is None,
    define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
    call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
    call the function cache_get with 2 arguments: key and root, substitute the result for result.
    if result is not root,
    increment stats dictionary value under the HITS key by integer 1.
    return result.
    call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
    substitute result for cache dictionary value under the key key.
    increment stats dictionary value under the MISSES key by integer 1.
    return result.
    if not,
    define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
    if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
    otherwise substitute args for key.   with lock,
    call the function cache_get with an argument key, substitute the result for link.
    if link is not None,
    substitute nonlocal_root for a tuple with an element root.
    substitute link for link_prev, link_next, key and result, respectively.
    substitute link_next for value under the NEXT key of the link_prev dictionary.
    substitute link_prev for value under the PREV key of the link_next dictionary.
    substitute value under the PREV key of the root dictionary for last.
    substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
    substitute last for value under the PREV key of the link dictionary.
    substitute root for value under the NEXT key of the link dictionary.
    increment stats dictionary value under the HITS key by integer 1.
    return result.
    call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
    with lock,
    substitute nonlocal_root for tuple root.
    if key is contained in cache,
    do nothing.
    otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
    substitute root for oldroot.
    substitute key for value under the KEY key of the oldroot dictionary.
    substitute result for value under the RESULT key of the oldroot dictionary.
    substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
    substitute value under the KEY key of the root dictionary for oldkey.
    substitute value under the RESULT key of the root dictionary for oldvalue.
    root dictionary values under the KEY and RESULT keys are both None.
    delete entry under the oldkey key of the cache dictionary.
    substitute oldroot for value under the key key of the cache dictionary.
    if not,
    substitute value under the PREV key of the root dictionary for last.
    link is a list with 4 elements: last, root, key and result.
    substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
    for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
    return result.
    define the function cache_info.
    with lock,
    return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
    value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
    with lock,
    call the method cache.clear.
    substitute first element of nonlocal_root for root.
    root is an list with 4 elements: root, root, None and None.
    stats is a list with 2 elements: 2 integers 0.
    substitute user_function for wrapper.__wrapped__.
    substitute cache_info for wrapper.cache_info.
    substitute cache_clear for wrapper.cache_clear.
    call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
    return decorating_function.
    from __future__ import absolute_import into default name space.
    import module copy.
    from importlib import import_module into default name space.
    import module os.
    import module sys.
    import module warnings.
    from django.core.exceptions import ImproperlyConfigured into default name space.
    from django.utils import six into default name space.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    define the function import_string with an argument dotted_path.
    try,
    split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
    if ValueError exception is caught,
    msg is a string "%s doesn't look like a module path" formated with dotted_path.
    call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
    and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
    try,
    get attribute class_name form the module object, return it.
    if AttributeError exception is caught,
    msg is a string 'Module "%s" does not define a "%s" attribute/class' formated with dotted_path and class_name, respectively.
    call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
    and third element of result of the function sys.exc_info.   define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..
    call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
    RemovedInDjango19Warning and stacklevel as integer 2.   try,
    call the function import_string with an argument dotted_path, substitute the result for attr.
    if ImportError, renamed to e, exception is caught,
    msg is a string '%sError importing module %s: "%s"', where '%s' is replaced with error_prefix, dotted_path and e, respectively.
    call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
    and third element of the function sys.exc_info result.   return attr.
    define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs.
    from django.apps import apps.
    get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
    call the method apps.get_app_configs, for every app_config in the result,
    try,
    if register_to is true,
    call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
    for every module_to_search in args,
    call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
    is exception is caught,
    if register_to is true,
    substitute before_import_registry for register_to._registry.
    if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
    raise an exception,
    if first and second element of sys.version_info are both equal to integer 3,
    if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
    from importlib.util import find_spec as importlib_find.
    if not,
    from importlib import find_loader as importlib_find.
    define the function module_has_submodule with 2 arguments: package and module_name.
    try,
    substitute package.__name__ for package_name.
    substitute package.__path__ for package_path.
    if AttributeError exception is caught,
    return boolean False.
    concatenate package_name, string '.' and module_name, substitute it for full_module_name.
    call the function importlib_find with 2 arguments: full_module_name and package_path, if the result is not None, return boolean True,
    otherwise return boolean False.   if not,
    import imp.
    define the function module_has_submodule with 2 arguments: package and module_name.
    join package.__name__ and module_name into a string separated with '.', substitute it for name.
    try,
    if value under the name key of the sys.modules dictionary is not None, return boolean True, otherwise return boolean False.
    if KeyError exception is caught,
    do nothing.
    try,
    substitute package.__path__ for package_path.
    if AttributeError exception is caught,
    return boolean False.
    for every finder in sys.meta_path,
    if call to the method finder.find_module with 2 arguments: name and package_path evaluates to true,
    return boolean True.
    for every entry in package_path,
    try,
    substitute the value under the entry key of the sys.path_importer_cache dictionary for finder.
    if finder is None,
    try,
    call the method imp.find_module with 2 arguments: module_name and list containing element entry, assign the result to file_, _,
    and _, respectively.   if file_ is true,
    close file_ file descriptor.
    return boolean True.
    if ImportError exception is caught,
    skip this loop iteration,
    otherwise if call to the method finder.find_module with an argument name evaluates to true,
    return boolean True.
    if not,
    skip this loop iteration,
    if KeyError exception is caught,
    for every hook in sys.path_hooks,
    try,
    call the function hook with an argument entry, substitute the result for finder.
    if call to the method finder.find_module with an argument name evaluates to true,
    return boolean True.
    if not,
    break from the loop execution,
    if ImportError exception is caught,
    skip this loop iteration,
    if not,
    if entry is a directory,
    try,
    call the method imp.find_module with 2 arguments: module_name and list containing element entry, assign the result to file_, _,
    and _, respectively.   if file_ is true,
    close file_ file descriptor.
    return boolean True.
    if ImportError exception is caught,
    do nothing.
    if not,
    return boolean False.
    from django.conf import settings into default name space.
    from django.utils.safestring import mark_safe into default name space.
    from django.utils import six into default name space.
    define the function format with 6 arguments: number, decimal_sep, decimal_pos set to None, grouping set to integer 0,
    if settings.USE_L10N is true, substitute settings.USE_THOUSAND_SEPARATOR for use_grouping,
    otherwise substitute settings.USE_L10N for use_grouping.   if use_grouping is true substitute it for use_grouping, otherwise substitute force_grouping for use_grouping.
    if use_grouping is true and grouping is greater than integer 0, use_grouping is boolean True, otherwise it is boolean False.
    if number is an integer and use_grouping is false and decimal_pos is false,
    call the function six.text_type with an argument number, use the result as an argument for the call to the function mark_safe,
    return the result.   sign is an empty string.
    call the function six.text_type with an argument number, substitute the result for str_number.
    if first element of str_number equals a string '-'.
    sign is a string '-'.
    remove the first element from str_number.
    if '.' is not contained in str_number,
    split str_number by '.', substitute the result for int_part and dec_part, respectively.
    if decimal_pos is not None,
    substitute first decimal_pos elements of dec_part for dec_part.
    if not,
    substitute str_number and an empty string for int_part and dec_part.
    if decimal_pos is not None
    subtract length of dec_part from decimal_pos, multiply the number of character '0' by the result,
    append the resulting string to dec_part, substitute it for dec_part.   if dec_part is true,
    add decimal_sep and dec_part, substitute the result for dec_part.
    if use_grouping is true,
    int_part_gd is an empty string.
    for every cnt and digit in enumerated list int_part with reversed ordering of elements,
    if cnt is true and remained of dividing cnt with grouping is zero,
    increment int_part_gd by thousand_sep.
    append digit to int_part_gd.
    invert the ordering of elements of int_part_gd, substitute it for int_part.
    sum sign, int_part and dec_part, return the result.
    from __future__ import unicode_literals into default name space.
    from django.utils import six into default name space.
    from django.utils.six.moves import zip into default name space.
    ESCAPE_MAPPINGS is an dictionary with 10 initial entries: None for 'A', None for 'b', None for 'B', '0' for 'd', 'x' for 'D',
    ' ' for 's', 'x' for 'S', 'x' for 'W', '!' for 'W' and None for 'Z'.   derive the class Choice from list base class.
    derive the class Group from list base class.
    derive the class NonCapture from list base class.
    define the function normalize with an argument pattern.
    result is an empty list.
    non_capturing_groups is an empty list.
    consume_next is boolean True.
    call the function next_char with an argument iterator pattern, substitute the result for pattern_iter.
    num_args is an integer 0.
    try,
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    if StopIteration exception,
    return a list with an element tuple with 2 elements: an empty string and an empty list.
    try,
    endless loop,
    if escaped is true,
    append ch to result.
    otherwise if ch equals a string '.',
    append string '.' to result.
    otherwise if ch equals a string '|',
    raise an NotImplementedError exception with an argument string 'Awaiting Implementation'.
    otherwise if ch equals a string '^',
    do nothing.
    otherwise if ch equals a string '$',
    skip this loop iteration.
    otherwise if ch equals a string ')',
    remove first element from non_capturing_groups, substitute it for start.
    inner is an instance of NonCapture, created with elements of result from start index to the end.
    append list with element inner to list containing first start elements of result, substitute it for result.
    otherwise if ch equals a string '[',
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    append ch to result.
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    while escaped is true or ch is not equal to a string ']',
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    otherwise if ch equals a string '(',
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    if ch is not equal to a sring '?' or escaped is true,
    name is a string "_%d" formated with num_args.
    increment num_args by one.
    instantiate a class Group with 2 arguments: string "%%(%s)s" formated with name, and name, append it to result.
    call the function walk_to_end with 2 arguments: ch and pattern_iter.
    if not,
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    if ch is contained in string "iLmsu#",
    call the function walk_to_end with 2 arguments: ch and pattern_iter.
    otherwise if ch equals a string ':',
    append length of result to non_capturing_groups.
    otherwise if ch equals a string 'P',
    raise an ValueError with an argument string "Non-reversible reg-exp portion: '(?%s'" formated with ch.
    if not,
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    if ch is not equal to string '<' or string '=',
    raise an ValueError with an argument string "Non-reversible reg-exp portion: '(?P%s'" formated with ch.
    if ch equals a string '<',
    terminal_char is an string '>'.
    if not,
    terminal_char is an string ')'.
    name is an empty list.
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    while ch is not equal to terminal_char,
    append ch to result.
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    join elements of name into a string, substitute it for param.
    if terminal_char is not equal to string ')',
    instantiate a class Group with 2 arguments: string "%%(%s)s" formated with param, and param, append it to result.
    call the function walk_to_end with 2 arguments: ch and pattern_iter.
    if not,
    instantiate a class Group with 2 arguments: string "%%(%s)s" formated with param, and None, append it to result.
    otherwise if ch is contained in string "*?+{",
    call the function get_quantifier with 2 arguments: ch and pattern_iter, substitute the result for count and ch, respectively.
    if ch is true,
    consume_next is boolean False.
    if count is equal to integer 0.
    if call to the function contains with 2 arguments: last element of result and Group, evaluates to true,
    last element of result is an instance of Choice class, created with an argument list with 2 elements: None and last element of result.
    if not,
    remove the first element from result.
    otherwise if count is greater than integer 1,
    create a list with count decremented by 1 number of last element of result elements, extend list result with it.
    if not,
    append ch to result.
    if consume_next is true,
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    if not,
    consume_next is boolean True.
    if StopIteration exception,
    do nothing.
    if NotImplementedError exception,
    return a list with an element tuple with 2 elements: an empty string and an empty list.
    call the function flatten_result with an argument result, unpack the resulting list and zip it in the list of tuples, return the result.
    define the function next_char with an argument input_iter.
    for every ch in input_iter,
    if ch is not equal to string '\\'.
    yield ch and boolean False.
    skip this loop iteration.
    get the next element of the iterable pattern_iter, assign the result for ch.
    get the value under ch key of the ESCAPE_MAPPINGS dictionary, if it exists substitute it for representative, if not substitute ch for representative.
    if representative is None,
    skip this loop iteration.
    yield representative and boolean True.
    define the function walk_to_end with 2 arguments ch and input_iter.
    if ch equal a string '(',
    nesting is integer 1.
    if not,
    nesting is integer 0.
    for every ch and escaped in input_iter,
    if escaped is true,
    skip this loop iteration.
    otherwise if ch equals a string '(',
    increment nesting by one.
    otherwise if ch equals a string ')',
    if nesting is false,
    return nothing.
    decrement nesting by one.
    define the function get_quantifier with 2 arguments ch and input_iter.
    if ch is contained in string '*?+',
    try,
    get the next element of the iterable pattern_iter, assign the result for ch2 and escaped, respectively.
    if StopIteration exception,
    ch2 is None.
    if ch2 equals string '?',
    ch2 is None.
    if ch equals string '+',
    return integer 1 and ch2.
    return integer 0 and ch2.
    quant is an empty list.
    while ch is not equal to a string '}',
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    append ch to quant.
    remove last element for quant.
    join elements of quant into a string, split it by string ',', substitute the result for values.
    try,
    get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
    if StopIteration exception,
    ch is None.
    if ch equals a string '?',
    ch is None.
    convert first element of values into a integer, return the result and ch.
    define the function contains with 2 arguments source and inst.
    if source is an instance of inst class,
    return boolean True.
    if source is an instance of NonCapture class,
    for every elt in source,
    call the function contains with 2 arguments: elt and inst, if it evaluates to true,
    return boolean True.
    return boolean False.
    define the function flatten_result with an argument source.
    if source is None,
    return a list containing an empty string and a list containing an empty list.
    if source is an instance of Group class,
    if second element of source is None,
    params is an empty list,
    if not,
    params is a list with second element of source as a element.
    return a list containing first element of source and a list containing params.
    result is a list containing an empty string.
    result_args is a list containing an empty list.
    pos and last are integer 0.
    for every pos and elt in enumerated iterable source,
    if elt is an instance of six.string_types class,
    skip this loop iteration.
    join source list elements from last till pos indexes into a string, substitute the result for piece.
    if elt is an instance of Group class,
    increment piece by firs element of elt.
    substitute second element of elt for param.
    if not,
    param is None.
    increment pos by one, substitute the result for last.
    for every i in range of integers from 0 to length of result, not included,
    increment i-th element of result by piece.
    if param is true,
    append param to i-th element of result_args.
    if elt is an instance of Choice or NonCapture classes,
    if elt is an instance of NonCapture class,
    elt is an list with an element elt.
    inner_result and inner_args are empty lists.
    for every item in elt,
    call the function flatten_result with an argument item, assign the result to res and args, respectively.
    extend list inner_result with res.
    extend list inner_args with args.
    new_result is an empty list.
    new_args is an empty list.
    zip elements of result and result_args into a list of tuples, for every item and args in the result,
    zip elements of inner_result and inner_args into a list of tuples, for every i_item and i_args in the result,
    sum item and i_item together, append the result to new_result.
    append i_args to args, append new_args with the result.
    substitute new_result for result.
    substitute new_args for result_args.
    if pos is greater than or equal to last,
    join elements of list source from index last to the end into a string, substitute it for piece.
    for every i in range of integers from 0 to length of result, not included,
    increment i-th element of result by piece.
    return result and result_args.
    from django.utils.functional import curry and Promise into default name space.
    from django.utils import six into default name space.
    derive the class EscapeData from object base class.
    do nothing.
    derive the class EscapeBytes from bytes and EscapeData base classes.
    do nothing.
    derive the class EscapeText from six.text_type and EscapeData base classes.
    do nothing.
    if six.PY3 is true,
    substitute EscapeText for EscapeString.
    if not,
    substitute EscapeBytes for EscapeString.
    substitute EscapeText for EscapeUnicode.
    derive the class SafeData from object base class.
    define the method __html__ with an argument self.
    return self.
    derive the class SafeBytes from bytes and SafeData base classes.
    define the method __add__ with 2 arguments self and rhs.
    call the __add__ method with an arguments rhs from the base class of the class SafeBytes, substitute the result for t.
    if rhs is an instance of SafeText,
    return an instance of SafeText, created with an argument t.
    otherwise if rhs is an instance of SafeBytes,
    return an instance of SafeBytes, created with an argument t.
    return t.
    define the method _proxy_method with 3 arguments self, unpacked list args and unpacked dictionary kwargs.
    remove kwargs dictionary element under the 'method' key, substitute it for method.
    call the function method with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, substitute the result for data.
    if data is an instance of bytes,
    return an instance of SafeBytes, created with an argument data.
    if not,
    return an instance of SafeText, created with an argument data.
    call the function curry with 2 arguments: _proxy_method and method set to bytes.decode, substitute the result for decode.
    derive the class SafeText from six.text_type and SafeData base classes.
    define the method __add__ with 2 arguments self and rhs.
    call the __add__ method with an arguments rhs from the base class of the class SafeText, substitute the result for t.
    if rhs is an instance of SafeData.
    return an instance of SafeText, created with an argument t.
    return t.
    define the method _proxy_method with 3 arguments self, unpacked list args and unpacked dictionary kwargs.
    remove kwargs dictionary element under the 'method' key, substitute it for method.
    call the function method with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, substitute the result for data.
    if data is an instance of bytes.
    return an instance of SafeBytes, created with an argument data.
    if not,
    return an instance of SafeText, created with an argument data.
    call the function curry with 2 arguments: _proxy_method and method set to six.text_type.encode, substitute the result for encode.
    if six.PY3 is true,
    substitute SafeText for SafeString.
    if not,
    substitute SafeBytes for SafeString.
    substitute SafeText for SafeUnicode.
    define the function mark_safe with an argument s.
    if s is an instance of SafeData.
    return s.
    if s is an instance of bytes or Promise and s._delegate_bytes is true,
    return an instance of SafeBytes, created with an argument s.
    if s is an instance of six.text_type or Promise,
    return an instance of SafeText, created with an argument s.
    return an instance of SafeText, created with an argument s converted into a string.
    define the function mark_for_escaping with an argument s.
    if s is an instance of SafeData or EscapeData,
    return s.
    if s is an instance of bytes or Promise and s._delegate_bytes is true,
    return an instance of EscapeBytes, created with an argument s.
    if s is an instance of six.text_type or Promise,
    return an instance of EscapeText, created with an argument s.
    return an instance of EscapeBytes, created with an argument, reuslt of the call to the function bytes with an argument s.
    import module opera.
    import module sys.
    import module types.
    __author__ is a string "Benjamin Peterson <benjamin@python.org>".
    __version__ is a string "1.6.1".
    if first element of sys.version_info equals integer 2, PY2 is boolean True, otherwise it is boolean False.
    if first element of sys.version_info equals integer 3, PY3 is boolean True, otherwise it is boolean False.
    if PY3 is true,
    substitute str for string_types.
    substitute int for integer_types.
    substitute type for class_types.
    substitute str for text_type.
    substitute bytes for binary_type.
    substitute sys.maxsize for MAXSIZE.
    if not,
    substitute basestring for string_types.
    integer_types is a tuple with 2 elements int and long.
    class_types is a tuple with 2 elements: type and types.ClassType.
    substitute unicode for text_type.
    substitute str for binary_type.
    if sys.platform starts with string 'java',
    bitwise shift integer 1 to the left by 31 spaces, substitute integer 1 from the result, convert the result to a integer, substitute it for MAXSIZE.
    if not,
    derive class X from the object base class.
    define the method __len__ with an argument self.
    bitwise shift integer 1 to the left by 31 spaces, return the result.
    try
    instantiate class X, get its length.
    if OverflowError exception is caught,
    bitwise shift integer 1 to the left by 31 spaces, substitute integer 1 from the result, convert the result to a integer, substitute it for MAXSIZE.
    if not,
    bitwise shift integer 1 to the left by 63 spaces, substitute integer 1 from the result, convert the result to a integer, substitute it for MAXSIZE.
    delete X.
    define the function _add_doc with 2 arguments: func and doc.
    substitute doc for func.__doc__.
    define the function _import_module with an argument name.
    call the function __import__ with an argument name.
    return value under the name key of the sys.modules dictionary.
    derive class _LazyDescr from the object base class.
    define the method __init__ with 2 arguments: self and name.
    substitute name for self.name.
    define the method __get__ with 3 arguments: self, obj and tp.
    try,
    call the method self._resolve, substitute the result for result.
    if ImportError exception is caught,
    raise an AttributeError with an argument string "%s could not be imported ", formated with self.name.
    set self.name attribute of the obj object to result.
    delete self.name attribute from the obj.__class__ object.
    return result.
    derive class MovedModule from the _LazyDescr base class.
    define the method __init__ with 4 arguments: self, name, old and new set to None.
    call the __init__ method with an argument name from the base class of the MovedModule class.
    if PY3 is true,
    if new is None,
    substitute name for new.
    substitute new for self.mod.
    if not,
    substitute old for self.mod.
    define the method _resolve with an argument self.
    call the function _import_module with an argument self.mod, return the result.
    define the method __getattr__ with 2 arguments: self and attr set to None.
    if attr equals any of the strings "__file__", "__name__" or "__path__" and self.mod is not contained in sys.modules,
    raise an AttributeError with an argument attr.
    try,
    call the method self._resolve, substitute the result for _module.
    if ImportError exception is caught,
    raise an AttributeError with an argument attr.
    get attr attribute from the _module object, substitute it for value.
    set attr attribute of the self object to value.
    return value.
    derive class _LazyModule from the types.ModuleType base class.
    define the method __init__ with 2 arguments: self and name.
    call the method __init__ with an argument name form the base class of the class _LazyModule.
    substitute self.__class__.__doc__ for self.__doc__.
    define the method __dir__ with an argument self.
    attrs is a list with 2 elements: strings "__doc__" and "__name__".
    append attr.name to attrs for every attr in self._moved_attributes.
    return attrs.
    _moved_attributes is an empty list.
    derive class MovedAttribute from the _LazyDescr base class.
    define the method __init__ with 6 arguments: self, name, old_mod, new_mod, old_attr set to None, new_attr set to None.
    call the method __init__ with an argument name form the base class of the class MovedAttribute.
    if PY3 is true,
    if new_mod is None,
    substitute name for new_mod.
    substitute new_mod for self.mod.
    if new_attr is None,
    if old_attr is None,
    substitute name for new_attr.
    if not,
    substitute old_attr for new_attr.
    substitute new_attr for self.attr.
    if not,
    substitute old_mod for self.mod.
    if old_attr is None,
    substitute name for old_attr.
    substitute old_attr for self.attr.
    define the method _resolve with an argument self.
    call the function _import_module with an argument self.mod, substitute the result for module.
    gett self.attr from the module object, return it.
    derive class _MovedItems from the _LazyModule base class.
    _moved_attributes is a list with 55 initial elements, 13 of them are the results of the call to the function MovedAttribute,
    with different 3 string arguments, the others are results of the call to the function MovedModule called with 3 string arguments.   for every attr in _moved_attributes,
    set attr.name attribute of the _MovedItemst object to attr.
    if attr is an instance of MovedModule.
    concatenate __name__, string '.moves' and attr.name together, use it as an key to get the value from the sys.modules dictionary,
    substitute attr for the obtained value.   delete attr.
    substitute _moved_attributes for _MovedItems._moved_attributes.
    append string '.moves' to __name__, use it as an argument to instantiate _MovedItems class, assign it to moves,
    and to value under the '.moves' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_parse from the _LazyModule base class.
    _urllib_parse_moved_attributes is a list with 16 elemetns, all of them are the results of the call to the function MovedAttribute with different 3 string arguments.
    for every attr in _urllib_parse_moved_attributes,
    set attr.name attribute of the Module_six_moves_urllib_parse object to attr.
    delete attr.
    substitute _urllib_parse_moved_attributes for Module_six_moves_urllib_parse._moved_attributes.
    call the method Module_six_moves_urllib_request with an argument: string ".moves.urllib_parse" appended to __name__,
    assign the result to the value under the string ".moves.urllib_parse" appended to __name__ key of the sys.modules dictionary,   and to the value under the string ".moves.urllib.parse" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_error from the _LazyModule base class.
    _urllib_error_moved_attributes is a list with 3 elements: result of the call to the function MovedAttribute with 3 arguments:
    strings "URLError", "urllib2", "urllib.error", result of the call to the function MovedAttribute with 3 arguments:   strings "HTTPError", "urllib2", "urllib.error" and result of the call to the function MovedAttribute with 3 arguments:   strings "ContentTooShortError", "urllib", "urllib.error".   for every attr in _urllib_error_moved_attributes,
    set attr.name attribute of the Module_six_moves_urllib_error object to attr.
    delete attr.
    substitute _urllib_error_moved_attributes for Module_six_moves_urllib_error._moved_attributes.
    call the method Module_six_moves_urllib_request with an argument: string ".moves.urllib.error" appended to __name__,
    assign the result to the value under the string ".moves.urllib_error" appended to __name__ key of the sys.modules dictionary,   and to the value under the string ".moves.urllib.error" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_request from the _LazyModule base class.
    _urllib_request_moved_attributes is an list with 33 elements, all of them are the results of the call to the function MovedAttribute with 3 different string arguments.
    for every attr in _urllib_request_moved_attributes,
    set attr.name attribute of the Module_six_moves_urllib_request object to attr.
    delete attr.
    substitute _urllib_request_moved_attributes for Module_six_moves_urllib_request._moved_attributes.
    call the method Module_six_moves_urllib_request with an argument: string ".moves.urllib.request" appended to __name__,
    assign the result to the value under the string ".moves.urllib_request" appended to __name__ key of the sys.modules dictionary,   and to the value under the string ".moves.urllib.request" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_response from the _LazyModule base class.
    _urllib_response_moved_attributes is a list with 4 elements: result of the function MovedAttribute, called with 3 arguments:
    strings "addbase", "urllib" and "urllib.response", result of the function MovedAttribute, called with 3 arguments:   strings "addclosehook", "urllib", "urllib.response", result of the function MovedAttribute, called with 3 arguments:   strings "addinfo", "urllib", "urllib.response" and result of the function MovedAttribute, called with 3 arguments:   strings "addinfourl", "urllib", "urllib.response".   for every attr in _urllib_response_moved_attributes,
    set attr.name attribute of Module_six_moves_urllib_response object to attr.
    delete attr.
    substitute _urllib_response_moved_attributes for Module_six_moves_urllib_response._moved_attributes.
    instantiate class Module_six_moves_urllib_response with an argument, string ".moves.urllib.response" appended to __name__,
    assign it to value under the string ".moves.urllib_response" appended to __name__ key of the sys.modules dictionary,   and to value under the string ".moves.urllib.response" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_robotparser from the _LazyModule base class.
    _urllib_robotparser_moved_attributes is a list containing an instance of MovedAttribute class, created with 3 argument: strings,
    "RobotFileParser", "robotparser", "urllib.robotparser".   for every attr in _urllib_robotparser_moved_attributes,
    set attr.name attribute of Module_six_moves_urllib_robotparser object to attr.
    delete attr.
    substitute _urllib_robotparser_moved_attributes for Module_six_moves_urllib_robotparser._moved_attributes.
    instantiate class Module_six_moves_urllib_robotparser with an argument, string ".moves.urllib.robotparser" appended to __name__,
    assign it to value under the string ".moves.urllib_robotparser" appended to __name__ key of the sys.modules dictionary,   and to value under the string ".moves.urllib.robotparser" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib from the types.ModuleType base class.
    append string ".moves.urllib_parse" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for parse.
    append string ".moves.urllib_error" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for error.
    append string ".moves.urllib_request" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for request.
    append string ".moves.urllib_response" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for response.
    append string ".moves.urllib_robotparser" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for robotparser.
    define the method __dir__ with an argument self.
    return a list with 5 elements: strings 'parse', 'error', 'request', 'response' and 'robotparser'.
    instantiate class Module_six_moves_urllib with an argument, string ".moves.urllib" appended to __name__,
    substitute it for value under the string ".moves.urllib" appended to __name__ key of the sys.modules dictionary.   define the function add_move with an argument move.
    set move.name attribute of the _MovedItems to move.
    define the function remove_move with an argument name.
    try,
    delete name attribute of the _MovedItems object.
    if AttributeError exception is caught,
    try,
    delete entry under the name key of the moves.__dict__ dictionary.
    if NameError exception is caught,
    raise an AttributeError with an argument string "no such move, %r", formated with a tuple with an element name.
    if PY3 is true,
    _meth_func is a string "__func__".
    _meth_self is a string "__self__".
    _func_closure is a string "__closure__".
    _func_code is a string "__code__".
    _func_defaults is a string "__defaults__".
    _func_globals is a string "__globals__".
    _iterkeys is a string "keys".
    _itervalues is a string "values".
    _iteritems is a string "items".
    _iterlists is a string "lists".
    if not,
    _meth_func is a string "im_func".
    _meth_self is a string "im_self".
    _func_closure is a string "func_closure".
    _func_code is a string "func_code".
    _func_defaults is a string "func_defaults".
    _func_globals is a string "func_globals".
    _iterkeys is a string "iterkeys".
    _iterkeys is a string "iterkeys".
    _iteritems is a string "iteritems".
    _iterlists is a string "iterlists".
    try,
    substitute next for advance_iterator.
    if NameError exception is caught,
    define the function advance_iterator with an argument it.
    return next element of the iterable it.
    substitute klass.__dict__ for next.
    try,
    substitute callable for callable.
    if NameError exception is caught,
    define the function callable with an argument obj.
    if "__call__" is contained in klass.__dict__ for any klass in __mro__ field of the obj class, return boolean True, otherwise return False.
    if PY3 is true,
    define the function get_unbound_function with an argument unbound.
    return unbound.
    substitute Iterator for create_bound_method.
    substitute object for Iterator.
    if not,
    define the function get_unbound_function with an argument unbound.
    return unbound.im_func.
    define the function create_bound_function with 2 arguments: func and obj.
    call the method types.MethodType with 3 arguments: func, obj and obj.__class__, return the result.
    derive the class Iterator from the base class object.
    define the method next with an argument self.
    call the function type with an argument self, on the result call the method __next__ with an argument self, return the result.
    substitute callable for callable.
    call the function _add_doc with 2 arguments: get_unbound_function and string """Get the function out of a possibly unbound function""".
    call the method operator.attrgetter with an argument _meth_func, substitute the result for get_method_function.
    call the method operator.attrgetter with an argument _meth_self, substitute the result for get_method_self.
    call the method operator.attrgetter with an argument _func_closure, substitute the result for get_method_closure.
    call the method operator.attrgetter with an argument _func_code, substitute the result for get_method_code.
    call the method operator.attrgetter with an argument _func_defaults, substitute the result for get_method_defaults.
    call the method operator.attrgetter with an argument _func_globals, substitute the result for get_method_globals.
    define the function iterkeys with 2 arguments: d and unpacked dictionary  kw.
    get _iterkeys attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
    return it.   define the function itervalues with 2 arguments: d and unpacked dictionary  kw.
    get _itervalues attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
    return it.   define the function iteritems with 2 arguments: d and unpacked dictionary  kw.
    get _iteritems attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
    return it.   define the function iterlists with 2 arguments: d and unpacked dictionary  kw.
    get _iterlists attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
    return it.   if PY3 is true,
    define the function b with an argument s.
    call the method e.encode with an argument string "latin-1".
    define the function u with an argument s.
    return s.
    substitute chr for unichr.
    if second element of sys.version_info is smaller than or equal to integer 1,
    define the function int2byte with an argument i.
    call the function bytes with an argument tuple with an element i, return the result.
    if not,
    call the method operator.methodcaller with 3 arguments: string 'to_bytes', integer 1 and string 'big', substitute the result for int2byte.
    call te method operator.itemgetter with an argument integer 0, substitute the result for byte2int.
    substitute operator.getitem for indexbytes.
    substitute iter for iterbytes.
    import io.
    substitute io.StringIO for StringIO.
    substitute io.BytesIO for BytesIO.
    if not,
    define the function b with an argument s.
    return s.
    define the function u with an argument s.
    replace every occurrence of raw string '\\' in s with a raw string '\\\\', use the result and string "unicode_escape",
    as arguments for the call to the unicode function, return the result.  substitute unichr for unichr.
    substitute chr for int2byte.
    define the function byte2int with an argument bs.
    get the integer representation of the first element of bs, return it.
    define the function indexbytes with 2 arguments buf and i.
    get the integer representation of the i-th element of buf, return it.
    define the function iterbytes with an argument buf.
    convert byte to its integer representation, return all of the results for every byte in buf.
    import StringIO.
    assign StringIO.StringIO to StringIO and BytesIO.
    call the function _add_doc with 2 arguments: b and string """Byte literal""".
    call the function _add_doc with 2 arguments: u and string """Text literal""".
    if PY3 is true,
    get 'exec' attribute from the moves.builtins object, substitute it for exec_.
    define the function reraise with 3 arguments: tp, value and tb set to None.
    if value.__traceback__ is not tb,
    raise an value.with_traceback exception with an argument tb.
    raise an exception value.
    if not,
    define the function exec with 3 arguments: _code_, _globs_ set to None and _locs_ set to None.
    if _globs_ is None,
    call the method sys._getframe with an argument 1, substitute the result for frame.
    substitute frame.f_globals for _globs_.
    if _locs_ is None,
    substitute if _locs_ is None for _locs_.
    delete frame.
    otherwise if _locs_ is None,
    substitute _globs_ with an argument _locs_.
    execute code statement """exec _code_ in _globs_, _locs_""".
    call the function exec_ with an argument string """def reraise(tp, value, tb=None):    raise tp, value, tb""".
    get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
    if print_ is None,
    define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
    remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
    if fp is None,
    return nothing.
    define the function write with an argument data.
    if data is not an instance of basestring,
    convert data to string, substitute it for data.
    if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
    get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
    if errors is None,
    errors is a string "strict".
    call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
    write data to fp.
    want_unicode is boolean False.
    remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
    if sep is not None,
    if sep is an instance of unicode,
    want_unicode is boolean True.
    otherwise if sep is not an instance of string type,
    raise an TypeError exception with an argument string "sep must be None or a string".
    remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
    if end is not None,
    if end is an instance of unicode,
    want_unicode is boolean True.
    otherwise if end is not an instance of string type,
    raise an TypeError exception with an argument string "end must be None or a string".
    if kwargs is true,
    raise an TypeError exception with an argument string "invalid keyword arguments to print()".
    if want_unicode is false,
    for every arg in args,
    if arg is an instance of unicode,
    want_unicode is boolean True.
    break from the loop execution.
    if want_unicode is true,
    convert newline character to unicode and substitute the result for newline.
    convert whitespace character to unicode and substitute the result for space.
    if not,
    substitute newline character for newline.
    substitute string " " for space.
    if sep is None,
    substitute space for sep.
    if end is None
    substitute space for end.
    for every i and arg in enumerated iterable args,
    if i is true,
    call the function write with an argument sep.
    call the function write with an argument arg.
    call the function write with an argument end.
    call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
    define the function with_metaclass with 2 arguments meta and unpacked list bases.
    derive the class metaclass form the meta base class.
    substitute type.__call__ for __call__.
    substitute type.__init__ for __init__.
    define the method __new__ with 4 arguments: cls, name, this_bases and d.
    if this_bases is None,
    call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
    call the function meta with 3 arguments: name, base and d.
    return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
    define the function add_metaclass with an argument metaclass.
    define the function wrapper with an argument cls.
    call the method cls.__dict__.copy substitute the result for orig_vars.
    remove '__dict__' key from the orig_vars dictionary.
    remove '__weakref__' key from the orig_vars dictionary.
    get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
    if slots is not None,
    if slots is an instance of str,
    slots is a list with an element, slots.
    for every slots_var in slots,
    remove slots_var key from the orig_vars dictionary.
    return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
    return wrapper.
    if PY3 is true,
    _assertCountEqual is a strnig "assertCountEqual".
    _assertRaisesRegex is a strnig "assertRaisesRegex".
    _assertRegex is a strnig "assertRegex".
    substitute memoryview for memoryview.
    buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
    if not,
    _assertCountEqual is a strnig "assertItemsEqual".
    _assertRaisesRegex is a strnig "assertRaisesRegexp".
    _assertRegex is a strnig "assertRegexpMatches".
    if sys.platform starts with a string 'java',
    substitute memoryview for memoryview.
    if not,
    substitute buffer for memoryview.
    buffer_types is a tuple with 2 elements bytearray and memoryview.
    define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
    get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
    and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
    get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
    and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
    get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
    and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
    use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
    import module contextlib.
    try,
    import threading.
    except ImportError.
    import dummy_threading as threading.
    derive the class RWLock from the object base class.
    define the method __init__ with an argument self.
    call the method threading.RLock, substitute the result for self.mutex.
    call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
    call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
    self.active_readers is an integer 0.
    self.active_writers is an integer 0.
    self.waiting_readers is an integer 0.
    self.waiting_writers is an integer 0.
    define the method reader_enters with an argument self.
    with self.mutex perform,
    if self.active_writers and self.waiting_writers both equal to integer 0,
    increment self.active_readers by 1.
    call the method self.can_read.release.
    if not,
    increment self.waiting_readers by 1.
    call the method self.can_read.acquire.
    define the method reader_leaves with an argument self.
    with self.mutex perform,
    decrement self.active_readers by integer 1,
    if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
    increment self.active_writers by 1.
    decrement self.waiting_writers by integer 1,
    call the method self.can_write.release.
    contextlib.contextmanager decorator,
    define the method reader with an argument self.
    call the method self.reader_enters.
    try,
    yield nothing.
    finally perform,
    call the method self.reader_leaves.
    define the method writer_enters with an argument self.
    with self.mutex perform,
    if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
    increment self.active_writers by integer 1,
    call the method self.can_write.release.
    if not,
    increment self.waiting_writers by integer 1,
    call the method self.can_write.acquire.
    define the method writer_leaves with an argument self.
    with self.mutex perform,
    decrement self.active_writers by integer 1,
    if self.waiting_writers is not equal to integer 0,
    increment self.active_writers by integer 1,
    decrement self.waiting_writers by integer 1,
    call the method self.can_write.release.
    otherwise if self.waiting_readers is not equal to integer 0,
    substitute self.waiting_readers for t.
    self.waiting_readers is integer 0.
    increment self.active_readers by t.
    while t is greater than integer 0,
    call the method self.can_read.release.
    decrement t by integer 1,
    contextlib.contextmanager decorator,
    define the method writer with an argument self.
    call the method self.writer_enters.
    try,
    yield nothing.
    finally perform,
    call the method self.writer_leaves.
    from django.utils import six into default name space.
    color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
    foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
    for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
    for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
    opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
    and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
    code_list is an empty list.
    if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
    format string '\x1b[%sm' with RESET, return the result.
    call the function six.iteritems with an argument kwargs, for every k and v in the result,
    if k equals a string 'fg',
    append value under the key v of foreground dictionary to code_list.
    otherwise if k equals a string 'bg',
    append value under the key v of background dictionary to code_list.
    for every o in opts,
    if o is contained in opt_dict,
    append value under the 0 key of the opt_dict dictionary to code_list.
    if string 'noreset' is not contained in opts,
    if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
    join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
    return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
    return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
    opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
    DARK_PALETTE is a string 'dark'.
    LIGHT_PALETTE is a string 'light'.
    PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
    a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
    define the function parse_color_setting with an argument config_string.
    if config_string is false,
    return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
    convert config_string to lowercase and split it by ';' character, substitute the result for parts.
    get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
    for every part in parts,
    if part is contained in PALETTES,
    get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
    otherwise if '=' is contained in part,
    definition is an empty dictionary,
    split part by '=' character, substitute the result for role and instructions, respectively.
    convert role to uppercase.
    split instructions by ',' character, substitute the result for styles.
    reverse the order of elements of styles.
    remove first element from styles, split it by the '/' character, substitute the result for colors.
    reverse the order of colors elements,
    remove the first element from colors, substitute it for fg.
    if fg is contained in color_names,
    substitute fg for value under the 'fg' key of definition dictionary.
    if colors is true and last element of colors is contained in color_names,
    substitute last element of colors for value under the 'bg' key of definition dictionary.
    opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
    if opts is true,
    substitute opts for value under the 'opts' key of definition dictionary.
    if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
    substitute definition for value under the role key of palette dictionary.
    if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
    return None.
    return palette.
    from __future__ import unicode_literals into default name space.
    import module re.
    import module unicodedata.
    from gzip import GzipFile into default name space.
    from io import BytesIO into default name space.
    import module warnings.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    from django.utils.encoding import force_text into default name space.
    from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
    from django.utils import six into default name space.
    from django.utils.six.moves import html_entities into default name space.
    from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
    from django.utils.safestring import mark_safe into default name space.
    if six.PY2 is true,
    from django.utils.encoding import force_unicode.
    if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
    convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
    call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
    re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
    re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
    re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
    call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
    define the function wrap with 2 arguments text and width.
    call the function force_text with an argument text, substitute the result for text.
    define the function _generator.
    call the method text.splitlines with an argument boolean True, for every line in the result,
    if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
    while length of line is grater than max_width,
    get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
    add integer 1 to it, substitute the result for space.   if space equals integer 0,
    find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
    if space equals integer 0,
    yield line.
    line is an empty string.
    break from the loop execution
    get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
    remove all the elements from space index of line.
    if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
    if line is true,
    yield line.
    call the function _generator, join the result into a string, return the result.
    call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
    derive the class Truncator form the SimpleLazyObject class.
    define the method __init__ with 2 arguments: self and text.
    call the method __init__ from the base class of the class Truncator,
    called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
    if truncate is None,
    call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
    call the function force_text with an argument truncate, substitute the result for truncate.
    if string '%(truncated_text)s' is contained in truncate,
    format truncate with a dictionary with an element: text for 'truncated_text', return the result.
    if text ends with truncate,
    return text.
    append truncate to text, return the result.
    define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
    convert num to an integer, substitute it for length.
    call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
    substitute length for truncate_len.
    for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
    call the method unicodedata.combining with an argument char, if it evaluates to false,
    decrement truncate_len by integer 1.
    if truncate_len equals integer 0.
    break from the loop execution.
    if html is true,
    call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
    call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
    call the function allow_lazy with an argument chars, substitute the result for chars.
    define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
    s_len is integer 0.
    end_index is None.
    for every i and char in enumerated text,
    call the function unicodedata.combining with an argument char, if it evaluates to true,
    skip this loop iteration,s
    increment s_len by integer 1,
    if end_index is None and s_len is greater than truncate_len,
    substitute i for end_index.
    if s_len is greater than length,
    call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
    if not an empty string, and truncate, return the result.   return text.
    define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
    convert num to an integer, substitute the result for length.
    if html is true,
    call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
    call the method self._text_words with 2 arguments length and truncate, return the result.
    call the function allow_lazy with an argument words, substitute the result for words.
    define the method _text_words with 3 arguments: self, length and truncate.
    split self._wrapped into words, substitute the result for words.
    if length of words is greater than length,
    substitute first length elements of words for words.
    call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
    and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
    define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
    if words is not empty and length is smaller than or equal to integer 0,
    return an empty string.
    html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
    pos is equal to integer 0.
    end_text_pos is equal to integer 0.
    current_len is equal to integer 0.
    open_tags is an empty list.
    if words is true, substitute re_words for regex, if not substitute re_chars for regex.
    while current_len is smaller than or equal to length,
    call the method regex.search with 2 arguments: text and pos.
    if m is false,
    break from the loop execution,
    call the method m.end with an argument integer 0, substitute the result for pos.
    call the function m.group, if the result evaluates to true,
    increment current_len by integer 1,
    if current_len equals truncate_len,
    substitute pos for end_text_pos.
    skip this loop iteration.
    call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
    substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
    skip this loop iteration.
    call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
    convert tagname to lowercase, substitute it for tagname.
    if self_closing is true or tagname is contained in html4_singlets,
    do nothing.
    otherwise if closing_tag is true,
    try,
    get the index of the first occurrence of tagname, substitute it for i.
    if ValueError exception is caught,
    do nothing.
    if not,
    create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
    if not,
    insert tagname at the beginning of open_tags.
    if current_len is smaller than or equal to length,
    return text.
    create a list out of fist end_text_pos text elemnts, substitue it for out.
    call the method self.add_truncation_text with 2 arguments: an empty string and truncate, substitute it for truncate_text.
    if truncate_text is true,
    append truncate_text to out.
    for every tag in open_tags,
    replace '%s' in string '</%s>' with tag, append the result to out.
    return out.
    define the function get_valid_filename with an argument s.
    call the function force_text with an argument s, strip the result of whitespaces from both ends,
    replace every occurrence of whitespaces in the previous result for '_', substitute the result for s.   call the function re.sub with 3 arguments: raw string '(?u)[^-\w.]', an empty string and s, return the result.
    call the function allow_lazy with 2 arguments: get_valid_filename and six.text_type, substitute the result for get_valid_filename.
    define the function get_text_list with 2 arguments: list_ and last_word set to result of the function ugettext_lazy called with an argument string 'or'.
    is length of list_ equals integer 0,
    return an empty string.
    if length of list_ equals integer 1,
    call the function force_text with first element of list_ as an argument, return the result.
    return a string '%s %s %s' formated with 3 elements: result of the function force_text called with an argument i,
    separated by result of the function _ called with an argument string ', ', for every i in list_ without last element,   result of the function force_text called with an argument last_word, result of the function force_text called with an argument:   last element of list_.   call the function allow_lazy with 2 arguments: get_text_list and six.text_type, substitute the result for get_text_list.
    define the function normalize_newlines with an argument text.
    call the function force_text with an argument text, substitute the result for text.
    call the method re_newlines.sub with 2 arguments: '\n' and text, return the result.
    call the function allow_lazy with 2 arguments: normalize_newlines and six.text_type, substitute the result for normalize_newlines.
    define the function phone2numeric with an argument phone.
    char2number is an dictionary, with 26 elements: 2 for 'a', 2 for 'b', 2 for 'c', 3 for 'd', 3 for 'e', 3 for 'f', 4 for 'g',
    4 for 'h', 4 for 'i', 4 for 'j', 5 for 'k', 5 for 'l', 5 for 'm', 6 for 'n', 6 for 'o', 6 for 'p', 7 for 'q', 7 for 'r', 7 for 'r',   7 for 's', 7 for 't', 8 for 't', 8 for 'u', 8 for 'v', 9 for 'w', 9 for 'x', 9 for 'y' and 9 for 'z'.   for every c in phone converted to lowercase, join the value under the c key of the char2number dictionary into a string, return it.
    call the function allow_lazy with an argument phone2numeric, substitute the result for phone2numeric.
    define the function compress_string with an argument s.
    zbuf is an instance of BytesIO class.
    zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
    and fileobj set to zbuf.   call the method zfile.write with an argument s.
    call the method zfile.close.
    call the method zbuf.getvalue, return the result.
    derive the class StreamingBuffer from the object base class.
    define the method __init__ with an argument self.
    self.vals is an empty list.
    define the method write with 2 arguments: self and val.
    append val to self.vals.
    define the method read with an argument self.
    join elements of self.vals into a bytes string, substitute the result for ret.
    self.vals is an empty list.
    return ret.
    define the method flush with an argument self.
    return nothing.
    define the method close with an argument self.
    return nothing.
    define the function compress_sequence with an argument sequence.
    buf is an instance of StreamingBuffer class.
    zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
    and fileobj set to buf.   read data from buf file stream, yield the result.
    for every item in sequence,
    write item to zfile stream.
    flush zfile stream buffer.
    read data from buf, yield the result.
    close zfile stream.
    read data from buf, yield the result.
    call the function re.compile with an argument string "([\u0080-\uffff])", substitute the result for ustring_re.
    define the function javascript_quote with 2 arguments: s and quote_double_quotes set to boolean False.
    msg is an string "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.".
    call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
    define the function fix with an argument match.
    get the unicode representation of result of the method match.group called with an integer 1, format with in a string "\\u%04x",
    return the result.   if type of s equals bytes,
    call the method s.decode with an argument string 'utf-8', substitute the result for s.
    otherwise if, type of s doesnt equal to six.text_type,
    raise an TypeError with an argument s.
    replace every occurrence of '\\' in s with '\\\\'.
    replace every occurrence of '\r' in s with '\\r'.
    replace every occurrence of '\n' in s with '\\n'.
    replace every occurrence of '\t' in s with '\\t'.
    replace every occurrence of "'" in s with "\\'".
    replace every occurrence of '</' in s with '<\\/'.
    if quote_double_quotes is true,
    replace every occurrence of '"' in s with '&quot;'.
    call the method ustring_re.sub with 2 arguments: fix and s, return the result.
    call the function allow_lazy with 2 arguments: javascript_quote and six.text_type, substitute the result for javascript_quote.
    call the function re.compile with 2 arguments: raw string "((?:[^\s'"]*(?:(?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')[^\s'"]*)+) | \+)",
    and re.VERBOSE, substitute the result for smart_split_re.   define the function smart_split with an argument text.
    call the function force_text with an argument text, substitute the result for text.
    call the method smart_split_re.finditer with an argument text, for every bit in result,
    call the method bit.group with an argument integer 0, yield the result.
    define the function _replace_entity with an argument match.
    call the method match.group with an argument integer 1, substitute the result for text.
    if first element of text equals '#',
    remove first element of text.
    try,
    if first element of text is contained in 'xX'.
    convert text without first element to hexadecimal integer, substitute it for c.
    if nor,
    convert text to an integer, substitute it for c.
    call the method six.unichr with an argument c, return the result.
    if ValueError exception is caught,
    call the method match.group with an argument integer 0, return the result.
    if not,
    try,
    call the function six.unichr with value under the text key of the html_entities.name2codepoint dictionary, return the result.
    if OverflowError or ValueError exceptions are caught,
    call the method match.group with an argument integer 0, return the result.
    call the method re.compile with an argument raw string "&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));", substitute the result for _entity_re.
    define the function unescape_entities with an argument text.
    call the method _entity_re.sub with 2 arguments: _replace_entity and text, return the result.
    call the function allow_lazy with 2 arguments: unescape_entities and six.text_type, substitute the result for unescape_entities.
    define the function unescape_string_literal with an argument s.
    if first element of s is not contained in "\"'" or last element of s is not equal to first element of s,
    raise an ValueError exception wit an argument string "Not a string literal: %r", where "%r" is replaced with s.
    substitute first element of s for quote.
    remove first and last elements of s, replace every occurrence of string '\%s' formated with quote with quote,
    replace every occurrence of raw string '\\' in the result with string '\\', return the result.   call the function allow_lazy with an argument unescape_string_literal, substitute the result for unescape_string_literal.
    define the function slugify with an argument value.
    call the method unicodedata.normalize with 2 arguments: string 'NFKD' and value, encode the result with 2 arguments: string 'ascii',
    and string 'ignore', call the method decode on the result with an argument string 'ascii', substitute the result for value.   call the method re.sub with 3 arguments: string '[^\w\s-]', empty string and value, strip the result of whitespaces from both ends,
    and convert it to lowercase, substitute the result for value.   call the function re.sub with 3 arguments: string '[-\s]+', string '-' and value, use the result as an argument for the call to the,
    mark_safe function, return the result.   call the function allow_lazy with 2 arguments: slugify and six.text_type, substitute the result slugify.
    define the function camel_case_to_spaces with an argument value.
    call the method re_camel_case.sub with 2 arguments: raw string ' \1' and value, strip the result of whitespaces from both ends,
    from __future__ import unicode_literals into default name space.
    import module datetime.
    from django.utils.html import avoid_wrapping into default name space.
    from django.utils.timezone import is_aware and utc into default name space.
    from django.utils.translation import ugettext and ungettext_lazy into default name space.
    define the function timesince with d, now defaulting to None, reversed defaulting to False as arguments.
    chunks is a tuple containing 6 initial tuples:
    result of multiplication of integers: 60,60,24,365, and return value of ungettext_lazy with 2 arguments: '%d year', '%d years',   result of multiplication of integers: 60,60,24,30, and return value of ungettext_lazy with 2 arguments: '%d month', '%d month',   result of multiplication of integers: 60,60,24,7, and return value of ungettext_lazy with 2 arguments: '%d weeks', '%d weeks',   result of multiplication of integers: 60,60,24, and return value of ungettext_lazy with 2 arguments: '%d days', '%d days',   result of multiplication of integers: 60,60, and return value of ungettext_lazy with 2 arguments: '%d hours', '%d hours',   result of multiplication of integers: 60, and return value of ungettext_lazy with 2 arguments: '%d minutes', '%d minutes',   if d is not an instance of datetime.datetime,
    call the function datetime.datetime with 3 arguments, d.year, d.month and d.day, substitute the result for d.
    if now equals to boolean True and now is not an instance of datetime.datetime,
    call the function datetime.datetime with 3 arguments, now.year, now.month and now.day, substitute the result for now.
    if now is false,
    call the function datetime.datetime with utc as argument if call to the is_aware(d) returns True, if not None is the argument, store the result in now.
    if reversed is True substitute difference of d and now for delta, if not substitute the difference of now and d for delta.
    multiply delta.days, integer 24, integer 60 and integer 60 add delta.seconds to it, substitute the result for since.
    if since is lesser or equal to integer 0,
    call the function ugettext with '0 minutes' as argument, use the result as the argument for the call to the avoid_wrapping function, return the result.
    for every i and tuple containing 2 elements: seconds and name, in enumerated chunks,
    divide since by seconds, store the floored result in count.
    if count does not equals to integer 0,
    break the execution of the smallest enclosing loop.
    use the remainder of the division of name by count as the argument for the call to the avoid_wrapping function, store the result in result.
    if i incremented by 1 is lesser than length of chunks,
    get the element of chunks at the (i+1)-the index, assign it to the seconds2 and name2, respectively.
    multiply seconds by count, subtract it from since, divide the result by seconds2, store the floored result in count2.
    if count2 does not equals to integer 0,
    call avoid_wrapping function with name2 modulus count2 as argument, call the ugettext with ', ' as argument, add previous 2 results, increment variable result by it.
    return result.
    define the function timeuntil with 2 arguments, d and now defaulting to none.
    evaluate the function timesince with d, now and reversed set to boolean true as arguments, return the result.
    from datetime import datetime,  timedelta and tzinfo into default name space.
    from threading import local into default name space.
    import module sys.
    import module time as _time.
    try,
    import pytz.
    if ImportError exception is caught,
    pytz is None.
    from django.conf import settings into default name space.
    from django.utils import six into default name space.
    __all__ is a list with 15 elements: strings 'utc', 'get_fixed_timezone', 'get_default_timezone', 'get_default_timezone_name',
    'get_current_timezone', 'get_current_timezone_name', 'activate', 'deactivate', 'override', 'localtime', 'now', 'is_aware',   'is_naive', 'make_aware' and 'make_naive'.   call the function timedelta with an argument integer 0, substitute the result for ZERO.
    derive the class UTC from the tzinfo base class.
    define the method __repr__ with an argument self.
    return a string "<UTC>".
    define the method utcoffset with 2 arguments self and dt.
    return ZERO.
    define the method tzname with 2 arguments self and dt.
    return a string "UTC".
    define the method dst with 2 arguments self and dt.
    return ZERO.
    derive the class FixedOffset from the tzinfo base class.
    define the method __init__ with 3 arguments: self, offset set to None, name set to None.
    if offset is not None,
    call the function timedelta with an argument minutes set to offset, substitute the result for self.__offset.
    if name is not None,
    substitute name for self.__name.
    define the method utcoffset with 2 arguments: self and dt.
    return self.__offset.
    define the method tzname with 2 arguments: self and dt.
    return self.__name.
    define the method dst with 2 arguments: self and dt.
    return ZERO.
    derive the class ReferenceLocalTimezone from the tzinfo base class.
    define the method __init__ with an argument self.
    call the function timedelta with an argument seconds set to negative _time.timezone, substitute the result for self.STDOFFSET.
    if _time.daylight is true,
    call the function timedelta with an argument seconds set to negative _time.altzone, substitute the result for self.DSTOFFSET.
    if not,
    substitute self.STDOFFSET for self.DSTOFFSET.
    subtract self.STDOFFSET with self.DSTOFFSET, substitute the result for self.DSTDIFF.
    call the method tzinfo.__init__ with an argument self.
    define the method utcoffset with 2 arguments: self and dt.
    call the method self._isdst with an argument dt, if it evaluates to true,
    return self.DSTOFFSET.
    if not,
    return self.STDOFFSET.
    define the method utcoffset with 2 arguments: self and dt.
    call the method self._isdst with an argument dt, if it evaluates to true,
    return self.DSTDIFF.
    if not,
    return ZERO.
    define the method tzname with 2 arguments: self and dt.
    call the method self._isdst with an argument dt, use it as an key to get the value from the _time.tzname dictionary, return it.
    define the method _isdst with 2 arguments: self and dt.
    tt is a tuple with 9 elements: dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, result of the method dt.weekday,
    ingeter 0 and integer 0.   call the method _time.mktime with an argument tt, substitute the result for stamp.
    call the method _time.localtime with an argument stamp, substitute the result for tt.
    if tt.tm_isdst is greater than integer 0, return the result.
    derive the class LocalTimezone from the ReferenceLocalTimezone base class.
    define the method tzname with 2 arguments: self and dt.
    if dt is None, is_dst is boolean False, otherwise call the method _isdst with an argument dt, substitute the result for is_dst.
    return the value under the is_dst key of the _time.tzname dictionary.
    define the method _isdst with 2 arguments: self and dt.
    try,
    call the method _isdst with an argument dt from the base class of the class LocalTimezone, return the result.
    if OverflowError or ValueError, renamed to exc, exceptions are caught,
    get the type of the exc object, substitute it for exc_type.
    call the function exc_type with an argument string "Unsupported value: %r. You should install pytz.", replace '%s' with dt,
    substitute the result for exc_value.   substitute exc for exc_value.__cause__.
    call the function six.reraise with 3 arguments: exc_type, exc_value and third element of the result of the method sys.exc_info.
    if pytz is true, substitute pytz.utc for utc, otherwise substitute result of the function UTC for utc.
    define the function get_fixed_timezone with an argument offset.
    if offset is an instance of timedelta class,
    substitute offset.seconds for offset.
    if offset is smaller than integer 0, sign is '-', otherwise sign is '+'.
    divide absolute offset by module 60, use the result to format string '%02d%02d', substitute it for hhmm.
    sum sign and hhmm, substitute the result for name.
    return an instance of FixedOffset class, created with 2 arguments: offset and name.
    _localtime is None.
    define the function get_default_timezone.
    use global variable _localtime.
    if _localtime is None,
    if settings.TIME_ZONE is an instance of six.string_types and pytz is not None,
    call the method pytz.timezone with an argument settings.TIME_ZONE, substitute the result for _localtime.
    if not,
    _localtime is an instance of LocalTimezone class.
    return _localtime.
    define the function get_default_timezone_name.
    call the function get_default_timezone, use the result as an argument for the call to the function _get_timezone_name, return the result.
    call the method local, substitute the result for _active.
    define the function get_current_timezone.
    get 'value' attribute of the _active object, if it exists return it, if not, call the function get_default_timezone and return the result.
    define the function get_current_timezone_name.
    call the function get_current_timezone, use the result as an argument for the call to the function _get_timezone_name, return the result.
    define the function _get_timezone_name with an argument timezone.
    try,
    return timezone.zone.
    if AttributeError exception is caught,
    call the method timezone.tzname with an argument None, return the result.
    define the function activate with an argument timezone.
    if timezone is an instance of tzinfo,
    substitute timezone for _active.value.
    otherwise if timezone is an instance of six.string_types and pytz is not None,
    call the method pytz.timezone with an argument timezone, substitute the result for _active.value.
    if not,
    raise an ValueError with an argument string "Invalid timezone: %r", substitute '%r' with timezone.
    define the function deactivate.
    if active has an attribute 'value',
    delete _active.value.
    derive the class override from the object base class.
    define the method __init__ with 2 arguments: self and timezone.
    substitute timezone for self.timezone.
    get 'value' attribute of the _active object
    define the method __enter__ with an argument self.
    if self.timezone is None,
    call the method deactivate.
    if not,
    call the method activate with an argument self.timezone.
    define the method __exit__ with 4 arguments self, exc_type, exc_value and traceback.
    if self.old_timezone is None,
    call the method deactivate.
    if not,
    substitute self.old_timezone for _active.value.
    define the function template_localtime with 2 arguments: value and use_tz set to None.
    if value is an instance of datetime and settings.USE_TZ if use_tz is None else use_tz and call to the function is_naive,
    with an argument value evaluates to false, and if 'convert_to_local_time' attribute of value object doesnt exists,   or is it does is boolean True, should_convert is boolean True, otherwise is boolean False.   if should_convert is true, call the function localtime with an argument value and return the result, otherwise return value.
    define the function localtime with 2 arguments: value and timezone set to None.
    if timezone is None,
    call the function get_current_timezone, substitute the result for timezone.
    call the method value.astimezone with an argument timezone, substitute the result for value.
    if timezone has an attribute 'normalize',
    call the method timezone.normalize with an argument value, substitute the result for value.
    return value.
    define the function now.
    if settings.USE_TZ is true,
    call the method datetime.utcnow, on the result call the method replace with an argument tzinfo set to utc, return the result.
    if not,
    call the method datetime.now, return the result.
    define the function is_aware with an argument value.
    if value.tzinfo is not None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to not None,
    return boolean True, otherwise return boolean False.   define the function is_naive with an argument value.
    if value.tzinfo is None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to None,
    return boolean True, otherwise return boolean False.   define the function make_aware with 2 arguments: value and timezone.
    if timezone has an attribute 'localize',
    call the method timezone.localize with 2 arguments: value and is_dst as None, return the result.
    if not,
    call the function is_aware with an argument value, if it evaluates to true,
    raise an ValueError exception with an argument string "make_aware expects a naive datetime, got %s", where '%s' is replaced with value.
    call the method value.replace with an argument tzinfo as timezone, return the result.
    define the function make_naive with 2 arguments: value and timezone.
    call the method value.astimezone with an argument timezone, substitute the result for value.
    if timezone has an attribute 'normalize',
    call the method timezone.normalize with an argument value, substitute the result for value.
    call the method value.replace with an arugment tzinfo set to None, return the result.
    from __future__ import unicode_literals into default name space.
    import module re.
    from django.utils.encoding import force_text into default name space.
    from django.utils.functional import lazy into default name space.
    from django.utils import six into default name space.
    __all__ is an list containing strings: 'activate', 'deactivate', 'override', 'deactivate_all', 'get_language',
    'get_language_from_request', 'get_language_info', 'get_language_bidi', 'check_for_language', 'to_locale', 'templatize',   'string_concat', 'gettext', 'gettext_lazy', 'gettext_noop', 'ugettext', 'ugettext_lazy', 'ugettext_noop', 'ngettext', 'ngettext_lazy',   'ungettext', 'ungettext_lazy', 'pgettext', 'pgettext_lazy', 'npgettext', 'npgettext_lazy' and 'LANGUAGE_SESSION_KEY'.   LANGUAGE_SESSION_KEY is an string '_language'.
    derive the class TranslatorCommentWarning from the SyntaxWarning base class.
    do nothing.
    derive the class Trans from the object base class.
    define the method __getattr__ with 2 arguments: self and real_name.
    from django.conf import settings.
    if settings.USE_I18N is true,
    from django.utils.translation import trans_real as trans.
    if not,
    from django.utils.translation import trans_null as trans.
    set real_name attribute of the self object to value of real_name attribute of trans object.
    get attribute real_name from the trans object, return it.
    _trans is an instance of Trans class.
    delete Trans.
    define the function gettext_noop with an argument message.
    call the method _trans.gettext_noop with an argument message.
    substitute gettext_noop for ugettext_noop.
    define the function gettext_noop with an argument message.
    call the method _trans.gettext with an argument message.
    define the function ngettext with 3 arguments: singular, plural and number.
    call the method _trans.ngettext with 3 arguments singular, plural and number.
    define the method ugettext with an argument message.
    call the method _trans.gettext_noop with an argument message.
    define the function ungettext with 3 arguments: singular, plural and number.
    call the method _trans.ungettext with 3 arguments singular, plural and number.
    define the function pgettext with 2 arguments: context and message.
    call the method _trans.pgettext with 2 arguments context and message.
    define the function npgettext with 4 arguments: context, singular, plural and number.
    call the method _trans.npgettext with 4 arguments context, singular, plural and number.
    call the function lazy with 2 arguments: gettext and str, substitute gettext_lazy.
    call the function lazy with 2 arguments: ugettext and six.text_type, substitute ugettext_lazy.
    call the function lazy with 2 arguments: pgettext and six.text_type, substitute pgettext_lazy.
    define the function lazy_number with 4 arguments: func, resultclass, number set to None and unpacked dictionary kwargs.
    if number is an instance of int type.
    substitute number for value under the 'number' key of the kwargs dictionary.
    call the function lazy with 2 arguments: func and resultclass, call the result with an argument, unpacked dictionary kwargs,
    substitute the result for proxy.   if not,
    derive the class NumberAwareString from the resultclass base class.
    define the method __mod__ with 2 arguments: self and rhs.
    if rhs is an instance of dict type and number is true,
    try,
    substitute value under the number key of the rhs dictionary for number_value.
    if KeyError exception is caught,
    raise an KeyError with an argument string 'Your dictionary lacks key \'%s\'. Please provide it, because it is required to '
    'determine whether string is singular or plural.', where '%s' is replaced with number.   if not,
    substitute rhs for number_value.
    substitute number_value for kwargs dictionary value under the 'number' key.
    call the function func with unpacked dictionary kwargs as an argument, substitute the result for translated.
    try,
    format translated with rhs, substitute the result for translated.
    if TypeError exception is caught,
    do nothing.
    return translated.
    call the function lazy with 2 arguments: lambda function with unpacked dictionary kwargs as an argument and return value an instance of NumberAwareString class and NumberAwareString, call the result with an argument unpacked dictionary kwargs, substitute the result for proxy.
    return proxy.
    define the function ngettext_lazy with 3 arguments: singular, plural and number set to None.
    call the function lazy_number with 5 arguments: ngettext, str, singular set to singular, plural set to plural,
    and number set to number, return the result.   define the function ungettext_lazy with 3 arguments: singular, plural and number set to None.
    call the function lazy_number with 5 arguments: ungettext, six.text_type, singular set to singular, plural set to plural,
    and number set to number, return the result.   define the function npgettext_lazy with 4 arguments: context, singular, plural and number set to None.
    call the function lazy_number with 6 arguments: npgettext, six.text_type, context set to context, singular set to singular,
    plural set to plural and number set to number, return the result.   define the function activate with an argument language.
    call the function _trans.activate with an argument language, return the result.
    define the function deactivate.
    call the function _trans.deactivate, return the result.
    derive the class override from the object base class.
    define the method __init__ with 3 arguments: self, language and deactivate set to boolean False.
    substitute language for self.language.
    substitute deactivate for self.deactivate.
    call the function get_language, substitute the result for self.old_language.
    define the method __enter__ with an argument self.
    if self.language is not None,
    call the function activate with an argument self.language.
    if not,
    call the function deactivate_all.
    define the method __exit__ with 4 arguments: self, exc_type, exc_value and traceback.
    if self.deactivate is true,
    call the method deactivate.
    if not,
    call the method activate with an argument self.old_language.
    define the function get_language.
    call the function _trans.get_language, return the result.
    define the function get_language_bidi.
    call the function _trans.get_language_bidi, return the result.
    define the function check_for_language with an argument lang_code.
    call the function _trans.check_for_language with an argument lang_code, return the result.
    define the function to_locale with an argument language.
    call the function _trans.to_locale with an argument language, return the result.
    define the function get_language_from_request with 2 arguments: request and check_path set to boolean False.
    call the function _trans.get_language_from_request with 2 arguments: request and check_path, return the result.
    define the function get_language_from_path with an argument path.
    call the function _trans.get_language_from_path with an argument path, return the result.
    define the function templatize with 2 arguments: src and origin set to None.
    call the function _trans.templatize with 2 arguments: src and origin, return the result.
    define the function deactivate_all.
    call the function _trans.deactivate_all, return the result.
    define the function _string_concat with an argument unpacked list strings.
    for every s in strings, call the function force_text with an argument s, join the results in a string, return the result.
    call the function lazy with 2 arguments: _string_concat and six.text_type, substitute the result for string_concat.
    define the function get_language_info with an argument lang_code.
    from django.conf.locale import LANG_INFO.
    try,
    get the value under the lang_code key of the LANG_INFO dictionary, return it.
    if KeyError exception is caught,
    if character '-' is not contained  in lang_code,
    raise an KeyError with an argument "Unknown language code %s.", where '%s' is replaced with lang_code.
    split lang_code by character '-', substitute the first element of the result for generic_lang_code.
    try,
    get the LANG_INFO dictionary value under the generic_lang_code key, return the result.
    if KeyError exception is caught,
    raise an KeyError with an argument string "Unknown language code %s and %s.", where '%s' is replaced with lang_code,
    and generic_lang_code.   call the function re.compile with an argument string '\s*\n\s*', substitute the result for trim_whitespace_re.
    define the function trim_whitespace with an argument s.
    call strip s of the surrounding whitespaces, substitute every occurrence of the whitespace in the trim_whitespace_re with previous result, return the result.
    from django.conf import settings into default name space.
    from django.utils.encoding import force_text into default name space.
    from django.utils.safestring import mark_safe and SafeData into default name space.
    define the function ngettext with 3 arguments: singular, plural and number.
    if number equals integer 1,
    return singular.
    return plural.
    substitute ngettext for ngettext_lazy.
    define the function ungettext with 3 arguments: singular, plural and number.
    call the function ngettext with 3 arguments: singular, plural and number, use the result as an argument for the call to the force_text,
    return the result.   define the function pgettext with 2 arguments: context and message.
    call the function ugettext with an argument message.
    define the function ngettext with 4 arguments: context, singular, plural and number.
    call the function ungettext with 3 arguments: singular, plural and number, return the result.
    activate is a lambda function which returns None for any argument x.
    deactivate and deactivate_all are lambda functions returning None.
    get_language is a lambda function returning settings.LANGUAGE_CODE.
    get_language_bidi is lambda function returning boolean True if settings.LANGUAGE_CODE is contained in settings.LANGUAGES_BIDI.
    check_for_language is lambda function that returns boolean True for every argument x.
    define the function gettext with an argument message.
    if message is an instance of SafeData.
    call the function mark_safe with an argument message, return the result.
    return message.
    define the function ugettext with an argument message.
    call the function gettext with an argument message, use the result as an argument for the call to the force_text function, return the result.
    substitute gettext for gettext_noop, gettext_lazy and _.
    define the function to_locale with an argument language.
    find position of '-' in the index of the language, substitute the result for p.
    if p is greater or equal to integer 0,
    append '_' to string created from first p elements of languages converted to lowercase,
    convert slice of language string from (p+1)-th index to the end to uppercase, append it to the previous result, return the resulting string.   if not,
    convert language to lowercase and return it.
    define the function get_language_from_request with 2 arguments: request and check_path set to boolean False.
    return settings.LANGUAGE_CODE.
    define the function get_language_from_path with an argument request.
    return None.
    from __future__ import unicode_literals into default name space.
    from collections import OrderedDict into default name space.
    import module os.
    import module re.
    import module sys.
    import module gettext as gettext_module.
    from threading import local into default name space.
    import module warnings.
    from django.apps import apps into default name space.
    from django.conf import settings into default name space.
    from django.core.exceptions import AppRegistryNotReady into default name space.
    from django.dispatch import receiver into default name space.
    from django.test.signals import setting_changed into default name space.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    from django.utils.encoding import force_text into default name space.
    from django.utils._os import upath into default name space.
    from django.utils.safestring import mark_safe and SafeData into default name space.
    from django.utils import six and lru_cache into default name space.
    from django.utils.six import StringIO into default name space.
    from django.utils.translation import TranslatorCommentWarning, trim_whitespace and LANGUAGE_SESSION_KEY into default name space.
    _translations is an empty dictionary.
    call the function local, substitute the result for _active.
    _default is None.
    _supported is None.
    CONTEXT_SEPARATOR is a string "\x04".
    call the function re.compile with 2 arguments: raw string "([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)(?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))?(?:\s*,\s*|$)",
    and re.VERBOSE, substitute the result for accept_language_re.   call the function re.compile with 2 arguments: raw string '^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$' and re.IGNORECASE,
    substitute the result for language_code_re.   call the function re.compile with an argument raw string '^/([\w-]+)(/|$)', substitute the result for language_code_prefix_re.
    _BROWSERS_DEPRECATED_LOCALES is an dictionary with 2 initial entries: 'zh-hans' for 'zh-cn' and 'zh-hant' for 'zh-tw'.
    substitute _BROWSERS_DEPRECATED_LOCALES for _DJANGO_DEPRECATED_LOCALES.
    decorator function receiver with an argument setting_changed,
    define the function reset_cache with an argument unpacked dictionary kwargs.
    if value under the 'setting' key of the kwargs dictionary is equal to string 'LANGUAGES' or strnig 'LANGUAGE_CODE',
    use global variable _supported.
    _supported is None.
    call the method check_for_language.cache_clear.
    call the method get_supported_language_variant.cache_clear.
    define the function to_locale with 2 arguments language and to_lower set to boolean False.
    find first index of occurrence of character '-' in language, substitute it for p.
    if p is greater or equal to integer 0,
    if to_lower is true,
    convert fist p elements of language to lowercase, append '_' to it,
    covert to lowercase language elements from (p+1)-th index to the end, append it to the previous result, return it.   if not,
    slice language from (p+1)-th index to the end, calculate the length of the obtained segment, if it is greater than integer 2,
    convert fist p elements of language to lowercase, append '_' to it,
    covert to lowercase language element at (p+1)-th index, append it to the previous result,   covert to lowercase language elements from (p+2)-th index to the end, append it to the previous result, return it.   convert fist p elements of language to lowercase, append '_' to it,
    covert to uppercase language elements from (p+1)-th index to the end, append it to the previous result, return it.   if not,
    convert language to lowercase, return it.
    define the function to_language with an argument locale.
    find first index of occurrence of character '-' in locale, substitute it for p.
    if p is greater or equal to integer 0,
    convert fist p elements of locale to lowercase, append '_' to it,
    covert to lowercase locale elements from (p+1)-th index to the end, append it to the previous result, return it.   if not,
    convert locale to lowercase and return it.
    derive the class DjangoTranslation from gettext_module.GNUTranslations base class.
    define the method __init__ with 2 arguments: self and language.
    call the method gettext_module.GNUTranslations.__init__ with an argument self.
    substitute language for self.__language.
    call the function to_language with an argument language, substitute it for self.__to_language.
    call the function to_locale with an argument language, substitute it for self.__locale.
    self.plural is an lambda function with an argument n, which returns result of boolean expression n not equal to integer 1,
    converted to an integer.   call the method self._init_translation_catalog.
    call the method self._add_installed_apps_translations.
    call the method self._add_local_translations.
    call the method self._add_fallback.
    define the method __repr__ with an argument self.
    return a string "<DjangoTranslation lang:%s>", where '%s' is replaced with self.__language.
    define the method _new_gnu_trans with 3 arguments: self, localedir and use_null_fallback set to boolean True.
    call the method gettext_module.translation with 5 arguments: domain set to string 'django', localedir set to localedir,
    languages set to a list with an element self.__locale, codeset set to a string 'utf-8' and fallback set to use_null_fallback,   substitute the result for translation.   if translation has an attribute '_catalog',
    translation._catalog is an empty dictionary.
    translation._info is an empty dictionary.
    return translation.
    define the method _init_translation_catalog with an argument self.
    get the value under the settings.__module__ key of the sys.modules dictionary,
    use its __file__ field as an argument for the call to the function upath, substitute the result for settingsfile.   call the function os.path.dirname with an argument settingsfile, join the result an string 'locale' into a file path,
    substitute it for localedir.   use_null_fallback is boolean True.
    if self.__language equals settings.LANGUAGE_CODE,
    use_null_fallback is boolean False.
    call the function self._new_gnu_trans with 2 arguments: localedir and use_null_fallback, substitute the result for translation.
    call the method translation._info.copy, substitute the result for self._info.
    call the method translation._catalog.copy, substitute the result for self._catalog.
    define the method _add_installed_apps_translations with an argument self.
    try,
    call the method apps.get_app_configs, convert the result in a list, reverse the order of elements, substitute the result for app_configs.
    if AppRegistryNotReady exception is caught,
    rais an AppRegistryNotReady exception with an argument string "The translation infrastructure cannot be initialized before the "
    "apps registry is ready. Check that you don't make non-lazy gettext calls at import time.".   for every app_config in app_configs,
    join app_config.path and string 'locale' into a file path, substitute it for localedir.
    call the method self._new_gnu_trans with an argument localedir, substitute the result for translation.
    call the method self.merge with an argument translation.
    define the method _add_local_translations with an argument self.
    reverse settings.LOCALE_PATHS element order, for every localedir in the result,
    call the function self._new_gnu_trans with an argument localedir, substitute the result for translation.
    call the method self.merge with an argument translation.
    define the method _add_fallback with an argument self.
    if self.__language equals settings.LANGUAGE_CODE or self.__language equals a string "en-us",
    return.
    call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for default_translation.
    call the method self.add_fallback with an argument default_translation.
    define the method merge with 2 arguments self and other.
    update the self._catalog dictionary with other._catalog.
    define the method language with an argument self.
    return self.__language.
    define the method to_language with an argument self.
    return self.__to_language.
    define the function translation with an argument language.
    use global variable _translations.
    if language is not contained in _translations,
    _translations dictionary value, under the language key is an instance of DjangoTranslation class, created with an argument language.
    return _translations dictionary value, under the language key.
    define the function activate with an argument language.
    if language is contained in _DJANGO_DEPRECATED_LOCALES,
    msg is a string "The use of the language code '%s' is deprecated. Please use the '%s' translation instead.".
    call the method call the function warnings.warn with 3 arguments: msg formatted with language and value under the language key,
    of the _DJANGO_DEPRECATED_LOCALES dictionary, RemovedInDjango19Warning and stacklevel set to integer 2.   call the function translation with an argument language, substitute the result for _active.value.
    define the function deactivate.
    if _active has an attribute "value",
    delete _active.value.
    define the function deactivate_all.
    call the method gettext_module.NullTranslations, substitute the result for _active.value.
    define the function get_language.
    get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
    if t is not None,
    try,
    call the method t.to_language, return the result.
    if AttributeError exception is caught,
    do nothing.
    return settings.LANGUAGE_CODE.
    define the function get_language_bidi.
    call the function get_language, split the result by '-', substitute the first element of the result for base_lang.
    if base_lang is contained in settings.LANGUAGES_BIDI, return boolean True, if not, return boolean False.
    define the function catalog.
    use global variable _default.
    get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
    if t is not None
    return t.
    if _default is None
    call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for _default.
    return _default.
    define the function do_translate with 2 arguments: message and translation_function.
    use global variable _default.
    replace every occurrence of string '\r\n' in message with '\n', replace every occurrence of string '\r',
    in the previous result for with string '\n', substitute the result for eol_message.   get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
    if t is not None,
    get translation_function attribute of the object t, call the result with an argument eol_message, substitute the result for result.
    if not,
    if _default is None,
    call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for _default.
    get translation_function attribute of the object _default, call the result with an argument eol_message, substitute the result for result.
    if message is an instance of SafeData,
    call the function mark_safe with an argument result, return it.
    return result.
    define the function gettext with an argument message.
    call the function do_translate with 2 arguments: message and string 'gettext', return the result.
    if six.PY3 is true,
    substitute gettext for ugettext.
    if not,
    define the function ugettext with an argument message.
    call the function do_translate with 2 arguments: message and string 'ugettext', return the result.
    define the function pgettext with 2 arguments: context and message.
    convert to strings and concatenate context, CONTEXT_SEPARATOR and message, substitute the result for msg_with_ctxt.
    call the function ugettext with an argument msg_with_ctxt, substitute the result for result.
    if CONTEXT_SEPARATOR is contained in result,
    call the function force_text with an argument message, return the result.
    return result.
    define the function locale with an argument locale.
    return message.
    define the function do_ntranslate with 4 arguments: singular, plural, number and translation_function.
    use global variable _default.
    get 'value' attribute of the _active object, if it exists substitute it for t, if not t is None.
    if t is not None,
    get translation_function attribute of the t object, call the result with 3 arguments: singular, plural and number, return the result.
    if _default is None,
    call the function translation with an argument settings.LANGUAGE_CODE, substitute the result for _default.
    get translation_function attribute of the _default object, call the result with 3 arguments: singular, plural and number, return the result.
    define the function ngettext with 3 arguments: singular, plural and number.
    call the function do_ntranslate with 3 arguments: singular, plural, number and string 'ngettext', return the result.
    if six.PY3 is true,
    substitute ngettext for ungettext.
    if not,
    define the function ungettext with 3 arguments: singular, plural and number.
    call the function do_ntranslate with 3 arguments: singular, plural, number and string 'ngettext', return the result.
    define the function npgettext with 4 arguments: context, singular, plural and number.
    msgs_with_ctxt is a tuple containing 2 elements: string created by concatenating context, CONTEXT_SEPARATOR and singular,
    string created by concatenating context, CONTEXT_SEPARATOR and plural and number.   call the function ungettext with unpacked dictionary msgs_with_ctxt, substitute the result for result.
    if CONTEXT_SEPARATOR is contained in result,
    call the function ungettext with 3 arguments: singular, plural and number, substitute the result for result.
    return result.
    define the function all_locale_paths.
    get the value under the settings.__module__ key of the sys.modules dictionary, use its __file__ field as an argument,
    for the call to the function upath, get the directory name of the resulting system path, join the result and string 'locale',   into a valid file path, substitute it for globalpath.   append settings.LOCALE_PATHS converted into a list to a list containing an element globalpath, return it.
    decorator function lru_cache.lru_cache with an argument maxsize set to integer 1000.
    define the function check_for_language with an argument lang_code.
    call the method language_code_re.search with an argument lang_code, if it evaluates to false,
    return boolean False.
    call the function all_locale_paths, for every path is the result,
    call the method gettext_module.find with 3 arguments: string 'django', path and list with an element: result of the function,
    to_locale called with an argument lang_code, if the result is not None,   return boolean True.
    return boolean False.
    decorator function lru_cache.lru_cache with an argument maxsize set to integer 1000.
    define the function get_supported_language_variant with 2 arguments: lang_code and strict set to boolean False.
    use global variable _supported.
    if _supported is None,
    _supported is an instance of OrderedDict class, created with an argument settings.LANGUAGES.
    if lang_code is true,
    get the value under the lang_code key of the _BROWSERS_DEPRECATED_LOCALES dictionary, substitute it for replacement.
    if lang_code is not contained in _supported and replacement is contained in _supported,
    return replacement.
    split lang_code by '-', substitute the first element of the result for generic_lang_code.
    for every code in tuple with 2 elements: lang_code and generic_lang_code,
    if code is contained in _supported and call to the function check_for_language with an argument code evaluates to true,
    return code.
    if strict is false,
    for every supported_code in _supported,
    append '-' to generic_lang_code, if supported_code starts with it,
    return supported_code.
    raise an LookupError with an argument lang_code.
    define the function get_language_from_path with 2 arguments: path and strict set to boolean False.
    call the function language_code_prefix_re.match with an argument path, substitute it for regex_match.
    if regex_match is false,
    return None.
    call the method regex_match.group with an argument integer 1, substitute the result for lang_code.
    try,
    call the function get_supported_language_variant with 2 arguments: lang_code and strict set to strict, return the result.
    if LookupError exception is caught,
    return None.
    define the function get_language_from_request with 2 arguments: request and check_path set to boolean False.
    use global variable _supported.
    if _supported is None,
    _supported is an instance of OrderedDict class, created with an argument settings.LANGUAGES.
    if check_path is true,
    call the function get_language_from_path with an argument request.path_info, substitute it for lang_code.
    if lang_code is not None,
    return lang_code.
    if request has an attribute 'session',
    get the value under the LANGUAGE_SESSION_KEY key of the request.session dictionary, substitute it for lang_code.
    if lang_code is contained in _supported and lang_code is not None and result of the function check_for_language,
    called with an argument lang_code is true,   return lang_code.
    get the value under the settings.LANGUAGE_COOKIE_NAME key of the request.COOKIES dictionary, substitute it for lang_code.
    try,
    call the function get_supported_language_variant with an argument lang_code, return the result.
    if LookupError exception is caught,
    do nothing.
    get the value under the 'HTTP_ACCEPT_LANGUAGE' key of the request.META dictionary, if it exists substitute it for accept,
    if not accept is an empty string.   call the function parse_accept_lang_header with an argument accept, for every accept_lang and unused in the result,
    if accept_lang equals '*',
    break from the loop execution.
    call the method language_code_re.search with an argument accept_lang, if it evaluates to false,
    skip this loop iteration.
    try,
    call the function get_supported_language_variant with an argument accept_lang, return the result.
    if LookupError exception is caught,
    skip this loop iteration.
    try,
    call the function get_supported_language_variant with an argument settings.LANGUAGE_CODE, return the result.
    if LookupError exception is caught,
    return settings.LANGUAGE_CODE.
    call the function re.compile with an argument raw string '\S', substitute it for dot_re.
    define the function blankout with 2 arguments: src and char.
    call the method dot_re.sub with 2 arguments: char and src, return the result.
    call the function re.compile with an argument raw string "^\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?'))\s*", substitute the result for context_re.
    call the function re.compile with an argument string "^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))(\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?')))?\s*", substitute the result for inline_re.
    call the function re.compile with an argument raw string "^\s*blocktrans(\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?')))?(?:\s+|$)",
    substitute the result for block_re.   call the function re.compile with an argument raw string "^\s*endblocktrans$", substitute the result for endblock_re.
    call the function re.compile with an argument raw string "^\s*plural$", substitute the result for plural_re.
    call the function re.compile with an argument raw string "_\(((?:".*?")|(?:'.*?'))\)", substitute the result for constant_re.
    call the function re.compile with an argument raw string "(?<!%)%(?!%)", substitute the result for one_percent_re.
    define the function templatize with 2 arguments: src and origin set to None.
    from django.template import Lexer, TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK, TOKEN_COMMENT and TRANSLATOR_COMMENT_MARK.
    call the function force_text with 2 arguments: src and settings.FILE_CHARSET.
    out is an instance of StringIO class, created with an empty string as an argument.
    message_context is None.
    intrans is boolean False.
    inplural is boolean False.
    trimmed is boolean False.
    singular is an empty list.
    plural is an empty list.
    incomment is boolean False.
    comment is an empty list.
    lineno_comment_map is an dictionary.
    comment_lineno_cache is None.
    define the function join_tokens with 2 arguments: tokens and trim set to boolean False.
    join tokens elements into a string, substitute it for message.
    if trim is true,
    call the function trim_whitespace with an argument message, substitute the result for message.
    return message.
    instantiate Lexer class with 2 argumets src and origin, call the method tokenize from it, for every t in the result,
    if incomment is true,
    if t.token_type equals TOKEN_BLOCK and t.contents equals 'endcomment',
    join comment elements into a string, substitute it for content.
    translators_comment_start is None.
    for every lineno and line is enumerated result of the method content.splitlines, called with an argument boolean True,
    call the method line.lstrip, if the result starts with TRANSLATOR_COMMENT_MARK,
    substitute lineno for translators_comment_start.
    for every lineno and line is enumerated result of the method content.splitlines, called with an argument boolean True,
    if translators_comment_start is not None and lineno is greater than or equal to translators_comment_start,
    substitute '%s' in string ' # %s' with line, write it to out file.
    if not,
    write string ' #\n' to out file.
    incomment is boolean False.
    comment is an empty list.
    if not,
    append t.contents to comment.
    otherwise if intrans is true,
    if t.token_type equals TOKEN_BLOCK,
    call the function endblock_re.match with an argument t.contents, substitute the result for endbmatch.
    call the function plural_re.match with an argument t.contents, substitute the result for pluralmatch.
    if endbmatch is true,
    if inplural is true,
    if message_context is true,
    substitute '%r' in string ' npgettext(%r, %r, %r,count) ' with message_context, result of the function join_tokens,
    called with 2 arguments: singular and trimmed and result of the function join_tokens called with 2 arguments: plural and trimmed,   write the result to out.   if not,
    substitute '%r' in string ' ngettext(%r, %r, count) ' with result of the function join_tokens, called with 2 arguments: singular,
    and trimmed and result of the function join_tokens called with 2 arguments: plural and trimmed, write the result to out.   for every part in singular,
    call the method blankout with 2 arguments: part and 'S', write the result to out.
    for every part in plural,
    call the method blankout with 2 arguments: part and 'P', write the result to out.
    if not,
    if message_context is true,
    substitute '%r' in string ' pgettext(%r, %r) ' with message_context and result of the function join_tokens,
    called with 2 arguments: singular and trimmed, write the result to out.   if not,
    substitute '%r' in string ' gettext(%r) ' with  result of the function join_tokens, called with 2 arguments: singular,
    and trimmed, write the result to out.   for every part in singular,
    call the method blankout with 2 arguments: part and 'S', write the result to out.
    message_context is None.
    intrans is boolean False.
    inplural is boolean False.
    singular is an empty list.
    plural is an empty list.
    otherwise if pluralmatch is true,
    inplural is boolean True.
    if not,
    filemsg is an empty string.
    if origin is true,
    filemsg is a string 'file %s, ', where '%s' is replaced with origin.
    raise an SyntaxError with an argument string "Translation blocks must not include other block tags: %s (%sline %d)",
    formated with t.contents, filemsg and t.lineno.   otherwise if t.token_type equals TOKEN_VAR,
    if inplural is true,
    append string '%%(%s)s' to plural, where '%s' is replaced with t.contents.
    if not,
    append string '%%(%s)s' to singular, where '%s' is replaced with t.contents.
    if t.token_type == TOKEN_TEXT:
    call the method one_percent_re.sub with 2 arguments: string '%%' and t.contents, substitute the result for contents.
    if inplural is true,
    append contents to plural.
    if not,
    append contents to singular.
    if not,
    if comment_lineno_cache is not None,
    count occurrences of '\n' in t.contents, add the result to t.lineno, substitute the result for cur_lineno.
    if comment_lineno_cache equals cur_lineno.
    if t.token_type is not equal to TOKEN_COMMENT,
    for every c in lineno_comment_map dictionary value under the comment_lineno_cache key,
    filemsg is an empty string.
    if origin is true,
    filemsg is a string 'file %s, ', where '%s' is replaced with origin.
    warn_msg is a string "The translator-targeted comment '%s' (%sline %d) was ignored, because it wasn't the last item on the line.",
    formated with c, filemsg and comment_lineno_cache.   call the function warnings.warn with 2 arguments: warn_msg and TranslatorCommentWarning.
    value under the comment_lineno_cache key of the lineno_comment_map dictionary is an empty string.
    if not,
    join lineno_comment_map dictionary value under the comment_lineno_cache key into a string, separated with ' | ',
    format with it a string '# %s', write it to out.   comment_lineno_cache is None,
    if t.token_type equals TOKEN_BLOCK,
    call the function inline_re.match with an argument t.contents, substitute the result for imatch.
    call the function block_re.match with an argument t.contents, substitute the result for bmatch.
    call the function constant_re.findall with an argument t.contents, substitute the result for cmatches.
    if imatch is true,
    call the method imatch.group with an argument integer 1, substitute the result for g.
    if first element of g equals a string '"',
    strip g of '"' from both ends,
    otherwise if first element of g equals a string "'",
    strip g of "'" from both ends,
    call the method one_percent_re.sub with 2 arguments: string '%%' and g, substitute the result for .
    call the method imatch.group with an argument integer 1, if it evaluates to true,
    call the method imatch.group with an argument integer 2, use the result as an argument for the call to the method context_re.match,
    substitute the result for context_match.   call the method context_match.group with an argument integer 1, substitute the result for message_context.
    if first element of message_context equals to character '"',
    strip message_context of '"' characters from both ends, substitute the result for message_context.
    otherwise if, first element of message_context is equal to "'",
    strip message_context of "'" characters from both ends, substitute the result for message_context.
    format string ' pgettext(%r, %r) ' with message_context and g, write it to out.
    message_context is None.
    if not,
    format string ' gettext(%r) ' with g, write it to out.
    otherwise if bmatch is true,
    call the method constant_re.findall with an argument t.contents, for every fmatch in the result,
    format string ' _(%s) ', with fmatch, write it to out.
    call the method bmatch.group with an argument integer 1, if it evaluates to true,
    call the method bmatch.group with an argument integer 1, use the result as an argument for the call to the function context_re.match,
    substitute the result for context_match.   call the method context_match.group with an argument integer 1, substitute the result for message_context.
    if first element of message_context equals to character '"',
    strip message_context of '"' characters from both ends, substitute the result for message_context.
    otherwise if first element of message_context equals to character "'",
    strip message_context of "'" characters from both ends, substitute the result for message_context.
    intrans is boolean True.
    inplural is boolean False.
    if string 'trimmed' is contained in result of the method t.split_contents, trimmed is boolean True, otherwise is boolean False.
    singular is an empty list.
    plural is an empty list.
    otherwise if cmatches is true,
    for every cmatch in cmatches,
    format string ' _(%s) ', with fmatch, write it to out.
    otherwise if t.contents equals a string 'comment',
    incomment is boolean True.
    if not,
    call the function blankout with 2 arguments: t.contents and 'B', write the result to out.
    otherwise if t.token_type equals TOKEN_VAR,
    split t.contents by '|' symbol, substitute the result for parts,
    call the method constant_re.match with first element of parts as an argument, substitute the result for cmatch.
    if cmatch is true,
    call the method cmatch.group with an argument integer 1, format with the result string ' _(%s) ', write it to out.
    for every p in parts without the first element,
    find index of the occurrence of string ':_(' in p, if its greater or equal to integer 0,
    split p into two parts at the first ':', use the second element of the result to format string ' _(%s) ', write it to out.
    if not,
    call the function blankout with 2 arguments: p and 'F', write the result to out.
    otherwise if t.token_type equals TOKEN_COMMENT,
    strip t.contents from the left side of whitespaces, if the result starts with TRANSLATOR_COMMENT_MARK,
    call the method lineno_comment_map.setdefault with 2 arguments: t.lineno and an empty list, append t.contents to the result.
    substitute t.lineno for comment_lineno_cache.
    if not,
    call the function blankout with 2 arguments: t.contents and 'X', write the result to out.
    call the method out.getvalue, return the result.
    define the function parse_accept_lang_header with an argument lang_string.
    result is an empty list.
    convert lang_string to lowercase, split by the result string accept_language_re, substitute the result for pieces.
    if last element of pieces is true,
    return an empty list.
    for every i in range of integers from integer 0 to the length of pieces decremented by one, with step of integer 3,
    substitute 3 successive elements starting from the i-th index of pieces for first, lang and priority, respectively.
    if first is true,
    return an empty list.
    if priority is true,
    try,
    convert priority into a floating point integer, substitute it for priority.
    if ValueError exception is caught,
    return an empty list.
    if priority is false,
    priority is floating point number 1.0.
    append a tuple with 2 entries lang and priority to result.
    sort result in reversed order by the key as lambda function with an argument k and reeturn value second element of k.
    return result.
    import module copy.
    derive the class Node from object base class.
    default is a string 'DEFAULT'.
    define the method __init__ with 4 arguments: self, children set to None, connector set to None and negated set to boolean False.
    if children is true, copy children list to self.children, otherwise self.children is an empty list.
    if connector is true, substitute it for self.connector, otherwise substitute self.default for self.connector.
    substitute negated for self.negated.
    decorator classmethod,
    define the method _new_instance with 4 arguments: (cls, children set to None, connector set to None and negated set to boolean False.
    obj is an instance of Node class, created with 3 arguments: children, connector and negated.
    substitute cls for obj.__class__.
    return obj.
    define the method __str__ with an argument self.
    if self.negated,
    return string '(NOT (%s: %s))', formated with self.connector and string created by joining c into a string, separated by ', ',
    for every c in self.children.   return string '(%s: %s)', formated with self.connector and string created by joining c into a string, separated by ', ',
    for every c in self.children.   define the method __repr__ with an argument self.
    return string "<%s: %s>", formated with self.__class__.__name__ and self.
    define the method __deepcopy__ with 2 arguments: self and memodict.
    obj is an instance of Node class, created with 2 arguments: connector set to self.connector and negated set to self.negated.
    substitute self.__class__ for obj.__class__.
    call the function copy.deepcopy with 2 arguments: self.children and memodict, substitute the result for obj.children.
    return obj.
    define the method __len__ with an argument self.
    return the length of self.children.
    define the method __bool__ with an argument self.
    convert self.children into an boolean, return it.
    define the method __nonzero__ with an argument self.
    get the type of the self object, on the result call the __bool__ method with an argument self, return the result.
    define the method __contains__ with 2 arguments: self and other.
    if other is contained in self.children, return boolean True, otherwise return boolean False.
    define the method _prepare_data with 2 arguments: self and data.
    return data.
    define the method add with 4 arguments: self, data, conn_type and squash set to boolean True.
    if data is contained in self.children,
    return data.
    call the method self._prepare_data with an argument data, substitute the result for data.
    if squash is false,
    append data to self.children.
    return data.
    if self.connector equals conn_type,
    if data is instance of Node and data.negated is false, and if data.connector equals conn_type or length of data equals integer 1,
    extend self.children list with data.children.
    return self.
    if not,
    append data to self.children.
    return data.
    if not,
    call the method self._new_instance with 3 arguments: self.children, self.connector and self.negated, substitute the result for obj.
    substitute conn_type for self.connector.
    self.children is an list with 2 elements: obj and data.
    return data.
    define the method negate with an argument self.
    invert self.negated.
    from __future__ import unicode_literals into default name space.
    from datetime import timedelta and tzinfo into default name space.
    import module time.
    import module warnings.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    from django.utils.encoding import force_str,  force_text and DEFAULT_LOCALE_ENCODING into default name space.
    call the function warnings.warn with 3 arguments: string "django.utils.tzinfo will be removed in Django 1.9. "
    "Use django.utils.timezone instead.", RemovedInDjango19Warning and stacklevel set to 2.   derive the class FixedOffset from the tzinfo base class.
    define the method __init__ with 2 arguments: self and offset.
    call the function warnings.warn with 2 arguments: "django.utils.tzinfo.FixedOffset will be removed in Django 1.9. "
    "Use django.utils.timezone.get_fixed_timezone instead." and RemovedInDjango19Warning.   if offset is an instance of timedelta class,
    substitute offset for self.__offset.
    substitute self.__offset.seconds for offset.
    if not,
    call the function timedelta with an argument minutes set to offset, substitute the result for self.__offset.
    if offset is lesser than integer 0, sign is set to '-', otherwise sign is '+',
    self.__name is a string "%s%02d%02d", replace '%s' with sign, '%02d' is replaced with absolute value of offset divided by 60,
    and placed into 2 character spaces, and '%02d' is replaced with reminder of the division of absolute offset by integer 60,   and placed into 2 character spaces.   define the method __repr__ with an argument self.
    return self.__name.
    define the method __getinitargs__ with an argument self.
    return a tuple with an element self.__offset.
    define the method utcoffset with 2 arguments self and dt.
    return self.__offset.
    define the method tzname with 2 arguments self and dt.
    return self.__name.
    define the method dst with 2 arguments self and dt.
    call the function timedelta with an argument integer 0, return the result.
    derive the class LocalTimezone from the tzinfo base class.
    define the method __init__ with 2 arguments self and dt.
    call the function warnings.warn with 2 arguments: string "django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. "
    "Use django.utils.timezone.get_default_timezone instead." and RemovedInDjango19Warning.   call the method tzinfo.__init__ with an argument self.
    substitute dt for self.__dt.
    call the method self.tzname with an argument dt, substitute the result for self._tzname.
    define the method __repr__ with an argument self.
    call the function force_str with an argument self._tzname, return the result.
    define the method __getinitargs__ with an argument self.
    return a tuple with an element self.__dt.
    define the method utcoffset with 2 arguments self and dt.
    call the nethod self._isdst with an argument dt, if it evaluates to true,
    call the function timedelta with an argument seconds as negative time.altzone, return the result.
    if not,
    call the function timedelta with an argument seconds as negative time.timezone, return the result.
    define the method dst with 2 arguments self and dt.
    call the nethod self._isdst with an argument dt, if it evaluates to true,
    call the function timedelta with an argument seconds as negative time.timezone, subtract the result from the result of the call,
    to the function timedelta called with an argument seconds as negative time.altzone, return the result.   if not,
    call the function timedelta with an argument integer 0, return the result.
    define the method tzname with 2 arguments self and dt.
    if dt is None is_dst is boolean False, otherwise call the method self._isdst with an argument dt, substitute the result for is_dst.
    try,
    call the function force_text with 2 arguments: value under the is_dst key of the time.tzname and DEFAULT_LOCALE_ENCODING,
    return the result.   if UnicodeDecodeError exception is caught,
    return None.
    define the method _isdst with 2 arguments self and dt.
    tt is an tuple with 9 elements: dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, result of the function dt.weekday,
    integer 0 and integer 0.   try,
    call the method time.mktime with an argument tt, substitute the result for stamp.
    if OverflowError or ValueError exceptions are caught,
    create a tuple out a tuple with an element integer 2037 and a list tt elements without the first element, substitute the result for tt.
    call the method time.mktime with an argument tt, substitute the result for stamp.
    call the method time.localtime with an argument stamp, substitute the result for tt.
    if tt.tm_isdst is greater than intger 0, return boolean True, otherwise return boolean False.
    from __future__ import absolute_import into default name space.
    import module warnings.
    from django.utils.deprecation import RemovedInDjango19Warning into default name space.
    call the function warnings.warn with 3 arguments: string "django.utils.unittest will be removed in Django 1.9.",
    RemovedInDjango19Warning and stacklevel as integer 2.   try,
    from unittest2 import everything.
    if ImportError exception is caught,
    from unittest import import everything.
    from __future__ import unicode_literals into default name space.
    import module datetime.
    import module os.
    import module subprocess.
    define the function get_version with version set to None as argument.
    call the get_complete_version function with version as argument, store the result in version.
    call the get_major_version wit version as argument, store the result in major.
    sub is an empty string.
    if fourth element of version equals to string 'alpha' and fight element of version equals to integer 0,
    call the function get_git_changeset, store the result in git_changeset.
    if git_changeset is true,
    convert git_changeset to string, append it to the string '.dev', replace it for sub.
    otherwise if fourth element of version does not equals to 'final',
    mapping is a dictionary with 3 initial entries: 'a' for 'alpha', 'b' for 'beta' and 'c' for 'rc'.
    use fourth element of version as a key to get the value from mapping dictionary, append to it fourth element of version converted to string, substitute it for sub.
    sum major and sub, return the result converted to string.
    define the function get_major_version with an argument version defaulting to None.
    call the get_complete_version with an argument version, store the result in version.
    assign integer 2 to parts if third element of version equals to zero, otherwise assign it integer 3.
    convert x into a string for every x in list of version elements up to the parts index, join the previous into a string separated by '.', assign the result to major.
    return major.
    define the function get_complete_version with in argument version, defaulting to None.
    if version is None,
    from django import VERSION as version into default name space.
    if not,
    if length of version does not equals to integer 5, raise an exception.
    if fourth element of version does not equals to string 'alpha' or 'beta' or 'rc' or 'final', raise an exception.
    return version
    define the function get_git_changeset.
    if get_git_changeset has an attribute 'cache',
    return get_git_changeset.cache.
    get the absolute path of the __file__, repo_dir is name of the directory two leveles above it.
    call the subprocess.Popen function with, 'git log --pretty=format:%ct --quiet -1 HEAD', stdout set to subprocess.PIPE,
    stderr set to subprocess.PIPE, shell set to boolean True, cwd set to repo_dir and universal_newlines set to boolean True,   as arguments, substitute the result for git_log.   evaluate the method git_log.communicate, substitute first element of the result for timestamp.
    try
    call the datetime.datetime.utcfromtimestamp with timestamp converted to an integer as argument, substitute result for timestamp.
    if ValueError exception is caught,
    changeset is None.
    if not,
    call the timestamp.strftime with string '%Y%m%d%H%M%S' as an argument, substitute the result for changeset.
    substitute changeset for get_git_changeset.cache.
    return changeset.
    from xml.sax.saxutils import XMLGenerator into default name space.
    derive the class SimplerXMLGenerator form the XMLGenerator base class.
    define the method addQuickElement with 4 arguments: self, name, contents set to None and attrs set to None.
    if attrs is None,
    attrs is an empty dictionary.
    cal the method self.startElement with 2 arguments: name and attrs.
    if contents is not None,
    call the method self.characters with an argument contents.
    call the method self.endElement with an argument name.
