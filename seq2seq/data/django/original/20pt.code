                       try :
                          self . configure_root ( root , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
    else :
                  disable_existing = config . pop ( 'disable_existing_loggers' , True )
  logging . _handlers . clear ( )
 del logging . _handlerList [ : ]
   formatters = config . get ( 'formatters' , EMPTY_DICT )
 for name in formatters :
                      try :
                          formatters [ name ] = self . configure_formatter (  formatters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )
    filters = config . get ( 'filters' , EMPTY_DICT )
 for name in filters :
                      try :
                          filters [ name ] = self . configure_filter ( filters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )
       handlers = config . get ( 'handlers' , EMPTY_DICT )
 for name in sorted ( handlers ) :
                      try :
                          handler = self . configure_handler ( handlers [ name ] )
 handler . name = name
 handlers [ name ] = handler
  except StandardError as e :
                          raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
             root = logging . root
 existing = list ( root . manager . loggerDict )
     existing . sort ( )
   child_loggers = [ ]
  loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      if name in existing :
                          i = existing . index ( name )
 prefixed = name + "."
 pflen = len ( prefixed )
 num_existing = len ( existing )
 i = i + 1
 while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :
                              child_loggers . append ( existing [ i ] )
 i = i + 1
  existing . remove ( name )
  try :
                          self . configure_logger ( name , loggers [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
         for log in existing :
                      logger = root . manager . loggerDict [ log ]
 if log in child_loggers :
                          logger . level = logging . NOTSET
 logger . handlers = [ ]
 logger . propagate = True
  elif disable_existing :
                          logger . disabled = True
     root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
     finally :
              logging . _releaseLock ( )
    def configure_formatter ( self , config ) :
 if '()' in config :
              factory = config [ '()' ]
 try :
                  result = self . configure_custom ( config )
  except TypeError as te :
                  if "'format'" not in str ( te ) :
                      raise
      config [ 'fmt' ] = config . pop ( 'format' )
 config [ '()' ] = factory
 result = self . configure_custom ( config )
   else :
              fmt = config . get ( 'format' , None )
 dfmt = config . get ( 'datefmt' , None )
 result = logging . Formatter ( fmt , dfmt )
  return result
   def configure_filter ( self , config ) :
 if '()' in config :
              result = self . configure_custom ( config )
  else :
              name = config . get ( 'name' , '' )
 result = logging . Filter ( name )
  return result
   def add_filters ( self , filterer , filters ) :
 for f in filters :
              try :
                  filterer . addFilter ( self . config [ 'filters' ] [ f ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )
     def configure_handler ( self , config ) :
 formatter = config . pop ( 'formatter' , None )
 if formatter :
              try :
                  formatter = self . config [ 'formatters' ] [ formatter ]
  except StandardError as e :
                  raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
   level = config . pop ( 'level' , None )
 filters = config . pop ( 'filters' , None )
 if '()' in config :
              c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
                  c = self . resolve ( c )
  factory = c
  else :
              klass = self . resolve ( config . pop ( 'class' ) )
  if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
                  try :
                      config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
  except StandardError as e :
                      raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
   elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
                  config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
  elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
                  config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
  factory = klass
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 try :
              result = factory ( ** kwargs )
  except TypeError as te :
              if "'stream'" not in str ( te ) :
                  raise
      kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
 result = factory ( ** kwargs )
  if formatter :
              result . setFormatter ( formatter )
  if level is not None :
              result . setLevel ( _checkLevel ( level ) )
  if filters :
              self . add_filters ( result , filters )
  return result
   def add_handlers ( self , logger , handlers ) :
 for h in handlers :
              try :
                  logger . addHandler ( self . config [ 'handlers' ] [ h ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
     def common_logger_config ( self , logger , config , incremental = False ) :
 level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
              return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
   if strings_only and is_protected_type ( s ) :
          return s
  if isinstance ( s , six . memoryview ) :
          return bytes ( s )
  if isinstance ( s , Promise ) :
          return six . text_type ( s ) . encode ( encoding , errors )
  if not isinstance ( s , six . string_types ) :
          try :
              if six . PY3 :
                  return six . text_type ( s ) . encode ( encoding )
  else :
                  return bytes ( s )
   except UnicodeEncodeError :
              if isinstance ( s , Exception ) :
                     return b' ' . join ( [ force_bytes ( arg , encoding , strings_only ,  errors ) for arg in s ] )
  return six . text_type ( s ) . encode ( encoding , errors )
   else :
          return s . encode ( encoding , errors )
    if six . PY3 :
      smart_str = smart_text
 force_str = force_text
  else :
      smart_str = smart_bytes
 force_str = force_bytes
  smart_unicode = smart_text
 force_unicode = force_text
   def iri_to_uri ( iri ) :
             if iri is None :
          return iri
  return quote ( force_bytes ( iri ) , safe = b"/#%[]=:;$&()+,!?*@'~" )
    def filepath_to_uri ( path ) :
 if path is None :
          return path
    return quote ( force_bytes ( path ) . replace ( b"\\" , b"/" ) , safe = b"/~!*()'" )
    def get_system_encoding ( ) :
 try :
          encoding = locale . getdefaultlocale ( ) [ 1 ] or 'ascii'
 codecs . lookup ( encoding )
  except Exception :
          encoding = 'ascii'
  return encoding
   DEFAULT_LOCALE_ENCODING = get_system_encoding ( )
 from __future__ import unicode_literals
  import datetime
 from django . utils . xmlutils import SimplerXMLGenerator
 from django . utils . encoding import force_text , iri_to_uri
 from django . utils import datetime_safe
 from django . utils import six
 from django . utils . six import StringIO
 from django . utils . six . moves . urllib . parse import urlparse
 from django . utils . timezone import is_aware
   def rfc2822_date ( date ) :
        months = ( 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' , )
 days = ( 'Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun' )
  date = datetime_safe . new_datetime ( date )
  dow = days [ date . weekday ( ) ]
 month = months [ date . month - 1 ]
 time_str = date . strftime ( '%s, %%d %s %%Y %%H:%%M:%%S ' % ( dow , month ) )
 if six . PY2 :
          time_str = time_str . decode ( 'utf-8' )
  if is_aware ( date ) :
          offset = date . tzinfo . utcoffset ( date )
 timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
 hour , minute = divmod ( timezone , 60 )
 return time_str + '%+03d%02d' % ( hour , minute )
  else :
          return time_str + '-0000'
     def rfc3339_date ( date ) :
       date = datetime_safe . new_datetime ( date )
 time_str = date . strftime ( '%Y-%m-%dT%H:%M:%S' )
 if six . PY2 :
          time_str = time_str . decode ( 'utf-8' )
  if is_aware ( date ) :
          offset = date . tzinfo . utcoffset ( date )
 timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
 hour , minute = divmod ( timezone , 60 )
 return time_str + '%+03d:%02d' % ( hour , minute )
  else :
          return time_str + 'Z'
     def get_tag_uri ( url , date ) :
 bits = urlparse ( url )
 d = ''
 if date is not None :
          d = ',%s' % datetime_safe . new_datetime ( date ) . strftime ( '%Y-%m-%d' )
  return 'tag:%s%s:%s/%s' % ( bits . hostname , d , bits . path , bits . fragment )
    class SyndicationFeed ( object ) :
 def __init__ ( self , title , link , description , language = None , author_email = None ,  author_name = None , author_link = None , subtitle = None , categories = None ,  feed_url = None , feed_copyright = None , feed_guid = None , ttl = None , ** kwargs ) :
          to_unicode = lambda s : force_text ( s , strings_only = True )
 if categories :
              categories = [ force_text ( c ) for c in categories ]
  if ttl is not None :
               ttl = force_text ( ttl )
  self . feed = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'language' : to_unicode ( language ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'subtitle' : to_unicode ( subtitle ) ,  'categories' : categories or ( ) ,  'feed_url' : iri_to_uri ( feed_url ) ,  'feed_copyright' : to_unicode ( feed_copyright ) ,  'id' : feed_guid or link ,  'ttl' : ttl ,  }
  self . feed . update ( kwargs )
 self . items = [ ]
   def add_item ( self , title , link , description , author_email = None ,  author_name = None , author_link = None , pubdate = None , comments = None ,  unique_id = None , unique_id_is_permalink = None , enclosure = None ,  categories = ( ) , item_copyright = None , ttl = None , updateddate = None , ** kwargs ) :
 to_unicode = lambda s : force_text ( s , strings_only = True )
 if categories :
              categories = [ ( c ) for c in categories ]
  if ttl is not None :
               ttl = force_text ( ttl )
  item = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'pubdate' : pubdate ,  'updateddate' : updateddate ,  'comments' : to_unicode ( comments ) ,  'unique_id' : to_unicode ( unique_id ) ,  'unique_id_is_permalink' : unique_id_is_permalink ,  'enclosure' : enclosure ,  'categories' : categories or ( ) ,  'item_copyright' : to_unicode ( item_copyright ) ,  'ttl' : ttl ,  }
 item . update ( kwargs )
 self . items . append ( item )
   def num_items ( self ) :
          return len ( self . items )
   def root_attributes ( self ) :
 return { }
   def add_root_elements ( self , handler ) :
 pass
   def item_attributes ( self , item ) :
 return { }
   def add_item_elements ( self , handler , item ) :
 pass
   def write ( self , outfile , encoding ) :
 raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
   def writeString ( self , encoding ) :
 s = StringIO ( )
 self . write ( s , encoding )
 return s . getvalue ( )
   def latest_post_date ( self ) :
 latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
      return latest_date or datetime . datetime . now ( )
     class Enclosure ( object ) :
 def __init__ ( self , url , length , mime_type ) :
 self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . time ) :
          format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  return value
    def sanitize_separators ( value ) :
 if settings . USE_L10N and isinstance ( value , six . string_types ) :
          parts = [ ]
 decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )
 if decimal_separator in value :
              value , decimals = value . split ( decimal_separator , 1 )
 parts . append ( decimals )
  if settings . USE_THOUSAND_SEPARATOR :
              thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )
 for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :
                  value = value . replace ( replacement , '' )
   parts . append ( value )
 value = '.' . join ( reversed ( parts ) )
  return value
import copy
 import operator
 from functools import wraps
 import sys
 import warnings
  from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . six . moves import copyreg
      def curry ( _curried_func , * args , ** kwargs ) :
      def _curried ( * moreargs , ** morekwargs ) :
          return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
  return _curried
    def memoize ( func , cache , num_args ) :
 warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
  @ wraps ( func )
 def wrapper ( * args ) :
          mem_args = args [ : num_args ]
 if mem_args in cache :
              return cache [ mem_args ]
  result = func ( * args )
 cache [ mem_args ] = result
 return result
  return wrapper
    class cached_property ( object ) :
 def __init__ ( self , func , name = None ) :
          self . func = func
 self . name = name or func . __name__
   def __get__ ( self , instance , type = None ) :
          if instance is None :
              return self
  res = instance . __dict__ [ self . name ] = self . func ( instance )
 return res
     class Promise ( object ) :
 pass
    def lazy ( func , * resultclasses ) :
  @ total_ordering
 class __proxy__ ( Promise ) :
 __dispatch = None
  def __init__ ( self , args , kw ) :
              self . __args = args
 self . __kw = kw
 if self . __dispatch is None :
                  self . __prepare_class__ ( )
    def __reduce__ ( self ) :
              return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
   @ classmethod
 def __prepare_class__ ( cls ) :
              cls . __dispatch = { }
 for resultclass in resultclasses :
                  cls . __dispatch [ resultclass ] = { }
 for type_ in reversed ( resultclass . mro ( ) ) :
                      for ( k , v ) in type_ . __dict__ . items ( ) :
                             meth = cls . __promise__ ( resultclass , k , v )
 if hasattr ( cls , k ) :
                              continue
  setattr ( cls , k , meth )
    cls . _delegate_bytes = bytes in resultclasses
 cls . _delegate_text = six . text_type in resultclasses
 assert not ( cls . _delegate_bytes and cls . _delegate_text ) , "Cannot call lazy() with both bytes and text return types."
 if cls . _delegate_text :
                  if six . PY3 :
                      cls . __str__ = cls . __text_cast
  else :
                      cls . __unicode__ = cls . __text_cast
   elif cls . _delegate_bytes :
                  if six . PY3 :
                      cls . __bytes__ = cls . __bytes_cast
  else :
                      cls . __str__ = cls . __bytes_cast
     @ classmethod
 def __promise__ ( cls , klass , funcname , method ) :
                def __wrapper__ ( self , * args , ** kw ) :
                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
                          return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
   raise TypeError ( "Lazy object returned unexpected type." )
   if klass not in cls . __dispatch :
                  cls . __dispatch [ klass ] = { }
  cls . __dispatch [ klass ] [ funcname ] = method
 return __wrapper__
   def __text_cast ( self ) :
              return func ( * self . __args , ** self . __kw )
   def __bytes_cast ( self ) :
              return bytes ( func ( * self . __args , ** self . __kw ) )
   def __cast ( self ) :
              if self . _delegate_bytes :
                  return self . __bytes_cast ( )
  elif self . _delegate_text :
                  return self . __text_cast ( )
  else :
                  return func ( * self . __args , ** self . __kw )
    def __ne__ ( self , other ) :
              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
  return self . __cast ( ) != other
   def __eq__ ( self , other ) :
              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
  return self . __cast ( ) == other
   def __lt__ ( self , other ) :
              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
  return self . __cast ( ) < other
   def __hash__ ( self ) :
              return hash ( self . __cast ( ) )
   def __mod__ ( self , rhs ) :
              if self . _delegate_bytes and six . PY2 :
                  return bytes ( self ) % rhs
  elif self . _delegate_text :
                  return six . text_type ( self ) % rhs
  return self . __cast ( ) % rhs
   def __deepcopy__ ( self , memo ) :
                 memo [ id ( self ) ] = self
 return self
    @ wraps ( func )
 def __wrapper__ ( * args , ** kw ) :
           return __proxy__ ( args , kw )
   return __wrapper__
    def _lazy_proxy_unpickle ( func , args , kwargs , * resultclasses ) :
      return lazy ( func , * resultclasses ) ( * args , ** kwargs )
    def allow_lazy ( func , * resultclasses ) :
 @ wraps ( func )
 def wrapper ( * args , ** kwargs ) :
          for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :
              if isinstance ( arg , Promise ) :
                  break
   else :
              return func ( * args , ** kwargs )
  return lazy ( func , * resultclasses ) ( * args , ** kwargs )
  return wrapper
   empty = object ( )
   def new_method_proxy ( func ) :
      def inner ( self , * args ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return func ( self . _wrapped , * args )
  return inner
    class LazyObject ( object ) :
   _wrapped = None
  def __init__ ( self ) :
          self . _wrapped = empty
   __getattr__ = new_method_proxy ( getattr )
  def __setattr__ ( self , name , value ) :
          if name == "_wrapped" :
               self . __dict__ [ "_wrapped" ] = value
  else :
              if self . _wrapped is empty :
                  self . _setup ( )
  setattr ( self . _wrapped , name , value )
    def __delattr__ ( self , name ) :
          if name == "_wrapped" :
              raise TypeError ( "can't delete _wrapped." )
  if self . _wrapped is empty :
              self . _setup ( )
  delattr ( self . _wrapped , name )
   def _setup ( self ) :
 raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )
        def __getstate__ ( self ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return self . _wrapped . __dict__
     @ classmethod
 def __newobj__ ( cls , * args ) :
          return cls . __new__ ( cls , * args )
   def __reduce_ex__ ( self , proto ) :
          if proto >= 2 :
                return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
  else :
                  return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )
    def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = type ( self ) ( )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
   if six . PY3 :
          __bytes__ = new_method_proxy ( bytes )
 __str__ = new_method_proxy ( str )
 __bool__ = new_method_proxy ( bool )
  else :
          __str__ = new_method_proxy ( str )
 __unicode__ = new_method_proxy ( unicode )
 __nonzero__ = new_method_proxy ( bool )
    __dir__ = new_method_proxy ( dir )
    __class__ = property ( new_method_proxy ( operator . attrgetter ( "__class__" ) ) )
 __eq__ = new_method_proxy ( operator . eq )
 __ne__ = new_method_proxy ( operator . ne )
 __hash__ = new_method_proxy ( hash )
   __getitem__ = new_method_proxy ( operator . getitem )
 __setitem__ = new_method_proxy ( operator . setitem )
 __delitem__ = new_method_proxy ( operator . delitem )
  __len__ = new_method_proxy ( len )
 __contains__ = new_method_proxy ( operator . contains )
     _super = super
   class SimpleLazyObject ( LazyObject ) :
 def __init__ ( self , func ) :
 self . __dict__ [ '_setupfunc' ] = func
 _super ( SimpleLazyObject , self ) . __init__ ( )
   def _setup ( self ) :
          self . _wrapped = self . _setupfunc ( )
     def __repr__ ( self ) :
          if self . _wrapped is empty :
              repr_attr = self . _setupfunc
  else :
              repr_attr = self . _wrapped
  return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )
   def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = SimpleLazyObject ( self . _setupfunc )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
     class lazy_property ( property ) :
 def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :
          if fget is not None :
              @ wraps ( fget )
 def fget ( instance , instance_type = None , name = fget . __name__ ) :
                  return getattr ( instance , name ) ( )
   if fset is not None :
              @ wraps ( fset )
 def fset ( instance , value , name = fset . __name__ ) :
                  return getattr ( instance , name ) ( value )
   if fdel is not None :
              @ wraps ( fdel )
 def fdel ( instance , name = fdel . __name__ ) :
                  return getattr ( instance , name ) ( )
   return property ( fget , fset , fdel , doc )
     def partition ( predicate , values ) :
 results = ( [ ] , [ ] )
 for item in values :
          results [ predicate ( item ) ] . append ( item )
  return results
   if sys . version_info >= ( 2 , 7 , 2 ) :
      from functools import total_ordering
  else :
         def total_ordering ( cls ) :
 convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
 roots = set ( dir ( cls ) ) & set ( convert )
 if not roots :
              raise ValueError ( 'must define at least one ordering operation: < > <= >=' )
  root = max ( roots )
 for opname , opfunc in convert [ root ] :
              if opname not in roots :
                  opfunc . __name__ = opname
 opfunc . __doc__ = getattr ( int , opname ) . __doc__
 setattr ( cls , opname , opfunc )
   return cls
  from __future__ import unicode_literals
  import re
 import sys
  from django . utils . encoding import force_text , force_str
 from django . utils . functional import allow_lazy
 from django . utils . safestring import SafeData , mark_safe
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
 from django . utils . text import normalize_newlines
  from . html_parser import HTMLParser , HTMLParseError
    TRAILING_PUNCTUATION = [ '.' , ',' , ':' , ';' , '.)' , '"' , '\'' ]
 WRAPPING_PUNCTUATION = [ ( '(' , ')' ) , ( '<' , '>' ) , ( '[' , ']' ) , ( '&lt;' , '&gt;' ) , ( '"' , '"' ) , ( '\'' , '\'' ) ]
   DOTS = [ '&middot;' , '*' , '\u2022' , '&#149;' , '&bull;' , '&#8226;' ]
  unencoded_ampersands_re = re . compile ( r'&(?!(\w+|#\d+);)' )
 word_split_re = re . compile ( r'(\s+)' )
 simple_url_re = re . compile ( r'^https?://\[?\w' , re . IGNORECASE )
 simple_url_2_re = re . compile ( r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$' , re . IGNORECASE )
 simple_email_re = re . compile ( r'^\S+@\S+\.\S+$' )
 link_target_attribute_re = re . compile ( r'(<a [^>]*?)target=[^\s>]+' )
 html_gunk_re = re . compile ( r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' , re . IGNORECASE )
 hard_coded_bullets_re = re . compile ( r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
 trailing_empty_content_re = re . compile ( r'(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z' )
   def escape ( text ) :
 return mark_safe ( force_text ( text ) . replace ( '&' , '&amp;' ) . replace ( '<' , '&lt;' ) . replace ( '>' , '&gt;' ) . replace ( '"' , '&quot;' ) . replace ( "'" , '&#39;' ) )
  escape = allow_lazy ( escape , six . text_type )
  _js_escapes = {  ord ( '\\' ) : '\\u005C' ,  ord ( '\'' ) : '\\u0027' ,  ord ( '"' ) : '\\u0022' ,  ord ( '>' ) : '\\u003E' ,  ord ( '<' ) : '\\u003C' ,  ord ( '&' ) : '\\u0026' ,  ord ( '=' ) : '\\u003D' ,  ord ( '-' ) : '\\u002D' ,  ord ( ';' ) : '\\u003B' ,  ord ( '\u2028' ) : '\\u2028' ,  ord ( '\u2029' ) : '\\u2029'  }
   _js_escapes . update ( ( ord ( '%c' % z ) , '\\u%04X' % z ) for z in range ( 32 ) )
   def escapejs ( value ) :
 return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )
  escapejs = allow_lazy ( escapejs , six . text_type )
   def conditional_escape ( text ) :
 if hasattr ( text , '__html__' ) :
          return text . __html__ ( )
  else :
          return escape ( text )
     def format_html ( format_string , * args , ** kwargs ) :
 args_safe = map ( conditional_escape , args )
 kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
 return mark_safe ( format_string . format ( * args_safe , ** kwargs_safe ) )
    def format_html_join ( sep , format_string , args_generator ) :
 return mark_safe ( conditional_escape ( sep ) . join (  format_html ( format_string , * tuple ( args ) )  for args in args_generator ) )
    def linebreaks ( value , autoescape = False ) :
 value = normalize_newlines ( value )
 paras = re . split ( '\n{2,}' , value )
 if autoescape :
          paras = [ '<p>%s</p>' % escape ( p ) . replace ( '\n' , '<br />' ) for p in paras ]
  else :
          paras = [ '<p>%s</p>' % p . replace ( '\n' , '<br />' ) for p in paras ]
  return '\n\n' . join ( paras )
  linebreaks = allow_lazy ( linebreaks , six . text_type )
   class MLStripper ( HTMLParser ) :
      def __init__ ( self ) :
            if sys . version_info [ : 2 ] == ( 3 , 2 ) :
              HTMLParser . __init__ ( self , strict = False )
  else :
              HTMLParser . __init__ ( self )
  self . reset ( )
 self . fed = [ ]
   def handle_data ( self , d ) :
          self . fed . append ( d )
   def handle_entityref ( self , name ) :
          self . fed . append ( '&%s;' % name )
   def handle_charref ( self , name ) :
          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
            return s . get_data ( ) + s . rawdata
  else :
          return s . get_data ( )
     def strip_tags ( value ) :
   while '<' in value and '>' in value :
          new_value = _strip_once ( value )
 if new_value == value :
               break
  value = new_value
  return value
  strip_tags = allow_lazy ( strip_tags )
   def remove_tags ( html , tags ) :
 tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
 tags_re = '(%s)' % '|' . join ( tags )
 starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
 endtag_re = re . compile ( '</%s>' % tags_re )
 html = starttag_re . sub ( '' , html )
 html = endtag_re . sub ( '' , html )
 return html
  remove_tags = allow_lazy ( remove_tags , six . text_type )
   def strip_spaces_between_tags ( value ) :
 return re . sub ( r'>\s+<' , '><' , force_text ( value ) )
  strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
   def strip_entities ( value ) :
 return re . sub ( r'&(?:\w+|#\d+);' , '' , force_text ( value ) )
  strip_entities = allow_lazy ( strip_entities , six . text_type )
   def smart_urlquote ( url ) :
  try :
          scheme , netloc , path , query , fragment = urlsplit ( url )
 try :
              netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
              pass
  else :
              url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
   except ValueError :
           pass
   url = unquote ( force_str ( url ) )
  url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
  return force_text ( url )
    def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
 def trim_url ( x , limit = trim_url_limit ) :
          if limit is None or len ( x ) <= limit :
              return x
  return '%s...' % x [ : max ( 0 , limit - 3 ) ]
  safe_input = isinstance ( text , SafeData )
 words = word_split_re . split ( force_text ( text ) )
 for i , word in enumerate ( words ) :
          if '.' in word or '@' in word or ':' in word :
               lead , middle , trail = '' , word , ''
 for punctuation in TRAILING_PUNCTUATION :
                  if middle . endswith ( punctuation ) :
                      middle = middle [ : - len ( punctuation ) ]
 trail = punctuation + trail
   for opening , closing in WRAPPING_PUNCTUATION :
                  if middle . startswith ( opening ) :
                      middle = middle [ len ( opening ) : ]
 lead = lead + opening
   if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
                      middle = middle [ : - len ( closing ) ]
 trail = closing + trail
     url = None
 nofollow_attr = ' rel="nofollow"' if nofollow else ''
 if simple_url_re . match ( middle ) :
                  url = smart_urlquote ( middle )
  elif simple_url_2_re . match ( middle ) :
                  url = smart_urlquote ( 'http://%s' % middle )
  elif ':' not in middle and simple_email_re . match ( middle ) :
                  local , domain = middle . rsplit ( '@' , 1 )
 try :
                      domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
                      continue
  url = 'mailto:%s@%s' % ( local , domain )
 nofollow_attr = ''
    if url :
                  trimmed = trim_url ( middle )
 if autoescape and not safe_input :
                      lead , trail = escape ( lead ) , escape ( trail )
 url , trimmed = escape ( url ) , escape ( trimmed )
  middle = '<a href="%s"%s>%s</a>' % ( url , nofollow_attr , trimmed )
 words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )
  else :
                  if safe_input :
                      words [ i ] = mark_safe ( word )
  elif autoescape :
                      words [ i ] = escape ( word )
    elif safe_input :
              words [ i ] = mark_safe ( word )
  elif autoescape :
              words [ i ] = escape ( word )
   return '' . join ( words )
  urlize = allow_lazy ( urlize , six . text_type )
   def avoid_wrapping ( value ) :
 return value . replace ( " " , "\xa0" )
from django . utils . six . moves import html_parser as _html_parser
 import re
 import sys
  current_version = sys . version_info
  use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )
  HTMLParseError = _html_parser . HTMLParseError
  if not use_workaround :
      if current_version >= ( 3 , 4 ) :
          class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self , convert_charrefs = False , ** kwargs ) :
                  _html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
    else :
          HTMLParser = _html_parser . HTMLParser
   else :
      tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' )
  class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self ) :
              _html_parser . HTMLParser . __init__ ( self )
 self . cdata_tag = None
   def set_cdata_mode ( self , tag ) :
              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
 return j
  self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
   tag = match . group ( 1 ) . strip ( )
 if self . cdata_tag is not None :
                  if tag . lower ( ) != self . cdata_tag :
                      self . handle_data ( rawdata [ i : j ] )
 return j
    self . handle_endtag ( tag . lower ( ) )
 self . clear_cdata_mode ( )
 return j
from __future__ import unicode_literals
  import base64
 import calendar
 import datetime
 import re
 import sys
  from binascii import Error as BinasciiError
 from email . utils import formatdate
  from django . utils . datastructures import MultiValueDict
 from django . utils . encoding import force_str , force_text
 from django . utils . functional import allow_lazy
 from django . utils import six
 from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )
  ETAG_MATCH = re . compile ( r'(?:W/)?"((?:\\.|[^"])*)"' )
  MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )
 __D = r'(?P<day>\d{2})'
 __D2 = r'(?P<day>[ \d]\d)'
 __M = r'(?P<mon>\w{3})'
 __Y = r'(?P<year>\d{4})'
 __Y2 = r'(?P<year>\d{2})'
 __T = r'(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'
 RFC1123_DATE = re . compile ( r'^\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )
 RFC850_DATE = re . compile ( r'^\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )
 ASCTIME_DATE = re . compile ( r'^\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )
   def urlquote ( url , safe = '/' ) :
 return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
  urlquote = allow_lazy ( urlquote , six . text_type )
   def urlquote_plus ( url , safe = '' ) :
 return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
  urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
   def urlunquote ( quoted_url ) :
 return force_text ( unquote ( force_str ( quoted_url ) ) )
  urlunquote = allow_lazy ( urlunquote , six . text_type )
   def urlunquote_plus ( quoted_url ) :
 return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
  urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
   def urlencode ( query , doseq = 0 ) :
 if isinstance ( query , MultiValueDict ) :
          query = query . lists ( )
  elif hasattr ( query , 'items' ) :
          query = query . items ( )
  return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )
    def cookie_date ( epoch_seconds = None ) :
 rfcdate = formatdate ( epoch_seconds )
 return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
    def http_date ( epoch_seconds = None ) :
 return formatdate ( epoch_seconds , usegmt = True )
    def parse_http_date ( date ) :
    for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
          m = regex . match ( date )
 if m is not None :
              break
   else :
          raise ValueError ( "%r is not in a valid HTTP date format" % date )
  try :
          year = int ( m . group ( 'year' ) )
 if year < 100 :
              if year < 70 :
                  year += 2000
  else :
                  year += 1900
   month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1
 day = int ( m . group ( 'day' ) )
 hour = int ( m . group ( 'hour' ) )
 min = int ( m . group ( 'min' ) )
 sec = int ( m . group ( 'sec' ) )
 result = datetime . datetime ( year , month , day , hour , min , sec )
 return calendar . timegm ( result . utctimetuple ( ) )
  except Exception :
          six . reraise ( ValueError , ValueError ( "%r is not a valid date" % date ) , sys . exc_info ( ) [ 2 ] )
     def parse_http_date_safe ( date ) :
 try :
          return parse_http_date ( date )
  except Exception :
          pass
       def base36_to_int ( s ) :
    if len ( s ) > 13 :
          raise ValueError ( "Base36 input too large" )
  value = int ( s , 36 )
   if six . PY2 and value > sys . maxint :
          raise ValueError ( "Base36 input too large" )
  return value
    def int_to_base36 ( i ) :
 digits = "0123456789abcdefghijklmnopqrstuvwxyz"
 factor = 0
 if i < 0 :
          raise ValueError ( "Negative base36 conversion input." )
  if six . PY2 :
          if not isinstance ( i , six . integer_types ) :
              raise TypeError ( "Non-integer base36 conversion input." )
  if i > sys . maxint :
              raise ValueError ( "Base36 conversion input too large." )
    while True :
          factor += 1
 if i < 36 ** factor :
              factor -= 1
 break
   base36 = [ ]
  while factor >= 0 :
          j = 36 ** factor
 base36 . append ( digits [ i // j ] )
 i = i % j
 factor -= 1
  return '' . join ( base36 )
    def urlsafe_base64_encode ( s ) :
 return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\n=' )
    def urlsafe_base64_decode ( s ) :
 s = s . encode ( 'utf-8' )
 try :
          return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )
  except ( LookupError , BinasciiError ) as e :
          raise ValueError ( e )
     def parse_etags ( etag_str ) :
 etags = ETAG_MATCH . findall ( etag_str )
 if not etags :
           return [ etag_str ]
  etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]
 return etags
    def quote_etag ( etag ) :
 return '"%s"' % etag . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' )
    def same_origin ( url1 , url2 ) :
 p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
 try :
          return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )
  except ValueError :
          return False
     def is_safe_url ( url , host = None ) :
 if not url :
          return False
   url = url . replace ( '\\' , '/' )
   if url . startswith ( '///' ) :
          return False
  url_info = urlparse ( url )
     if not url_info . netloc and url_info . scheme :
          return False
  return ( ( not url_info . netloc or url_info . netloc == host ) and  ( not url_info . scheme or url_info . scheme in [ 'http' , 'https' ] ) )
 import warnings
 import sys
  from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
   warnings . warn ( "django.utils.importlib will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
   def _resolve_name ( name , package , level ) :
 if not hasattr ( package , 'rindex' ) :
          raise ValueError ( "'package' not set to a string" )
  dot = len ( package )
 for x in range ( level , 1 , - 1 ) :
          try :
              dot = package . rindex ( '.' , 0 , dot )
  except ValueError :
              raise ValueError ( "attempted relative import beyond top-level package" )
   return "%s.%s" % ( package [ : dot ] , name )
    if six . PY3 :
      from importlib import import_module
  else :
      def import_module ( name , package = None ) :
 if name . startswith ( '.' ) :
              if not package :
                  raise TypeError ( "relative imports require the 'package' argument" )
  level = 0
 for character in name :
                  if character != '.' :
                      break
  level += 1
  name = _resolve_name ( name [ level : ] , package , level )
  __import__ ( name )
 return sys . modules [ name ]
   from django . core . exceptions import ValidationError
 from django . utils . translation import ugettext_lazy as _
 from django . utils . six . moves import xrange
   def clean_ipv6_address ( ip_str , unpack_ipv4 = False ,  error_message = _ ( "This is not a valid IPv6 address." ) ) :
 best_doublecolon_start = - 1
 best_doublecolon_len = 0
 doublecolon_start = - 1
 doublecolon_len = 0
  if not is_valid_ipv6_address ( ip_str ) :
          raise ValidationError ( error_message , code = 'invalid' )
     ip_str = _explode_shorthand_ip_string ( ip_str )
  ip_str = _sanitize_ipv4_mapping ( ip_str )
    if unpack_ipv4 :
          ipv4_unpacked = _unpack_ipv4 ( ip_str )
  if ipv4_unpacked :
              return ipv4_unpacked
    hextets = ip_str . split ( ":" )
  for index in range ( len ( hextets ) ) :
           hextets [ index ] = hextets [ index ] . lstrip ( '0' )
 if not hextets [ index ] :
              hextets [ index ] = '0'
    if hextets [ index ] == '0' :
              doublecolon_len += 1
 if doublecolon_start == - 1 :
                   doublecolon_start = index
  if doublecolon_len > best_doublecolon_len :
                   best_doublecolon_len = doublecolon_len
 best_doublecolon_start = doublecolon_start
   else :
              doublecolon_len = 0
 doublecolon_start = - 1
     if best_doublecolon_len > 1 :
          best_doublecolon_end = ( best_doublecolon_start +  best_doublecolon_len )
  if best_doublecolon_end == len ( hextets ) :
              hextets += [ '' ]
  hextets [ best_doublecolon_start : best_doublecolon_end ] = [ '' ] 
 if best_doublecolon_start == 0 :
              hextets = [ '' ] + hextets
    result = ":" . join ( hextets )
  return result . lower ( )
    def _sanitize_ipv4_mapping ( ip_str ) :
 if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :
           return ip_str
   hextets = ip_str . split ( ':' )
  if '.' in hextets [ - 1 ] :
           return ip_str
   ipv4_address = "%d.%d.%d.%d" % (  int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) ,  int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) ,  )
 result = ':' . join ( hextets [ 0 : 6 ] )
 result += ':' + ipv4_address
  return result
    def _unpack_ipv4 ( ip_str ) :
 if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :
          return None
   return ip_str . rsplit ( ':' , 1 ) [ 1 ]
    def is_valid_ipv6_address ( ip_str ) :
 from django . core . validators import validate_ipv4_address
   if ':' not in ip_str :
          return False
    if ip_str . count ( '::' ) > 1 :
          return False
    if ':::' in ip_str :
          return False
    if ( ( ip_str . startswith ( ':' ) and not ip_str . startswith ( '::' ) ) or  ( ip_str . endswith ( ':' ) and not ip_str . endswith ( '::' ) ) ) :
          return False
    if ip_str . count ( ':' ) > 7 :
          return False
    if '::' not in ip_str and ip_str . count ( ':' ) != 7 :
           if ip_str . count ( '.' ) != 3 :
              return False
    ip_str = _explode_shorthand_ip_string ( ip_str )
    for hextet in ip_str . split ( ':' ) :
          if hextet . count ( '.' ) == 3 :
                if not ip_str . split ( ':' ) [ - 1 ] == hextet :
                  return False
  try :
                  validate_ipv4_address ( hextet )
  except ValidationError :
                  return False
   else :
              try :
                    if int ( hextet , 16 ) < 0x0 or int ( hextet , 16 ) > 0xFFFF :
                      return False
   except ValueError :
                  return False
    return True
    def _explode_shorthand_ip_string ( ip_str ) :
 if not _is_shorthand_ip ( ip_str ) :
           return ip_str
   new_ip = [ ]
 hextet = ip_str . split ( '::' )
     if '.' in ip_str . split ( ':' ) [ - 1 ] :
          fill_to = 7
  else :
          fill_to = 8
   if len ( hextet ) > 1 :
          sep = len ( hextet [ 0 ] . split ( ':' ) ) + len ( hextet [ 1 ] . split ( ':' ) )
 new_ip = hextet [ 0 ] . split ( ':' )
  for __ in xrange ( fill_to - sep ) :
              new_ip . append ( '0000' )
  new_ip += hextet [ 1 ] . split ( ':' )
   else :
          new_ip = ip_str . split ( ':' )
     ret_ip = [ ]
 for hextet in new_ip :
          ret_ip . append ( ( '0' * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )
  return ':' . join ( ret_ip )
    def _is_shorthand_ip ( ip_str ) :
 if ip_str . count ( '::' ) == 1 :
          return True
  if any ( len ( x ) < 4 for x in ip_str . split ( ':' ) ) :
          return True
  return False
   def is_iterable ( x ) :
 try :
          iter ( x )
  except TypeError :
          return False
  else :
          return True
  import re
   class Tok ( object ) :
 num = 0
  def __init__ ( self , name , regex , next = None ) :
          self . id = Tok . num
 Tok . num += 1
 self . name = name
 self . regex = regex
 self . next = next
     def literals ( choices , prefix = "" , suffix = "" ) :
 return "|" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
    class Lexer ( object ) :
  def __init__ ( self , states , first ) :
          self . regexes = { }
 self . toks = { }
  for state , rules in states . items ( ) :
              parts = [ ]
 for tok in rules :
                  groupid = "t%d" % tok . id
 self . toks [ groupid ] = tok
 parts . append ( "(?P<%s>%s)" % ( groupid , tok . regex ) )
  self . regexes [ state ] = re . compile ( "|" . join ( parts ) , re . MULTILINE | re . VERBOSE )
   self . state = first
   def lex ( self , text ) :
 end = len ( text )
 state = self . state
 regexes = self . regexes
 toks = self . toks
 start = 0
  while start < end :
              for match in regexes [ state ] . finditer ( text , start ) :
                  name = match . lastgroup
 tok = toks [ name ]
 toktext = match . group ( name )
 start += len ( toktext )
 yield ( tok . name , toktext )
  if tok . next :
                      state = tok . next
 break
     self . state = state
     class JsLexer ( Lexer ) :
               both_before = [  Tok ( "comment" , r"/\*(.|\n)*?\*/" ) ,  Tok ( "linecomment" , r"//.*?$" ) ,  Tok ( "ws" , r"\s+" ) ,  Tok ( "keyword" , literals ( """                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            """ , suffix = r"\b" ) , next = 'reg' ) ,  Tok ( "reserved" , literals ( "null true false" , suffix = r"\b" ) , next = 'div' ) ,  Tok ( "id" , r"""                   ([a-zA-Z_$   ]|\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*  # rest chars                   """ , next = 'div' ) ,  Tok ( "hnum" , r"0[xX][0-9a-fA-F]+" , next = 'div' ) ,  Tok ( "onum" , r"0[0-7]+" ) ,  Tok ( "dnum" , r"""                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     """ , next = 'div' ) ,  Tok ( "punct" , literals ( """                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          """ ) , next = "reg" ) ,  Tok ( "punct" , literals ( "++ -- ) ]" ) , next = 'div' ) ,  Tok ( "punct" , literals ( "{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =" ) , next = 'reg' ) ,  Tok ( "string" , r'"([^"\\]|(\\(.|\n)))*?"' , next = 'div' ) ,  Tok ( "string" , r"'([^'\\]|(\\(.|\n)))*?'" , next = 'div' ) ,  ]
  both_after = [  Tok ( "other" , r"." ) ,  ]
  states = {   'div' : both_before + [  Tok ( "punct" , literals ( "/= /" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( "regex" ,  r"""                     /                       # opening slash                     # First character is..                     (   [^*\\/[]            # anything but * \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )                     # Following characters are same, except for excluding a star                     (   [^\\/[]             # anything but \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 """ , next = 'div' ) ,  ] + both_after ,  }
  def __init__ ( self ) :
          super ( JsLexer , self ) . __init__ ( self . states , 'reg' )
     def prepare_js_for_gettext ( js ) :
 def escape_quotes ( m ) :
 s = m . group ( 0 )
 if s == '"' :
              return r'\"'
  else :
              return s
    lexer = JsLexer ( )
 c = [ ]
 for name , tok in lexer . lex ( js ) :
          if name == 'regex' :
                tok = '"REGEX"'
  elif name == 'string' :
                if tok . startswith ( "'" ) :
                  guts = re . sub ( r"\\.|." , escape_quotes , tok [ 1 : - 1 ] )
 tok = '"' + guts + '"'
   elif name == 'id' :
                 tok = tok . replace ( "\\" , "U" )
  c . append ( tok )
  return '' . join ( c )
import logging
 import sys
 import warnings
  from django . conf import settings
 from django . core import mail
 from django . core . mail import get_connection
 from django . utils . deprecation import RemovedInNextVersionWarning
 from django . utils . module_loading import import_string
 from django . views . debug import ExceptionReporter , get_exception_reporter_filter
   from logging import NullHandler
 from logging . config import dictConfig
  getLogger = logging . getLogger
     DEFAULT_LOGGING = {  'version' : 1 ,  'disable_existing_loggers' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }
   def configure_logging ( logging_config , logging_settings ) :
      if not sys . warnoptions :
           logging . captureWarnings ( True )
   warnings . simplefilter ( "default" , RemovedInNextVersionWarning )
   if logging_config :
           logging_config_func = import_string ( logging_config )
  logging_config_func ( DEFAULT_LOGGING )
   if logging_settings :
              logging_config_func ( logging_settings )
      class AdminEmailHandler ( logging . Handler ) :
  def __init__ ( self , include_html = False , email_backend = None ) :
          logging . Handler . __init__ ( self )
 self . include_html = include_html
 self . email_backend = email_backend
   def emit ( self , record ) :
          try :
              request = record . request
 subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
 filter = get_exception_reporter_filter ( request )
 request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
  except Exception :
              subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
 request = None
 request_repr = "unavailable"
  subject = self . format_subject ( subject )
  if record . exc_info :
              exc_info = record . exc_info
  else :
              exc_info = ( None , record . getMessage ( ) , None )
   message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
 reporter = ExceptionReporter ( request , is_email = True , * exc_info )
 html_message = reporter . get_traceback_html ( ) if self . include_html else None
 mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
   def connection ( self ) :
          return get_connection ( backend = self . email_backend , fail_silently = True )
   def format_subject ( self , subject ) :
 formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
 return formatted_subject [ : 989 ]
     class CallbackFilter ( logging . Filter ) :
 def __init__ ( self , callback ) :
          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
  return 0
     class RequireDebugFalse ( logging . Filter ) :
      def filter ( self , record ) :
          return not settings . DEBUG
     class RequireDebugTrue ( logging . Filter ) :
      def filter ( self , record ) :
          return settings . DEBUG
try :
      from functools import lru_cache
   except ImportError :
           from collections import namedtuple
 from functools import update_wrapper
 from threading import RLock
  _CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
  class _HashedSeq ( list ) :
          __slots__ = 'hashvalue'
  def __init__ ( self , tup , hash = hash ) :
              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
  return _HashedSeq ( key )
   def lru_cache ( maxsize = 100 , typed = False ) :
       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
  return result
    def cache_info ( ) :
 with lock :
                      return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
    def cache_clear ( ) :
 with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
 return update_wrapper ( wrapper , user_function )
   return decorating_function
from __future__ import absolute_import
  import copy
 from importlib import import_module
 import os
 import sys
 import warnings
  from django . core . exceptions import ImproperlyConfigured
 from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
   def import_string ( dotted_path ) :
 try :
          module_path , class_name = dotted_path . rsplit ( '.' , 1 )
  except ValueError :
          msg = "%s doesn't look like a module path" % dotted_path
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
   module = import_module ( module_path )
  try :
          return getattr ( module , class_name )
  except AttributeError :
          msg = 'Module "%s" does not define a "%s" attribute/class' % (  dotted_path , class_name )
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
     def import_by_path ( dotted_path , error_prefix = '' ) :
 warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
 try :
          attr = import_string ( dotted_path )
  except ImportError as e :
          msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
 six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
  return attr
    def autodiscover_modules ( * args , ** kwargs ) :
 from django . apps import apps
  register_to = kwargs . get ( 'register_to' )
 for app_config in apps . get_app_configs ( ) :
           try :
              if register_to :
                  before_import_registry = copy . copy ( register_to . _registry )
   for module_to_search in args :
                  import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
   except :
                  if register_to :
                  register_to . _registry = before_import_registry
      if module_has_submodule ( app_config . module , module_to_search ) :
                  raise
       if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
      if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
          from importlib . util import find_spec as importlib_find
  else :
          from importlib import find_loader as importlib_find
   def module_has_submodule ( package , module_name ) :
 try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
               return False
   full_module_name = package_name + '.' + module_name
 return importlib_find ( full_module_name , package_path ) is not None
    else :
      import imp
  def module_has_submodule ( package , module_name ) :
 name = "." . join ( [ package . __name__ , module_name ] )
 try :
               return sys . modules [ name ] is not None
  except KeyError :
              pass
  try :
              package_path = package . __path__
  except AttributeError :
                return False
  for finder in sys . meta_path :
              if finder . find_module ( name , package_path ) :
                  return True
   for entry in package_path :
              try :
                   finder = sys . path_importer_cache [ entry ]
 if finder is None :
                       try :
                          file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
 if file_ :
                              file_ . close ( )
  return True
  except ImportError :
                          continue
    elif finder . find_module ( name ) :
                      return True
  else :
                      continue
   except KeyError :
                   for hook in sys . path_hooks :
                      try :
                          finder = hook ( entry )
  if finder . find_module ( name ) :
                              return True
  else :
                               break
   except ImportError :
                           continue
   else :
                        if os . path . isdir ( entry ) :
                          try :
                              file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
 if file_ :
                                  file_ . close ( )
  return True
  except ImportError :
                              pass
       else :
               return False
from django . conf import settings
 from django . utils . safestring import mark_safe
 from django . utils import six
   def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = '' ,  force_grouping = False ) :
 use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR
 use_grouping = use_grouping or force_grouping
 use_grouping = use_grouping and grouping > 0
  if isinstance ( number , int ) and not use_grouping and not decimal_pos :
          return mark_safe ( six . text_type ( number ) )
   sign = ''
 str_number = six . text_type ( number )
 if str_number [ 0 ] == '-' :
          sign = '-'
 str_number = str_number [ 1 : ]
   if '.' in str_number :
          int_part , dec_part = str_number . split ( '.' )
 if decimal_pos is not None :
              dec_part = dec_part [ : decimal_pos ]
   else :
          int_part , dec_part = str_number , ''
  if decimal_pos is not None :
          dec_part = dec_part + ( '0' * ( decimal_pos - len ( dec_part ) ) )
  if dec_part :
          dec_part = decimal_sep + dec_part
   if use_grouping :
          int_part_gd = ''
 for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :
              if cnt and not cnt % grouping :
                  int_part_gd += thousand_sep
  int_part_gd += digit
  int_part = int_part_gd [ : : - 1 ]
  return sign + int_part + dec_part
 from __future__ import unicode_literals
  from django . utils import six
 from django . utils . six . moves import zip
     ESCAPE_MAPPINGS = {  "A" : None ,  "b" : None ,  "B" : None ,  "d" : "0" ,  "D" : "x" ,  "s" : " " ,  "S" : "x" ,  "w" : "x" ,  "W" : "!" ,  "Z" : None ,  }
   class Choice ( list ) :
    class Group ( list ) :
    class NonCapture ( list ) :
    def normalize ( pattern ) :
    result = [ ]
 non_capturing_groups = [ ]
 consume_next = True
 pattern_iter = next_char ( iter ( pattern ) )
 num_args = 0
     try :
          ch , escaped = next ( pattern_iter )
  except StopIteration :
          return [ ( '' , [ ] ) ]
   try :
          while True :
              if escaped :
                  result . append ( ch )
  elif ch == '.' :
                   result . append ( "." )
  elif ch == '|' :
                   raise NotImplementedError ( 'Awaiting Implementation' )
  elif ch == "^" :
                  pass
  elif ch == '$' :
                  break
  elif ch == ')' :
                        start = non_capturing_groups . pop ( )
 inner = NonCapture ( result [ start : ] )
 result = result [ : start ] + [ inner ]
  elif ch == '[' :
                   ch , escaped = next ( pattern_iter )
 result . append ( ch )
 ch , escaped = next ( pattern_iter )
 while escaped or ch != ']' :
                      ch , escaped = next ( pattern_iter )
   elif ch == '(' :
                   ch , escaped = next ( pattern_iter )
 if ch != '?' or escaped :
                       name = "_%d" % num_args
 num_args += 1
 result . append ( Group ( ( ( "%%(%s)s" % name ) , name ) ) )
 walk_to_end ( ch , pattern_iter )
  else :
                      ch , escaped = next ( pattern_iter )
 if ch in "iLmsu#" :
                            walk_to_end ( ch , pattern_iter )
  elif ch == ':' :
                           non_capturing_groups . append ( len ( result ) )
  elif ch != 'P' :
                            raise ValueError ( "Non-reversible reg-exp portion: '(?%s'" % ch )
  else :
                          ch , escaped = next ( pattern_iter )
 if ch not in ( '<' , '=' ) :
                              raise ValueError ( "Non-reversible reg-exp portion: '(?P%s'" % ch )
    if ch == '<' :
                              terminal_char = '>'
   else :
                              terminal_char = ')'
  name = [ ]
 ch , escaped = next ( pattern_iter )
 while ch != terminal_char :
                              name . append ( ch )
 ch , escaped = next ( pattern_iter )
  param = '' . join ( name )
   if terminal_char != ')' :
                              result . append ( Group ( ( ( "%%(%s)s" % param ) , param ) ) )
 walk_to_end ( ch , pattern_iter )
  else :
                              result . append ( Group ( ( ( "%%(%s)s" % param ) , None ) ) )
     elif ch in "*?+{" :
                   count , ch = get_quantifier ( ch , pattern_iter )
 if ch :
                         consume_next = False
   if count == 0 :
                      if contains ( result [ - 1 ] , Group ) :
                                result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )
  else :
                          result . pop ( )
   elif count > 1 :
                      result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )
   else :
                   result . append ( ch )
   if consume_next :
                  ch , escaped = next ( pattern_iter )
  else :
                  consume_next = True
    except StopIteration :
          pass
  except NotImplementedError :
           return [ ( '' , [ ] ) ]
   return list ( zip ( * flatten_result ( result ) ) )
    def next_char ( input_iter ) :
 for ch in input_iter :
          if ch != '\\' :
              yield ch , False
 continue
  ch = next ( input_iter )
 representative = ESCAPE_MAPPINGS . get ( ch , ch )
 if representative is None :
              continue
  yield representative , True
     def walk_to_end ( ch , input_iter ) :
 if ch == '(' :
          nesting = 1
  else :
          nesting = 0
  for ch , escaped in input_iter :
          if escaped :
              continue
  elif ch == '(' :
              nesting += 1
  elif ch == ')' :
              if not nesting :
                  return
  nesting -= 1
      def get_quantifier ( ch , input_iter ) :
 if ch in '*?+' :
          try :
              ch2 , escaped = next ( input_iter )
  except StopIteration :
              ch2 = None
  if ch2 == '?' :
              ch2 = None
  if ch == '+' :
              return 1 , ch2
  return 0 , ch2
   quant = [ ]
 while ch != '}' :
          ch , escaped = next ( input_iter )
 quant . append ( ch )
  quant = quant [ : - 1 ]
 values = '' . join ( quant ) . split ( ',' )
   try :
          ch , escaped = next ( input_iter )
  except StopIteration :
          ch = None
  if ch == '?' :
          ch = None
  return int ( values [ 0 ] ) , ch
    def contains ( source , inst ) :
 if isinstance ( source , inst ) :
          return True
  if isinstance ( source , NonCapture ) :
          for elt in source :
              if contains ( elt , inst ) :
                  return True
    return False
    def flatten_result ( source ) :
 if source is None :
          return [ '' ] , [ [ ] ]
  if isinstance ( source , Group ) :
          if source [ 1 ] is None :
              params = [ ]
  else :
              params = [ source [ 1 ] ]
  return [ source [ 0 ] ] , [ params ]
  result = [ '' ]
 result_args = [ [ ] ]
 pos = last = 0
 for pos , elt in enumerate ( source ) :
          if isinstance ( elt , six . string_types ) :
              continue
  piece = '' . join ( source [ last : pos ] )
 if isinstance ( elt , Group ) :
              piece += elt [ 0 ]
 param = elt [ 1 ]
  else :
              param = None
  last = pos + 1
 for i in range ( len ( result ) ) :
              result [ i ] += piece
 if param :
                  result_args [ i ] . append ( param )
   if isinstance ( elt , ( Choice , NonCapture ) ) :
              if isinstance ( elt , NonCapture ) :
                  elt = [ elt ]
  inner_result , inner_args = [ ] , [ ]
 for item in elt :
                  res , args = flatten_result ( item )
 inner_result . extend ( res )
 inner_args . extend ( args )
  new_result = [ ]
 new_args = [ ]
 for item , args in zip ( result , result_args ) :
                  for i_item , i_args in zip ( inner_result , inner_args ) :
                      new_result . append ( item + i_item )
 new_args . append ( args [ : ] + i_args )
   result = new_result
 result_args = new_args
   if pos >= last :
          piece = '' . join ( source [ last : ] )
 for i in range ( len ( result ) ) :
              result [ i ] += piece
   return result , result_args
 from django . utils . functional import curry , Promise
 from django . utils import six
   class EscapeData ( object ) :
      pass
    class EscapeBytes ( bytes , EscapeData ) :
 pass
    class EscapeText ( six . text_type , EscapeData ) :
 pass
   if six . PY3 :
      EscapeString = EscapeText
  else :
      EscapeString = EscapeBytes
  EscapeUnicode = EscapeText
    class SafeData ( object ) :
      def __html__ ( self ) :
 return self
     class SafeBytes ( bytes , SafeData ) :
 def __add__ ( self , rhs ) :
 t = super ( SafeBytes , self ) . __add__ ( rhs )
 if isinstance ( rhs , SafeText ) :
              return SafeText ( t )
  elif isinstance ( rhs , SafeBytes ) :
              return SafeBytes ( t )
  return t
   def _proxy_method ( self , * args , ** kwargs ) :
 method = kwargs . pop ( 'method' )
 data = method ( self , * args , ** kwargs )
 if isinstance ( data , bytes ) :
              return SafeBytes ( data )
  else :
              return SafeText ( data )
    decode = curry ( _proxy_method , method = bytes . decode )
    class SafeText ( six . text_type , SafeData ) :
 def __add__ ( self , rhs ) :
 t = super ( SafeText , self ) . __add__ ( rhs )
 if isinstance ( rhs , SafeData ) :
              return SafeText ( t )
  return t
   def _proxy_method ( self , * args , ** kwargs ) :
 method = kwargs . pop ( 'method' )
 data = method ( self , * args , ** kwargs )
 if isinstance ( data , bytes ) :
              return SafeBytes ( data )
  else :
              return SafeText ( data )
    encode = curry ( _proxy_method , method = six . text_type . encode )
   if six . PY3 :
      SafeString = SafeText
  else :
      SafeString = SafeBytes
  SafeUnicode = SafeText
    def mark_safe ( s ) :
 if isinstance ( s , SafeData ) :
          return s
  if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
          return SafeBytes ( s )
  if isinstance ( s , ( six . text_type , Promise ) ) :
          return SafeText ( s )
  return SafeString ( str ( s ) )
    def mark_for_escaping ( s ) :
 if isinstance ( s , ( SafeData , EscapeData ) ) :
          return s
  if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
          return EscapeBytes ( s )
  if isinstance ( s , ( six . text_type , Promise ) ) :
          return EscapeText ( s )
  return EscapeBytes ( bytes ( s ) )
                      import operator
 import sys
 import types
  __author__ = "Benjamin Peterson <benjamin@python.org>"
 __version__ = "1.6.1"
    PY2 = sys . version_info [ 0 ] == 2
 PY3 = sys . version_info [ 0 ] == 3
  if PY3 :
      string_types = str ,
 integer_types = int ,
 class_types = type ,
 text_type = str
 binary_type = bytes
  MAXSIZE = sys . maxsize
  else :
      string_types = basestring ,
 integer_types = ( int , long )
 class_types = ( type , types . ClassType )
 text_type = unicode
 binary_type = str
  if sys . platform . startswith ( "java" ) :
           MAXSIZE = int ( ( 1 << 31 ) - 1 )
  else :
           class X ( object ) :
              def __len__ ( self ) :
                  return 1 << 31
   try :
              len ( X ( ) )
  except OverflowError :
               MAXSIZE = int ( ( 1 << 31 ) - 1 )
  else :
               MAXSIZE = int ( ( 1 << 63 ) - 1 )
  del X
     def _add_doc ( func , doc ) :
 func . __doc__ = doc
    def _import_module ( name ) :
 __import__ ( name )
 return sys . modules [ name ]
    class _LazyDescr ( object ) :
       def __init__ ( self , name ) :
          self . name = name
   def __get__ ( self , obj , tp ) :
          try :
              result = self . _resolve ( )
  except ImportError :
               raise AttributeError ( "%s could not be imported " % self . name )
  setattr ( obj , self . name , result )
  delattr ( obj . __class__ , self . name )
 return result
     class MovedModule ( _LazyDescr ) :
       def __init__ ( self , name , old , new = None ) :
          super ( MovedModule , self ) . __init__ ( name )
 if PY3 :
              if new is None :
                  new = name
  self . mod = new
  else :
              self . mod = old
    def _resolve ( self ) :
          return _import_module ( self . mod )
   def __getattr__ ( self , attr ) :
                   if ( attr in ( "__file__" , "__name__" , "__path__" ) and  self . mod not in sys . modules ) :
              raise AttributeError ( attr )
  try :
              _module = self . _resolve ( )
  except ImportError :
              raise AttributeError ( attr )
  value = getattr ( _module , attr )
 setattr ( self , attr , value )
 return value
     class _LazyModule ( types . ModuleType ) :
       def __init__ ( self , name ) :
          super ( _LazyModule , self ) . __init__ ( name )
 self . __doc__ = self . __class__ . __doc__
   def __dir__ ( self ) :
          attrs = [ "__doc__" , "__name__" ]
 attrs += [ attr . name for attr in self . _moved_attributes ]
 return attrs
    _moved_attributes = [ ]
    class MovedAttribute ( _LazyDescr ) :
       def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) :
          super ( MovedAttribute , self ) . __init__ ( name )
 if PY3 :
              if new_mod is None :
                  new_mod = name
  self . mod = new_mod
 if new_attr is None :
                  if old_attr is None :
                      new_attr = name
  else :
                      new_attr = old_attr
   self . attr = new_attr
  else :
              self . mod = old_mod
 if old_attr is None :
                  old_attr = name
  self . attr = old_attr
    def _resolve ( self ) :
          module = _import_module ( self . mod )
 return getattr ( module , self . attr )
      class _MovedItems ( _LazyModule ) :
    _moved_attributes = [  MovedAttribute ( "cStringIO" , "cStringIO" , "io" , "StringIO" ) ,  MovedAttribute ( "filter" , "itertools" , "builtins" , "ifilter" , "filter" ) ,  MovedAttribute ( "filterfalse" , "itertools" , "itertools" , "ifilterfalse" , "filterfalse" ) ,  MovedAttribute ( "input" , "__builtin__" , "builtins" , "raw_input" , "input" ) ,  MovedAttribute ( "map" , "itertools" , "builtins" , "imap" , "map" ) ,  MovedAttribute ( "range" , "__builtin__" , "builtins" , "xrange" , "range" ) ,  MovedAttribute ( "reload_module" , "__builtin__" , "imp" , "reload" ) ,  MovedAttribute ( "reduce" , "__builtin__" , "functools" ) ,  MovedAttribute ( "StringIO" , "StringIO" , "io" ) ,  MovedAttribute ( "UserString" , "UserString" , "collections" ) ,  MovedAttribute ( "xrange" , "__builtin__" , "builtins" , "xrange" , "range" ) ,  MovedAttribute ( "zip" , "itertools" , "builtins" , "izip" , "zip" ) ,  MovedAttribute ( "zip_longest" , "itertools" , "itertools" , "izip_longest" , "zip_longest" ) ,   MovedModule ( "builtins" , "__builtin__" ) ,  MovedModule ( "configparser" , "ConfigParser" ) ,  MovedModule ( "copyreg" , "copy_reg" ) ,  MovedModule ( "dbm_gnu" , "gdbm" , "dbm.gnu" ) ,  MovedModule ( "http_cookiejar" , "cookielib" , "http.cookiejar" ) ,  MovedModule ( "http_cookies" , "Cookie" , "http.cookies" ) ,  MovedModule ( "html_entities" , "htmlentitydefs" , "html.entities" ) ,  MovedModule ( "html_parser" , "HTMLParser" , "html.parser" ) ,  MovedModule ( "http_client" , "httplib" , "http.client" ) ,  MovedModule ( "email_mime_multipart" , "email.MIMEMultipart" , "email.mime.multipart" ) ,  MovedModule ( "email_mime_text" , "email.MIMEText" , "email.mime.text" ) ,  MovedModule ( "email_mime_base" , "email.MIMEBase" , "email.mime.base" ) ,  MovedModule ( "BaseHTTPServer" , "BaseHTTPServer" , "http.server" ) ,  MovedModule ( "CGIHTTPServer" , "CGIHTTPServer" , "http.server" ) ,  MovedModule ( "SimpleHTTPServer" , "SimpleHTTPServer" , "http.server" ) ,  MovedModule ( "cPickle" , "cPickle" , "pickle" ) ,  MovedModule ( "queue" , "Queue" ) ,  MovedModule ( "reprlib" , "repr" ) ,  MovedModule ( "socketserver" , "SocketServer" ) ,  MovedModule ( "_thread" , "thread" , "_thread" ) ,  MovedModule ( "tkinter" , "Tkinter" ) ,  MovedModule ( "tkinter_dialog" , "Dialog" , "tkinter.dialog" ) ,  MovedModule ( "tkinter_filedialog" , "FileDialog" , "tkinter.filedialog" ) ,  MovedModule ( "tkinter_scrolledtext" , "ScrolledText" , "tkinter.scrolledtext" ) ,  MovedModule ( "tkinter_simpledialog" , "SimpleDialog" , "tkinter.simpledialog" ) ,  MovedModule ( "tkinter_tix" , "Tix" , "tkinter.tix" ) ,  MovedModule ( "tkinter_ttk" , "ttk" , "tkinter.ttk" ) ,  MovedModule ( "tkinter_constants" , "Tkconstants" , "tkinter.constants" ) ,  MovedModule ( "tkinter_dnd" , "Tkdnd" , "tkinter.dnd" ) ,  MovedModule ( "tkinter_colorchooser" , "tkColorChooser" ,  "tkinter.colorchooser" ) ,  MovedModule ( "tkinter_commondialog" , "tkCommonDialog" ,  "tkinter.commondialog" ) ,  MovedModule ( "tkinter_tkfiledialog" , "tkFileDialog" , "tkinter.filedialog" ) ,  MovedModule ( "tkinter_font" , "tkFont" , "tkinter.font" ) ,  MovedModule ( "tkinter_messagebox" , "tkMessageBox" , "tkinter.messagebox" ) ,  MovedModule ( "tkinter_tksimpledialog" , "tkSimpleDialog" ,  "tkinter.simpledialog" ) ,  MovedModule ( "urllib_parse" , __name__ + ".moves.urllib_parse" , "urllib.parse" ) ,  MovedModule ( "urllib_error" , __name__ + ".moves.urllib_error" , "urllib.error" ) ,  MovedModule ( "urllib" , __name__ + ".moves.urllib" , __name__ + ".moves.urllib" ) ,  MovedModule ( "urllib_robotparser" , "robotparser" , "urllib.robotparser" ) ,  MovedModule ( "xmlrpc_client" , "xmlrpclib" , "xmlrpc.client" ) ,  MovedModule ( "xmlrpc_server" , "xmlrpclib" , "xmlrpc.server" ) ,  MovedModule ( "winreg" , "_winreg" ) ,  ]
 for attr in _moved_attributes :
      setattr ( _MovedItems , attr . name , attr )
 if isinstance ( attr , MovedModule ) :
          sys . modules [ __name__ + ".moves." + attr . name ] = attr
   del attr
  _MovedItems . _moved_attributes = _moved_attributes
  moves = sys . modules [ __name__ + ".moves" ] = _MovedItems ( __name__ + ".moves" )
   class Module_six_moves_urllib_parse ( _LazyModule ) :
    _urllib_parse_moved_attributes = [  MovedAttribute ( "ParseResult" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "SplitResult" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "parse_qs" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "parse_qsl" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urldefrag" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urljoin" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlparse" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlsplit" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlunparse" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlunsplit" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "quote" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "quote_plus" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "unquote" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "unquote_plus" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "urlencode" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "splitquery" , "urllib" , "urllib.parse" ) ,  ]
 for attr in _urllib_parse_moved_attributes :
      setattr ( Module_six_moves_urllib_parse , attr . name , attr )
  del attr
  Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_parse" ] = sys . modules [ __name__ + ".moves.urllib.parse" ] = Module_six_moves_urllib_parse ( __name__ + ".moves.urllib_parse" )
   class Module_six_moves_urllib_error ( _LazyModule ) :
    _urllib_error_moved_attributes = [  MovedAttribute ( "URLError" , "urllib2" , "urllib.error" ) ,  MovedAttribute ( "HTTPError" , "urllib2" , "urllib.error" ) ,  MovedAttribute ( "ContentTooShortError" , "urllib" , "urllib.error" ) ,  ]
 for attr in _urllib_error_moved_attributes :
      setattr ( Module_six_moves_urllib_error , attr . name , attr )
  del attr
  Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_error" ] = sys . modules [ __name__ + ".moves.urllib.error" ] = Module_six_moves_urllib_error ( __name__ + ".moves.urllib.error" )
   class Module_six_moves_urllib_request ( _LazyModule ) :
    _urllib_request_moved_attributes = [  MovedAttribute ( "urlopen" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "install_opener" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "build_opener" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "pathname2url" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "url2pathname" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "getproxies" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "Request" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "OpenerDirector" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPDefaultErrorHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPRedirectHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPCookieProcessor" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "BaseHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPPasswordMgr" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPPasswordMgrWithDefaultRealm" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "AbstractBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "AbstractDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPSHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "FileHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "FTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "CacheFTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "UnknownHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPErrorProcessor" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "urlretrieve" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "urlcleanup" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "URLopener" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "FancyURLopener" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "proxy_bypass" , "urllib" , "urllib.request" ) ,  ]
 for attr in _urllib_request_moved_attributes :
      setattr ( Module_six_moves_urllib_request , attr . name , attr )
  del attr
  Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_request" ] = sys . modules [ __name__ + ".moves.urllib.request" ] = Module_six_moves_urllib_request ( __name__ + ".moves.urllib.request" )
  class Module_six_moves_urllib_response ( _LazyModule ) :
    _urllib_response_moved_attributes = [  MovedAttribute ( "addbase" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addclosehook" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addinfo" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addinfourl" , "urllib" , "urllib.response" ) ,  ]
 for attr in _urllib_response_moved_attributes :
      setattr ( Module_six_moves_urllib_response , attr . name , attr )
  del attr
  Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_response" ] = sys . modules [ __name__ + ".moves.urllib.response" ] = Module_six_moves_urllib_response ( __name__ + ".moves.urllib.response" )
   class Module_six_moves_urllib_robotparser ( _LazyModule ) :
    _urllib_robotparser_moved_attributes = [  MovedAttribute ( "RobotFileParser" , "robotparser" , "urllib.robotparser" ) ,  ]
 for attr in _urllib_robotparser_moved_attributes :
      setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )
  del attr
  Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_robotparser" ] = sys . modules [ __name__ + ".moves.urllib.robotparser" ] = Module_six_moves_urllib_robotparser ( __name__ + ".moves.urllib.robotparser" )
   class Module_six_moves_urllib ( types . ModuleType ) :
 parse = sys . modules [ __name__ + ".moves.urllib_parse" ]
 error = sys . modules [ __name__ + ".moves.urllib_error" ]
 request = sys . modules [ __name__ + ".moves.urllib_request" ]
 response = sys . modules [ __name__ + ".moves.urllib_response" ]
 robotparser = sys . modules [ __name__ + ".moves.urllib_robotparser" ]
  def __dir__ ( self ) :
          return [ 'parse' , 'error' , 'request' , 'response' , 'robotparser' ]
     sys . modules [ __name__ + ".moves.urllib" ] = Module_six_moves_urllib ( __name__ + ".moves.urllib" )
   def add_move ( move ) :
 setattr ( _MovedItems , move . name , move )
    def remove_move ( name ) :
 try :
          delattr ( _MovedItems , name )
  except AttributeError :
          try :
              del moves . __dict__ [ name ]
  except KeyError :
              raise AttributeError ( "no such move, %r" % ( name , ) )
      if PY3 :
      _meth_func = "__func__"
 _meth_self = "__self__"
  _func_closure = "__closure__"
 _func_code = "__code__"
 _func_defaults = "__defaults__"
 _func_globals = "__globals__"
  _iterkeys = "keys"
 _itervalues = "values"
 _iteritems = "items"
 _iterlists = "lists"
  else :
      _meth_func = "im_func"
 _meth_self = "im_self"
  _func_closure = "func_closure"
 _func_code = "func_code"
 _func_defaults = "func_defaults"
 _func_globals = "func_globals"
  _iterkeys = "iterkeys"
 _itervalues = "itervalues"
 _iteritems = "iteritems"
 _iterlists = "iterlists"
    try :
      advance_iterator = next
  except NameError :
      def advance_iterator ( it ) :
          return it . next ( )
   next = advance_iterator
   try :
      callable = callable
  except NameError :
      def callable ( obj ) :
          return any ( "__call__" in klass . __dict__ for klass in type ( obj ) . __mro__ )
     if PY3 :
      def get_unbound_function ( unbound ) :
          return unbound
   create_bound_method = types . MethodType
  Iterator = object
  else :
      def get_unbound_function ( unbound ) :
          return unbound . im_func
   def create_bound_method ( func , obj ) :
          return types . MethodType ( func , obj , obj . __class__ )
   class Iterator ( object ) :
           def next ( self ) :
              return type ( self ) . __next__ ( self )
    callable = callable
  _add_doc ( get_unbound_function ,  """Get the function out of a possibly unbound function""" )
   get_method_function = operator . attrgetter ( _meth_func )
 get_method_self = operator . attrgetter ( _meth_self )
 get_function_closure = operator . attrgetter ( _func_closure )
 get_function_code = operator . attrgetter ( _func_code )
 get_function_defaults = operator . attrgetter ( _func_defaults )
 get_function_globals = operator . attrgetter ( _func_globals )
   def iterkeys ( d , ** kw ) :
 return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
   def itervalues ( d , ** kw ) :
 return iter ( getattr ( d , _itervalues ) ( ** kw ) )
   def iteritems ( d , ** kw ) :
 return iter ( getattr ( d , _iteritems ) ( ** kw ) )
   def iterlists ( d , ** kw ) :
 return iter ( getattr ( d , _iterlists ) ( ** kw ) )
    if PY3 :
      def b ( s ) :
          return s . encode ( "latin-1" )
  def u ( s ) :
          return s
  unichr = chr
 if sys . version_info [ 1 ] <= 1 :
          def int2byte ( i ) :
              return bytes ( ( i , ) )
   else :
           int2byte = operator . methodcaller ( "to_bytes" , 1 , "big" )
  byte2int = operator . itemgetter ( 0 )
 indexbytes = operator . getitem
 iterbytes = iter
 import io
 StringIO = io . StringIO
 BytesIO = io . BytesIO
  else :
      def b ( s ) :
          return s
   def u ( s ) :
          return unicode ( s . replace ( r'\\' , r'\\\\' ) , "unicode_escape" )
  unichr = unichr
 int2byte = chr
 def byte2int ( bs ) :
          return ord ( bs [ 0 ] )
  def indexbytes ( buf , i ) :
          return ord ( buf [ i ] )
  def iterbytes ( buf ) :
          return ( ord ( byte ) for byte in buf )
  import StringIO
 StringIO = BytesIO = StringIO . StringIO
  _add_doc ( b , """Byte literal""" )
 _add_doc ( u , """Text literal""" )
   if PY3 :
      exec_ = getattr ( moves . builtins , "exec" )
   def reraise ( tp , value , tb = None ) :
          if value . __traceback__ is not tb :
              raise value . with_traceback ( tb )
  raise value
    else :
      def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
 if _globs_ is None :
              frame = sys . _getframe ( 1 )
 _globs_ = frame . f_globals
 if _locs_ is None :
                  _locs_ = frame . f_locals
  del frame
  elif _locs_ is None :
              _locs_ = _globs_
  exec ( """exec _code_ in _globs_, _locs_""" )
    exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
  return ' ' . join ( words )
   def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
 if words and length <= 0 :
              return ''
   html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
   pos = 0
 end_text_pos = 0
 current_len = 0
 open_tags = [ ]
  regex = re_words if words else re_chars
  while current_len <= length :
              m = regex . search ( text , pos )
 if not m :
                   break
  pos = m . end ( 0 )
 if m . group ( 1 ) :
                   current_len += 1
 if current_len == truncate_len :
                      end_text_pos = pos
  continue
   tag = re_tag . match ( m . group ( 0 ) )
 if not tag or current_len >= truncate_len :
                   continue
  closing_tag , tagname , self_closing = tag . groups ( )
  tagname = tagname . lower ( )
 if self_closing or tagname in html4_singlets :
                  pass
  elif closing_tag :
                   try :
                      i = open_tags . index ( tagname )
  except ValueError :
                      pass
  else :
                        open_tags = open_tags [ i + 1 : ]
   else :
                   open_tags . insert ( 0 , tagname )
    if current_len <= length :
              return text
  out = text [ : end_text_pos ]
 truncate_text = self . add_truncation_text ( '' , truncate )
 if truncate_text :
              out += truncate_text
   for tag in open_tags :
              out += '</%s>' % tag
   return out
     def get_valid_filename ( s ) :
 s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )
 return re . sub ( r'(?u)[^-\w.]' , '' , s )
  get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
   def get_text_list ( list_ , last_word = ugettext_lazy ( 'or' ) ) :
 if len ( list_ ) == 0 :
          return ''
  if len ( list_ ) == 1 :
          return force_text ( list_ [ 0 ] )
  return '%s %s %s' % (   _ ( ', ' ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) ,  force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )
  get_text_list = allow_lazy ( get_text_list , six . text_type )
   def normalize_newlines ( text ) :
 text = force_text ( text )
 return re_newlines . sub ( '\n' , text )
  normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
   def phone2numeric ( phone ) :
 char2number = { 'a' : '2' , 'b' : '2' , 'c' : '2' , 'd' : '3' , 'e' : '3' , 'f' : '3' ,  'g' : '4' , 'h' : '4' , 'i' : '4' , 'j' : '5' , 'k' : '5' , 'l' : '5' , 'm' : '6' ,  'n' : '6' , 'o' : '6' , 'p' : '7' , 'q' : '7' , 'r' : '7' , 's' : '7' , 't' : '8' ,  'u' : '8' , 'v' : '8' , 'w' : '9' , 'x' : '9' , 'y' : '9' , 'z' : '9' }
 return '' . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
  phone2numeric = allow_lazy ( phone2numeric )
     def compress_string ( s ) :
      zbuf = BytesIO ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = zbuf )
 zfile . write ( s )
 zfile . close ( )
 return zbuf . getvalue ( )
    class StreamingBuffer ( object ) :
      def __init__ ( self ) :
          self . vals = [ ]
   def write ( self , val ) :
          self . vals . append ( val )
   def read ( self ) :
          ret = b'' . join ( self . vals )
 self . vals = [ ]
 return ret
   def flush ( self ) :
          return
   def close ( self ) :
          return
      def compress_sequence ( sequence ) :
      buf = StreamingBuffer ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )
  yield buf . read ( )
 for item in sequence :
          zfile . write ( item )
 zfile . flush ( )
 yield buf . read ( )
  zfile . close ( )
 yield buf . read ( )
   ustring_re = re . compile ( "([\u0080-\uffff])" )
   def javascript_quote ( s , quote_double_quotes = False ) :
      msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
 warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
  def fix ( match ) :
          return "\\u%04x" % ord ( match . group ( 1 ) )
   if type ( s ) == bytes :
          s = s . decode ( 'utf-8' )
  elif type ( s ) != six . text_type :
          raise TypeError ( s )
  s = s . replace ( '\\' , '\\\\' )
 s = s . replace ( '\r' , '\\r' )
 s = s . replace ( '\n' , '\\n' )
 s = s . replace ( '\t' , '\\t' )
 s = s . replace ( "'" , "\\'" )
 s = s . replace ( '</' , '<\\/' )
 if quote_double_quotes :
          s = s . replace ( '"' , '&quot;' )
  return ustring_re . sub ( fix , s )
  javascript_quote = allow_lazy ( javascript_quote , six . text_type )
    smart_split_re = re . compile ( r"""     ((?:         [^\s'"]*         (?:             (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) """ , re . VERBOSE )
   def smart_split ( text ) :
 text = force_text ( text )
 for bit in smart_split_re . finditer ( text ) :
          yield bit . group ( 0 )
     def _replace_entity ( match ) :
      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
  return six . unichr ( c )
  except ValueError :
              return match . group ( 0 )
   else :
          try :
              return six . unichr ( html_entities . name2codepoint [ text ] )
  except ( ValueError , KeyError ) :
              return match . group ( 0 )
     _entity_re = re . compile ( r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));" )
   def unescape_entities ( text ) :
      return _entity_re . sub ( _replace_entity , text )
  unescape_entities = allow_lazy ( unescape_entities , six . text_type )
   def unescape_string_literal ( s ) :
 if s [ 0 ] not in "\"'" or s [ - 1 ] != s [ 0 ] :
          raise ValueError ( "Not a string literal: %r" % s )
  quote = s [ 0 ]
 return s [ 1 : - 1 ] . replace ( r'\%s' % quote , quote ) . replace ( r'\\' , '\\' )
  unescape_string_literal = allow_lazy ( unescape_string_literal )
   def slugify ( value ) :
 value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' )
 value = re . sub ( '[^\w\s-]' , '' , value ) . strip ( ) . lower ( )
 return mark_safe ( re . sub ( '[-\s]+' , '-' , value ) )
  slugify = allow_lazy ( slugify , six . text_type )
   def camel_case_to_spaces ( value ) :
 return re_camel_case . sub ( r' \1' , value ) . strip ( ) . lower ( )
from __future__ import unicode_literals
  import datetime
  from django . utils . html import avoid_wrapping
 from django . utils . timezone import is_aware , utc
 from django . utils . translation import ugettext , ungettext_lazy
   def timesince ( d , now = None , reversed = False ) :
 chunks = (  ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d year' , '%d years' ) ) ,  ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d month' , '%d months' ) ) ,  ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d week' , '%d weeks' ) ) ,  ( 60 * 60 * 24 , ungettext_lazy ( '%d day' , '%d days' ) ) ,  ( 60 * 60 , ungettext_lazy ( '%d hour' , '%d hours' ) ) ,  ( 60 , ungettext_lazy ( '%d minute' , '%d minutes' ) )  )
   if not isinstance ( d , datetime . datetime ) :
          d = datetime . datetime ( d . year , d . month , d . day )
  if now and not isinstance ( now , datetime . datetime ) :
          now = datetime . datetime ( now . year , now . month , now . day )
   if not now :
          now = datetime . datetime . now ( utc if is_aware ( d ) else None )
   delta = ( d - now ) if reversed else ( now - d )
  since = delta . days * 24 * 60 * 60 + delta . seconds
 if since <= 0 :
           return avoid_wrapping ( ugettext ( '0 minutes' ) )
  for i , ( seconds , name ) in enumerate ( chunks ) :
          count = since // seconds
 if count != 0 :
              break
   result = avoid_wrapping ( name % count )
 if i + 1 < len ( chunks ) :
           seconds2 , name2 = chunks [ i + 1 ]
 count2 = ( since - ( seconds * count ) ) // seconds2
 if count2 != 0 :
              result += ugettext ( ', ' ) + avoid_wrapping ( name2 % count2 )
   return result
    def timeuntil ( d , now = None ) :
 return timesince ( d , now , reversed = True )
  from datetime import datetime , timedelta , tzinfo
 from threading import local
 import sys
 import time as _time
  try :
      import pytz
  except ImportError :
      pytz = None
   from django . conf import settings
 from django . utils import six
  __all__ = [  'utc' , 'get_fixed_timezone' ,  'get_default_timezone' , 'get_default_timezone_name' ,  'get_current_timezone' , 'get_current_timezone_name' ,  'activate' , 'deactivate' , 'override' ,  'localtime' , 'now' ,  'is_aware' , 'is_naive' , 'make_aware' , 'make_naive' ,  ]
     ZERO = timedelta ( 0 )
   class UTC ( tzinfo ) :
  def __repr__ ( self ) :
          return "<UTC>"
   def utcoffset ( self , dt ) :
          return ZERO
   def tzname ( self , dt ) :
          return "UTC"
   def dst ( self , dt ) :
          return ZERO
     class FixedOffset ( tzinfo ) :
  def __init__ ( self , offset = None , name = None ) :
          if offset is not None :
              self . __offset = timedelta ( minutes = offset )
  if name is not None :
              self . __name = name
    def utcoffset ( self , dt ) :
          return self . __offset
   def tzname ( self , dt ) :
          return self . __name
   def dst ( self , dt ) :
          return ZERO
     class ReferenceLocalTimezone ( tzinfo ) :
  def __init__ ( self ) :
          self . STDOFFSET = timedelta ( seconds = - _time . timezone )
 if _time . daylight :
              self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
  else :
              self . DSTOFFSET = self . STDOFFSET
  self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
 tzinfo . __init__ ( self )
   def utcoffset ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTOFFSET
  else :
              return self . STDOFFSET
    def dst ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTDIFF
  else :
              return ZERO
    def tzname ( self , dt ) :
          return _time . tzname [ self . _isdst ( dt ) ]
   def _isdst ( self , dt ) :
          tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )
 stamp = _time . mktime ( tt )
 tt = _time . localtime ( stamp )
 return tt . tm_isdst > 0
     class LocalTimezone ( ReferenceLocalTimezone ) :
  def tzname ( self , dt ) :
          is_dst = False if dt is None else self . _isdst ( dt )
 return _time . tzname [ is_dst ]
   def _isdst ( self , dt ) :
          try :
              return super ( LocalTimezone , self ) . _isdst ( dt )
  except ( OverflowError , ValueError ) as exc :
              exc_type = type ( exc )
 exc_value = exc_type (  "Unsupported value: %r. You should install pytz." % dt )
 exc_value . __cause__ = exc
 six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
     utc = pytz . utc if pytz else UTC ( )
   def get_fixed_timezone ( offset ) :
 if isinstance ( offset , timedelta ) :
          offset = offset . seconds // 60
  sign = '-' if offset < 0 else '+'
 hhmm = '%02d%02d' % divmod ( abs ( offset ) , 60 )
 name = sign + hhmm
 return FixedOffset ( offset , name )
     _localtime = None
   def get_default_timezone ( ) :
 global _localtime
 if _localtime is None :
          if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
              _localtime = pytz . timezone ( settings . TIME_ZONE )
  else :
               _localtime = LocalTimezone ( )
   return _localtime
     def get_default_timezone_name ( ) :
 return _get_timezone_name ( get_default_timezone ( ) )
   _active = local ( )
   def get_current_timezone ( ) :
 return getattr ( _active , "value" , get_default_timezone ( ) )
    def get_current_timezone_name ( ) :
 return _get_timezone_name ( get_current_timezone ( ) )
    def _get_timezone_name ( timezone ) :
 try :
           return timezone . zone
  except AttributeError :
           return timezone . tzname ( None )
          def activate ( timezone ) :
 if isinstance ( timezone , tzinfo ) :
          _active . value = timezone
  elif isinstance ( timezone , six . string_types ) and pytz is not None :
          _active . value = pytz . timezone ( timezone )
  else :
          raise ValueError ( "Invalid timezone: %r" % timezone )
     def deactivate ( ) :
 if hasattr ( _active , "value" ) :
          del _active . value
     class override ( object ) :
 def __init__ ( self , timezone ) :
          self . timezone = timezone
 self . old_timezone = getattr ( _active , 'value' , None )
   def __enter__ ( self ) :
          if self . timezone is None :
              deactivate ( )
  else :
              activate ( self . timezone )
    def __exit__ ( self , exc_type , exc_value , traceback ) :
          if self . old_timezone is None :
              deactivate ( )
  else :
              _active . value = self . old_timezone
        def template_localtime ( value , use_tz = None ) :
 should_convert = ( isinstance ( value , datetime )  and ( settings . USE_TZ if use_tz is None else use_tz )  and not is_naive ( value )  and getattr ( value , 'convert_to_local_time' , True ) )
 return localtime ( value ) if should_convert else value
      def localtime ( value , timezone = None ) :
 if timezone is None :
          timezone = get_current_timezone ( )
    value = value . astimezone ( timezone )
 if hasattr ( timezone , 'normalize' ) :
           value = timezone . normalize ( value )
  return value
    def now ( ) :
 if settings . USE_TZ :
           return datetime . utcnow ( ) . replace ( tzinfo = utc )
  else :
          return datetime . now ( )
        def is_aware ( value ) :
 return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
    def is_naive ( value ) :
 return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
   def make_aware ( value , timezone ) :
 if hasattr ( timezone , 'localize' ) :
           return timezone . localize ( value , is_dst = None )
  else :
           if is_aware ( value ) :
              raise ValueError (  "make_aware expects a naive datetime, got %s" % value )
   return value . replace ( tzinfo = timezone )
     def make_naive ( value , timezone ) :
   value = value . astimezone ( timezone )
 if hasattr ( timezone , 'normalize' ) :
           value = timezone . normalize ( value )
  return value . replace ( tzinfo = None )
 from __future__ import unicode_literals
 import re
 from django . utils . encoding import force_text
 from django . utils . functional import lazy
 from django . utils import six
   __all__ = [  'activate' , 'deactivate' , 'override' , 'deactivate_all' ,  'get_language' , 'get_language_from_request' ,  'get_language_info' , 'get_language_bidi' ,  'check_for_language' , 'to_locale' , 'templatize' , 'string_concat' ,  'gettext' , 'gettext_lazy' , 'gettext_noop' ,  'ugettext' , 'ugettext_lazy' , 'ugettext_noop' ,  'ngettext' , 'ngettext_lazy' ,  'ungettext' , 'ungettext_lazy' ,  'pgettext' , 'pgettext_lazy' ,  'npgettext' , 'npgettext_lazy' ,  'LANGUAGE_SESSION_KEY' ,  ]
  LANGUAGE_SESSION_KEY = '_language'
   class TranslatorCommentWarning ( SyntaxWarning ) :
      pass
            class Trans ( object ) :
  def __getattr__ ( self , real_name ) :
          from django . conf import settings
 if settings . USE_I18N :
              from django . utils . translation import trans_real as trans
  else :
              from django . utils . translation import trans_null as trans
  setattr ( self , real_name , getattr ( trans , real_name ) )
 return getattr ( trans , real_name )
    _trans = Trans ( )
   del Trans
   def gettext_noop ( message ) :
      return _trans . gettext_noop ( message )
   ugettext_noop = gettext_noop
   def gettext ( message ) :
      return _trans . gettext ( message )
    def ngettext ( singular , plural , number ) :
      return _trans . ngettext ( singular , plural , number )
    def ugettext ( message ) :
      return _trans . ugettext ( message )
    def ungettext ( singular , plural , number ) :
      return _trans . ungettext ( singular , plural , number )
    def pgettext ( context , message ) :
      return _trans . pgettext ( context , message )
    def npgettext ( context , singular , plural , number ) :
      return _trans . npgettext ( context , singular , plural , number )
   gettext_lazy = lazy ( gettext , str )
 ugettext_lazy = lazy ( ugettext , six . text_type )
 pgettext_lazy = lazy ( pgettext , six . text_type )
   def lazy_number ( func , resultclass , number = None , ** kwargs ) :
      if isinstance ( number , int ) :
          kwargs [ 'number' ] = number
 proxy = lazy ( func , resultclass ) ( ** kwargs )
  else :
          class NumberAwareString ( resultclass ) :
              def __mod__ ( self , rhs ) :
                  if isinstance ( rhs , dict ) and number :
                      try :
                          number_value = rhs [ number ]
  except KeyError :
                          raise KeyError ( 'Your dictionary lacks key \'%s\'. '  'Please provide it, because it is required to '  'determine whether string is singular or plural.'  % number )
   else :
                      number_value = rhs
  kwargs [ 'number' ] = number_value
 translated = func ( ** kwargs )
 try :
                      translated = translated % rhs
  except TypeError :
                       pass
  return translated
    proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )
  return proxy
    def ngettext_lazy ( singular , plural , number = None ) :
      return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )
    def ungettext_lazy ( singular , plural , number = None ) :
      return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )
    def npgettext_lazy ( context , singular , plural , number = None ) :
      return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )
    def activate ( language ) :
      return _trans . activate ( language )
    def deactivate ( ) :
      return _trans . deactivate ( )
    class override ( object ) :
      def __init__ ( self , language , deactivate = False ) :
          self . language = language
 self . deactivate = deactivate
 self . old_language = get_language ( )
   def __enter__ ( self ) :
          if self . language is not None :
              activate ( self . language )
  else :
              deactivate_all ( )
    def __exit__ ( self , exc_type , exc_value , traceback ) :
          if self . deactivate :
              deactivate ( )
  else :
              activate ( self . old_language )
      def get_language ( ) :
      return _trans . get_language ( )
    def get_language_bidi ( ) :
      return _trans . get_language_bidi ( )
    def check_for_language ( lang_code ) :
      return _trans . check_for_language ( lang_code )
    def to_locale ( language ) :
      return _trans . to_locale ( language )
    def get_language_from_request ( request , check_path = False ) :
      return _trans . get_language_from_request ( request , check_path )
    def get_language_from_path ( path ) :
      return _trans . get_language_from_path ( path )
    def templatize ( src , origin = None ) :
      return _trans . templatize ( src , origin )
    def deactivate_all ( ) :
      return _trans . deactivate_all ( )
    def _string_concat ( * strings ) :
 return '' . join ( force_text ( s ) for s in strings )
  string_concat = lazy ( _string_concat , six . text_type )
   def get_language_info ( lang_code ) :
      from django . conf . locale import LANG_INFO
 try :
          return LANG_INFO [ lang_code ]
  except KeyError :
          if '-' not in lang_code :
              raise KeyError ( "Unknown language code %s." % lang_code )
  generic_lang_code = lang_code . split ( '-' ) [ 0 ]
 try :
              return LANG_INFO [ generic_lang_code ]
  except KeyError :
              raise KeyError ( "Unknown language code %s and %s." % ( lang_code , generic_lang_code ) )
     trim_whitespace_re = re . compile ( '\s*\n\s*' )
   def trim_whitespace ( s ) :
      return trim_whitespace_re . sub ( ' ' , s . strip ( ) )
    from django . conf import settings
 from django . utils . encoding import force_text
 from django . utils . safestring import mark_safe , SafeData
   def ngettext ( singular , plural , number ) :
      if number == 1 :
          return singular
  return plural
  ngettext_lazy = ngettext
   def ungettext ( singular , plural , number ) :
      return force_text ( ngettext ( singular , plural , number ) )
    def pgettext ( context , message ) :
      return ugettext ( message )
    def npgettext ( context , singular , plural , number ) :
      return ungettext ( singular , plural , number )
   activate = lambda x : None
 deactivate = deactivate_all = lambda : None
 get_language = lambda : settings . LANGUAGE_CODE
 get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI
 check_for_language = lambda x : True
   def gettext ( message ) :
      if isinstance ( message , SafeData ) :
          return mark_safe ( message )
  return message
    def ugettext ( message ) :
      return force_text ( gettext ( message ) )
   gettext_noop = gettext_lazy = _ = gettext
   def to_locale ( language ) :
      p = language . find ( '-' )
 if p >= 0 :
          return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( )
  else :
          return language . lower ( )
     def get_language_from_request ( request , check_path = False ) :
      return settings . LANGUAGE_CODE
    def get_language_from_path ( request ) :
      return None
 from __future__ import unicode_literals
  from collections import OrderedDict
 import os
 import re
 import sys
 import gettext as gettext_module
 from threading import local
 import warnings
  from django . apps import apps
 from django . conf import settings
 from django . core . exceptions import AppRegistryNotReady
 from django . dispatch import receiver
 from django . test . signals import setting_changed
 from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . _os import upath
 from django . utils . safestring import mark_safe , SafeData
 from django . utils import six , lru_cache
 from django . utils . six import StringIO
 from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY
     _translations = { }
 _active = local ( )
   _default = None
    _supported = None
   CONTEXT_SEPARATOR = "\x04"
    accept_language_re = re . compile ( r'''         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))?   # Optional "q=1.00", "q=0.8"         (?:\s*,\s*|$)                                 # Multiple accepts per header.         ''' , re . VERBOSE )
  language_code_re = re . compile ( r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$' , re . IGNORECASE )
  language_code_prefix_re = re . compile ( r'^/([\w-]+)(/|$)' )
   _BROWSERS_DEPRECATED_LOCALES = {  'zh-cn' : 'zh-hans' ,  'zh-tw' : 'zh-hant' ,  }
  _DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
   @ receiver ( setting_changed )
 def reset_cache ( ** kwargs ) :
 if kwargs [ 'setting' ] in ( 'LANGUAGES' , 'LANGUAGE_CODE' ) :
          global _supported
 _supported = None
 check_for_language . cache_clear ( )
 get_supported_language_variant . cache_clear ( )
     def to_locale ( language , to_lower = False ) :
 p = language . find ( '-' )
 if p >= 0 :
          if to_lower :
              return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . lower ( )
  else :
               if len ( language [ p + 1 : ] ) > 2 :
                  return language [ : p ] . lower ( ) + '_' + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )
  return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( )
   else :
          return language . lower ( )
     def to_language ( locale ) :
 p = locale . find ( '_' )
 if p >= 0 :
          return locale [ : p ] . lower ( ) + '-' + locale [ p + 1 : ] . lower ( )
  else :
          return locale . lower ( )
     class DjangoTranslation ( gettext_module . GNUTranslations ) :
 def __init__ ( self , language ) :
 gettext_module . GNUTranslations . __init__ ( self )
  self . __language = language
 self . __to_language = to_language ( language )
 self . __locale = to_locale ( language )
 self . plural = lambda n : int ( n != 1 )
  self . _init_translation_catalog ( )
 self . _add_installed_apps_translations ( )
 self . _add_local_translations ( )
 self . _add_fallback ( )
   def __repr__ ( self ) :
          return "<DjangoTranslation lang:%s>" % self . __language
   def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
 translation = gettext_module . translation (  domain = 'django' ,  localedir = localedir ,  languages = [ self . __locale ] ,  codeset = 'utf-8' ,  fallback = use_null_fallback )
 if not hasattr ( translation , '_catalog' ) :
               translation . _catalog = { }
 translation . _info = { }
  return translation
   def _init_translation_catalog ( self ) :
 settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )
 localedir = os . path . join ( os . path . dirname ( settingsfile ) , 'locale' )
 use_null_fallback = True
 if self . __language == settings . LANGUAGE_CODE :
                use_null_fallback = False
  translation = self . _new_gnu_trans ( localedir , use_null_fallback )
 self . _info = translation . _info . copy ( )
 self . _catalog = translation . _catalog . copy ( )
   def _add_installed_apps_translations ( self ) :
 try :
              app_configs = reversed ( list ( apps . get_app_configs ( ) ) )
  except AppRegistryNotReady :
              raise AppRegistryNotReady (  "The translation infrastructure cannot be initialized before the "  "apps registry is ready. Check that you don't make non-lazy "  "gettext calls at import time." )
  for app_config in app_configs :
              localedir = os . path . join ( app_config . path , 'locale' )
 translation = self . _new_gnu_trans ( localedir )
 self . merge ( translation )
    def _add_local_translations ( self ) :
 for localedir in reversed ( settings . LOCALE_PATHS ) :
              translation = self . _new_gnu_trans ( localedir )
 self . merge ( translation )
    def _add_fallback ( self ) :
     if self . __language == settings . LANGUAGE_CODE or self . __language == "en-us" :
              return
  default_translation = translation ( settings . LANGUAGE_CODE )
 self . add_fallback ( default_translation )
   def merge ( self , other ) :
 self . _catalog . update ( other . _catalog )
   def language ( self ) :
 return self . __language
   def to_language ( self ) :
 return self . __to_language
     def translation ( language ) :
 global _translations
 if language not in _translations :
          _translations [ language ] = DjangoTranslation ( language )
  return _translations [ language ]
    def activate ( language ) :
 if language in _DJANGO_DEPRECATED_LOCALES :
          msg = ( "The use of the language code '%s' is deprecated. "  "Please use the '%s' translation instead." )
 warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) ,  RemovedInDjango19Warning , stacklevel = 2 )
  _active . value = translation ( language )
    def deactivate ( ) :
 if hasattr ( _active , "value" ) :
          del _active . value
     def deactivate_all ( ) :
 _active . value = gettext_module . NullTranslations ( )
    def get_language ( ) :
 t = getattr ( _active , "value" , None )
 if t is not None :
          try :
              return t . to_language ( )
  except AttributeError :
              pass
    return settings . LANGUAGE_CODE
    def get_language_bidi ( ) :
 base_lang = get_language ( ) . split ( '-' ) [ 0 ]
 return base_lang in settings . LANGUAGES_BIDI
    def catalog ( ) :
 global _default
  t = getattr ( _active , "value" , None )
 if t is not None :
          return t
  if _default is None :
          _default = translation ( settings . LANGUAGE_CODE )
  return _default
    def do_translate ( message , translation_function ) :
 global _default
   eol_message = message . replace ( str ( '\r\n' ) , str ( '\n' ) ) . replace ( str ( '\r' ) , str ( '\n' ) )
 t = getattr ( _active , "value" , None )
 if t is not None :
          result = getattr ( t , translation_function ) ( eol_message )
  else :
          if _default is None :
              _default = translation ( settings . LANGUAGE_CODE )
  result = getattr ( _default , translation_function ) ( eol_message )
  if isinstance ( message , SafeData ) :
          return mark_safe ( result )
  return result
    def gettext ( message ) :
 return do_translate ( message , 'gettext' )
   if six . PY3 :
      ugettext = gettext
  else :
      def ugettext ( message ) :
          return do_translate ( message , 'ugettext' )
     def pgettext ( context , message ) :
      msg_with_ctxt = "%s%s%s" % ( context , CONTEXT_SEPARATOR , message )
 result = ugettext ( msg_with_ctxt )
 if CONTEXT_SEPARATOR in result :
            result = force_text ( message )
  return result
    def gettext_noop ( message ) :
 return message
    def do_ntranslate ( singular , plural , number , translation_function ) :
      global _default
  t = getattr ( _active , "value" , None )
 if t is not None :
          return getattr ( t , translation_function ) ( singular , plural , number )
  if _default is None :
          _default = translation ( settings . LANGUAGE_CODE )
  return getattr ( _default , translation_function ) ( singular , plural , number )
    def ngettext ( singular , plural , number ) :
 return do_ntranslate ( singular , plural , number , 'ngettext' )
   if six . PY3 :
      ungettext = ngettext
  else :
      def ungettext ( singular , plural , number ) :
 return do_ntranslate ( singular , plural , number , 'ungettext' )
     def npgettext ( context , singular , plural , number ) :
      msgs_with_ctxt = ( "%s%s%s" % ( context , CONTEXT_SEPARATOR , singular ) ,  "%s%s%s" % ( context , CONTEXT_SEPARATOR , plural ) ,  number )
 result = ungettext ( * msgs_with_ctxt )
 if CONTEXT_SEPARATOR in result :
           result = ungettext ( singular , plural , number )
  return result
    def all_locale_paths ( ) :
 globalpath = os . path . join (  os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , 'locale' )
 return [ globalpath ] + list ( settings . LOCALE_PATHS )
    @ lru_cache . lru_cache ( maxsize = 1000 )
 def check_for_language ( lang_code ) :
  if not language_code_re . search ( lang_code ) :
          return False
  for path in all_locale_paths ( ) :
          if gettext_module . find ( 'django' , path , [ to_locale ( lang_code ) ] ) is not None :
              return True
   return False
    @ lru_cache . lru_cache ( maxsize = 1000 )
 def get_supported_language_variant ( lang_code , strict = False ) :
 global _supported
 if _supported is None :
          _supported = OrderedDict ( settings . LANGUAGES )
  if lang_code :
           replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
 if lang_code not in _supported and replacement in _supported :
              return replacement
   generic_lang_code = lang_code . split ( '-' ) [ 0 ]
 for code in ( lang_code , generic_lang_code ) :
              if code in _supported and check_for_language ( code ) :
                  return code
   if not strict :
               for supported_code in _supported :
                  if supported_code . startswith ( generic_lang_code + '-' ) :
                      return supported_code
     raise LookupError ( lang_code )
    def get_language_from_path ( path , strict = False ) :
 regex_match = language_code_prefix_re . match ( path )
 if not regex_match :
          return None
  lang_code = regex_match . group ( 1 )
 try :
          return get_supported_language_variant ( lang_code , strict = strict )
  except LookupError :
          return None
     def get_language_from_request ( request , check_path = False ) :
 global _supported
 if _supported is None :
          _supported = OrderedDict ( settings . LANGUAGES )
   if check_path :
          lang_code = get_language_from_path ( request . path_info )
 if lang_code is not None :
              return lang_code
    if hasattr ( request , 'session' ) :
          lang_code = request . session . get ( LANGUAGE_SESSION_KEY )
 if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) :
              return lang_code
    lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )
  try :
          return get_supported_language_variant ( lang_code )
  except LookupError :
          pass
   accept = request . META . get ( 'HTTP_ACCEPT_LANGUAGE' , '' )
 for accept_lang , unused in parse_accept_lang_header ( accept ) :
          if accept_lang == '*' :
              break
   if not language_code_re . search ( accept_lang ) :
              continue
   try :
              return get_supported_language_variant ( accept_lang )
  except LookupError :
              continue
    try :
          return get_supported_language_variant ( settings . LANGUAGE_CODE )
  except LookupError :
          return settings . LANGUAGE_CODE
    dot_re = re . compile ( r'\S' )
   def blankout ( src , char ) :
 return dot_re . sub ( char , src )
    context_re = re . compile ( r"""^\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?'))\s*""" )
 inline_re = re . compile ( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))(\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?')))?\s*""" )
 block_re = re . compile ( r"""^\s*blocktrans(\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?')))?(?:\s+|$)""" )
 endblock_re = re . compile ( r"""^\s*endblocktrans$""" )
 plural_re = re . compile ( r"""^\s*plural$""" )
 constant_re = re . compile ( r"""_\(((?:".*?")|(?:'.*?'))\)""" )
 one_percent_re = re . compile ( r"""(?<!%)%(?!%)""" )
   def templatize ( src , origin = None ) :
 from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK ,  TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK )
 src = force_text ( src , settings . FILE_CHARSET )
 out = StringIO ( '' )
 message_context = None
 intrans = False
 inplural = False
 trimmed = False
 singular = [ ]
 plural = [ ]
 incomment = False
 comment = [ ]
 lineno_comment_map = { }
 comment_lineno_cache = None
  def join_tokens ( tokens , trim = False ) :
          message = '' . join ( tokens )
 if trim :
              message = trim_whitespace ( message )
  return message
   for t in Lexer ( src , origin ) . tokenize ( ) :
          if incomment :
              if t . token_type == TOKEN_BLOCK and t . contents == 'endcomment' :
                  content = '' . join ( comment )
 translators_comment_start = None
 for lineno , line in enumerate ( content . splitlines ( True ) ) :
                      if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
                          translators_comment_start = lineno
   for lineno , line in enumerate ( content . splitlines ( True ) ) :
                      if translators_comment_start is not None and lineno >= translators_comment_start :
                          out . write ( ' # %s' % line )
  else :
                          out . write ( ' #\n' )
   incomment = False
 comment = [ ]
  else :
                  comment . append ( t . contents )
   elif intrans :
              if t . token_type == TOKEN_BLOCK :
                  endbmatch = endblock_re . match ( t . contents )
 pluralmatch = plural_re . match ( t . contents )
 if endbmatch :
                      if inplural :
                          if message_context :
                              out . write ( ' npgettext(%r, %r, %r,count) ' % (  message_context ,  join_tokens ( singular , trimmed ) ,  join_tokens ( plural , trimmed ) ) )
  else :
                              out . write ( ' ngettext(%r, %r, count) ' % (  join_tokens ( singular , trimmed ) ,  join_tokens ( plural , trimmed ) ) )
  for part in singular :
                              out . write ( blankout ( part , 'S' ) )
  for part in plural :
                              out . write ( blankout ( part , 'P' ) )
   else :
                          if message_context :
                              out . write ( ' pgettext(%r, %r) ' % (  message_context ,  join_tokens ( singular , trimmed ) ) )
  else :
                              out . write ( ' gettext(%r) ' % join_tokens ( singular ,  trimmed ) )
  for part in singular :
                              out . write ( blankout ( part , 'S' ) )
   message_context = None
 intrans = False
 inplural = False
 singular = [ ]
 plural = [ ]
  elif pluralmatch :
                      inplural = True
  else :
                      filemsg = ''
 if origin :
                          filemsg = 'file %s, ' % origin
  raise SyntaxError ( "Translation blocks must not include other block tags: %s (%sline %d)" % ( t . contents , filemsg , t . lineno ) )
   elif t . token_type == TOKEN_VAR :
                  if inplural :
                      plural . append ( '%%(%s)s' % t . contents )
  else :
                      singular . append ( '%%(%s)s' % t . contents )
   elif t . token_type == TOKEN_TEXT :
                  contents = one_percent_re . sub ( '%%' , t . contents )
 if inplural :
                      plural . append ( contents )
  else :
                      singular . append ( contents )
     else :
                if comment_lineno_cache is not None :
                  cur_lineno = t . lineno + t . contents . count ( '\n' )
 if comment_lineno_cache == cur_lineno :
                      if t . token_type != TOKEN_COMMENT :
                          for c in lineno_comment_map [ comment_lineno_cache ] :
                              filemsg = ''
 if origin :
                                  filemsg = 'file %s, ' % origin
  warn_msg = ( "The translator-targeted comment '%s' "  "(%sline %d) was ignored, because it wasn't the last item "  "on the line." ) % ( c , filemsg , comment_lineno_cache )
 warnings . warn ( warn_msg , TranslatorCommentWarning )
  lineno_comment_map [ comment_lineno_cache ] = [ ]
   else :
                      out . write ( '# %s' % ' | ' . join ( lineno_comment_map [ comment_lineno_cache ] ) )
  comment_lineno_cache = None
   if t . token_type == TOKEN_BLOCK :
                  imatch = inline_re . match ( t . contents )
 bmatch = block_re . match ( t . contents )
 cmatches = constant_re . findall ( t . contents )
 if imatch :
                      g = imatch . group ( 1 )
 if g [ 0 ] == '"' :
                          g = g . strip ( '"' )
  elif g [ 0 ] == "'" :
                          g = g . strip ( "'" )
  g = one_percent_re . sub ( '%%' , g )
 if imatch . group ( 2 ) :
                           context_match = context_re . match ( imatch . group ( 2 ) )
 message_context = context_match . group ( 1 )
 if message_context [ 0 ] == '"' :
                              message_context = message_context . strip ( '"' )
  elif message_context [ 0 ] == "'" :
                              message_context = message_context . strip ( "'" )
  out . write ( ' pgettext(%r, %r) ' % ( message_context , g ) )
 message_context = None
  else :
                          out . write ( ' gettext(%r) ' % g )
   elif bmatch :
                      for fmatch in constant_re . findall ( t . contents ) :
                          out . write ( ' _(%s) ' % fmatch )
  if bmatch . group ( 1 ) :
                           context_match = context_re . match ( bmatch . group ( 1 ) )
 message_context = context_match . group ( 1 )
 if message_context [ 0 ] == '"' :
                              message_context = message_context . strip ( '"' )
  elif message_context [ 0 ] == "'" :
                              message_context = message_context . strip ( "'" )
   intrans = True
 inplural = False
 trimmed = 'trimmed' in t . split_contents ( )
 singular = [ ]
 plural = [ ]
  elif cmatches :
                      for cmatch in cmatches :
                          out . write ( ' _(%s) ' % cmatch )
   elif t . contents == 'comment' :
                      incomment = True
  else :
                      out . write ( blankout ( t . contents , 'B' ) )
   elif t . token_type == TOKEN_VAR :
                  parts = t . contents . split ( '|' )
 cmatch = constant_re . match ( parts [ 0 ] )
 if cmatch :
                      out . write ( ' _(%s) ' % cmatch . group ( 1 ) )
  for p in parts [ 1 : ] :
                      if p . find ( ':_(' ) >= 0 :
                          out . write ( ' %s ' % p . split ( ':' , 1 ) [ 1 ] )
  else :
                          out . write ( blankout ( p , 'F' ) )
    elif t . token_type == TOKEN_COMMENT :
                  if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
                      lineno_comment_map . setdefault ( t . lineno ,  [ ] ) . append ( t . contents )
 comment_lineno_cache = t . lineno
   else :
                  out . write ( blankout ( t . contents , 'X' ) )
    return out . getvalue ( )
    def parse_accept_lang_header ( lang_string ) :
 result = [ ]
 pieces = accept_language_re . split ( lang_string . lower ( ) )
 if pieces [ - 1 ] :
          return [ ]
  for i in range ( 0 , len ( pieces ) - 1 , 3 ) :
          first , lang , priority = pieces [ i : i + 3 ]
 if first :
              return [ ]
  if priority :
              try :
                  priority = float ( priority )
  except ValueError :
                  return [ ]
   if not priority :
              priority = 1.0
  result . append ( ( lang , priority ) )
  result . sort ( key = lambda k : k [ 1 ] , reverse = True )
 return result
  import copy
   class Node ( object ) :
   default = 'DEFAULT'
  def __init__ ( self , children = None , connector = None , negated = False ) :
 self . children = children [ : ] if children else [ ]
 self . connector = connector or self . default
 self . negated = negated
     @ classmethod
 def _new_instance ( cls , children = None , connector = None , negated = False ) :
 obj = Node ( children , connector , negated )
 obj . __class__ = cls
 return obj
   def __str__ ( self ) :
          if self . negated :
              return '(NOT (%s: %s))' % ( self . connector , ', ' . join ( [ str ( c ) for c  in self . children ] ) )
  return '(%s: %s)' % ( self . connector , ', ' . join ( [ str ( c ) for c in  self . children ] ) )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ , self )
   def __deepcopy__ ( self , memodict ) :
 obj = Node ( connector = self . connector , negated = self . negated )
 obj . __class__ = self . __class__
 obj . children = copy . deepcopy ( self . children , memodict )
 return obj
   def __len__ ( self ) :
 return len ( self . children )
   def __bool__ ( self ) :
 return bool ( self . children )
   def __nonzero__ ( self ) :
          return type ( self ) . __bool__ ( self )
   def __contains__ ( self , other ) :
 return other in self . children
   def _prepare_data ( self , data ) :
 return data
   def add ( self , data , conn_type , squash = True ) :
 if data in self . children :
              return data
  data = self . _prepare_data ( data )
 if not squash :
              self . children . append ( data )
 return data
  if self . connector == conn_type :
               if ( isinstance ( data , Node ) and not data . negated  and ( data . connector == conn_type or len ( data ) == 1 ) ) :
                        self . children . extend ( data . children )
 return self
  else :
                    self . children . append ( data )
 return data
   else :
              obj = self . _new_instance ( self . children , self . connector ,  self . negated )
 self . connector = conn_type
 self . children = [ obj , data ]
 return data
    def negate ( self ) :
 self . negated = not self . negated
  from __future__ import unicode_literals
  from datetime import timedelta , tzinfo
 import time
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
  warnings . warn (  "django.utils.tzinfo will be removed in Django 1.9. "  "Use django.utils.timezone instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
        class FixedOffset ( tzinfo ) :
 def __init__ ( self , offset ) :
          warnings . warn (  "django.utils.tzinfo.FixedOffset will be removed in Django 1.9. "  "Use django.utils.timezone.get_fixed_timezone instead." ,  RemovedInDjango19Warning )
 if isinstance ( offset , timedelta ) :
              self . __offset = offset
 offset = self . __offset . seconds // 60
  else :
              self . __offset = timedelta ( minutes = offset )
   sign = '-' if offset < 0 else '+'
 self . __name = "%s%02d%02d" % ( sign , abs ( offset ) / 60. , abs ( offset ) % 60 )
   def __repr__ ( self ) :
          return self . __name
   def __getinitargs__ ( self ) :
          return self . __offset ,
   def utcoffset ( self , dt ) :
          return self . __offset
   def tzname ( self , dt ) :
          return self . __name
   def dst ( self , dt ) :
          return timedelta ( 0 )
           class LocalTimezone ( tzinfo ) :
 def __init__ ( self , dt ) :
          warnings . warn (  "django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. "  "Use django.utils.timezone.get_default_timezone instead." ,  RemovedInDjango19Warning )
 tzinfo . __init__ ( self )
 self . __dt = dt
 self . _tzname = self . tzname ( dt )
   def __repr__ ( self ) :
          return force_str ( self . _tzname )
   def __getinitargs__ ( self ) :
          return self . __dt ,
   def utcoffset ( self , dt ) :
          if self . _isdst ( dt ) :
              return timedelta ( seconds = - time . altzone )
  else :
              return timedelta ( seconds = - time . timezone )
    def dst ( self , dt ) :
          if self . _isdst ( dt ) :
              return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )
  else :
              return timedelta ( 0 )
    def tzname ( self , dt ) :
          is_dst = False if dt is None else self . _isdst ( dt )
 try :
              return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )
  except UnicodeDecodeError :
              return None
    def _isdst ( self , dt ) :
          tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )
 try :
              stamp = time . mktime ( tt )
  except ( OverflowError , ValueError ) :
                        tt = ( 2037 , ) + tt [ 1 : ]
 stamp = time . mktime ( tt )
  tt = time . localtime ( stamp )
 return tt . tm_isdst > 0
from __future__ import absolute_import
  import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
  warnings . warn ( "django.utils.unittest will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
  try :
      from unittest2 import *
  except ImportError :
      from unittest import *
from __future__ import unicode_literals
  import datetime
 import os
 import subprocess
   def get_version ( version = None ) :
 version = get_complete_version ( version )
       major = get_major_version ( version )
  sub = ''
 if version [ 3 ] == 'alpha' and version [ 4 ] == 0 :
          git_changeset = get_git_changeset ( )
 if git_changeset :
              sub = '.dev%s' % git_changeset
    elif version [ 3 ] != 'final' :
          mapping = { 'alpha' : 'a' , 'beta' : 'b' , 'rc' : 'c' }
 sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )
   return str ( major + sub )
    def get_major_version ( version = None ) :
 version = get_complete_version ( version )
 parts = 2 if version [ 2 ] == 0 else 3
 major = '.' . join ( str ( x ) for x in version [ : parts ] )
 return major
    def get_complete_version ( version = None ) :
 if version is None :
          from django import VERSION as version
  else :
          assert len ( version ) == 5
 assert version [ 3 ] in ( 'alpha' , 'beta' , 'rc' , 'final' )
   return version
    def get_git_changeset ( ) :
  if hasattr ( get_git_changeset , 'cache' ) :
          return get_git_changeset . cache
   repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )
 git_log = subprocess . Popen ( 'git log --pretty=format:%ct --quiet -1 HEAD' ,  stdout = subprocess . PIPE , stderr = subprocess . PIPE ,  shell = True , cwd = repo_dir , universal_newlines = True )
 timestamp = git_log . communicate ( ) [ 0 ]
 try :
          timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )
  except ValueError :
          changeset = None
  else :
          changeset = timestamp . strftime ( '%Y%m%d%H%M%S' )
   get_git_changeset . cache = changeset
 return changeset
  from xml . sax . saxutils import XMLGenerator
   class SimplerXMLGenerator ( XMLGenerator ) :
      def addQuickElement ( self , name , contents = None , attrs = None ) :
 if attrs is None :
              attrs = { }
  self . startElement ( name , attrs )
 if contents is not None :
              self . characters ( contents )
  self . endElement ( name )
